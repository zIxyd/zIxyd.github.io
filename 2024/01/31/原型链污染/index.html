<!DOCTYPE html><html lang="zh-CN" id="theme-light-mode"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="author" content="zIxyd"><title>原型链污染 · zIxyd's Blog</title><meta name="description" content="什么是原型污染？原型污染是一个 JavaScript 漏洞，攻击者可以利用它向全局对象原型添加任意属性，然后用户定义的对象可以继承这些属性。
原型链污染又分为客户端原型链污染和服务端原型链污染；在ctf中基本都是服务端污染导致绕过验证,得到管理员权限或者RCE等等;
JavaScript 中的原型是"><meta name="keywords" content="Blog,博客,Hexo"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="renderer" content="webkit"><link rel="shortcut icon" type="image/x-icon" href="/images/logo.png"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/blog_basic.css"><link rel="stylesheet" href="/css/font-awesome.min.css"><link rel="stylesheet" href="/css/insight.css"><link rel="stylesheet" href="/css/search.css"><link rel="alternate" type="application/atom+xml" title="ATOM 1.0" href="/atom.xml"><script src="/js/jquery.js"></script><meta name="generator" content="Hexo 6.3.0"></head><body><div class="page-top animated fadeInDown"><div class="nav"><li> <a href="/">Home</a></li><li> <a href="/archives">Archives</a></li><li> <a href="/tags">Tags</a></li><li> <a href="/about">About</a></li></div><div class="information"><div class="nav_right_btn"><li><a class="fa fa-chevron-left" onclick="window.history.go(-1)"> </a></li><li><a class="fa fa-search" onclick="openWindow();"></a></li><li><a class="fa fa-sun-o" onclick="darkLightToggle();"></a></li></div><div class="avatar"></div></div></div><div class="toc-container in-page animated fadeInDown"><details class="ltr toc-toggle"><summary>Menu</summary><div class="tocmenu"><ol class="toclist"><li class="toclist-item toclist-level-2"><a class="toclist-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%8E%9F%E5%9E%8B%E6%B1%A1%E6%9F%93%EF%BC%9F"><span class="toclist-text">什么是原型污染？</span></a></li><li class="toclist-item toclist-level-2"><a class="toclist-link" href="#JavaScript-%E4%B8%AD%E7%9A%84%E5%8E%9F%E5%9E%8B%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toclist-text">JavaScript 中的原型是什么？</span></a></li><li class="toclist-item toclist-level-2"><a class="toclist-link" href="#%E5%AF%B9%E8%B1%A1%E7%BB%A7%E6%89%BF%E6%98%AF%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C%E7%9A%84%EF%BC%9F"><span class="toclist-text">对象继承是如何工作的？</span></a></li><li class="toclist-item toclist-level-2"><a class="toclist-link" href="#%E5%8E%9F%E5%9E%8B%E9%93%BE"><span class="toclist-text">原型链</span></a></li><li class="toclist-item toclist-level-2"><a class="toclist-link" href="#%E4%BD%BF%E7%94%A8-proto-%E8%AE%BF%E9%97%AE%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%8E%9F%E5%9E%8B"><span class="toclist-text">使用 __proto__ 访问对象的原型</span></a></li><li class="toclist-item toclist-level-2"><a class="toclist-link" href="#%E4%BF%AE%E6%94%B9%E5%8E%9F%E5%9E%8B"><span class="toclist-text">修改原型</span></a></li><li class="toclist-item toclist-level-2"><a class="toclist-link" href="#%E5%8E%9F%E5%9E%8B%E6%B1%A1%E6%9F%93%E6%BC%8F%E6%B4%9E%E6%98%AF%E5%A6%82%E4%BD%95%E4%BA%A7%E7%94%9F%E7%9A%84%EF%BC%9F"><span class="toclist-text">原型污染漏洞是如何产生的？</span></a></li><li class="toclist-item toclist-level-2"><a class="toclist-link" href="#prototype-proto"><span class="toclist-text">prototype , __proto__</span></a></li><li class="toclist-item toclist-level-2"><a class="toclist-link" href="#%E9%80%9A%E8%BF%87-JSON-%E8%BE%93%E5%85%A5%E9%80%A0%E6%88%90%E5%8E%9F%E5%9E%8B%E6%B1%A1%E6%9F%93"><span class="toclist-text">通过 JSON 输入造成原型污染</span></a><ol class="toclist-child"><li class="toclist-item toclist-level-3"><a class="toclist-link" href="#JSON-parse"><span class="toclist-text">JSON.parse()</span></a></li><li class="toclist-item toclist-level-3"><a class="toclist-link" href="#Example"><span class="toclist-text">Example</span></a></li></ol></li><li class="toclist-item toclist-level-2"><a class="toclist-link" href="#%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AB%AF%E5%8E%9F%E5%9E%8B%E6%B1%A1%E6%9F%93"><span class="toclist-text">服务器端原型污染</span></a><ol class="toclist-child"><li class="toclist-item toclist-level-3"><a class="toclist-link" href="#%E6%B1%A1%E6%9F%93%E8%BF%9B%E8%A1%8C%E6%9D%83%E9%99%90%E5%8D%87%E7%BA%A7"><span class="toclist-text">污染进行权限升级</span></a></li><li class="toclist-item toclist-level-3"><a class="toclist-link" href="#%E6%A3%80%E6%B5%8B%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AB%AF%E5%8E%9F%E5%9E%8B%E6%B1%A1%E6%9F%93"><span class="toclist-text">检测服务器端原型污染</span></a><ol class="toclist-child"><li class="toclist-item toclist-level-4"><a class="toclist-link" href="#%E7%8A%B6%E6%80%81%E7%A0%81%E8%A6%86%E7%9B%96"><span class="toclist-text">状态码覆盖</span></a></li><li class="toclist-item toclist-level-4"><a class="toclist-link" href="#JSON-%E7%A9%BA%E6%A0%BC%E8%A6%86%E7%9B%96"><span class="toclist-text">JSON 空格覆盖</span></a></li></ol></li></ol></li><li class="toclist-item toclist-level-2"><a class="toclist-link" href="#%E7%BB%95%E8%BF%87%E8%BF%87%E6%BB%A4%E9%80%A0%E6%88%90%E5%8E%9F%E5%9E%8B%E6%B1%A1%E6%9F%93"><span class="toclist-text">绕过过滤造成原型污染</span></a></li><li class="toclist-item toclist-level-2"><a class="toclist-link" href="#Tools"><span class="toclist-text">Tools</span></a></li></ol></div></details></div><div class="sidebar animated fadeInDown"><div class="sidebar-top"><div class="logo-title"><div class="title"><img src="/images/logo.png" style="width:220px;" alt="favicon"><h3 title=""><a href="/">zIxyd's Blog</a></h3><div class="description"><p>存放个人学习笔记的小窝，欢迎交流</p></div></div><ul class="social-links"><li><a target="_blank" rel="noopener" href="https://github.com/zIxyd"><i class="fa fa-github"></i></a></li><li><a href="mailto:2972914692@qq.comm"><i class="fa fa-envelope"></i></a></li><li><a target="_blank" rel="noopener" href="https://res.abeim.cn/api-qq?qq=2972914692"><i class="fa fa-qq"></i></a></li></ul></div><div class="toc-container in-sidebar"><details class="ltr" open><summary>Menu</summary><div class="tocmenu"><ol class="toclist"><li class="toclist-item toclist-level-2"><a class="toclist-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%8E%9F%E5%9E%8B%E6%B1%A1%E6%9F%93%EF%BC%9F"><span class="toclist-text">什么是原型污染？</span></a></li><li class="toclist-item toclist-level-2"><a class="toclist-link" href="#JavaScript-%E4%B8%AD%E7%9A%84%E5%8E%9F%E5%9E%8B%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toclist-text">JavaScript 中的原型是什么？</span></a></li><li class="toclist-item toclist-level-2"><a class="toclist-link" href="#%E5%AF%B9%E8%B1%A1%E7%BB%A7%E6%89%BF%E6%98%AF%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C%E7%9A%84%EF%BC%9F"><span class="toclist-text">对象继承是如何工作的？</span></a></li><li class="toclist-item toclist-level-2"><a class="toclist-link" href="#%E5%8E%9F%E5%9E%8B%E9%93%BE"><span class="toclist-text">原型链</span></a></li><li class="toclist-item toclist-level-2"><a class="toclist-link" href="#%E4%BD%BF%E7%94%A8-proto-%E8%AE%BF%E9%97%AE%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%8E%9F%E5%9E%8B"><span class="toclist-text">使用 __proto__ 访问对象的原型</span></a></li><li class="toclist-item toclist-level-2"><a class="toclist-link" href="#%E4%BF%AE%E6%94%B9%E5%8E%9F%E5%9E%8B"><span class="toclist-text">修改原型</span></a></li><li class="toclist-item toclist-level-2"><a class="toclist-link" href="#%E5%8E%9F%E5%9E%8B%E6%B1%A1%E6%9F%93%E6%BC%8F%E6%B4%9E%E6%98%AF%E5%A6%82%E4%BD%95%E4%BA%A7%E7%94%9F%E7%9A%84%EF%BC%9F"><span class="toclist-text">原型污染漏洞是如何产生的？</span></a></li><li class="toclist-item toclist-level-2"><a class="toclist-link" href="#prototype-proto"><span class="toclist-text">prototype , __proto__</span></a></li><li class="toclist-item toclist-level-2"><a class="toclist-link" href="#%E9%80%9A%E8%BF%87-JSON-%E8%BE%93%E5%85%A5%E9%80%A0%E6%88%90%E5%8E%9F%E5%9E%8B%E6%B1%A1%E6%9F%93"><span class="toclist-text">通过 JSON 输入造成原型污染</span></a><ol class="toclist-child"><li class="toclist-item toclist-level-3"><a class="toclist-link" href="#JSON-parse"><span class="toclist-text">JSON.parse()</span></a></li><li class="toclist-item toclist-level-3"><a class="toclist-link" href="#Example"><span class="toclist-text">Example</span></a></li></ol></li><li class="toclist-item toclist-level-2"><a class="toclist-link" href="#%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AB%AF%E5%8E%9F%E5%9E%8B%E6%B1%A1%E6%9F%93"><span class="toclist-text">服务器端原型污染</span></a><ol class="toclist-child"><li class="toclist-item toclist-level-3"><a class="toclist-link" href="#%E6%B1%A1%E6%9F%93%E8%BF%9B%E8%A1%8C%E6%9D%83%E9%99%90%E5%8D%87%E7%BA%A7"><span class="toclist-text">污染进行权限升级</span></a></li><li class="toclist-item toclist-level-3"><a class="toclist-link" href="#%E6%A3%80%E6%B5%8B%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AB%AF%E5%8E%9F%E5%9E%8B%E6%B1%A1%E6%9F%93"><span class="toclist-text">检测服务器端原型污染</span></a><ol class="toclist-child"><li class="toclist-item toclist-level-4"><a class="toclist-link" href="#%E7%8A%B6%E6%80%81%E7%A0%81%E8%A6%86%E7%9B%96"><span class="toclist-text">状态码覆盖</span></a></li><li class="toclist-item toclist-level-4"><a class="toclist-link" href="#JSON-%E7%A9%BA%E6%A0%BC%E8%A6%86%E7%9B%96"><span class="toclist-text">JSON 空格覆盖</span></a></li></ol></li></ol></li><li class="toclist-item toclist-level-2"><a class="toclist-link" href="#%E7%BB%95%E8%BF%87%E8%BF%87%E6%BB%A4%E9%80%A0%E6%88%90%E5%8E%9F%E5%9E%8B%E6%B1%A1%E6%9F%93"><span class="toclist-text">绕过过滤造成原型污染</span></a></li><li class="toclist-item toclist-level-2"><a class="toclist-link" href="#Tools"><span class="toclist-text">Tools</span></a></li></ol></div></details></div></div><div class="footer"><div class="p"> <span> 全站CC-BY-SA-3.0 </span><i class="fa fa-star"></i><span> zIxyd</span></div><div class="by_farbox"><span>Powered by </span><a href="https://hexo.io/zh-cn/" target="_blank">Hexo </a><span> & </span><a href="https://github.com/Lhcfl/hexo-theme-anatolo" target="_blank">Anatolo </a></div><div class="beian"></div></div></div><div class="main"><div class="autopagerize_page_element"><div class="content"><div class="post-page"><div class="post animated fadeInDown"><div class="post-title"><h3><a>原型链污染</a></h3></div><div class="post-content"><p><h2 id="什么是原型污染？"><a href="#什么是原型污染？" class="headerlink" title="什么是原型污染？"></a>什么是原型污染？</h2><p>原型污染是一个 JavaScript 漏洞，攻击者可以利用它向全局对象原型添加任意属性，然后用户定义的对象可以继承这些属性。</p>
<p>原型链污染又分为<strong>客户端</strong>原型链污染和<a target="_blank" rel="noopener" href="https://portswigger.net/web-security/prototype-pollution/server-side">服务端原型链污染</a>；在ctf中基本都是服务端污染导致绕过验证,得到管理员权限或者RCE等等;</p>
<h2 id="JavaScript-中的原型是什么？"><a href="#JavaScript-中的原型是什么？" class="headerlink" title="JavaScript 中的原型是什么？"></a>JavaScript 中的原型是什么？</h2><p>JavaScript 中的每个对象都链接到某种类型的另一个对象，称为原型。JavaScript 使用原型继承模型，这与许多其他语言使用的基于类的模型有很大不同。默认情况下，JavaScript 会自动将新对象分配给其内置原型之一。例如，字符串会自动分配内置的<code>String.prototype</code>. 您可以在下面看到这些全局原型的更多示例：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> myObject = &#123;&#125;;</span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">getPrototypeOf</span>(myObject);    <span class="comment">// Object.prototype</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> myString = <span class="string">&quot;&quot;</span>;</span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">getPrototypeOf</span>(myString);    <span class="comment">// String.prototype</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> myArray = [];</span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">getPrototypeOf</span>(myArray);	    <span class="comment">// Array.prototype</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> myNumber = <span class="number">1</span>;</span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">getPrototypeOf</span>(myNumber);    <span class="comment">// Number.prototype</span></span><br></pre></td></tr></table></figure>

<p>对象会自动继承其指定原型的所有属性，除非它们已经拥有具有相同键的自己的属性。这使得开发人员能够创建可以重用现有对象的属性和方法的新对象。</p>
<p>内置原型提供了用于处理基本数据类型的有用属性和方法。例如，<code>String.prototype</code>对象有一个<code>toLowerCase()</code>方法。因此，所有字符串都会自动有一个现成的方法将它们转换为小写。这使得开发人员不必手动将此行为添加到他们创建的每个新字符串中。</p>
<h2 id="对象继承是如何工作的？"><a href="#对象继承是如何工作的？" class="headerlink" title="对象继承是如何工作的？"></a>对象继承是如何工作的？</h2><p>每当您引用对象的属性时，JavaScript 引擎都会首先尝试直接在对象本身上访问该属性。如果对象没有匹配的属性，JavaScript 引擎会在对象的原型上查找它。</p>
<p><img src="https://cdn.jsdelivr.net/gh/zIxyd/image@main/ctfshow/%E8%81%94%E6%83%B3%E6%88%AA%E5%9B%BE_20240130192543.png"></p>
<h2 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h2><p>请注意，一个对象的原型只是另一个对象，该对象也应该有自己的原型，依此类推。由于实际上 JavaScript 中的所有内容都是底层的对象，因此这条链最终会回到顶层<code>Object.prototype</code>，其原型很简单<code>null</code>。</p>
<p><img src="https://cdn.jsdelivr.net/gh/zIxyd/image@main/ctfshow/prototype-pollution-prototype-chain.svg"></p>
<p>至关重要的是，对象不仅从其直接原型继承属性，而且从原型链中位于其上方的所有对象继承属性。在上面的示例中，这意味着username对象可以访问String的属性和方法。<code>String.prototype</code> and <code>Object.prototype</code>.</p>
<h2 id="使用-proto-访问对象的原型"><a href="#使用-proto-访问对象的原型" class="headerlink" title="使用 __proto__ 访问对象的原型"></a>使用 <code>__proto__ </code>访问对象的原型</h2><p>每个对象都有一个特殊的属性，您可以使用它来访问其原型。尽管它没有正式的标准化名称，但<code>__proto__</code>它是大多数浏览器使用的事实上的标准。您可以使用它来读取原型及其属性，甚至在必要时重新分配它们。</p>
<p>与任何属性一样，您可以<code>__proto__</code>使用括号或点符号进行访问：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">username.<span class="property">__proto__</span></span><br><span class="line">username[<span class="string">&#x27;__proto__&#x27;</span>]</span><br></pre></td></tr></table></figure>

<p>甚至可以链接引用以<code>__proto__</code>沿着原型链向上工作：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">username.<span class="property">__proto__</span>                        <span class="comment">// String.prototype</span></span><br><span class="line">username.<span class="property">__proto__</span>.<span class="property">__proto__</span>              <span class="comment">// Object.prototype</span></span><br><span class="line">username.<span class="property">__proto__</span>.<span class="property">__proto__</span>.<span class="property">__proto__</span>    <span class="comment">// null</span></span><br></pre></td></tr></table></figure>

<h2 id="修改原型"><a href="#修改原型" class="headerlink" title="修改原型"></a>修改原型</h2><p>修改原型可以像修改任何其他对象一样修改 JavaScript 的内置原型。这意味着开发人员可以自定义或重写内置方法的行为，甚至添加新方法来执行有用的操作。</p>
<p>例如，现代 JavaScript 提供了<code>trim()</code>字符串方法，使您能够轻松删除任何前导或尾随空格。在引入此内置方法之前，开发人员有时会<code>String.prototype</code>通过执行以下操作将自己的此行为的自定义实现添加到对象中：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">String</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">removeWhitespace</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;    <span class="comment">// remove leading and trailing whitespace &#125;</span></span><br></pre></td></tr></table></figure>

<p>由于原型继承，所有字符串都可以访问此方法：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> searchTerm = <span class="string">&quot;  example &quot;</span>; searchTerm.<span class="title function_">removeWhitespace</span>();    <span class="comment">// &quot;example&quot;</span></span><br></pre></td></tr></table></figure>

<h2 id="原型污染漏洞是如何产生的？"><a href="#原型污染漏洞是如何产生的？" class="headerlink" title="原型污染漏洞是如何产生的？"></a>原型污染漏洞是如何产生的？</h2><p>当JavaScript函数递归地将包含用户可控属性的对象合并到现有对象时，通常会出现原型污染漏洞。这可以允许攻击者注入带有类似<code>__proto__</code>的键的属性，以及任意嵌套的属性。</p>
<p>由于<code>__proto__</code>在JavaScript上下文中的特殊含义，合并操作可能会将嵌套属性分配给对象的原型，而不是目标对象本身。因此，攻击者可以用包含恶意值的属性污染原型，这些属性随后可能被应用程序以危险的方式使用。</p>
<p><a target="_blank" rel="noopener" href="https://portswigger.net/web-security/prototype-pollution">更多参考</a></p>
<h2 id="prototype-proto"><a href="#prototype-proto" class="headerlink" title="prototype , __proto__"></a><code>prototype</code> , <code>__proto__</code></h2><p><code>prototype</code> 和 <code>__proto__</code> 是 JavaScript 中与原型（prototype）相关的两个重要概念，但它们有不同的用途和含义。</p>
<ol>
<li><p><strong>prototype:</strong></p>
<ul>
<li><code>prototype</code> 是函数对象特有的属性。每个函数都有一个 <code>prototype</code> 属性，这个prototype属性是一个指向原型对象的指针，它包含了可以由该函数的实例继承的属性和方法。</li>
<li>当你创建一个新的函数时，JavaScript 自动为该函数创建一个 <code>prototype</code> 对象，并赋值给 <code>prototype</code> 属性。</li>
<li>通过 <code>prototype</code> 对象，你可以定义函数的共享属性和方法，它将被该函数的所有实例所共享。</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义构造函数</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params">name, age</span>) &#123;</span><br><span class="line">    <span class="comment">// 实例属性</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">age</span> = age;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 在构造函数的 prototype 上定义共享方法</span></span><br><span class="line">  <span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">sayHello</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Hello, my name is <span class="subst">$&#123;<span class="variable language_">this</span>.name&#125;</span> and I am <span class="subst">$&#123;<span class="variable language_">this</span>.age&#125;</span> years old.`</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 创建实例</span></span><br><span class="line">  <span class="keyword">const</span> person1 = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Alice&quot;</span>, <span class="number">25</span>);</span><br><span class="line">  <span class="keyword">const</span> person2 = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Bob&quot;</span>, <span class="number">30</span>);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 调用共享方法</span></span><br><span class="line">  person1.<span class="title function_">sayHello</span>(); <span class="comment">// 输出: Hello, my name is Alice and I am 25 years old.</span></span><br><span class="line">  person2.<span class="title function_">sayHello</span>(); <span class="comment">// 输出: Hello, my name is Bob and I am 30 years old.</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>proto:</strong></p>
<ul>
<li><code>__proto__</code> 是每个对象都具有的属性，用于指向其构造函数的原型。它是一个指向该对象的原型链上一层的链接。</li>
<li><code>__proto__</code> 属性是非标准的，尽管大多数现代浏览器都支持它，但它已经被 ECMAScript 6 标准中的 <code>Object.getPrototypeOf</code> 方法所替代。</li>
<li><code>__proto__</code> 主要用于获取和设置对象的原型。</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span>  myObject= &#123;&#125;;</span><br><span class="line"><span class="keyword">const</span> myObjectPrototype = <span class="title class_">Object</span>.<span class="title function_">getPrototypeOf</span>(myObject);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(myObjectPrototype === <span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>);	<span class="comment">//true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(myObject.<span class="property">__proto__</span> === <span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>);	<span class="comment">//true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> myString = <span class="string">&quot;&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> myStringPrototype = <span class="title class_">Object</span>.<span class="title function_">getPrototypeOf</span>(myString);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(myStringPrototype.<span class="property">__proto__</span> === <span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>);	<span class="comment">//true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> myArray = [];</span><br><span class="line"><span class="keyword">const</span> myArrayPrototype = <span class="title class_">Object</span>.<span class="title function_">getPrototypeOf</span>(myArray);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(myArrayPrototype.<span class="property">__proto__</span> === <span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>); 	<span class="comment">//true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> myNumber = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">const</span> myNumberPrototype = <span class="title class_">Object</span>.<span class="title function_">getPrototypeOf</span>(myNumber);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(myNumberPrototype.<span class="property">__proto__</span> === <span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>); 	<span class="comment">//true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//======================================================================</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="title function_">getPrototypeOf</span>(myString))      								<span class="comment">//&#123;&#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="title function_">getPrototypeOf</span>(myNumber))									<span class="comment">//&#123;&#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="title function_">getPrototypeOf</span>(myString) ==<span class="title class_">Object</span>.<span class="title function_">getPrototypeOf</span>(myNumber))  	<span class="comment">//false</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="title function_">getPrototypeOf</span>(myString).<span class="property">__proto__</span> ==<span class="title class_">Object</span>.<span class="title function_">getPrototypeOf</span>(myNumber).<span class="property">__proto__</span>) <span class="comment">//true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//下面解释为什么是 false?</span></span><br><span class="line"><span class="comment">//在 JavaScript 中，Object.getPrototypeOf 用于获取对象的原型。在代码中，myString 是一个空字符串，而 myNumber 是一个数字。当调用 Object.getPrototypeOf(myString) 时，它返回的是字符串的原型对象 String.prototype。同样，Object.getPrototypeOf(myNumber) 返回的是数字的原型对象 Number.prototype。虽然输出结果都是 &#123;&#125; 对象，但它们是不同的对象。这是因为 &#123;&#125; 是表示一个空对象字面量的方式，而不是真正的空对象。在 JavaScript 中，每次调用 Object.getPrototypeOf 都会返回一个新的对象，即使它们有着相同的结构和原型链。</span></span><br></pre></td></tr></table></figure></li>
</ol>
<p>总的来说，<code>prototype</code> 用于构造函数，帮助定义共享属性和方法，而 <code>__proto__</code> 是每个对象都有的属性，用于指向其构造函数的原型。<code>Object.getPrototypeOf</code> 方法是更推荐使用的获取原型的方式，而 <code>__proto__</code> 在现代 JavaScript 中已经不再建议使用。</p>
<p>一个简单的案例</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> myObject = &#123; <span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: <span class="number">2</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">c</span> = <span class="number">3</span>;</span><br><span class="line">myObject.<span class="property">__proto__</span>.<span class="property">d</span> = <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">const</span> propertyKey <span class="keyword">in</span> myObject)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(propertyKey);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出：</span></span><br><span class="line"><span class="comment">//a</span></span><br><span class="line"><span class="comment">//b</span></span><br><span class="line"><span class="comment">//c</span></span><br><span class="line"><span class="comment">//d</span></span><br></pre></td></tr></table></figure>

<p>这也适用于数组，其中<code>for...in</code>循环首先迭代每个索引（本质上只是底层的数字属性键），然后再继续处理任何继承的属性。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> myArray = [<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>];</span><br><span class="line"></span><br><span class="line"><span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">c</span> = <span class="number">3</span>;</span><br><span class="line">myArray.<span class="property">__proto__</span>.<span class="property">d</span> = <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">const</span> arrayKey <span class="keyword">in</span> myArray)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(arrayKey);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出</span></span><br><span class="line"><span class="comment">//0</span></span><br><span class="line"><span class="comment">//1</span></span><br><span class="line"><span class="comment">//d</span></span><br><span class="line"><span class="comment">//c</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//下面解释为什么键“c”输出在“d”的后面？</span></span><br><span class="line"><span class="comment">//在这个例子中，给 Object.prototype 添加了一个属性 c，并给 myArray.__proto__ 添加了一个属性 d。当您使用 for...in 循环迭代数组时，它会遍历对象的所有可枚举属性，包括原型链上的属性。在JavaScript中，Object.prototype 是所有对象的原型链的顶部，因此它的属性会在其他原型上的属性之前被遍历。在这里，c 是添加到所有对象的原型链上的属性，而 d 是添加到 myArray.__proto__ 上的属性。因此，在 for...in 循环中，d 的输出在 c 之前，因为 myArray.__proto__ 的属性会先被遍历。</span></span><br></pre></td></tr></table></figure>

<h2 id="通过-JSON-输入造成原型污染"><a href="#通过-JSON-输入造成原型污染" class="headerlink" title="通过 JSON 输入造成原型污染"></a>通过 JSON 输入造成原型污染</h2><h3 id="JSON-parse"><a href="#JSON-parse" class="headerlink" title="JSON.parse()"></a>JSON.parse()</h3><p>在ctf中最常见的莫过于<code>JSON.parse()</code>函数了；</p>
<p>用户可控的对象通常是使用该<code>JSON.parse()</code>方法从 JSON 字符串派生的。有趣的是，<code>JSON.parse()</code>还将 JSON 对象中的任何键视为任意字符串，包括<code>__proto__</code>. 这为原型污染提供了另一个潜在载体。</p>
<p>假设攻击者通过网络消息注入以下恶意 JSON：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;__proto__&quot;</span>: &#123;</span><br><span class="line">        <span class="string">&quot;evilProperty&quot;</span>: <span class="string">&quot;payload&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果通过该方法将其转换为 JavaScript 对象<code>JSON.parse()</code>，则生成的对象实际上将具有一个带有 key 的属性<code>__proto__</code>：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> objectLiteral = &#123;<span class="attr">__proto__</span>: &#123;<span class="attr">evilProperty</span>: <span class="string">&#x27;payload&#x27;</span>&#125;&#125;;</span><br><span class="line"><span class="keyword">const</span> objectFromJson = <span class="title class_">JSON</span>.<span class="title function_">parse</span>(<span class="string">&#x27;&#123;&quot;__proto__&quot;: &#123;&quot;evilProperty&quot;: &quot;payload&quot;&#125;&#125;&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(objectLiteral.<span class="title function_">hasOwnProperty</span>(<span class="string">&#x27;__proto__&#x27;</span>));     <span class="comment">// false</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(objectFromJson.<span class="title function_">hasOwnProperty</span>(<span class="string">&#x27;__proto__&#x27;</span>));    <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p><strong>注意：</strong>在Node.js中，<code>hasOwnProperty</code>函数是JavaScript中的一个内置函数，用于检查对象自身是否包含指定的属性（即不包括从原型链继承的属性）。这个函数返回一个布尔值，如果对象包含指定的属性，则返回true，否则返回false。</p>
<p>例如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;<span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: <span class="number">2</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj.<span class="title function_">hasOwnProperty</span>(<span class="string">&#x27;a&#x27;</span>)); <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj.<span class="title function_">hasOwnProperty</span>(<span class="string">&#x27;c&#x27;</span>)); <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<h3 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">merge</span>(<span class="params">target, source</span>) &#123; </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> source) &#123;       </span><br><span class="line">        <span class="keyword">if</span> (key <span class="keyword">in</span> source &amp;&amp; key <span class="keyword">in</span> target) &#123;</span><br><span class="line">            <span class="comment">// console.log(key)</span></span><br><span class="line">            <span class="comment">// console.log(target[key])</span></span><br><span class="line">            <span class="comment">// console.log(source[key])</span></span><br><span class="line">            <span class="title function_">merge</span>(target[key], source[key])</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            target[key] = source[key]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;&#125;</span><br><span class="line"><span class="keyword">let</span> object1 = &#123;&#125;</span><br><span class="line"><span class="keyword">let</span> object2 = <span class="title class_">JSON</span>.<span class="title function_">parse</span>(<span class="string">&#x27;&#123;&quot;a&quot;: 1, &quot;__proto__&quot;: &#123;&quot;b&quot;: 2&#125;&#125;&#x27;</span>)</span><br><span class="line"><span class="title function_">merge</span>(object1, object2)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(object1.<span class="property">a</span>, object1.<span class="property">b</span>) 	<span class="comment">//1 2</span></span><br><span class="line">object3 = &#123;&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(object3.<span class="property">b</span>)	      		<span class="comment">//2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> object4 = <span class="string">&quot;&quot;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(object4.<span class="property">b</span>)				<span class="comment">//2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// console.log(object2.hasOwnProperty(&#x27;a&#x27;));</span></span><br><span class="line"><span class="comment">// console.log(object2.hasOwnProperty(&#x27;b&#x27;));</span></span><br><span class="line"><span class="comment">// console.log(object2.hasOwnProperty(&#x27;__proto__&#x27;));</span></span><br><span class="line"><span class="comment">// console.log(object1.__proto__);</span></span><br><span class="line"><span class="comment">// console.log(object2.__proto__);</span></span><br><span class="line"><span class="comment">// console.log(object3.__proto__);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//我将大致解释一下这段代码是如何通过merge函数污染到object3的属性的(这样说也许不太对，应该是污染到了原型的属性，所以新建一个对象，都会拥有b属性)</span></span><br><span class="line"><span class="comment">//JSON.parse在上面已经分析过了；这里主要看merge函数；</span></span><br><span class="line"><span class="comment">//第一次循环:&quot;a&quot;: 1</span></span><br><span class="line"><span class="comment">//单纯的将object2的a属性赋值给object1</span></span><br><span class="line"><span class="comment">//第二次循环:&quot;__proto__&quot;: &#123;&quot;b&quot;: 2&#125;</span></span><br><span class="line"><span class="comment">//首先将__proto__赋值给key;</span></span><br><span class="line"><span class="comment">//if (key in source &amp;&amp; key in target)判断为真，因为target也就是object2有__proto__属性，这一点可以用hasOwnProperty函数更能看明白</span></span><br><span class="line"><span class="comment">//如果判断为真，递归merge函数，这里注意 传递的第一个参数是object1.__proto__和第二个参数object2.__proto__ == (&#123;&quot;b&quot;: 2&#125;)</span></span><br><span class="line"><span class="comment">//接着会向object1.__proto__赋值b属性，而object1.__proto__就是原型，所以整个原型污染流程结束</span></span><br></pre></td></tr></table></figure>



<h2 id="服务器端原型污染"><a href="#服务器端原型污染" class="headerlink" title="服务器端原型污染"></a>服务器端原型污染</h2><p>记录一下<strong>portswigger</strong>上的实验；漏洞点都是在一个修改个人形象的功能点，后端是基于 Node.js 和 Express 框架构建。它很容易受到服务器端原型污染的影响，因为它将用户可控的输入不安全地合并到服务器端 JavaScript 对象中。</p>
<p><img src="https://cdn.jsdelivr.net/gh/zIxyd/image@main/ctfshow/%E8%81%94%E6%83%B3%E6%88%AA%E5%9B%BE_20240131105458.png"></p>
<h3 id="污染进行权限升级"><a href="#污染进行权限升级" class="headerlink" title="污染进行权限升级"></a>污染进行权限升级</h3><p>用bp抓包;往请求包中用<code>__proto__</code>尝试原型污染；然后发送请求。可以看到响应包中出现了<code>&quot;hacker&quot;:&quot;zIxyd&quot;</code></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;__proto__&quot;</span>:&#123;<span class="string">&quot;hacker&quot;</span>:<span class="string">&quot;zIxyd&quot;</span>&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/zIxyd/image@main/ctfshow/%E8%81%94%E6%83%B3%E6%88%AA%E5%9B%BE_20240131105749.png"></p>
<p>确认存在原型链污染，发送恶意数据，</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;__proto__&quot;</span>:&#123;<span class="string">&quot;isAdmin&quot;</span>:<span class="literal">true</span>&#125;</span><br></pre></td></tr></table></figure>

<h3 id="检测服务器端原型污染"><a href="#检测服务器端原型污染" class="headerlink" title="检测服务器端原型污染"></a>检测服务器端原型污染</h3><p>大多数时候，即使您成功污染了服务器端原型对象，您也不会在响应中看到受影响的属性。也就是说你在一个点上无法判断是否存在原型污染；那该怎么办呢？</p>
<p>一种方法是尝试注入与服务器的潜在配置选项相匹配的属性。然后，您可以比较注入前后服务器的行为，以查看此配置更改是否已生效。如果是这样，这强烈表明您已成功发现服务器端原型污染漏洞。</p>
<h4 id="状态码覆盖"><a href="#状态码覆盖" class="headerlink" title="状态码覆盖"></a>状态码覆盖</h4><p>Express 等服务器端 JavaScript 框架允许开发人员设置自定义 HTTP 响应状态。如果出现错误，JavaScript 服务器可能会发出通用 HTTP 响应，但在正文中包含 JSON 格式的错误对象。这是提供有关错误发生原因的附加详细信息的一种方法，这从默认 HTTP 状态中可能并不明显。</p>
<p>Node 的<code>http-errors</code>模块包含以下用于生成此类错误响应的函数：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">createError</span> () &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="keyword">if</span> (type === <span class="string">&#x27;object&#x27;</span> &amp;&amp; arg <span class="keyword">instanceof</span> <span class="title class_">Error</span>) &#123;</span><br><span class="line">        err = arg</span><br><span class="line">        <span class="comment">//注意下面这一行</span></span><br><span class="line">        status = err.<span class="property">status</span> || err.<span class="property">statusCode</span> || status</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type === <span class="string">&#x27;number&#x27;</span> &amp;&amp; i === <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> status !== <span class="string">&#x27;number&#x27;</span> ||</span><br><span class="line">    (!statuses.<span class="property">message</span>[status] &amp;&amp; (status &gt; <span class="number">400</span> || status &gt;= <span class="number">600</span>))) &#123;</span><br><span class="line">        status = <span class="number">500</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//...</span></span><br></pre></td></tr></table></figure>

<p>“ &#x2F;&#x2F;注意下面这一行”显示的下一行试图通过读取传递给函数的对象的status或statusCode属性来分配状态变量。如果网站的开发人员没有明确地为错误设置状态属性，你可以使用它来探测原型污染；</p>
<p><strong>注意：</strong>根据代码分析，我们要修改的状态码必须在400和600之间，否则为状态码为500</p>
<p>再次声明，实验环境用的是：portswigger</p>
<p>多加了一个双引号，使得json格式不对，返回报错状态码为400</p>
<p><img src="https://cdn.jsdelivr.net/gh/zIxyd/image@main/ctfshow/%E8%81%94%E6%83%B3%E6%88%AA%E5%9B%BE_20240131130012.png"></p>
<p>尝试污染<code>status</code>的值</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;__proto__&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;status&quot;</span>:<span class="number">555</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再次使得json格式错乱，查看报错状态码为555,说明已经污染成功了</p>
<p><img src="https://cdn.jsdelivr.net/gh/zIxyd/image@main/ctfshow/%E8%81%94%E6%83%B3%E6%88%AA%E5%9B%BE_20240131130211.png"></p>
<h4 id="JSON-空格覆盖"><a href="#JSON-空格覆盖" class="headerlink" title="JSON 空格覆盖"></a>JSON 空格覆盖</h4><p>Express 框架提供了一个<code>json spaces</code>选项，使您能够配置用于缩进响应中任何 JSON 数据的空格数。在许多情况下，开发人员不会定义此属性，因为他们对默认值感到满意，这使其容易受到原型链的污染。</p>
<p>如果您可以访问任何类型的 JSON 响应，则可以尝试使用自己的<code>json spaces</code>属性污染原型，然后重新发出相关请求以查看 JSON 中的缩进是否相应增加。您可以执行相同的步骤来删除缩进以确认漏洞。</p>
<p>这是一项特别有用的技术，因为它不依赖于所反映的特定属性。它也非常安全，因为您只需将属性重置为与默认值相同的值即可有效地打开和关闭污染。</p>
<p>尽管 Express 4.17.4 中已经修复了原型污染问题，但未升级的网站可能仍然容易受到攻击。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;__proto__&quot;</span>:&#123;</span><br><span class="line">    <span class="string">&quot;json spaces&quot;</span>:<span class="number">10</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/zIxyd/image@main/ctfshow/%E8%81%94%E6%83%B3%E6%88%AA%E5%9B%BE_20240131130553.png"></p>
<p>除了上面介绍的俩种；还有<a target="_blank" rel="noopener" href="https://portswigger.net/web-security/prototype-pollution/server-side">字符集覆盖</a>方法等等</p>
<h2 id="绕过过滤造成原型污染"><a href="#绕过过滤造成原型污染" class="headerlink" title="绕过过滤造成原型污染"></a>绕过过滤造成原型污染</h2><p>有时会过滤<code>__proto__</code>，但是这种关键的过滤方法并不是一个强大的长期解决方案，因为有多种方法可能会绕过它。</p>
<p><code>__proto__</code>节点应用程序还可以分别使用命令行标志<code>--disable-proto=delete</code>或来完全 删除或禁用<code>--disable-proto=throw</code>。然而，这也可以通过使用构造函数技术来绕过。</p>
<p>实验</p>
<p>多次发送<code>json spaces</code>请求,但是响应包没有反应</p>
<p><img src="https://cdn.jsdelivr.net/gh/zIxyd/image@main/ctfshow/%E8%81%94%E6%83%B3%E6%88%AA%E5%9B%BE_20240131163020.png"></p>
<p>每个构造函数(constructor)都有一个原型对象(prototype); 上面已经解释的很清楚了</p>
<p><img src="https://cdn.jsdelivr.net/gh/zIxyd/image@main/ctfshow/%E8%81%94%E6%83%B3%E6%88%AA%E5%9B%BE_20240131165203.png"></p>
<p><code>constructor.prototype === __proto__</code></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> myObject = &#123;&#125;</span><br><span class="line"></span><br><span class="line">myObject.<span class="property">constructor</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">b</span> = <span class="string">&#x27;zIxyd&#x27;</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">const</span> propertyKey <span class="keyword">in</span> myObject)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(propertyKey);									<span class="comment">//b</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> myString = <span class="string">&quot;&quot;</span></span><br><span class="line">															<span class="comment">//zIxyd</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(myString.<span class="property">b</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(myObject.<span class="property">__proto__</span>)									<span class="comment">//[Object: null prototype] &#123; b: &#x27;zIxyd&#x27; &#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(myObject.<span class="property">constructor</span>.<span class="property"><span class="keyword">prototype</span></span> === myObject.<span class="property">__proto__</span>) 	<span class="comment">//true</span></span><br></pre></td></tr></table></figure>

<p>尝试使用<code>constructor</code>；</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;constructor&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;prototype&quot;</span>: &#123;</span><br><span class="line">        <span class="string">&quot;json spaces&quot;</span>:<span class="number">10</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/zIxyd/image@main/ctfshow/%E8%81%94%E6%83%B3%E6%88%AA%E5%9B%BE_20240131163146.png"></p>
<h2 id="Tools"><a href="#Tools" class="headerlink" title="Tools"></a>Tools</h2><p><a target="_blank" rel="noopener" href="https://portswigger.net/bappstore/c1d4bd60626d4178a54d36ee802cf7e8">Server-Side Prototype Pollution Scanner</a></p>
<p><a target="_blank" rel="noopener" href="https://portswigger.net/research/server-side-prototype-pollution">https://portswigger.net/research/server-side-prototype-pollution</a></p>
</p></div><div class="post-footer"><div class="tip">All rights reserved<br>Author: zIxyd</div><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2024-01-31</span><i class="fa fa-tag"></i><a class="tag" href="/tags/pollution/" title="pollution">pollution </a><span class="leancloud_visitors"></span><span>About 4182 words, 13 min 56 sec  read</span></div></div></div></div><div class="share"><div class="evernote"><a class="fa fa-bookmark" href="" onclick="javascript:join_favorite()" ref="sidebar"></a></div><div class="weibo"><a class="fa fa-weibo" href="javascript:void((function(s,d,e){try{}catch(e){}var f='http://service.weibo.com/share/share.php?',u=d.location.href,p=['url=',e(u),'&amp;title=',e(d.title),'&amp;appkey=2924220432'].join('');function a(){if(!window.open([f,p].join(''),'mb',['toolbar=0,status=0,resizable=1,width=620,height=450,left=',(s.width-620)/2,',top=',(s.height-450)/2].join('')))u.href=[f,p].join('');};if(/Firefox/.test(navigator.userAgent)){setTimeout(a,0)}else{a()}})(screen,document,encodeURIComponent));"></a></div><div class="twitter"><a class="fa fa-twitter" target="_blank" rel="noopener" href="http://twitter.com/intent/tweet?text=I%20have%20found%20a%20great%20blog.%0A%0AzIxyd's%20Blog%20%C2%B7%20%E5%8E%9F%E5%9E%8B%E9%93%BE%E6%B1%A1%E6%9F%93%0Ahttps://zIxyd.github.io/2024/01/31/%E5%8E%9F%E5%9E%8B%E9%93%BE%E6%B1%A1%E6%9F%93/%0A"></a></div></div><div class="pagination"><ul class="clearfix"><li class="next pagbuttons"><a class="btn" role="navigation" href="/2024/01/30/http-header%E4%BC%AA%E9%80%A0ip/" title="http-header伪造ip">Next</a></li></ul></div><script src="/js/visitors.js"></script></div></div></div></div><script src="/js/darkLightToggle.js"></script><script src="/js/jquery-migrate-1.2.1.min.js"></script><script src="/js/jquery.appear.js"></script><script src="/js/add-bookmark.js"></script><script>(function(window){var INSIGHT_CONFIG={TRANSLATION:{POSTS:"Posts",PAGES:"Pages",CATEGORIES:"Categories",TAGS:"Tags",UNTITLED:"(Untitled)",},CONTENT_URL:"/content.json",};window.INSIGHT_CONFIG=INSIGHT_CONFIG})(window);</script><script src="/js/insight.js" defer></script><div class="searchbox ins-search"><div class="searchbox-container ins-search-container"><div class="searchbox-input-wrapper"><input class="searchbox-input ins-search-input" type="text" placeholder="Search..."><span class="searchbox-close"><a class="fa fa-times-circle" onclick="closeWindow();"></a></span></div><div class="searchbox-result-wrapper ins-section-wrapper"><div class="ins-section-container"><p>Seraching...</p></div></div></div></div></body></html>