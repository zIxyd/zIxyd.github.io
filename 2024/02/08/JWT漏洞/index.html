<!DOCTYPE html><html lang="zh-CN" id="theme-light-mode"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="author" content="zIxyd"><title>JWT漏洞 · zIxyd's Blog</title><meta name="description" content="什么是 JWT？JSON web tokens (JWT) 是一种标准化格式，用于在系统之间发送加密签名的 JSON 数据。理论上，它们可以包含任何类型的数据，但最常用于发送有关用户的信息（“声明”），作为身份验证、会话处理和访问控制机制的一部分。
与经典会话令牌不同，服务器所需的所有数据都存储在 "><meta name="keywords" content="Blog,博客,Hexo"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="renderer" content="webkit"><link rel="shortcut icon" type="image/x-icon" href="/images/logo.png"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/blog_basic.css"><link rel="stylesheet" href="/css/font-awesome.min.css"><link rel="stylesheet" href="/css/insight.css"><link rel="stylesheet" href="/css/search.css"><link rel="alternate" type="application/atom+xml" title="ATOM 1.0" href="/atom.xml"><script src="/js/jquery.js"></script><meta name="generator" content="Hexo 6.3.0"></head><body><div class="page-top animated fadeInDown"><div class="nav"><li> <a href="/">Home</a></li><li> <a href="/archives">Archives</a></li><li> <a href="/tags">Tags</a></li><li> <a href="/about">About</a></li></div><div class="information"><div class="nav_right_btn"><li><a class="fa fa-chevron-left" onclick="window.history.go(-1)"> </a></li><li><a class="fa fa-search" onclick="openWindow();"></a></li><li><a class="fa fa-sun-o" onclick="darkLightToggle();"></a></li></div><div class="avatar"></div></div></div><div class="toc-container in-page animated fadeInDown"><details class="ltr toc-toggle"><summary>Menu</summary><div class="tocmenu"><ol class="toclist"><li class="toclist-item toclist-level-2"><a class="toclist-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF-JWT%EF%BC%9F"><span class="toclist-text">什么是 JWT？</span></a><ol class="toclist-child"><li class="toclist-item toclist-level-3"><a class="toclist-link" href="#JWT-%E6%A0%BC%E5%BC%8F"><span class="toclist-text">JWT 格式</span></a></li><li class="toclist-item toclist-level-3"><a class="toclist-link" href="#%E7%AD%BE%E5%90%8D"><span class="toclist-text">签名</span></a></li></ol></li><li class="toclist-item toclist-level-2"><a class="toclist-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF-JWT-%E6%94%BB%E5%87%BB%EF%BC%9F"><span class="toclist-text">什么是 JWT 攻击？</span></a></li><li class="toclist-item toclist-level-2"><a class="toclist-link" href="#JWT-%E6%94%BB%E5%87%BB%E7%9A%84%E6%BC%8F%E6%B4%9E%E6%98%AF%E5%A6%82%E4%BD%95%E4%BA%A7%E7%94%9F%E7%9A%84%EF%BC%9F"><span class="toclist-text">JWT 攻击的漏洞是如何产生的？</span></a></li><li class="toclist-item toclist-level-2"><a class="toclist-link" href="#%E5%88%A9%E7%94%A8%E6%9C%89%E7%BC%BA%E9%99%B7%E7%9A%84-JWT-%E7%AD%BE%E5%90%8D%E9%AA%8C%E8%AF%81"><span class="toclist-text">利用有缺陷的 JWT 签名验证</span></a><ol class="toclist-child"><li class="toclist-item toclist-level-3"><a class="toclist-link" href="#%E6%8E%A5%E5%8F%97%E4%BB%BB%E6%84%8F%E7%AD%BE%E5%90%8D"><span class="toclist-text">接受任意签名</span></a></li><li class="toclist-item toclist-level-3"><a class="toclist-link" href="#%E6%8E%A5%E5%8F%97%E6%B2%A1%E6%9C%89%E7%AD%BE%E5%90%8D%E7%9A%84%E4%BB%A4%E7%89%8C"><span class="toclist-text">接受没有签名的令牌</span></a></li></ol></li><li class="toclist-item toclist-level-2"><a class="toclist-link" href="#%E6%9A%B4%E5%8A%9B%E7%A0%B4%E8%A7%A3%E5%AF%86%E9%92%A5"><span class="toclist-text">暴力破解密钥</span></a></li><li class="toclist-item toclist-level-2"><a class="toclist-link" href="#JWT-%E6%A0%87%E5%A4%B4%E5%8F%82%E6%95%B0%E6%B3%A8%E5%85%A5"><span class="toclist-text">JWT 标头参数注入</span></a><ol class="toclist-child"><li class="toclist-item toclist-level-3"><a class="toclist-link" href="#%E9%80%9A%E8%BF%87-jwk-%E5%8F%82%E6%95%B0%E6%B3%A8%E5%85%A5%E8%87%AA%E7%AD%BE%E5%90%8D-JWT"><span class="toclist-text">通过 jwk 参数注入自签名 JWT</span></a></li><li class="toclist-item toclist-level-3"><a class="toclist-link" href="#%E9%80%9A%E8%BF%87-jku-%E5%8F%82%E6%95%B0%E6%B3%A8%E5%85%A5%E8%87%AA%E7%AD%BE%E5%90%8D-JWT"><span class="toclist-text">通过 jku 参数注入自签名 JWT</span></a></li><li class="toclist-item toclist-level-3"><a class="toclist-link" href="#%E9%80%9A%E8%BF%87kid%E5%8F%82%E6%95%B0%E6%B3%A8%E5%85%A5%E8%87%AA%E7%AD%BE%E5%90%8DJWT"><span class="toclist-text">通过kid参数注入自签名JWT</span></a></li></ol></li><li class="toclist-item toclist-level-2"><a class="toclist-link" href="#JWT%E7%AE%97%E6%B3%95%E6%B7%B7%E6%B7%86%E6%94%BB%E5%87%BB"><span class="toclist-text">JWT算法混淆攻击</span></a><ol class="toclist-child"><li class="toclist-item toclist-level-3"><a class="toclist-link" href="#%E7%AE%97%E6%B3%95%E6%B7%B7%E6%B7%86%E6%BC%8F%E6%B4%9E%E6%98%AF%E5%A6%82%E4%BD%95%E4%BA%A7%E7%94%9F%E7%9A%84%EF%BC%9F"><span class="toclist-text">算法混淆漏洞是如何产生的？</span></a></li><li class="toclist-item toclist-level-3"><a class="toclist-link" href="#%E6%89%A7%E8%A1%8C%E7%AE%97%E6%B3%95%E6%B7%B7%E6%B7%86%E6%94%BB%E5%87%BB"><span class="toclist-text">执行算法混淆攻击</span></a></li><li class="toclist-item toclist-level-3"><a class="toclist-link" href="#%E4%BB%8E%E7%8E%B0%E6%9C%89%E4%BB%A4%E7%89%8C%E6%B4%BE%E7%94%9F%E5%85%AC%E9%92%A5"><span class="toclist-text">从现有令牌派生公钥</span></a></li></ol></li></ol></div></details></div><div class="sidebar animated fadeInDown"><div class="sidebar-top"><div class="logo-title"><div class="title"><img src="/images/logo.png" style="width:220px;" alt="favicon"><h3 title=""><a href="/">zIxyd's Blog</a></h3><div class="description"><p>存放个人学习笔记的小窝，欢迎交流</p></div></div><ul class="social-links"><li><a target="_blank" rel="noopener" href="https://github.com/zIxyd"><i class="fa fa-github"></i></a></li><li><a href="mailto:2972914692@qq.comm"><i class="fa fa-envelope"></i></a></li><li><a target="_blank" rel="noopener" href="https://res.abeim.cn/api-qq?qq=2972914692"><i class="fa fa-qq"></i></a></li></ul></div><div class="toc-container in-sidebar"><details class="ltr" open><summary>Menu</summary><div class="tocmenu"><ol class="toclist"><li class="toclist-item toclist-level-2"><a class="toclist-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF-JWT%EF%BC%9F"><span class="toclist-text">什么是 JWT？</span></a><ol class="toclist-child"><li class="toclist-item toclist-level-3"><a class="toclist-link" href="#JWT-%E6%A0%BC%E5%BC%8F"><span class="toclist-text">JWT 格式</span></a></li><li class="toclist-item toclist-level-3"><a class="toclist-link" href="#%E7%AD%BE%E5%90%8D"><span class="toclist-text">签名</span></a></li></ol></li><li class="toclist-item toclist-level-2"><a class="toclist-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF-JWT-%E6%94%BB%E5%87%BB%EF%BC%9F"><span class="toclist-text">什么是 JWT 攻击？</span></a></li><li class="toclist-item toclist-level-2"><a class="toclist-link" href="#JWT-%E6%94%BB%E5%87%BB%E7%9A%84%E6%BC%8F%E6%B4%9E%E6%98%AF%E5%A6%82%E4%BD%95%E4%BA%A7%E7%94%9F%E7%9A%84%EF%BC%9F"><span class="toclist-text">JWT 攻击的漏洞是如何产生的？</span></a></li><li class="toclist-item toclist-level-2"><a class="toclist-link" href="#%E5%88%A9%E7%94%A8%E6%9C%89%E7%BC%BA%E9%99%B7%E7%9A%84-JWT-%E7%AD%BE%E5%90%8D%E9%AA%8C%E8%AF%81"><span class="toclist-text">利用有缺陷的 JWT 签名验证</span></a><ol class="toclist-child"><li class="toclist-item toclist-level-3"><a class="toclist-link" href="#%E6%8E%A5%E5%8F%97%E4%BB%BB%E6%84%8F%E7%AD%BE%E5%90%8D"><span class="toclist-text">接受任意签名</span></a></li><li class="toclist-item toclist-level-3"><a class="toclist-link" href="#%E6%8E%A5%E5%8F%97%E6%B2%A1%E6%9C%89%E7%AD%BE%E5%90%8D%E7%9A%84%E4%BB%A4%E7%89%8C"><span class="toclist-text">接受没有签名的令牌</span></a></li></ol></li><li class="toclist-item toclist-level-2"><a class="toclist-link" href="#%E6%9A%B4%E5%8A%9B%E7%A0%B4%E8%A7%A3%E5%AF%86%E9%92%A5"><span class="toclist-text">暴力破解密钥</span></a></li><li class="toclist-item toclist-level-2"><a class="toclist-link" href="#JWT-%E6%A0%87%E5%A4%B4%E5%8F%82%E6%95%B0%E6%B3%A8%E5%85%A5"><span class="toclist-text">JWT 标头参数注入</span></a><ol class="toclist-child"><li class="toclist-item toclist-level-3"><a class="toclist-link" href="#%E9%80%9A%E8%BF%87-jwk-%E5%8F%82%E6%95%B0%E6%B3%A8%E5%85%A5%E8%87%AA%E7%AD%BE%E5%90%8D-JWT"><span class="toclist-text">通过 jwk 参数注入自签名 JWT</span></a></li><li class="toclist-item toclist-level-3"><a class="toclist-link" href="#%E9%80%9A%E8%BF%87-jku-%E5%8F%82%E6%95%B0%E6%B3%A8%E5%85%A5%E8%87%AA%E7%AD%BE%E5%90%8D-JWT"><span class="toclist-text">通过 jku 参数注入自签名 JWT</span></a></li><li class="toclist-item toclist-level-3"><a class="toclist-link" href="#%E9%80%9A%E8%BF%87kid%E5%8F%82%E6%95%B0%E6%B3%A8%E5%85%A5%E8%87%AA%E7%AD%BE%E5%90%8DJWT"><span class="toclist-text">通过kid参数注入自签名JWT</span></a></li></ol></li><li class="toclist-item toclist-level-2"><a class="toclist-link" href="#JWT%E7%AE%97%E6%B3%95%E6%B7%B7%E6%B7%86%E6%94%BB%E5%87%BB"><span class="toclist-text">JWT算法混淆攻击</span></a><ol class="toclist-child"><li class="toclist-item toclist-level-3"><a class="toclist-link" href="#%E7%AE%97%E6%B3%95%E6%B7%B7%E6%B7%86%E6%BC%8F%E6%B4%9E%E6%98%AF%E5%A6%82%E4%BD%95%E4%BA%A7%E7%94%9F%E7%9A%84%EF%BC%9F"><span class="toclist-text">算法混淆漏洞是如何产生的？</span></a></li><li class="toclist-item toclist-level-3"><a class="toclist-link" href="#%E6%89%A7%E8%A1%8C%E7%AE%97%E6%B3%95%E6%B7%B7%E6%B7%86%E6%94%BB%E5%87%BB"><span class="toclist-text">执行算法混淆攻击</span></a></li><li class="toclist-item toclist-level-3"><a class="toclist-link" href="#%E4%BB%8E%E7%8E%B0%E6%9C%89%E4%BB%A4%E7%89%8C%E6%B4%BE%E7%94%9F%E5%85%AC%E9%92%A5"><span class="toclist-text">从现有令牌派生公钥</span></a></li></ol></li></ol></div></details></div></div><div class="footer"><div class="p"> <span> 全站CC-BY-SA-3.0 </span><i class="fa fa-star"></i><span> zIxyd</span></div><div class="by_farbox"><span>Powered by </span><a href="https://hexo.io/zh-cn/" target="_blank">Hexo </a><span> & </span><a href="https://github.com/Lhcfl/hexo-theme-anatolo" target="_blank">Anatolo </a></div><div class="beian"></div></div></div><div class="main"><div class="autopagerize_page_element"><div class="content"><div class="post-page"><div class="post animated fadeInDown"><div class="post-title"><h3><a>JWT漏洞</a></h3></div><div class="post-content"><p><h2 id="什么是-JWT？"><a href="#什么是-JWT？" class="headerlink" title="什么是 JWT？"></a>什么是 JWT？</h2><p>JSON web tokens (JWT) 是一种标准化格式，用于在系统之间发送加密签名的 JSON 数据。理论上，它们可以包含任何类型的数据，但最常用于发送有关用户的信息（“声明”），作为身份验证、会话处理和访问控制机制的一部分。</p>
<p>与经典会话令牌不同，服务器所需的所有数据都存储在 JWT 本身的<strong>客户端</strong>中。</p>
<h3 id="JWT-格式"><a href="#JWT-格式" class="headerlink" title="JWT 格式"></a>JWT 格式</h3><p>JWT 由 3 部分组成：标头、有效负载和签名。它们均由点分隔，如以下示例所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">eyJraWQiOiI5MTM2ZGRiMy1jYjBhLTRhMTktYTA3ZS1lYWRmNWE0NGM4YjUiLCJhbGciOiJSUzI1NiJ9.eyJpc3MiOiJwb3J0c3dpZ2dlciIsImV4cCI6MTY0ODAzNzE2NCwibmFtZSI6IkNhcmxvcyBNb250b3lhIiwic3ViIjoiY2FybG9zIiwicm9sZSI6ImJsb2dfYXV0aG9yIiwiZW1haWwiOiJjYXJsb3NAY2FybG9zLW1vbnRveWEubmV0IiwiaWF0IjoxNTE2MjM5MDIyfQ.SYZBPIBg2CRjXAJ8vCER0LA_ENjII1JakvNQoP-Hw6GG1zfl4JyngsZReIfqRvIAEi5L4HV0q7_9qGhQZvy9ZdxEJbwTxRs_6Lb-fZTDpW6lKYNdMyjw45_alSCZ1fypsMWz_2mTpQzil0lOtps5Ei_z7mM7M8gCwe_AGpI53JxduQOaB5HkT5gVrv9cKu9CsW5MS6ZbqYXpGyOG5ehoxqm8DL5tFYaW3lB50ELxi0KsuTKEbD0t5BCl0aCR2MBJWAbN-xeLwEenaqBiwPVvKixYleeDQiBEIylFdNNIMviKRgXiYuAvMziVPbwSgkZVHeEdF5MQP1Oe2Spac-6IfA</span><br></pre></td></tr></table></figure>

<p>JWT 的标头和有效负载部分只是 base64url 编码的 JSON 对象。标头包含有关令牌本身的元数据，而有效负载包含有关用户的实际“声明”。例如，您可以从上面的令牌中解码有效负载以揭示以下声明：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;iss&quot;</span><span class="punctuation">:</span> <span class="string">&quot;portswigger&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;exp&quot;</span><span class="punctuation">:</span> <span class="number">1648037164</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Carlos Montoya&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;sub&quot;</span><span class="punctuation">:</span> <span class="string">&quot;carlos&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;role&quot;</span><span class="punctuation">:</span> <span class="string">&quot;blog_author&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;email&quot;</span><span class="punctuation">:</span> <span class="string">&quot;carlos@carlos-montoya.net&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;iat&quot;</span><span class="punctuation">:</span> <span class="number">1516239022</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p>在大多数情况下，任何有权访问令牌的人都可以轻松读取或修改此数据。因此，任何基于 JWT 的机制的安全性都<strong>严重依赖</strong>于加密<code>签名</code>。</p>
<h3 id="签名"><a href="#签名" class="headerlink" title="签名"></a>签名</h3><p>发出令牌的服务器通常通过散列标头和有效负载来生成签名。在某些情况下，他们还会对生成的哈希值进行加密。无论哪种方式，此过程都涉及秘密签名密钥。此机制为服务器提供了一种方法来验证令牌中的数据自发布以来没有被篡改：</p>
<ul>
<li>由于签名是直接从令牌的其余部分派生的，因此更改标头或有效负载的单个字节会导致签名不匹配。</li>
<li>如果不知道服务器的秘密签名密钥，就不可能为给定的标头或有效负载生成正确的签名。</li>
</ul>
<p>注意：<a target="_blank" rel="noopener" href="https://jwt.io/">https://jwt.io/</a></p>
<h2 id="什么是-JWT-攻击？"><a href="#什么是-JWT-攻击？" class="headerlink" title="什么是 JWT 攻击？"></a>什么是 JWT 攻击？</h2><p>JWT 攻击的影响通常很严重。如果攻击者能够使用任意值创建自己的有效令牌，他们可能能够升级自己的权限或冒充其他用户，完全控制他们的帐户。</p>
<p><strong>注意：</strong>一旦 JWT 被签发，就无法撤销。即使在 JWT 还未过期的情况下，如果需要立即使其失效，是无法做到的；也就是说即使你的账号logout，但是曾经的jwt令牌依然有效；</p>
<h2 id="JWT-攻击的漏洞是如何产生的？"><a href="#JWT-攻击的漏洞是如何产生的？" class="headerlink" title="JWT 攻击的漏洞是如何产生的？"></a>JWT 攻击的漏洞是如何产生的？</h2><p>JWT 漏洞通常是由于应用程序本身的 JWT 处理缺陷而引起的。与 JWT 相关的各种规范在设计上相对灵活，允许网站开发人员自行决定许多实现细节。即使使用久经考验的库，这也可能导致他们意外引入漏洞。</p>
<p>这些实现缺陷通常意味着 JWT 的签名未得到正确验证。这使得攻击者能够篡改通过令牌的有效负载传递给应用程序的值。即使签名得到了可靠的验证，它是否真正可信在很大程度上依赖于服务器的秘密密钥是否保密。如果该密钥以某种方式泄露，或者可以被猜测或暴力破解，则攻击者可以为任何任意令牌生成有效签名，从而损害整个机制</p>
<h2 id="利用有缺陷的-JWT-签名验证"><a href="#利用有缺陷的-JWT-签名验证" class="headerlink" title="利用有缺陷的 JWT 签名验证"></a>利用有缺陷的 JWT 签名验证</h2><h3 id="接受任意签名"><a href="#接受任意签名" class="headerlink" title="接受任意签名"></a>接受任意签名</h3><p>JWT 库通常提供一种验证令牌的方法和另一种仅对其进行解码的方法。例如，Node.js 库<code>jsonwebtoken</code>有<code>verify()</code>和<code>decode()</code>。</p>
<p>有时，开发人员会混淆这两种方法，只将传入的令牌传递给该<code>decode()</code>方法。这实际上意味着应用程序根本不验证签名。也就是说，后端服务器并没有使用<code>verify()</code>函数对令牌进行验证，而是直接使用<code>decode</code>函数解码</p>
<h3 id="接受没有签名的令牌"><a href="#接受没有签名的令牌" class="headerlink" title="接受没有签名的令牌"></a>接受没有签名的令牌</h3><p>其中，JWT 标头包含一个<code>alg</code>参数。这告诉服务器使用哪种算法对令牌进行签名，以及在验证签名时需要使用哪种算法。</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;alg&quot;</span><span class="punctuation">:</span> <span class="string">&quot;HS256&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;typ&quot;</span><span class="punctuation">:</span> <span class="string">&quot;JWT&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p>这本质上是有缺陷的，因为服务器别无选择，只能隐式信任来自令牌的用户可控输入，而此时该令牌根本尚未经过验证。换句话说，攻击者可以直接影响服务器如何检查令牌是否可信。</p>
<p>JWT支持“none”算法。如果将alg字段设置为“none”，则任何令牌都将被视为有效。</p>
<h2 id="暴力破解密钥"><a href="#暴力破解密钥" class="headerlink" title="暴力破解密钥"></a>暴力破解密钥</h2><p>某些签名算法，例如 HS256 (HMAC + SHA-256)，使用任意独立字符串作为密钥。就像密码一样，这一秘密可能轻易被攻击者猜出或暴力破解，</p>
<p>Tools:<a target="_blank" rel="noopener" href="https://github.com/ticarpi/jwt_tool">https://github.com/ticarpi/jwt_tool</a></p>
<h2 id="JWT-标头参数注入"><a href="#JWT-标头参数注入" class="headerlink" title="JWT 标头参数注入"></a>JWT 标头参数注入</h2><p>根据JWS规范，只有<code>alg</code>标头参数是强制的。但实际上，JWT 标头通常包含其他几个参数。攻击者特别感兴趣的是以下内容。</p>
<ul>
<li><code>jwk</code>- 提供表示密钥的嵌入式 JSON 对象。</li>
<li><code>jku</code>- 提供一个 URL，服务器可以从中获取包含正确密钥的一组密钥。</li>
<li><code>kid</code>- 提供一个 ID，服务器可以使用该 ID 在有多个密钥可供选择的情况下识别正确的密钥。根据密钥的格式，这可能具有匹配的<code>kid</code>参数。</li>
</ul>
<h3 id="通过-jwk-参数注入自签名-JWT"><a href="#通过-jwk-参数注入自签名-JWT" class="headerlink" title="通过 jwk 参数注入自签名 JWT"></a>通过 jwk 参数注入自签名 JWT</h3><p>JWS规范描述了一个可选的<code>jwk</code>标头参数，服务器可以使用该参数以 JWK 格式将其公钥直接嵌入到令牌本身中。</p>
<p> JWT 标头示例：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;kid&quot;</span><span class="punctuation">:</span> <span class="string">&quot;ed2Nf8sb-sD6ng0-scs5390g-fFD8sfxG&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;typ&quot;</span><span class="punctuation">:</span> <span class="string">&quot;JWT&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;alg&quot;</span><span class="punctuation">:</span> <span class="string">&quot;RS256&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;jwk&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;kty&quot;</span><span class="punctuation">:</span> <span class="string">&quot;RSA&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;e&quot;</span><span class="punctuation">:</span> <span class="string">&quot;AQAB&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;kid&quot;</span><span class="punctuation">:</span> <span class="string">&quot;ed2Nf8sb-sD6ng0-scs5390g-fFD8sfxG&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;n&quot;</span><span class="punctuation">:</span> <span class="string">&quot;yy1wpYmffgXBxhAUJzHHocCuJolwDqql75ZWuCQ_cb33K2vh9m&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p>在理想情况下，服务器应该是只使用公钥白名单来验证JWT签名的，但对于一些相关配置错误的服务器会用JWK参数中嵌入的任何密钥进行验证，攻击者就可以利用这一行为，用自己的RSA私钥对修改过的JWT进行签名，然后在JWK头部中嵌入对应的公钥进行越权操作</p>
<p><strong>实验如下</strong></p>
<p>实验环境来自:<a target="_blank" rel="noopener" href="https://portswigger.net/">https://portswigger.net/</a></p>
<p>使用：wiener:peter登陆 ,没有权限访问<code>/admin</code></p>
<p><img src="https://cdn.jsdelivr.net/gh/zIxyd/image@main/ctfshow/%E8%81%94%E6%83%B3%E6%88%AA%E5%9B%BE_20240207205203.png"></p>
<p>使用jwk注入步骤：</p>
<ol>
<li>生成新的 RSA 密钥</li>
<li>请注意，您无需选择密钥大小，因为稍后会自动更新。</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/zIxyd/image@main/ctfshow/%E8%81%94%E6%83%B3%E6%88%AA%E5%9B%BE_20240207205019.png"></p>
<p><img src="https://cdn.jsdelivr.net/gh/zIxyd/image@main/ctfshow/%E8%81%94%E6%83%B3%E6%88%AA%E5%9B%BE_20240207205509.png"></p>
<p>此时标头已经成功注入<code>jwk</code>；再次发送请求包之后，可以成功拿到adminstrator权限</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;kid&quot;</span><span class="punctuation">:</span> <span class="string">&quot;45287eda-91e5-420e-9477-95856bbfd5f2&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;typ&quot;</span><span class="punctuation">:</span> <span class="string">&quot;JWT&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;alg&quot;</span><span class="punctuation">:</span> <span class="string">&quot;RS256&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;jwk&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;kty&quot;</span><span class="punctuation">:</span> <span class="string">&quot;RSA&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;e&quot;</span><span class="punctuation">:</span> <span class="string">&quot;AQAB&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;kid&quot;</span><span class="punctuation">:</span> <span class="string">&quot;45287eda-91e5-420e-9477-95856bbfd5f2&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;n&quot;</span><span class="punctuation">:</span> <span class="string">&quot;nNJZA3RKyKP8fsXTZ9BSKlOEKM7HSo6HbaSKiDhK70mzlqHQmgAjYjFLpq-hsmlZp8oY34kLDCnMfYgNhRZlNoadPxwy7tWdUklawuQPVvbAlPbY9gIXaDpu-7h1P0bm_8uw3MtmX5PPhW7-mFysBAHb-EJIryU5xFueFuZVIJzQ1yeepb6j7IgbjDcGzO_XP0zoXQBTpJTBYlpUaAhr_5fjKiHM6LaXgQYKIcImquEDbqo9Z4N1QJYmaLZH256Ki-AP6cav6uu0erYO1eejrDJ41bg34Sd-IzaN-Rr9v2kbDoLxd_jh041uXMz0UNBVbRHnCqB6kIbG-w1O0g2Jcw&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<h3 id="通过-jku-参数注入自签名-JWT"><a href="#通过-jku-参数注入自签名-JWT" class="headerlink" title="通过 jku 参数注入自签名 JWT"></a>通过 jku 参数注入自签名 JWT</h3><p>有些服务器并不会直接使用JWK头部参数来嵌入公钥，而是使用JKU（JWK Set URL）来引用一个包含了密钥的JWK Set，当验证签名时，服务器从该 URL 中获取相关密钥；我们就可以借此来构造一个密钥从而实现越权操作</p>
<p>JWK Set 是一个 JSON 对象，包含表示不同键的 JWK 数组。您可以在下面看到这样的示例。</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;keys&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;kty&quot;</span><span class="punctuation">:</span> <span class="string">&quot;RSA&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;e&quot;</span><span class="punctuation">:</span> <span class="string">&quot;AQAB&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;kid&quot;</span><span class="punctuation">:</span> <span class="string">&quot;75d0ef47-af89-47a9-9061-7c02a610d5ab&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;n&quot;</span><span class="punctuation">:</span> <span class="string">&quot;o-yy1wpYmffgXBxhAUJzHHocCuJolwDqql75ZWuCQ_cb33K2vh9mk6GPM9gNN4Y_qTVX67WhsN3JvaFYw-fhvsWQ&quot;</span></span><br><span class="line">        <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;kty&quot;</span><span class="punctuation">:</span> <span class="string">&quot;RSA&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;e&quot;</span><span class="punctuation">:</span> <span class="string">&quot;AQAB&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;kid&quot;</span><span class="punctuation">:</span> <span class="string">&quot;d8fDFo-fS9-faS14a9-ASf99sa-7c1Ad5abA&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;n&quot;</span><span class="punctuation">:</span> <span class="string">&quot;fc3f-yy1wpYmffgXBxhAUJzHql79gNNQ_cb33HocCuJolwDqmk6GPM4Y_qTVX67WhsN3JvaFYw-dfg6DH-asAScw&quot;</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p><strong>实验如下</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/zIxyd/image@main/ctfshow/%E8%81%94%E6%83%B3%E6%88%AA%E5%9B%BE_20240207211057.png"></p>
<p>右键单击刚刚生成的密钥条目，然后选择将<strong>公钥复制为 JWK</strong>。</p>
<p><img src="https://cdn.jsdelivr.net/gh/zIxyd/image@main/ctfshow/%E8%81%94%E6%83%B3%E6%88%AA%E5%9B%BE_20240207211256.png"></p>
<p>实验已经提供了:exploit-server；将公钥复制的JWK放到Body部分</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;keys&quot;: [</span><br><span class="line"></span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/zIxyd/image@main/ctfshow/%E8%81%94%E6%83%B3%E6%88%AA%E5%9B%BE_20240207211328.png"></p>
<p>把kid替换为我们生成的kid,将jkw写出exploit-server地址；然后将改成administrator，再用一开始生成的RSA签名即可</p>
<p><img src="https://cdn.jsdelivr.net/gh/zIxyd/image@main/ctfshow/%E8%81%94%E6%83%B3%E6%88%AA%E5%9B%BE_20240207211459.png"></p>
<p>注意：如果你用的burpsuit是盗版的话，使用插件可能sign不成功；我最终是用kali自带的社区版解决的；</p>
<h3 id="通过kid参数注入自签名JWT"><a href="#通过kid参数注入自签名JWT" class="headerlink" title="通过kid参数注入自签名JWT"></a>通过kid参数注入自签名JWT</h3><p>服务器可能使用多个加密密钥来签署不同类型的数据，而不仅仅是 JWT。因此，JWT 的 header 中可能会包含一个<code>kid</code>（Key ID）参数，该参数可以帮助服务器识别在验证签名时使用哪个密钥。</p>
<p>验证密钥通常存储为 JWK 集。在这种情况下，服务器可以简单地查找与<code>kid</code>令牌相同的JWK。然而，JWS 规范并未定义此 ID 的具体结构 - 它只是开发人员选择的任意字符串。例如，他们可能使用<code>kid</code>参数来指向数据库中的特定条目，甚至是文件名。</p>
<p>如果此参数也容易受到目录遍历的攻击，则攻击者可能会强制服务器使用其文件系统中的任意文件作为验证密钥。</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;kid&quot;</span><span class="punctuation">:</span> <span class="string">&quot;../../path/to/file&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;typ&quot;</span><span class="punctuation">:</span> <span class="string">&quot;JWT&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;alg&quot;</span><span class="punctuation">:</span> <span class="string">&quot;HS256&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;k&quot;</span><span class="punctuation">:</span> <span class="string">&quot;asGsADas3421-dfh9DGN-AFDFDbasfd8-anfjkvc&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p>如果服务器还支持使用对称算法签名的 JWT，则这尤其危险。在这种情况下，攻击者可能会将<code>kid</code>参数指向可预测的静态文件，然后使用与该文件内容匹配的密钥对 JWT 进行签名。</p>
<p>理论上，您可以对任何文件执行此操作，但最简单的方法之一是使用<code>/dev/null</code>，它存在于大多数 Linux 系统上。由于这是一个空文件，读取它会返回一个空字符串。因此，使用空字符串对令牌进行签名将得到有效的签名。</p>
<p><strong>实验如下</strong></p>
<p><strong>新建对称密钥</strong>;请注意，您无需选择密钥大小，因为稍后会自动更新。将生成的属性值替换<code>k</code>为 Base64 编码的空字节 ( <code>AA==</code>)。</p>
<p><img src="https://cdn.jsdelivr.net/gh/zIxyd/image@main/ctfshow/%E8%81%94%E6%83%B3%E6%88%AA%E5%9B%BE_20240207212455.png"></p>
<p>将参数的值更改<code>kid</code>为指向<code>/dev/null</code>文件,修改为administrator;单击<strong>Sign</strong>，然后选择在上一部分中生成的对称密钥即可</p>
<p><img src="https://cdn.jsdelivr.net/gh/zIxyd/image@main/ctfshow/%E8%81%94%E6%83%B3%E6%88%AA%E5%9B%BE_20240207212623.png"></p>
<h2 id="JWT算法混淆攻击"><a href="#JWT算法混淆攻击" class="headerlink" title="JWT算法混淆攻击"></a>JWT算法混淆攻击</h2><p>当攻击者能够强制服务器使用与网站开发人员预期不同的算法来验证 JSON Web 令牌 ( <a target="_blank" rel="noopener" href="https://portswigger.net/web-security/jwt">JWT</a> ) 的签名时，就会发生算法混淆攻击（也称为密钥混淆攻击）。如果这种情况处理不当，攻击者可能会伪造包含任意值的有效 JWT，而无需知道服务器的秘密签名密钥。</p>
<h3 id="算法混淆漏洞是如何产生的？"><a href="#算法混淆漏洞是如何产生的？" class="headerlink" title="算法混淆漏洞是如何产生的？"></a>算法混淆漏洞是如何产生的？</h3><p>算法混乱漏洞通常是由于 JWT 库的实现有缺陷而引起的。尽管实际的验证过程因所使用的算法而异，但许多库提供了一种与算法无关的单一方法来验证签名。这些方法依赖于<code>alg</code>令牌标头中的参数来确定它们应执行的验证类型。</p>
<p>以下伪代码显示了此泛型<code>verify()</code>方法的声明在 JWT 库中的简化示例：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">verify</span>(<span class="params">token, secretOrPublicKey</span>)&#123;</span><br><span class="line">    algorithm = token.<span class="title function_">getAlgHeader</span>();</span><br><span class="line">    <span class="keyword">if</span>(algorithm == <span class="string">&quot;RS256&quot;</span>)&#123;</span><br><span class="line">        <span class="comment">// Use the provided key as an RSA public key</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (algorithm == <span class="string">&quot;HS256&quot;</span>)&#123;</span><br><span class="line">        <span class="comment">// Use the provided key as an HMAC secret key</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当随后使用此方法的网站开发人员假设它将专门处理使用 RS256 等非对称算法签名的 JWT 时，就会出现问题。由于这个有缺陷的假设，他们可能总是将固定的公钥传递给该方法，如下所示：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">publicKey = &lt;public-key-<span class="keyword">of</span>-server&gt;;</span><br><span class="line">token = request.<span class="title function_">getCookie</span>(<span class="string">&quot;session&quot;</span>);</span><br><span class="line"><span class="title function_">verify</span>(token, publicKey);</span><br></pre></td></tr></table></figure>

<p>在这种情况下，如果服务器收到使用 HS256 等对称算法签名的令牌，则库的通用<code>verify()</code>方法会将公钥视为 HMAC 秘密。这意味着攻击者可以使用 HS256 和公钥对令牌进行签名，并且服务器将使用相同的公钥来验证签名。</p>
<p><strong>注意：</strong>用于签署令牌的公钥必须与服务器上存储的公钥完全相同。这包括使用相同的格式（例如 X.509 PEM）</p>
<h3 id="执行算法混淆攻击"><a href="#执行算法混淆攻击" class="headerlink" title="执行算法混淆攻击"></a>执行算法混淆攻击</h3><p>算法混淆攻击通常涉及以下高级步骤：</p>
<ol>
<li>获取服务器的公钥</li>
<li>将公钥转换为合适的格式</li>
<li>创建一个恶意 JWT，其负载经过修改，<code>alg</code>标头设置为<code>HS256</code>.</li>
<li>使用公钥作为密钥，使用 HS256 对令牌进行签名。</li>
</ol>
<p>可以获取服务器的公钥非常重要；例如，服务器有时会通过映射到<code>/jwks.json</code> 的 标准端点将其公钥公开为 JSON Web Key (JWK) 对象。<code>/.well-known/jwks.json</code>这些可以存储在名为 的 JWK 数组中<code>keys</code>。这称为 JWK 集。</p>
<p><strong>注意：</strong>私钥用于解密数据或生成数字签名；而公钥用于加密数据或验证数字签名</p>
<p>实验如下：</p>
<p>访问<code>jwks.json</code>拿到公钥，</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;keys&quot;:[</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;kty&quot;:&quot;RSA&quot;,</span><br><span class="line">            &quot;e&quot;:&quot;AQAB&quot;,</span><br><span class="line">            &quot;use&quot;:&quot;sig&quot;,</span><br><span class="line">            &quot;kid&quot;:&quot;0db5403e-6f79-47e5-aa30-b005a59dc7be&quot;,</span><br><span class="line">            &quot;alg&quot;:&quot;RS256&quot;,</span><br><span class="line">            &quot;n&quot;:&quot;mVx2PicKCcRTrUZ-2rcpVVGjUedQie9HKP8coUmvWY7eKHb7XoHZVj9kD79CW5bRtipLV27NzeunNwtbXfYRTVRD33C6oDF393Q0czJc63EXmMCE6p2MWKpsieVhPe5XjK0L7UGm1BGSGafMndQrjdNv2V1eMnz5oX1AsSwltMDkZD_wFrhVxBXO71GmHfm4jWYoJzchr1Z5X_DCM6Q_0cWZ4PLl9GVeCZwiZg-5SvGvhwEOeKqnJriulWIubqCouY2ygOVNbmMK0_L8SPHXfntZ4JXm0pvRbV-gufizH7vnAJfJ7O7dMc6AVTqSNnWNWIgp1_Z8VQ253WkM77dpEw&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>并转化成pem格式，可以利用python脚本</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"><span class="keyword">import</span> binascii</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">from</span> cryptography.hazmat.primitives <span class="keyword">import</span> serialization</span><br><span class="line"><span class="keyword">from</span> cryptography.hazmat.primitives.asymmetric <span class="keyword">import</span> rsa</span><br><span class="line"><span class="keyword">from</span> cryptography.hazmat.primitives.asymmetric <span class="keyword">import</span> padding</span><br><span class="line"><span class="keyword">from</span> cryptography.hazmat.primitives <span class="keyword">import</span> hashes</span><br><span class="line"></span><br><span class="line">jwk_data = &#123;</span><br><span class="line">    <span class="string">&quot;keys&quot;</span>:[</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="string">&quot;kty&quot;</span>:<span class="string">&quot;RSA&quot;</span>,</span><br><span class="line">            <span class="string">&quot;e&quot;</span>:<span class="string">&quot;AQAB&quot;</span>,</span><br><span class="line">            <span class="string">&quot;use&quot;</span>:<span class="string">&quot;sig&quot;</span>,</span><br><span class="line">            <span class="string">&quot;kid&quot;</span>:<span class="string">&quot;0db5403e-6f79-47e5-aa30-b005a59dc7be&quot;</span>,</span><br><span class="line">            <span class="string">&quot;alg&quot;</span>:<span class="string">&quot;RS256&quot;</span>,</span><br><span class="line">            <span class="string">&quot;n&quot;</span>:<span class="string">&quot;mVx2PicKCcRTrUZ-2rcpVVGjUedQie9HKP8coUmvWY7eKHb7XoHZVj9kD79CW5bRtipLV27NzeunNwtbXfYRTVRD33C6oDF393Q0czJc63EXmMCE6p2MWKpsieVhPe5XjK0L7UGm1BGSGafMndQrjdNv2V1eMnz5oX1AsSwltMDkZD_wFrhVxBXO71GmHfm4jWYoJzchr1Z5X_DCM6Q_0cWZ4PLl9GVeCZwiZg-5SvGvhwEOeKqnJriulWIubqCouY2ygOVNbmMK0_L8SPHXfntZ4JXm0pvRbV-gufizH7vnAJfJ7O7dMc6AVTqSNnWNWIgp1_Z8VQ253WkM77dpEw&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> key <span class="keyword">in</span> jwk_data[<span class="string">&quot;keys&quot;</span>]:</span><br><span class="line">    modulus = <span class="built_in">int</span>.from_bytes(base64.urlsafe_b64decode(key[<span class="string">&quot;n&quot;</span>] + <span class="string">&quot;===&quot;</span>), <span class="string">&quot;big&quot;</span>)</span><br><span class="line">    exponent = <span class="built_in">int</span>.from_bytes(base64.urlsafe_b64decode(key[<span class="string">&quot;e&quot;</span>] + <span class="string">&quot;===&quot;</span>), <span class="string">&quot;big&quot;</span>)</span><br><span class="line">    public_numbers = rsa.RSAPublicNumbers(exponent, modulus)</span><br><span class="line">    public_key = public_numbers.public_key()</span><br><span class="line">    pem = public_key.public_bytes(</span><br><span class="line">        encoding=serialization.Encoding.PEM,</span><br><span class="line">        <span class="built_in">format</span>=serialization.PublicFormat.SubjectPublicKeyInfo</span><br><span class="line">    )</span><br><span class="line">    <span class="built_in">print</span>(pem.decode())</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>或者burp插件</p>
<p><strong>新建 RSA 密钥</strong>,复制到key框中，再选择pem单选框或者右键单击刚刚创建的密钥条目，然后选择<strong>将公钥复制为 PEM</strong>(注意这里最后有个换行符)</p>
<p><img src="https://cdn.jsdelivr.net/gh/zIxyd/image@main/ctfshow/%E8%81%94%E6%83%B3%E6%88%AA%E5%9B%BE_20240208122246.png"></p>
<p>对此 PEM 密钥进行 Base64 编码，然后复制生成的字符串<img src="https://cdn.jsdelivr.net/gh/zIxyd/image@main/ctfshow/%E8%81%94%E6%83%B3%E6%88%AA%E5%9B%BE_20240208122532.png"></p>
<p><strong>新建对称密钥</strong>。在对话框中，单击<strong>“生成”</strong>以生成 JWK 格式的新密钥。请注意，您无需选择密钥大小，因为稍后会自动更新；将 k 属性的生成值替换为您刚刚创建的 Base64 编码的 PEM。</p>
<p><img src="https://cdn.jsdelivr.net/gh/zIxyd/image@main/ctfshow/%E8%81%94%E6%83%B3%E6%88%AA%E5%9B%BE_20240208122632.png"></p>
<p>将<code>alg</code>参数的值更改为<code>HS256</code>。将声明的值更改<code>sub</code>为<code>administrator</code>。单击<strong>Sign</strong>，然后选择在上一部分中生成的对称密钥即可;</p>
<p><img src="https://cdn.jsdelivr.net/gh/zIxyd/image@main/ctfshow/%E8%81%94%E6%83%B3%E6%88%AA%E5%9B%BE_20240208122818.png"></p>
<h3 id="从现有令牌派生公钥"><a href="#从现有令牌派生公钥" class="headerlink" title="从现有令牌派生公钥"></a>从现有令牌派生公钥</h3><p>在公钥不易获得的情况下，您仍然可以通过从一对现有 JWT 派生密钥来测试算法混淆。使用诸如 之类的工具，此过程相对简单<code>jwt_forgery.py</code>。您可以在<a target="_blank" rel="noopener" href="https://github.com/silentsignal/rsa_sign2n"><code>rsa_sign2n</code>GitHub 存储库</a>上找到此脚本以及其他几个有用的脚本。</p>
<p>我们还创建了该工具的简化版本，您可以将其作为单个命令运行：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run --<span class="built_in">rm</span> -it portswigger/sig2n &lt;token1&gt; &lt;token2&gt;</span><br></pre></td></tr></table></figure>

<p>这将使用您提供的 JWT 来计算 的一个或多个潜在值<code>n</code>。不要太担心这意味着什么 - 您需要知道的是只有其中之一<code>n</code>与服务器密钥使用的值相匹配。对于每个潜在值，我们的脚本输出：</p>
<ul>
<li>X.509 和 PKCS1 格式的 Base64 编码 PEM 密钥。</li>
<li>使用每个密钥签名的伪造 JWT。</li>
</ul>
<p>要识别正确的密钥，请使用 Burp Repeater 发送包含每个伪造 JWT 的请求。服务器仅接受其中之一。然后，您可以使用匹配密钥来构造算法混淆攻击。</p>
<p>实验如下：</p>
<p>获取服务器生成的两个 JWT(登陆第一次，拿到一个jwt令牌后退出，再登陆第二次，拿到第二个jwt令牌)</p>
<p>在终端中，运行以下命令，并传入两个 JWT 作为参数。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run --<span class="built_in">rm</span> -it portswigger/sig2n &lt;token1&gt; &lt;token2&gt;</span><br></pre></td></tr></table></figure>

<p>请注意，输出包含一个或多个 的计算值<code>n</code>。其中每一项在数学上都是可能的，但只有其中一项与服务器使用的值匹配。</p>
<p><img src="https://cdn.jsdelivr.net/gh/zIxyd/image@main/ctfshow/%E8%81%94%E6%83%B3%E6%88%AA%E5%9B%BE_20240208123948.png"></p>
<p>返回到 Burp Repeater 中的请求并将路径更改回<code>/my-account</code>;将会话 cookie 替换为这个新的 JWT，然后发送请求;发现第二个成功返回200；说明成功；</p>
<p>从终端窗口中，复制您在上一部分中确定为正确的 Base64 编码的 X.509 密钥。请注意，您需要选择密钥，而不是上一节中使用的被篡改的 JWT。</p>
<p><img src="https://cdn.jsdelivr.net/gh/zIxyd/image@main/ctfshow/%E8%81%94%E6%83%B3%E6%88%AA%E5%9B%BE_20240208124456.png"></p>
<p><img src="https://cdn.jsdelivr.net/gh/zIxyd/image@main/ctfshow/%E8%81%94%E6%83%B3%E6%88%AA%E5%9B%BE_20240208124703.png"></p>
</p></div><div class="post-footer"><div class="tip">All rights reserved<br>Author: zIxyd</div><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2024-02-08</span><span class="leancloud_visitors"></span><span>About 4723 words, 15 min 44 sec  read</span></div></div></div></div><div class="share"><div class="evernote"><a class="fa fa-bookmark" href="" onclick="javascript:join_favorite()" ref="sidebar"></a></div><div class="weibo"><a class="fa fa-weibo" href="javascript:void((function(s,d,e){try{}catch(e){}var f='http://service.weibo.com/share/share.php?',u=d.location.href,p=['url=',e(u),'&amp;title=',e(d.title),'&amp;appkey=2924220432'].join('');function a(){if(!window.open([f,p].join(''),'mb',['toolbar=0,status=0,resizable=1,width=620,height=450,left=',(s.width-620)/2,',top=',(s.height-450)/2].join('')))u.href=[f,p].join('');};if(/Firefox/.test(navigator.userAgent)){setTimeout(a,0)}else{a()}})(screen,document,encodeURIComponent));"></a></div><div class="twitter"><a class="fa fa-twitter" target="_blank" rel="noopener" href="http://twitter.com/intent/tweet?text=I%20have%20found%20a%20great%20blog.%0A%0AzIxyd's%20Blog%20%C2%B7%20JWT%E6%BC%8F%E6%B4%9E%0Ahttps://zIxyd.github.io/2024/02/08/JWT%E6%BC%8F%E6%B4%9E/%0A"></a></div></div><div class="pagination"><ul class="clearfix"><li class="next pagbuttons"><a class="btn" role="navigation" href="/2024/02/06/python%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/" title="python反序列化">Next</a></li></ul></div><script src="/js/visitors.js"></script></div></div></div></div><script src="/js/darkLightToggle.js"></script><script src="/js/jquery-migrate-1.2.1.min.js"></script><script src="/js/jquery.appear.js"></script><script src="/js/add-bookmark.js"></script><script>(function(window){var INSIGHT_CONFIG={TRANSLATION:{POSTS:"Posts",PAGES:"Pages",CATEGORIES:"Categories",TAGS:"Tags",UNTITLED:"(Untitled)",},CONTENT_URL:"/content.json",};window.INSIGHT_CONFIG=INSIGHT_CONFIG})(window);</script><script src="/js/insight.js" defer></script><div class="searchbox ins-search"><div class="searchbox-container ins-search-container"><div class="searchbox-input-wrapper"><input class="searchbox-input ins-search-input" type="text" placeholder="Search..."><span class="searchbox-close"><a class="fa fa-times-circle" onclick="closeWindow();"></a></span></div><div class="searchbox-result-wrapper ins-section-wrapper"><div class="ins-section-container"><p>Seraching...</p></div></div></div></div></body></html>